// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Adds a repository to the list of selected repositories that can access a self-hosted runner group.
	// The runner group must have `visibility` set to `selected`. For more information, see "[Create a
	// self-hosted runner group for an
	// organization](#create-a-self-hosted-runner-group-for-an-organization)."
	// You must authenticate using an access token with the `admin:org`
	// scope to use this endpoint.
	//
	// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
	ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) error
	// ActionsAddSelectedRepoToOrgSecret invokes actions/add-selected-repo-to-org-secret operation.
	//
	// Adds a repository to an organization secret when the `visibility` for repository access is set to
	// `selected`. The visibility is set when you [Create or update an organization secret](https://docs.
	// github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate
	// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
	// `secrets` organization permission to use this endpoint.
	//
	// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
	ActionsAddSelectedRepoToOrgSecret(ctx context.Context, params ActionsAddSelectedRepoToOrgSecretParams) (ActionsAddSelectedRepoToOrgSecretRes, error)
	// ActionsAddSelfHostedRunnerToGroupForOrg invokes actions/add-self-hosted-runner-to-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Adds a self-hosted runner to a runner group configured in an organization.
	// You must authenticate using an access token with the `admin:org`
	// scope to use this endpoint.
	//
	// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
	ActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, params ActionsAddSelfHostedRunnerToGroupForOrgParams) error
	// ActionsApproveWorkflowRun invokes actions/approve-workflow-run operation.
	//
	// Approves a workflow run for a pull request from a public fork of a first time contributor. For
	// more information, see ["Approving workflow runs from public forks](https://docs.github.
	// com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
	// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
	// Apps must have the `actions:write` permission to use this endpoint.
	//
	// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
	ActionsApproveWorkflowRun(ctx context.Context, params ActionsApproveWorkflowRunParams) (ActionsApproveWorkflowRunRes, error)
	// ActionsCancelWorkflowRun invokes actions/cancel-workflow-run operation.
	//
	// Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo`
	// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
	// endpoint.
	//
	// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
	ActionsCancelWorkflowRun(ctx context.Context, params ActionsCancelWorkflowRunParams) error
	// ActionsCreateOrUpdateEnvironmentSecret invokes actions/create-or-update-environment-secret operation.
	//
	// Creates or updates an environment secret with an encrypted value. Encrypt your secret using
	// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
	// using an access
	// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
	// permission to use
	// this endpoint.
	// #### Example encrypting a secret using Node.js
	// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
	// ```
	// const sodium = require('tweetsodium');
	// const key = "base64-encoded-public-key";
	// const value = "plain-text-secret";
	// // Convert the message and key to Uint8Array's (Buffer implements that interface)
	// const messageBytes = Buffer.from(value);
	// const keyBytes = Buffer.from(key, 'base64');
	// // Encrypt using LibSodium.
	// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
	// // Base64 the encrypted secret
	// const encrypted = Buffer.from(encryptedBytes).toString('base64');
	// console.log(encrypted);
	// ```
	// #### Example encrypting a secret using Python
	// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
	// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
	// ```
	// from base64 import b64encode
	// from nacl import encoding, public
	// def encrypt(public_key: str, secret_value: str) -> str:
	// """Encrypt a Unicode string using the public key."""
	// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
	// sealed_box = public.SealedBox(public_key)
	// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
	// return b64encode(encrypted).decode("utf-8")
	// ```
	// #### Example encrypting a secret using C#
	// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
	// ```
	// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
	// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
	// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
	// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
	// ```
	// #### Example encrypting a secret using Ruby
	// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
	// ```ruby
	// require "rbnacl"
	// require "base64"
	// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
	// public_key = RbNaCl::PublicKey.new(key)
	// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
	// encrypted_secret = box.encrypt("my_secret")
	// # Print the base64 encoded secret
	// puts Base64.strict_encode64(encrypted_secret)
	// ```.
	//
	// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
	ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, request *ActionsCreateOrUpdateEnvironmentSecretReq, params ActionsCreateOrUpdateEnvironmentSecretParams) (ActionsCreateOrUpdateEnvironmentSecretRes, error)
	// ActionsCreateOrUpdateOrgSecret invokes actions/create-or-update-org-secret operation.
	//
	// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
	// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
	// using an access
	// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
	// organization permission to
	// use this endpoint.
	// #### Example encrypting a secret using Node.js
	// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
	// ```
	// const sodium = require('tweetsodium');
	// const key = "base64-encoded-public-key";
	// const value = "plain-text-secret";
	// // Convert the message and key to Uint8Array's (Buffer implements that interface)
	// const messageBytes = Buffer.from(value);
	// const keyBytes = Buffer.from(key, 'base64');
	// // Encrypt using LibSodium.
	// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
	// // Base64 the encrypted secret
	// const encrypted = Buffer.from(encryptedBytes).toString('base64');
	// console.log(encrypted);
	// ```
	// #### Example encrypting a secret using Python
	// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
	// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
	// ```
	// from base64 import b64encode
	// from nacl import encoding, public
	// def encrypt(public_key: str, secret_value: str) -> str:
	// """Encrypt a Unicode string using the public key."""
	// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
	// sealed_box = public.SealedBox(public_key)
	// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
	// return b64encode(encrypted).decode("utf-8")
	// ```
	// #### Example encrypting a secret using C#
	// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
	// ```
	// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
	// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
	// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
	// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
	// ```
	// #### Example encrypting a secret using Ruby
	// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
	// ```ruby
	// require "rbnacl"
	// require "base64"
	// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
	// public_key = RbNaCl::PublicKey.new(key)
	// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
	// encrypted_secret = box.encrypt("my_secret")
	// # Print the base64 encoded secret
	// puts Base64.strict_encode64(encrypted_secret)
	// ```.
	//
	// PUT /orgs/{org}/actions/secrets/{secret_name}
	ActionsCreateOrUpdateOrgSecret(ctx context.Context, request *ActionsCreateOrUpdateOrgSecretReq, params ActionsCreateOrUpdateOrgSecretParams) (ActionsCreateOrUpdateOrgSecretRes, error)
	// ActionsCreateOrUpdateRepoSecret invokes actions/create-or-update-repo-secret operation.
	//
	// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
	// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
	// using an access
	// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
	// permission to use
	// this endpoint.
	// #### Example encrypting a secret using Node.js
	// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
	// ```
	// const sodium = require('tweetsodium');
	// const key = "base64-encoded-public-key";
	// const value = "plain-text-secret";
	// // Convert the message and key to Uint8Array's (Buffer implements that interface)
	// const messageBytes = Buffer.from(value);
	// const keyBytes = Buffer.from(key, 'base64');
	// // Encrypt using LibSodium.
	// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
	// // Base64 the encrypted secret
	// const encrypted = Buffer.from(encryptedBytes).toString('base64');
	// console.log(encrypted);
	// ```
	// #### Example encrypting a secret using Python
	// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
	// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
	// ```
	// from base64 import b64encode
	// from nacl import encoding, public
	// def encrypt(public_key: str, secret_value: str) -> str:
	// """Encrypt a Unicode string using the public key."""
	// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
	// sealed_box = public.SealedBox(public_key)
	// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
	// return b64encode(encrypted).decode("utf-8")
	// ```
	// #### Example encrypting a secret using C#
	// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
	// ```
	// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
	// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
	// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
	// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
	// ```
	// #### Example encrypting a secret using Ruby
	// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
	// ```ruby
	// require "rbnacl"
	// require "base64"
	// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
	// public_key = RbNaCl::PublicKey.new(key)
	// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
	// encrypted_secret = box.encrypt("my_secret")
	// # Print the base64 encoded secret
	// puts Base64.strict_encode64(encrypted_secret)
	// ```.
	//
	// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
	ActionsCreateOrUpdateRepoSecret(ctx context.Context, request *ActionsCreateOrUpdateRepoSecretReq, params ActionsCreateOrUpdateRepoSecretParams) (ActionsCreateOrUpdateRepoSecretRes, error)
	// ActionsCreateRegistrationTokenForOrg invokes actions/create-registration-token-for-org operation.
	//
	// Returns a token that you can pass to the `config` script. The token expires after one hour.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// #### Example using registration token
	// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
	// endpoint.
	// ```
	// ./config.sh --url https://github.com/octo-org --token TOKEN
	// ```.
	//
	// POST /orgs/{org}/actions/runners/registration-token
	ActionsCreateRegistrationTokenForOrg(ctx context.Context, params ActionsCreateRegistrationTokenForOrgParams) (*AuthenticationToken, error)
	// ActionsCreateRegistrationTokenForRepo invokes actions/create-registration-token-for-repo operation.
	//
	// Returns a token that you can pass to the `config` script. The token expires after one hour. You
	// must authenticate
	// using an access token with the `repo` scope to use this endpoint.
	// #### Example using registration token
	// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
	// endpoint.
	// ```
	// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
	// ```.
	//
	// POST /repos/{owner}/{repo}/actions/runners/registration-token
	ActionsCreateRegistrationTokenForRepo(ctx context.Context, params ActionsCreateRegistrationTokenForRepoParams) (*AuthenticationToken, error)
	// ActionsCreateRemoveTokenForOrg invokes actions/create-remove-token-for-org operation.
	//
	// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
	// organization. The token expires after one hour.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// #### Example using remove token
	// To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
	// provided by this
	// endpoint.
	// ```
	// ./config.sh remove --token TOKEN
	// ```.
	//
	// POST /orgs/{org}/actions/runners/remove-token
	ActionsCreateRemoveTokenForOrg(ctx context.Context, params ActionsCreateRemoveTokenForOrgParams) (*AuthenticationToken, error)
	// ActionsCreateRemoveTokenForRepo invokes actions/create-remove-token-for-repo operation.
	//
	// Returns a token that you can pass to remove a self-hosted runner from a repository. The token
	// expires after one hour.
	// You must authenticate using an access token with the `repo` scope to use this endpoint.
	// #### Example using remove token
	// To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided
	// by this endpoint.
	// ```
	// ./config.sh remove --token TOKEN
	// ```.
	//
	// POST /repos/{owner}/{repo}/actions/runners/remove-token
	ActionsCreateRemoveTokenForRepo(ctx context.Context, params ActionsCreateRemoveTokenForRepoParams) (*AuthenticationToken, error)
	// ActionsCreateSelfHostedRunnerGroupForOrg invokes actions/create-self-hosted-runner-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
	// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Creates a new self-hosted runner group for an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// POST /orgs/{org}/actions/runner-groups
	ActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, request *ActionsCreateSelfHostedRunnerGroupForOrgReq, params ActionsCreateSelfHostedRunnerGroupForOrgParams) (*RunnerGroupsOrg, error)
	// ActionsDeleteArtifact invokes actions/delete-artifact operation.
	//
	// Deletes an artifact for a workflow run. You must authenticate using an access token with the
	// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
	// this endpoint.
	//
	// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
	ActionsDeleteArtifact(ctx context.Context, params ActionsDeleteArtifactParams) error
	// ActionsDeleteEnvironmentSecret invokes actions/delete-environment-secret operation.
	//
	// Deletes a secret in an environment using the secret name. You must authenticate using an access
	// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
	// permission to use this endpoint.
	//
	// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
	ActionsDeleteEnvironmentSecret(ctx context.Context, params ActionsDeleteEnvironmentSecretParams) error
	// ActionsDeleteOrgSecret invokes actions/delete-org-secret operation.
	//
	// Deletes a secret in an organization using the secret name. You must authenticate using an access
	// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
	// organization permission to use this endpoint.
	//
	// DELETE /orgs/{org}/actions/secrets/{secret_name}
	ActionsDeleteOrgSecret(ctx context.Context, params ActionsDeleteOrgSecretParams) error
	// ActionsDeleteRepoSecret invokes actions/delete-repo-secret operation.
	//
	// Deletes a secret in a repository using the secret name. You must authenticate using an access
	// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
	// permission to use this endpoint.
	//
	// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
	ActionsDeleteRepoSecret(ctx context.Context, params ActionsDeleteRepoSecretParams) error
	// ActionsDeleteSelfHostedRunnerFromOrg invokes actions/delete-self-hosted-runner-from-org operation.
	//
	// Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
	// completely remove the runner when the machine you were using no longer exists.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// DELETE /orgs/{org}/actions/runners/{runner_id}
	ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromOrgParams) error
	// ActionsDeleteSelfHostedRunnerFromRepo invokes actions/delete-self-hosted-runner-from-repo operation.
	//
	// Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
	// completely remove the runner when the machine you were using no longer exists.
	// You must authenticate using an access token with the `repo`
	// scope to use this endpoint.
	//
	// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
	ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromRepoParams) error
	// ActionsDeleteSelfHostedRunnerGroupFromOrg invokes actions/delete-self-hosted-runner-group-from-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Deletes a self-hosted runner group for an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
	ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) error
	// ActionsDeleteWorkflowRun invokes actions/delete-workflow-run operation.
	//
	// Delete a specific workflow run. Anyone with write access to the repository can use this endpoint.
	// If the repository is
	// private you must use an access token with the `repo` scope. GitHub Apps must have the
	// `actions:write` permission to use
	// this endpoint.
	//
	// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
	ActionsDeleteWorkflowRun(ctx context.Context, params ActionsDeleteWorkflowRunParams) error
	// ActionsDeleteWorkflowRunLogs invokes actions/delete-workflow-run-logs operation.
	//
	// Deletes all logs for a workflow run. You must authenticate using an access token with the `repo`
	// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
	// endpoint.
	//
	// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
	ActionsDeleteWorkflowRunLogs(ctx context.Context, params ActionsDeleteWorkflowRunLogsParams) error
	// ActionsDisableSelectedRepositoryGithubActionsOrganization invokes actions/disable-selected-repository-github-actions-organization operation.
	//
	// Removes a repository from the list of selected repositories that are enabled for GitHub Actions in
	// an organization. To use this endpoint, the organization permission policy for
	// `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub
	// Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
	ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) error
	// ActionsDownloadArtifact invokes actions/download-artifact operation.
	//
	// Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look
	// for `Location:` in
	// the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone
	// with read access to
	// the repository can use this endpoint. If the repository is private you must use an access token
	// with the `repo` scope.
	// GitHub Apps must have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
	ActionsDownloadArtifact(ctx context.Context, params ActionsDownloadArtifactParams) (*ActionsDownloadArtifactFound, error)
	// ActionsDownloadJobLogsForWorkflowRun invokes actions/download-job-logs-for-workflow-run operation.
	//
	// Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires
	// after 1 minute. Look
	// for `Location:` in the response header to find the URL for the download. Anyone with read access
	// to the repository can
	// use this endpoint. If the repository is private you must use an access token with the `repo` scope.
	//  GitHub Apps must
	// have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
	ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, params ActionsDownloadJobLogsForWorkflowRunParams) (*ActionsDownloadJobLogsForWorkflowRunFound, error)
	// ActionsDownloadWorkflowRunLogs invokes actions/download-workflow-run-logs operation.
	//
	// Gets a redirect URL to download an archive of log files for a workflow run. This link expires
	// after 1 minute. Look for
	// `Location:` in the response header to find the URL for the download. Anyone with read access to
	// the repository can use
	// this endpoint. If the repository is private you must use an access token with the `repo` scope.
	// GitHub Apps must have
	// the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
	ActionsDownloadWorkflowRunLogs(ctx context.Context, params ActionsDownloadWorkflowRunLogsParams) (*ActionsDownloadWorkflowRunLogsFound, error)
	// ActionsEnableSelectedRepositoryGithubActionsOrganization invokes actions/enable-selected-repository-github-actions-organization operation.
	//
	// Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an
	// organization. To use this endpoint, the organization permission policy for `enabled_repositories`
	// must be must be configured to `selected`. For more information, see "[Set GitHub Actions
	// permissions for an organization](#set-github-actions-permissions-for-an-organization)."
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
	ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) error
	// ActionsGetAllowedActionsOrganization invokes actions/get-allowed-actions-organization operation.
	//
	// Gets the selected actions that are allowed in an organization. To use this endpoint, the
	// organization permission policy for `allowed_actions` must be configured to `selected`. For more
	// information, see "[Set GitHub Actions permissions for an
	// organization](#set-github-actions-permissions-for-an-organization).""
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// GET /orgs/{org}/actions/permissions/selected-actions
	ActionsGetAllowedActionsOrganization(ctx context.Context, params ActionsGetAllowedActionsOrganizationParams) (*SelectedActions, error)
	// ActionsGetAllowedActionsRepository invokes actions/get-allowed-actions-repository operation.
	//
	// Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the
	// repository policy for `allowed_actions` must be configured to `selected`. For more information,
	// see "[Set GitHub Actions permissions for a
	// repository](#set-github-actions-permissions-for-a-repository)."
	// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
	// Apps must have the `administration` repository permission to use this API.
	//
	// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
	ActionsGetAllowedActionsRepository(ctx context.Context, params ActionsGetAllowedActionsRepositoryParams) (*SelectedActions, error)
	// ActionsGetArtifact invokes actions/get-artifact operation.
	//
	// Gets a specific artifact for a workflow run. Anyone with read access to the repository can use
	// this endpoint. If the repository is private you must use an access token with the `repo` scope.
	// GitHub Apps must have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
	ActionsGetArtifact(ctx context.Context, params ActionsGetArtifactParams) (*Artifact, error)
	// ActionsGetEnvironmentPublicKey invokes actions/get-environment-public-key operation.
	//
	// Get the public key for an environment, which you need to encrypt environment secrets. You need to
	// encrypt a secret before you can create or update secrets. Anyone with read access to the
	// repository can use this endpoint. If the repository is private you must use an access token with
	// the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
	//
	// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
	ActionsGetEnvironmentPublicKey(ctx context.Context, params ActionsGetEnvironmentPublicKeyParams) (*ActionsPublicKey, error)
	// ActionsGetEnvironmentSecret invokes actions/get-environment-secret operation.
	//
	// Gets a single environment secret without revealing its encrypted value. You must authenticate
	// using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
	// `secrets` repository permission to use this endpoint.
	//
	// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
	ActionsGetEnvironmentSecret(ctx context.Context, params ActionsGetEnvironmentSecretParams) (*ActionsSecret, error)
	// ActionsGetGithubActionsPermissionsOrganization invokes actions/get-github-actions-permissions-organization operation.
	//
	// Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// GET /orgs/{org}/actions/permissions
	ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, params ActionsGetGithubActionsPermissionsOrganizationParams) (*ActionsOrganizationPermissions, error)
	// ActionsGetGithubActionsPermissionsRepository invokes actions/get-github-actions-permissions-repository operation.
	//
	// Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is
	// enabled and the actions allowed to run in the repository.
	// You must authenticate using an access token with the `repo` scope to use this
	// endpoint. GitHub Apps must have the `administration` repository permission to use this API.
	//
	// GET /repos/{owner}/{repo}/actions/permissions
	ActionsGetGithubActionsPermissionsRepository(ctx context.Context, params ActionsGetGithubActionsPermissionsRepositoryParams) (*ActionsRepositoryPermissions, error)
	// ActionsGetJobForWorkflowRun invokes actions/get-job-for-workflow-run operation.
	//
	// Gets a specific job in a workflow run. Anyone with read access to the repository can use this
	// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
	// Apps must have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
	ActionsGetJobForWorkflowRun(ctx context.Context, params ActionsGetJobForWorkflowRunParams) (*Job, error)
	// ActionsGetOrgPublicKey invokes actions/get-org-public-key operation.
	//
	// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
	// can create or update secrets. You must authenticate using an access token with the `admin:org`
	// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
	// this endpoint.
	//
	// GET /orgs/{org}/actions/secrets/public-key
	ActionsGetOrgPublicKey(ctx context.Context, params ActionsGetOrgPublicKeyParams) (*ActionsPublicKey, error)
	// ActionsGetOrgSecret invokes actions/get-org-secret operation.
	//
	// Gets a single organization secret without revealing its encrypted value. You must authenticate
	// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
	// `secrets` organization permission to use this endpoint.
	//
	// GET /orgs/{org}/actions/secrets/{secret_name}
	ActionsGetOrgSecret(ctx context.Context, params ActionsGetOrgSecretParams) (*OrganizationActionsSecret, error)
	// ActionsGetRepoPublicKey invokes actions/get-repo-public-key operation.
	//
	// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
	// can create or update secrets. Anyone with read access to the repository can use this endpoint. If
	// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
	// have the `secrets` repository permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/secrets/public-key
	ActionsGetRepoPublicKey(ctx context.Context, params ActionsGetRepoPublicKeyParams) (*ActionsPublicKey, error)
	// ActionsGetRepoSecret invokes actions/get-repo-secret operation.
	//
	// Gets a single repository secret without revealing its encrypted value. You must authenticate using
	// an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
	// repository permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
	ActionsGetRepoSecret(ctx context.Context, params ActionsGetRepoSecretParams) (*ActionsSecret, error)
	// ActionsGetReviewsForRun invokes actions/get-reviews-for-run operation.
	//
	// Anyone with read access to the repository can use this endpoint. If the repository is private, you
	// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
	// permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
	ActionsGetReviewsForRun(ctx context.Context, params ActionsGetReviewsForRunParams) ([]EnvironmentApprovals, error)
	// ActionsGetSelfHostedRunnerForOrg invokes actions/get-self-hosted-runner-for-org operation.
	//
	// Gets a specific self-hosted runner configured in an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runners/{runner_id}
	ActionsGetSelfHostedRunnerForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerForOrgParams) (*Runner, error)
	// ActionsGetSelfHostedRunnerForRepo invokes actions/get-self-hosted-runner-for-repo operation.
	//
	// Gets a specific self-hosted runner configured in a repository.
	// You must authenticate using an access token with the `repo` scope to use this
	// endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
	ActionsGetSelfHostedRunnerForRepo(ctx context.Context, params ActionsGetSelfHostedRunnerForRepoParams) (*Runner, error)
	// ActionsGetSelfHostedRunnerGroupForOrg invokes actions/get-self-hosted-runner-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Gets a specific self-hosted runner group for an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
	ActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerGroupForOrgParams) (*RunnerGroupsOrg, error)
	// ActionsGetWorkflowRun invokes actions/get-workflow-run operation.
	//
	// Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If
	// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
	// have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runs/{run_id}
	ActionsGetWorkflowRun(ctx context.Context, params ActionsGetWorkflowRunParams) (*WorkflowRun, error)
	// ActionsGetWorkflowRunUsage invokes actions/get-workflow-run-usage operation.
	//
	// Gets the number of billable minutes and total run time for a specific workflow run. Billable
	// minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is
	// listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also
	// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
	// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
	// GitHub Actions](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
	// Anyone with read access to the repository can use this endpoint. If the repository is private you
	// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
	// permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
	ActionsGetWorkflowRunUsage(ctx context.Context, params ActionsGetWorkflowRunUsageParams) (*WorkflowRunUsage, error)
	// ActionsListArtifactsForRepo invokes actions/list-artifacts-for-repo operation.
	//
	// Lists all artifacts for a repository. Anyone with read access to the repository can use this
	// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
	// Apps must have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/artifacts
	ActionsListArtifactsForRepo(ctx context.Context, params ActionsListArtifactsForRepoParams) (*ActionsListArtifactsForRepoOKHeaders, error)
	// ActionsListEnvironmentSecrets invokes actions/list-environment-secrets operation.
	//
	// Lists all secrets available in an environment without revealing their encrypted values. You must
	// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
	// have the `secrets` repository permission to use this endpoint.
	//
	// GET /repositories/{repository_id}/environments/{environment_name}/secrets
	ActionsListEnvironmentSecrets(ctx context.Context, params ActionsListEnvironmentSecretsParams) (*ActionsListEnvironmentSecretsOKHeaders, error)
	// ActionsListJobsForWorkflowRun invokes actions/list-jobs-for-workflow-run operation.
	//
	// Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If
	// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
	// have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list
	// of results. For more information about using parameters, see [Parameters](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#parameters).
	//
	// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
	ActionsListJobsForWorkflowRun(ctx context.Context, params ActionsListJobsForWorkflowRunParams) (*ActionsListJobsForWorkflowRunOKHeaders, error)
	// ActionsListOrgSecrets invokes actions/list-org-secrets operation.
	//
	// Lists all secrets available in an organization without revealing their encrypted values. You must
	// authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps
	// must have the `secrets` organization permission to use this endpoint.
	//
	// GET /orgs/{org}/actions/secrets
	ActionsListOrgSecrets(ctx context.Context, params ActionsListOrgSecretsParams) (*ActionsListOrgSecretsOKHeaders, error)
	// ActionsListRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
	// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Lists the repositories with access to a self-hosted runner group configured in an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
	ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) (*ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK, error)
	// ActionsListRepoSecrets invokes actions/list-repo-secrets operation.
	//
	// Lists all secrets available in a repository without revealing their encrypted values. You must
	// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
	// have the `secrets` repository permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/secrets
	ActionsListRepoSecrets(ctx context.Context, params ActionsListRepoSecretsParams) (*ActionsListRepoSecretsOKHeaders, error)
	// ActionsListRepoWorkflows invokes actions/list-repo-workflows operation.
	//
	// Lists the workflows in a repository. Anyone with read access to the repository can use this
	// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
	// Apps must have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/workflows
	ActionsListRepoWorkflows(ctx context.Context, params ActionsListRepoWorkflowsParams) (*ActionsListRepoWorkflowsOKHeaders, error)
	// ActionsListRunnerApplicationsForOrg invokes actions/list-runner-applications-for-org operation.
	//
	// Lists binaries for the runner application that you can download and run.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runners/downloads
	ActionsListRunnerApplicationsForOrg(ctx context.Context, params ActionsListRunnerApplicationsForOrgParams) ([]RunnerApplication, error)
	// ActionsListRunnerApplicationsForRepo invokes actions/list-runner-applications-for-repo operation.
	//
	// Lists binaries for the runner application that you can download and run.
	// You must authenticate using an access token with the `repo` scope to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runners/downloads
	ActionsListRunnerApplicationsForRepo(ctx context.Context, params ActionsListRunnerApplicationsForRepoParams) ([]RunnerApplication, error)
	// ActionsListSelectedReposForOrgSecret invokes actions/list-selected-repos-for-org-secret operation.
	//
	// Lists all repositories that have been selected when the `visibility` for repository access to a
	// secret is set to `selected`. You must authenticate using an access token with the `admin:org`
	// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
	// this endpoint.
	//
	// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
	ActionsListSelectedReposForOrgSecret(ctx context.Context, params ActionsListSelectedReposForOrgSecretParams) (*ActionsListSelectedReposForOrgSecretOK, error)
	// ActionsListSelectedRepositoriesEnabledGithubActionsOrganization invokes actions/list-selected-repositories-enabled-github-actions-organization operation.
	//
	// Lists the selected repositories that are enabled for GitHub Actions in an organization. To use
	// this endpoint, the organization permission policy for `enabled_repositories` must be configured to
	// `selected`. For more information, see "[Set GitHub Actions permissions for an
	// organization](#set-github-actions-permissions-for-an-organization)."
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// GET /orgs/{org}/actions/permissions/repositories
	ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) (*ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK, error)
	// ActionsListSelfHostedRunnerGroupsForOrg invokes actions/list-self-hosted-runner-groups-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runner-groups
	ActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, params ActionsListSelfHostedRunnerGroupsForOrgParams) (*ActionsListSelfHostedRunnerGroupsForOrgOK, error)
	// ActionsListSelfHostedRunnersForOrg invokes actions/list-self-hosted-runners-for-org operation.
	//
	// Lists all self-hosted runners configured in an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runners
	ActionsListSelfHostedRunnersForOrg(ctx context.Context, params ActionsListSelfHostedRunnersForOrgParams) (*ActionsListSelfHostedRunnersForOrgOKHeaders, error)
	// ActionsListSelfHostedRunnersForRepo invokes actions/list-self-hosted-runners-for-repo operation.
	//
	// Lists all self-hosted runners configured in a repository. You must authenticate using an access
	// token with the `repo` scope to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runners
	ActionsListSelfHostedRunnersForRepo(ctx context.Context, params ActionsListSelfHostedRunnersForRepoParams) (*ActionsListSelfHostedRunnersForRepoOKHeaders, error)
	// ActionsListSelfHostedRunnersInGroupForOrg invokes actions/list-self-hosted-runners-in-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Lists self-hosted runners that are in a specific organization group.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
	ActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, params ActionsListSelfHostedRunnersInGroupForOrgParams) (*ActionsListSelfHostedRunnersInGroupForOrgOKHeaders, error)
	// ActionsListWorkflowRunArtifacts invokes actions/list-workflow-run-artifacts operation.
	//
	// Lists artifacts for a workflow run. Anyone with read access to the repository can use this
	// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
	// Apps must have the `actions:read` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
	ActionsListWorkflowRunArtifacts(ctx context.Context, params ActionsListWorkflowRunArtifactsParams) (*ActionsListWorkflowRunArtifactsOKHeaders, error)
	// ActionsListWorkflowRunsForRepo invokes actions/list-workflow-runs-for-repo operation.
	//
	// Lists all workflow runs for a repository. You can use parameters to narrow the list of results.
	// For more information about using parameters, see [Parameters](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#parameters).
	// Anyone with read access to the repository can use this endpoint. If the repository is private you
	// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
	// permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/actions/runs
	ActionsListWorkflowRunsForRepo(ctx context.Context, params ActionsListWorkflowRunsForRepoParams) (*ActionsListWorkflowRunsForRepoOKHeaders, error)
	// ActionsReRunWorkflow invokes actions/re-run-workflow operation.
	//
	// **Deprecation Notice:** This endpoint is deprecated.
	// We recommend migrating your existing code to use the new [retry workflow](https://docs.github.
	// com/rest/reference/actions#retry-a-workflow) endpoint.
	// Re-runs your workflow run using its `id`. You must authenticate using
	// an access token with the `repo` scope to use this endpoint. GitHub Apps must have
	// the `actions:write` permission to use this endpoint.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
	ActionsReRunWorkflow(ctx context.Context, params ActionsReRunWorkflowParams) error
	// ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Removes a repository from the list of selected repositories that can access a self-hosted runner
	// group. The runner group must have `visibility` set to `selected`. For more information, see
	// "[Create a self-hosted runner group for an
	// organization](#create-a-self-hosted-runner-group-for-an-organization)."
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
	ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) error
	// ActionsRemoveSelectedRepoFromOrgSecret invokes actions/remove-selected-repo-from-org-secret operation.
	//
	// Removes a repository from an organization secret when the `visibility` for repository access is
	// set to `selected`. The visibility is set when you [Create or update an organization
	// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `secrets` organization permission to use this endpoint.
	//
	// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
	ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, params ActionsRemoveSelectedRepoFromOrgSecretParams) (ActionsRemoveSelectedRepoFromOrgSecretRes, error)
	// ActionsRemoveSelfHostedRunnerFromGroupForOrg invokes actions/remove-self-hosted-runner-from-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Removes a self-hosted runner from a group configured in an organization. The runner is then
	// returned to the default group.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
	ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) error
	// ActionsRetryWorkflow invokes actions/retry-workflow operation.
	//
	// Retry your workflow run using its `id`. You must authenticate using an access token with the
	// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
	// this endpoint.
	//
	// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
	ActionsRetryWorkflow(ctx context.Context, params ActionsRetryWorkflowParams) error
	// ActionsReviewPendingDeploymentsForRun invokes actions/review-pending-deployments-for-run operation.
	//
	// Approve or reject pending deployments that are waiting on approval by a required reviewer.
	// Anyone with read access to the repository contents and deployments can use this endpoint.
	//
	// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
	ActionsReviewPendingDeploymentsForRun(ctx context.Context, request *ActionsReviewPendingDeploymentsForRunReq, params ActionsReviewPendingDeploymentsForRunParams) ([]Deployment, error)
	// ActionsSetAllowedActionsOrganization invokes actions/set-allowed-actions-organization operation.
	//
	// Sets the actions that are allowed in an organization. To use this endpoint, the organization
	// permission policy for `allowed_actions` must be configured to `selected`. For more information,
	// see "[Set GitHub Actions permissions for an
	// organization](#set-github-actions-permissions-for-an-organization)."
	// If the organization belongs to an enterprise that has `selected` actions set at the enterprise
	// level, then you cannot override any of the enterprise's allowed actions settings.
	// To use the `patterns_allowed` setting for private repositories, the organization must belong to an
	// enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed`
	// setting only applies to public repositories in the organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// PUT /orgs/{org}/actions/permissions/selected-actions
	ActionsSetAllowedActionsOrganization(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsOrganizationParams) error
	// ActionsSetAllowedActionsRepository invokes actions/set-allowed-actions-repository operation.
	//
	// Sets the actions that are allowed in a repository. To use this endpoint, the repository permission
	// policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set
	// GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
	// If the repository belongs to an organization or enterprise that has `selected` actions set at the
	// organization or enterprise levels, then you cannot override any of the allowed actions settings.
	// To use the `patterns_allowed` setting for private repositories, the repository must belong to an
	// enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed`
	// setting only applies to public repositories.
	// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
	// Apps must have the `administration` repository permission to use this API.
	//
	// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
	ActionsSetAllowedActionsRepository(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsRepositoryParams) error
	// ActionsSetGithubActionsPermissionsOrganization invokes actions/set-github-actions-permissions-organization operation.
	//
	// Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
	// If the organization belongs to an enterprise that has set restrictive permissions at the
	// enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them
	// for the organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// PUT /orgs/{org}/actions/permissions
	ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, request *ActionsSetGithubActionsPermissionsOrganizationReq, params ActionsSetGithubActionsPermissionsOrganizationParams) error
	// ActionsSetGithubActionsPermissionsRepository invokes actions/set-github-actions-permissions-repository operation.
	//
	// Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the
	// repository.
	// If the repository belongs to an organization or enterprise that has set restrictive permissions at
	// the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you
	// cannot override them for the repository.
	// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
	// Apps must have the `administration` repository permission to use this API.
	//
	// PUT /repos/{owner}/{repo}/actions/permissions
	ActionsSetGithubActionsPermissionsRepository(ctx context.Context, request *ActionsSetGithubActionsPermissionsRepositoryReq, params ActionsSetGithubActionsPermissionsRepositoryParams) error
	// ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Replaces the list of repositories that have access to a self-hosted runner group configured in an
	// organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
	ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, request *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq, params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) error
	// ActionsSetSelectedReposForOrgSecret invokes actions/set-selected-repos-for-org-secret operation.
	//
	// Replaces all repositories for an organization secret when the `visibility` for repository access
	// is set to `selected`. The visibility is set when you [Create or update an organization
	// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `secrets` organization permission to use this endpoint.
	//
	// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
	ActionsSetSelectedReposForOrgSecret(ctx context.Context, request *ActionsSetSelectedReposForOrgSecretReq, params ActionsSetSelectedReposForOrgSecretParams) error
	// ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization invokes actions/set-selected-repositories-enabled-github-actions-organization operation.
	//
	// Replaces the list of selected repositories that are enabled for GitHub Actions in an organization.
	// To use this endpoint, the organization permission policy for `enabled_repositories` must be
	// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
	// organization](#set-github-actions-permissions-for-an-organization)."
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	// GitHub Apps must have the `administration` organization permission to use this API.
	//
	// PUT /orgs/{org}/actions/permissions/repositories
	ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, request *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq, params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) error
	// ActionsSetSelfHostedRunnersInGroupForOrg invokes actions/set-self-hosted-runners-in-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Replaces the list of self-hosted runners that are part of an organization runner group.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
	ActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, request *ActionsSetSelfHostedRunnersInGroupForOrgReq, params ActionsSetSelfHostedRunnersInGroupForOrgParams) error
	// ActionsUpdateSelfHostedRunnerGroupForOrg invokes actions/update-self-hosted-runner-group-for-org operation.
	//
	// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
	// information, see "[GitHub's products](https://docs.github.
	// com/github/getting-started-with-github/githubs-products)."
	// Updates the `name` and `visibility` of a self-hosted runner group in an organization.
	// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
	//
	// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
	ActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, request *ActionsUpdateSelfHostedRunnerGroupForOrgReq, params ActionsUpdateSelfHostedRunnerGroupForOrgParams) (*RunnerGroupsOrg, error)
	// ActivityCheckRepoIsStarredByAuthenticatedUser invokes activity/check-repo-is-starred-by-authenticated-user operation.
	//
	// Check if a repository is starred by the authenticated user.
	//
	// GET /user/starred/{owner}/{repo}
	ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, params ActivityCheckRepoIsStarredByAuthenticatedUserParams) (ActivityCheckRepoIsStarredByAuthenticatedUserRes, error)
	// ActivityDeleteRepoSubscription invokes activity/delete-repo-subscription operation.
	//
	// This endpoint should only be used to stop watching a repository. To control whether or not you
	// wish to receive notifications from a repository, [set the repository's subscription
	// manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
	//
	// DELETE /repos/{owner}/{repo}/subscription
	ActivityDeleteRepoSubscription(ctx context.Context, params ActivityDeleteRepoSubscriptionParams) error
	// ActivityDeleteThreadSubscription invokes activity/delete-thread-subscription operation.
	//
	// Mutes all future notifications for a conversation until you comment on the thread or get an
	// **@mention**. If you are watching the repository of the thread, you will still receive
	// notifications. To ignore future notifications for a repository you are watching, use the [Set a
	// thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
	// endpoint and set `ignore` to `true`.
	//
	// DELETE /notifications/threads/{thread_id}/subscription
	ActivityDeleteThreadSubscription(ctx context.Context, params ActivityDeleteThreadSubscriptionParams) (ActivityDeleteThreadSubscriptionRes, error)
	// ActivityGetFeeds invokes activity/get-feeds operation.
	//
	// GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard))
	// format. The Feeds API lists all the feeds available to the authenticated user:
	// *   **Timeline**: The GitHub global public timeline
	// *   **User**: The public timeline for any user, using [URI template](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#hypermedia)
	// *   **Current user public**: The public timeline for the authenticated user
	// *   **Current user**: The private timeline for the authenticated user
	// *   **Current user actor**: The private timeline for activity created by the authenticated user
	// *   **Current user organizations**: The private timeline for the organizations the authenticated
	// user is a member of.
	// *   **Security advisories**: A collection of public announcements that provide information about
	// security-related vulnerabilities in software on GitHub.
	// **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use
	// the older, non revocable auth tokens.
	//
	// GET /feeds
	ActivityGetFeeds(ctx context.Context) (*Feed, error)
	// ActivityGetRepoSubscription invokes activity/get-repo-subscription operation.
	//
	// Get a repository subscription.
	//
	// GET /repos/{owner}/{repo}/subscription
	ActivityGetRepoSubscription(ctx context.Context, params ActivityGetRepoSubscriptionParams) (ActivityGetRepoSubscriptionRes, error)
	// ActivityGetThread invokes activity/get-thread operation.
	//
	// Get a thread.
	//
	// GET /notifications/threads/{thread_id}
	ActivityGetThread(ctx context.Context, params ActivityGetThreadParams) (ActivityGetThreadRes, error)
	// ActivityGetThreadSubscriptionForAuthenticatedUser invokes activity/get-thread-subscription-for-authenticated-user operation.
	//
	// This checks to see if the current user is subscribed to a thread. You can also [get a repository
	// subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
	// Note that subscriptions are only generated if a user is participating in a conversation--for
	// example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
	//
	// GET /notifications/threads/{thread_id}/subscription
	ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, params ActivityGetThreadSubscriptionForAuthenticatedUserParams) (ActivityGetThreadSubscriptionForAuthenticatedUserRes, error)
	// ActivityListEventsForAuthenticatedUser invokes activity/list-events-for-authenticated-user operation.
	//
	// If you are authenticated as the given user, you will see your private events. Otherwise, you'll
	// only see public events.
	//
	// GET /users/{username}/events
	ActivityListEventsForAuthenticatedUser(ctx context.Context, params ActivityListEventsForAuthenticatedUserParams) ([]Event, error)
	// ActivityListNotificationsForAuthenticatedUser invokes activity/list-notifications-for-authenticated-user operation.
	//
	// List all notifications for the current user, sorted by most recently updated.
	//
	// GET /notifications
	ActivityListNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListNotificationsForAuthenticatedUserParams) (ActivityListNotificationsForAuthenticatedUserRes, error)
	// ActivityListOrgEventsForAuthenticatedUser invokes activity/list-org-events-for-authenticated-user operation.
	//
	// This is the user's organization dashboard. You must be authenticated as the user to view this.
	//
	// GET /users/{username}/events/orgs/{org}
	ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, params ActivityListOrgEventsForAuthenticatedUserParams) ([]Event, error)
	// ActivityListPublicEvents invokes activity/list-public-events operation.
	//
	// We delay the public events feed by five minutes, which means the most recent event returned by the
	// public events API actually occurred at least five minutes ago.
	//
	// GET /events
	ActivityListPublicEvents(ctx context.Context, params ActivityListPublicEventsParams) (ActivityListPublicEventsRes, error)
	// ActivityListPublicEventsForRepoNetwork invokes activity/list-public-events-for-repo-network operation.
	//
	// List public events for a network of repositories.
	//
	// GET /networks/{owner}/{repo}/events
	ActivityListPublicEventsForRepoNetwork(ctx context.Context, params ActivityListPublicEventsForRepoNetworkParams) (ActivityListPublicEventsForRepoNetworkRes, error)
	// ActivityListPublicEventsForUser invokes activity/list-public-events-for-user operation.
	//
	// List public events for a user.
	//
	// GET /users/{username}/events/public
	ActivityListPublicEventsForUser(ctx context.Context, params ActivityListPublicEventsForUserParams) ([]Event, error)
	// ActivityListPublicOrgEvents invokes activity/list-public-org-events operation.
	//
	// List public organization events.
	//
	// GET /orgs/{org}/events
	ActivityListPublicOrgEvents(ctx context.Context, params ActivityListPublicOrgEventsParams) ([]Event, error)
	// ActivityListReceivedEventsForUser invokes activity/list-received-events-for-user operation.
	//
	// These are events that you've received by watching repos and following users. If you are
	// authenticated as the given user, you will see private events. Otherwise, you'll only see public
	// events.
	//
	// GET /users/{username}/received_events
	ActivityListReceivedEventsForUser(ctx context.Context, params ActivityListReceivedEventsForUserParams) ([]Event, error)
	// ActivityListReceivedPublicEventsForUser invokes activity/list-received-public-events-for-user operation.
	//
	// List public events received by a user.
	//
	// GET /users/{username}/received_events/public
	ActivityListReceivedPublicEventsForUser(ctx context.Context, params ActivityListReceivedPublicEventsForUserParams) ([]Event, error)
	// ActivityListRepoEvents invokes activity/list-repo-events operation.
	//
	// List repository events.
	//
	// GET /repos/{owner}/{repo}/events
	ActivityListRepoEvents(ctx context.Context, params ActivityListRepoEventsParams) ([]Event, error)
	// ActivityListRepoNotificationsForAuthenticatedUser invokes activity/list-repo-notifications-for-authenticated-user operation.
	//
	// List all notifications for the current user.
	//
	// GET /repos/{owner}/{repo}/notifications
	ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListRepoNotificationsForAuthenticatedUserParams) (*ActivityListRepoNotificationsForAuthenticatedUserOKHeaders, error)
	// ActivityListReposStarredByAuthenticatedUser invokes activity/list-repos-starred-by-authenticated-user operation.
	//
	// Lists repositories the authenticated user has starred.
	// You can also find out _when_ stars were created by passing the following custom [media
	// type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:.
	//
	// GET /user/starred
	ActivityListReposStarredByAuthenticatedUser(ctx context.Context, params ActivityListReposStarredByAuthenticatedUserParams) (ActivityListReposStarredByAuthenticatedUserRes, error)
	// ActivityListReposWatchedByUser invokes activity/list-repos-watched-by-user operation.
	//
	// Lists repositories a user is watching.
	//
	// GET /users/{username}/subscriptions
	ActivityListReposWatchedByUser(ctx context.Context, params ActivityListReposWatchedByUserParams) (*ActivityListReposWatchedByUserOKHeaders, error)
	// ActivityListWatchedReposForAuthenticatedUser invokes activity/list-watched-repos-for-authenticated-user operation.
	//
	// Lists repositories the authenticated user is watching.
	//
	// GET /user/subscriptions
	ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, params ActivityListWatchedReposForAuthenticatedUserParams) (ActivityListWatchedReposForAuthenticatedUserRes, error)
	// ActivityListWatchersForRepo invokes activity/list-watchers-for-repo operation.
	//
	// Lists the people watching the specified repository.
	//
	// GET /repos/{owner}/{repo}/subscribers
	ActivityListWatchersForRepo(ctx context.Context, params ActivityListWatchersForRepoParams) (*ActivityListWatchersForRepoOKHeaders, error)
	// ActivityMarkNotificationsAsRead invokes activity/mark-notifications-as-read operation.
	//
	// Marks all notifications as "read" removes it from the [default view on GitHub](https://github.
	// com/notifications). If the number of notifications is too large to complete in one request, you
	// will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark
	// notifications as "read." To check whether any "unread" notifications remain, you can use the [List
	// notifications for the authenticated user](https://docs.github.
	// com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the
	// query parameter `all=false`.
	//
	// PUT /notifications
	ActivityMarkNotificationsAsRead(ctx context.Context, request OptActivityMarkNotificationsAsReadReq) (ActivityMarkNotificationsAsReadRes, error)
	// ActivityMarkRepoNotificationsAsRead invokes activity/mark-repo-notifications-as-read operation.
	//
	// Marks all notifications in a repository as "read" removes them from the [default view on
	// GitHub](https://github.com/notifications). If the number of notifications is too large to complete
	// in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous
	// process to mark notifications as "read." To check whether any "unread" notifications remain, you
	// can use the [List repository notifications for the authenticated user](https://docs.github.
	// com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and
	// pass the query parameter `all=false`.
	//
	// PUT /repos/{owner}/{repo}/notifications
	ActivityMarkRepoNotificationsAsRead(ctx context.Context, request OptActivityMarkRepoNotificationsAsReadReq, params ActivityMarkRepoNotificationsAsReadParams) (ActivityMarkRepoNotificationsAsReadRes, error)
	// ActivityMarkThreadAsRead invokes activity/mark-thread-as-read operation.
	//
	// Mark a thread as read.
	//
	// PATCH /notifications/threads/{thread_id}
	ActivityMarkThreadAsRead(ctx context.Context, params ActivityMarkThreadAsReadParams) (ActivityMarkThreadAsReadRes, error)
	// ActivitySetRepoSubscription invokes activity/set-repo-subscription operation.
	//
	// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore
	// notifications made within a repository, set `ignored` to `true`. If you would like to stop
	// watching a repository, [delete the repository's subscription](https://docs.github.
	// com/rest/reference/activity#delete-a-repository-subscription) completely.
	//
	// PUT /repos/{owner}/{repo}/subscription
	ActivitySetRepoSubscription(ctx context.Context, request OptActivitySetRepoSubscriptionReq, params ActivitySetRepoSubscriptionParams) (*RepositorySubscription, error)
	// ActivitySetThreadSubscription invokes activity/set-thread-subscription operation.
	//
	// If you are watching a repository, you receive notifications for all threads by default. Use this
	// endpoint to ignore future notifications for threads until you comment on the thread or get an
	// **@mention**.
	// You can also use this endpoint to subscribe to threads that you are currently not receiving
	// notifications for or to subscribed to threads that you have previously ignored.
	// Unsubscribing from a conversation in a repository that you are not watching is functionally
	// equivalent to the [Delete a thread subscription](https://docs.github.
	// com/rest/reference/activity#delete-a-thread-subscription) endpoint.
	//
	// PUT /notifications/threads/{thread_id}/subscription
	ActivitySetThreadSubscription(ctx context.Context, request OptActivitySetThreadSubscriptionReq, params ActivitySetThreadSubscriptionParams) (ActivitySetThreadSubscriptionRes, error)
	// ActivityStarRepoForAuthenticatedUser invokes activity/star-repo-for-authenticated-user operation.
	//
	// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
	// information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs).".
	//
	// PUT /user/starred/{owner}/{repo}
	ActivityStarRepoForAuthenticatedUser(ctx context.Context, params ActivityStarRepoForAuthenticatedUserParams) (ActivityStarRepoForAuthenticatedUserRes, error)
	// ActivityUnstarRepoForAuthenticatedUser invokes activity/unstar-repo-for-authenticated-user operation.
	//
	// Unstar a repository for the authenticated user.
	//
	// DELETE /user/starred/{owner}/{repo}
	ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, params ActivityUnstarRepoForAuthenticatedUserParams) (ActivityUnstarRepoForAuthenticatedUserRes, error)
	// AppsAddRepoToInstallation invokes apps/add-repo-to-installation operation.
	//
	// Add a single repository to an installation. The authenticated user must have admin access to the
	// repository.
	// You must use a personal access token (which you can create via the [command line](https://docs.
	// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
	// Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
	//
	// PUT /user/installations/{installation_id}/repositories/{repository_id}
	AppsAddRepoToInstallation(ctx context.Context, params AppsAddRepoToInstallationParams) (AppsAddRepoToInstallationRes, error)
	// AppsCheckToken invokes apps/check-token operation.
	//
	// OAuth applications can use a special API method for checking OAuth token validity without
	// exceeding the normal rate limits for failed login attempts. Authentication works differently with
	// this particular endpoint. You must use [Basic Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where
	// the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid
	// tokens will return `404 NOT FOUND`.
	//
	// POST /applications/{client_id}/token
	AppsCheckToken(ctx context.Context, request *AppsCheckTokenReq, params AppsCheckTokenParams) (AppsCheckTokenRes, error)
	// AppsCreateContentAttachment invokes apps/create-content-attachment operation.
	//
	// Creates an attachment under a content reference URL in the body or comment of an issue or pull
	// request. Use the `id` and `repository` `full_name` of the content reference from the
	// [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to
	// create an attachment.
	// The app must create a content attachment within six hours of the content reference URL being
	// posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)"
	// for details about content attachments.
	// You must use an [installation access token](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
	// to access this endpoint.
	//
	// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
	AppsCreateContentAttachment(ctx context.Context, request *AppsCreateContentAttachmentReq, params AppsCreateContentAttachmentParams) (AppsCreateContentAttachmentRes, error)
	// AppsCreateFromManifest invokes apps/create-from-manifest operation.
	//
	// Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest
	// flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/).
	// When you create a GitHub App with the manifest flow, you receive a temporary `code` used to
	// retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
	//
	// POST /app-manifests/{code}/conversions
	AppsCreateFromManifest(ctx context.Context, request *AppsCreateFromManifestReq, params AppsCreateFromManifestParams) (AppsCreateFromManifestRes, error)
	// AppsCreateInstallationAccessToken invokes apps/create-installation-access-token operation.
	//
	// Creates an installation access token that enables a GitHub App to make authenticated API requests
	// for the app's installation on an organization or individual account. Installation tokens expire
	// one hour from the time you create them. Using an expired token produces a status code of `401 -
	// Unauthorized`, and requires creating a new installation token. By default the installation token
	// has access to all repositories that the installation can access. To restrict the access to
	// specific repositories, you can provide the `repository_ids` when creating the token. When you omit
	// `repository_ids`, the response does not contain the `repositories` key.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// POST /app/installations/{installation_id}/access_tokens
	AppsCreateInstallationAccessToken(ctx context.Context, request OptAppsCreateInstallationAccessTokenReq, params AppsCreateInstallationAccessTokenParams) (AppsCreateInstallationAccessTokenRes, error)
	// AppsDeleteAuthorization invokes apps/delete-authorization operation.
	//
	// OAuth application owners can revoke a grant for their OAuth application and a specific user. You
	// must use [Basic Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
	// using the OAuth application's `client_id` and `client_secret` as the username and password. You
	// must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's
	// owner will be deleted.
	// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
	// application for the user. Once deleted, the application will have no access to the user's account
	// and will no longer be listed on [the application authorizations settings screen within
	// GitHub](https://github.com/settings/applications#authorized).
	//
	// DELETE /applications/{client_id}/grant
	AppsDeleteAuthorization(ctx context.Context, request *AppsDeleteAuthorizationReq, params AppsDeleteAuthorizationParams) (AppsDeleteAuthorizationRes, error)
	// AppsDeleteInstallation invokes apps/delete-installation operation.
	//
	// Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily
	// suspend an app's access to your account's resources, then we recommend the "[Suspend an app
	// installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// DELETE /app/installations/{installation_id}
	AppsDeleteInstallation(ctx context.Context, params AppsDeleteInstallationParams) (AppsDeleteInstallationRes, error)
	// AppsDeleteToken invokes apps/delete-token operation.
	//
	// OAuth application owners can revoke a single token for an OAuth application. You must use [Basic
	// Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
	// using the OAuth application's `client_id` and `client_secret` as the username and password.
	//
	// DELETE /applications/{client_id}/token
	AppsDeleteToken(ctx context.Context, request *AppsDeleteTokenReq, params AppsDeleteTokenParams) (AppsDeleteTokenRes, error)
	// AppsGetAuthenticated invokes apps/get-authenticated operation.
	//
	// Returns the GitHub App associated with the authentication credentials used. To see how many app
	// installations are associated with this GitHub App, see the `installations_count` in the response.
	// For more details about your app's installations, see the "[List installations for the
	// authenticated app](https://docs.github.
	// com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// GET /app
	AppsGetAuthenticated(ctx context.Context) (*Integration, error)
	// AppsGetBySlug invokes apps/get-by-slug operation.
	//
	// **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on
	// the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
	// If the GitHub App you specify is public, you can access this endpoint without authenticating. If
	// the GitHub App you specify is private, you must authenticate with a [personal access
	// token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or
	// an [installation access token](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
	// to access this endpoint.
	//
	// GET /apps/{app_slug}
	AppsGetBySlug(ctx context.Context, params AppsGetBySlugParams) (AppsGetBySlugRes, error)
	// AppsGetSubscriptionPlanForAccount invokes apps/get-subscription-plan-for-account operation.
	//
	// Shows whether the user or organization account actively subscribes to a plan listed by the
	// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
	// of their billing cycle, you will also see the upcoming pending change.
	// GitHub Apps must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
	// client secret to access this endpoint.
	//
	// GET /marketplace_listing/accounts/{account_id}
	AppsGetSubscriptionPlanForAccount(ctx context.Context, params AppsGetSubscriptionPlanForAccountParams) (AppsGetSubscriptionPlanForAccountRes, error)
	// AppsGetSubscriptionPlanForAccountStubbed invokes apps/get-subscription-plan-for-account-stubbed operation.
	//
	// Shows whether the user or organization account actively subscribes to a plan listed by the
	// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
	// of their billing cycle, you will also see the upcoming pending change.
	// GitHub Apps must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
	// client secret to access this endpoint.
	//
	// GET /marketplace_listing/stubbed/accounts/{account_id}
	AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, params AppsGetSubscriptionPlanForAccountStubbedParams) (AppsGetSubscriptionPlanForAccountStubbedRes, error)
	// AppsGetWebhookConfigForApp invokes apps/get-webhook-config-for-app operation.
	//
	// Returns the webhook configuration for a GitHub App. For more information about configuring a
	// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// GET /app/hook/config
	AppsGetWebhookConfigForApp(ctx context.Context) (*WebhookConfig, error)
	// AppsGetWebhookDelivery invokes apps/get-webhook-delivery operation.
	//
	// Returns a delivery for the webhook configured for a GitHub App.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// GET /app/hook/deliveries/{delivery_id}
	AppsGetWebhookDelivery(ctx context.Context, params AppsGetWebhookDeliveryParams) (AppsGetWebhookDeliveryRes, error)
	// AppsListAccountsForPlan invokes apps/list-accounts-for-plan operation.
	//
	// Returns user and organization accounts associated with the specified plan, including free plans.
	// For per-seat pricing, you see the list of accounts that have purchased the plan, including the
	// number of seats purchased. When someone submits a plan change that won't be processed until the
	// end of their billing cycle, you will also see the upcoming pending change.
	// GitHub Apps must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
	// client secret to access this endpoint.
	//
	// GET /marketplace_listing/plans/{plan_id}/accounts
	AppsListAccountsForPlan(ctx context.Context, params AppsListAccountsForPlanParams) (AppsListAccountsForPlanRes, error)
	// AppsListAccountsForPlanStubbed invokes apps/list-accounts-for-plan-stubbed operation.
	//
	// Returns repository and organization accounts associated with the specified plan, including free
	// plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including
	// the number of seats purchased. When someone submits a plan change that won't be processed until
	// the end of their billing cycle, you will also see the upcoming pending change.
	// GitHub Apps must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
	// client secret to access this endpoint.
	//
	// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
	AppsListAccountsForPlanStubbed(ctx context.Context, params AppsListAccountsForPlanStubbedParams) (AppsListAccountsForPlanStubbedRes, error)
	// AppsListInstallationReposForAuthenticatedUser invokes apps/list-installation-repos-for-authenticated-user operation.
	//
	// List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
	// `:admin`) to access for an installation.
	// The authenticated user has explicit permission to access repositories they own, repositories where
	// they are a collaborator, and repositories that they can access through an organization membership.
	// You must use a [user-to-server OAuth access token](https://docs.github.
	// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
	// The access the user has to each repository is included in the hash under the `permissions` key.
	//
	// GET /user/installations/{installation_id}/repositories
	AppsListInstallationReposForAuthenticatedUser(ctx context.Context, params AppsListInstallationReposForAuthenticatedUserParams) (AppsListInstallationReposForAuthenticatedUserRes, error)
	// AppsListPlans invokes apps/list-plans operation.
	//
	// Lists all plans that are part of your GitHub Marketplace listing.
	// GitHub Apps must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
	// client secret to access this endpoint.
	//
	// GET /marketplace_listing/plans
	AppsListPlans(ctx context.Context, params AppsListPlansParams) (AppsListPlansRes, error)
	// AppsListPlansStubbed invokes apps/list-plans-stubbed operation.
	//
	// Lists all plans that are part of your GitHub Marketplace listing.
	// GitHub Apps must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
	// client secret to access this endpoint.
	//
	// GET /marketplace_listing/stubbed/plans
	AppsListPlansStubbed(ctx context.Context, params AppsListPlansStubbedParams) (AppsListPlansStubbedRes, error)
	// AppsListReposAccessibleToInstallation invokes apps/list-repos-accessible-to-installation operation.
	//
	// List repositories that an app installation can access.
	// You must use an [installation access token](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
	// to access this endpoint.
	//
	// GET /installation/repositories
	AppsListReposAccessibleToInstallation(ctx context.Context, params AppsListReposAccessibleToInstallationParams) (AppsListReposAccessibleToInstallationRes, error)
	// AppsListSubscriptionsForAuthenticatedUser invokes apps/list-subscriptions-for-authenticated-user operation.
	//
	// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
	// access token](https://docs.github.
	// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
	//
	// GET /user/marketplace_purchases
	AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserParams) (AppsListSubscriptionsForAuthenticatedUserRes, error)
	// AppsListSubscriptionsForAuthenticatedUserStubbed invokes apps/list-subscriptions-for-authenticated-user-stubbed operation.
	//
	// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
	// access token](https://docs.github.
	// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
	//
	// GET /user/marketplace_purchases/stubbed
	AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserStubbedParams) (AppsListSubscriptionsForAuthenticatedUserStubbedRes, error)
	// AppsListWebhookDeliveries invokes apps/list-webhook-deliveries operation.
	//
	// Returns a list of webhook deliveries for the webhook configured for a GitHub App.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// GET /app/hook/deliveries
	AppsListWebhookDeliveries(ctx context.Context, params AppsListWebhookDeliveriesParams) (AppsListWebhookDeliveriesRes, error)
	// AppsRedeliverWebhookDelivery invokes apps/redeliver-webhook-delivery operation.
	//
	// Redeliver a delivery for the webhook configured for a GitHub App.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// POST /app/hook/deliveries/{delivery_id}/attempts
	AppsRedeliverWebhookDelivery(ctx context.Context, params AppsRedeliverWebhookDeliveryParams) (AppsRedeliverWebhookDeliveryRes, error)
	// AppsRemoveRepoFromInstallation invokes apps/remove-repo-from-installation operation.
	//
	// Remove a single repository from an installation. The authenticated user must have admin access to
	// the repository.
	// You must use a personal access token (which you can create via the [command line](https://docs.
	// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
	// Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
	//
	// DELETE /user/installations/{installation_id}/repositories/{repository_id}
	AppsRemoveRepoFromInstallation(ctx context.Context, params AppsRemoveRepoFromInstallationParams) (AppsRemoveRepoFromInstallationRes, error)
	// AppsResetToken invokes apps/reset-token operation.
	//
	// OAuth applications can use this API method to reset a valid OAuth token without end-user
	// involvement. Applications must save the "token" property in the response because changes take
	// effect immediately. You must use [Basic Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
	// using the OAuth application's `client_id` and `client_secret` as the username and password.
	// Invalid tokens will return `404 NOT FOUND`.
	//
	// PATCH /applications/{client_id}/token
	AppsResetToken(ctx context.Context, request *AppsResetTokenReq, params AppsResetTokenParams) (AppsResetTokenRes, error)
	// AppsRevokeInstallationAccessToken invokes apps/revoke-installation-access-token operation.
	//
	// Revokes the installation token you're using to authenticate as an installation and access this
	// endpoint.
	// Once an installation token is revoked, the token is invalidated and cannot be used. Other
	// endpoints that require the revoked installation token must have a new installation token to work.
	// You can create a new token using the "[Create an installation access token for an
	// app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
	// endpoint.
	// You must use an [installation access token](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
	// to access this endpoint.
	//
	// DELETE /installation/token
	AppsRevokeInstallationAccessToken(ctx context.Context) error
	// AppsScopeToken invokes apps/scope-token operation.
	//
	// Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission
	// scoped user-to-server OAuth access token. You can specify which repositories the token can access
	// and which permissions are granted to the token. You must use [Basic Authentication](https://docs.
	// github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this
	// endpoint, using the OAuth application's `client_id` and `client_secret` as the username and
	// password. Invalid tokens will return `404 NOT FOUND`.
	//
	// POST /applications/{client_id}/token/scoped
	AppsScopeToken(ctx context.Context, request *AppsScopeTokenReq, params AppsScopeTokenParams) (AppsScopeTokenRes, error)
	// AppsSuspendInstallation invokes apps/suspend-installation operation.
	//
	// Suspends a GitHub App on a user, organization, or business account, which blocks the app from
	// accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub
	// API or webhook events is blocked for that account.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// PUT /app/installations/{installation_id}/suspended
	AppsSuspendInstallation(ctx context.Context, params AppsSuspendInstallationParams) (AppsSuspendInstallationRes, error)
	// AppsUnsuspendInstallation invokes apps/unsuspend-installation operation.
	//
	// Removes a GitHub App installation suspension.
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// DELETE /app/installations/{installation_id}/suspended
	AppsUnsuspendInstallation(ctx context.Context, params AppsUnsuspendInstallationParams) (AppsUnsuspendInstallationRes, error)
	// AppsUpdateWebhookConfigForApp invokes apps/update-webhook-config-for-app operation.
	//
	// Updates the webhook configuration for a GitHub App. For more information about configuring a
	// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
	// You must use a [JWT](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
	// access this endpoint.
	//
	// PATCH /app/hook/config
	AppsUpdateWebhookConfigForApp(ctx context.Context, request OptAppsUpdateWebhookConfigForAppReq) (*WebhookConfig, error)
	// BillingGetGithubActionsBillingGhe invokes billing/get-github-actions-billing-ghe operation.
	//
	// Gets the summary of the free and paid GitHub Actions minutes used.
	// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
	// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
	// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
	// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
	// GitHub Actions](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
	// The authenticated user must be an enterprise admin.
	//
	// GET /enterprises/{enterprise}/settings/billing/actions
	BillingGetGithubActionsBillingGhe(ctx context.Context, params BillingGetGithubActionsBillingGheParams) (*ActionsBillingUsage, error)
	// BillingGetGithubActionsBillingOrg invokes billing/get-github-actions-billing-org operation.
	//
	// Gets the summary of the free and paid GitHub Actions minutes used.
	// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
	// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
	// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
	// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
	// billing for GitHub Actions](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
	// Access tokens must have the `repo` or `admin:org` scope.
	//
	// GET /orgs/{org}/settings/billing/actions
	BillingGetGithubActionsBillingOrg(ctx context.Context, params BillingGetGithubActionsBillingOrgParams) (*ActionsBillingUsage, error)
	// BillingGetGithubActionsBillingUser invokes billing/get-github-actions-billing-user operation.
	//
	// Gets the summary of the free and paid GitHub Actions minutes used.
	// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
	// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
	// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
	// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
	// billing for GitHub Actions](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
	// Access tokens must have the `user` scope.
	//
	// GET /users/{username}/settings/billing/actions
	BillingGetGithubActionsBillingUser(ctx context.Context, params BillingGetGithubActionsBillingUserParams) (*ActionsBillingUsage, error)
	// BillingGetGithubPackagesBillingGhe invokes billing/get-github-packages-billing-ghe operation.
	//
	// Gets the free and paid storage used for GitHub Packages in gigabytes.
	// Paid minutes only apply to packages stored for private repositories. For more information, see
	// "[Managing billing for GitHub Packages](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
	// The authenticated user must be an enterprise admin.
	//
	// GET /enterprises/{enterprise}/settings/billing/packages
	BillingGetGithubPackagesBillingGhe(ctx context.Context, params BillingGetGithubPackagesBillingGheParams) (*PackagesBillingUsage, error)
	// BillingGetGithubPackagesBillingOrg invokes billing/get-github-packages-billing-org operation.
	//
	// Gets the free and paid storage used for GitHub Packages in gigabytes.
	// Paid minutes only apply to packages stored for private repositories. For more information, see
	// "[Managing billing for GitHub Packages](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
	// Access tokens must have the `repo` or `admin:org` scope.
	//
	// GET /orgs/{org}/settings/billing/packages
	BillingGetGithubPackagesBillingOrg(ctx context.Context, params BillingGetGithubPackagesBillingOrgParams) (*PackagesBillingUsage, error)
	// BillingGetGithubPackagesBillingUser invokes billing/get-github-packages-billing-user operation.
	//
	// Gets the free and paid storage used for GitHub Packages in gigabytes.
	// Paid minutes only apply to packages stored for private repositories. For more information, see
	// "[Managing billing for GitHub Packages](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
	// Access tokens must have the `user` scope.
	//
	// GET /users/{username}/settings/billing/packages
	BillingGetGithubPackagesBillingUser(ctx context.Context, params BillingGetGithubPackagesBillingUserParams) (*PackagesBillingUsage, error)
	// BillingGetSharedStorageBillingGhe invokes billing/get-shared-storage-billing-ghe operation.
	//
	// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
	// Paid minutes only apply to packages stored for private repositories. For more information, see
	// "[Managing billing for GitHub Packages](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
	// The authenticated user must be an enterprise admin.
	//
	// GET /enterprises/{enterprise}/settings/billing/shared-storage
	BillingGetSharedStorageBillingGhe(ctx context.Context, params BillingGetSharedStorageBillingGheParams) (*CombinedBillingUsage, error)
	// BillingGetSharedStorageBillingOrg invokes billing/get-shared-storage-billing-org operation.
	//
	// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
	// Paid minutes only apply to packages stored for private repositories. For more information, see
	// "[Managing billing for GitHub Packages](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
	// Access tokens must have the `repo` or `admin:org` scope.
	//
	// GET /orgs/{org}/settings/billing/shared-storage
	BillingGetSharedStorageBillingOrg(ctx context.Context, params BillingGetSharedStorageBillingOrgParams) (*CombinedBillingUsage, error)
	// BillingGetSharedStorageBillingUser invokes billing/get-shared-storage-billing-user operation.
	//
	// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
	// Paid minutes only apply to packages stored for private repositories. For more information, see
	// "[Managing billing for GitHub Packages](https://help.github.
	// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
	// Access tokens must have the `user` scope.
	//
	// GET /users/{username}/settings/billing/shared-storage
	BillingGetSharedStorageBillingUser(ctx context.Context, params BillingGetSharedStorageBillingUserParams) (*CombinedBillingUsage, error)
	// ChecksCreateSuite invokes checks/create-suite operation.
	//
	// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
	// run were created. Pushes to a branch in a forked repository are not detected and return an empty
	// `pull_requests` array and a `null` value for `head_branch`.
	// By default, check suites are automatically created when you create a [check run](https://docs.
	// github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually
	// creating check suites when you've disabled automatic creation using "[Update repository
	// preferences for check suites](https://docs.github.
	// com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must
	// have the `checks:write` permission to create check suites.
	//
	// POST /repos/{owner}/{repo}/check-suites
	ChecksCreateSuite(ctx context.Context, request *ChecksCreateSuiteReq, params ChecksCreateSuiteParams) (ChecksCreateSuiteRes, error)
	// ChecksGet invokes checks/get operation.
	//
	// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
	// run were created. Pushes to a branch in a forked repository are not detected and return an empty
	// `pull_requests` array.
	// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a
	// private repository or pull access to a public repository to get check runs. OAuth Apps and
	// authenticated users must have the `repo` scope to get check runs in a private repository.
	//
	// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
	ChecksGet(ctx context.Context, params ChecksGetParams) (*CheckRun, error)
	// ChecksGetSuite invokes checks/get-suite operation.
	//
	// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
	// run were created. Pushes to a branch in a forked repository are not detected and return an empty
	// `pull_requests` array and a `null` value for `head_branch`.
	// Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a
	// private repository or pull access to a public repository to get check suites. OAuth Apps and
	// authenticated users must have the `repo` scope to get check suites in a private repository.
	//
	// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
	ChecksGetSuite(ctx context.Context, params ChecksGetSuiteParams) (*CheckSuite, error)
	// ChecksListAnnotations invokes checks/list-annotations operation.
	//
	// Lists annotations for a check run using the annotation `id`. GitHub Apps must have the
	// `checks:read` permission on a private repository or pull access to a public repository to get
	// annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get
	// annotations for a check run in a private repository.
	//
	// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
	ChecksListAnnotations(ctx context.Context, params ChecksListAnnotationsParams) (*ChecksListAnnotationsOKHeaders, error)
	// ChecksListForRef invokes checks/list-for-ref operation.
	//
	// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
	// run were created. Pushes to a branch in a forked repository are not detected and return an empty
	// `pull_requests` array.
	// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps
	// must have the `checks:read` permission on a private repository or pull access to a public
	// repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get
	// check runs in a private repository.
	//
	// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
	ChecksListForRef(ctx context.Context, params ChecksListForRefParams) (*ChecksListForRefOKHeaders, error)
	// ChecksListForSuite invokes checks/list-for-suite operation.
	//
	// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
	// run were created. Pushes to a branch in a forked repository are not detected and return an empty
	// `pull_requests` array.
	// Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read`
	// permission on a private repository or pull access to a public repository to get check runs. OAuth
	// Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
	//
	// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
	ChecksListForSuite(ctx context.Context, params ChecksListForSuiteParams) (*ChecksListForSuiteOKHeaders, error)
	// ChecksListSuitesForRef invokes checks/list-suites-for-ref operation.
	//
	// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
	// run were created. Pushes to a branch in a forked repository are not detected and return an empty
	// `pull_requests` array and a `null` value for `head_branch`.
	// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub
	// Apps must have the `checks:read` permission on a private repository or pull access to a public
	// repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to
	// get check suites in a private repository.
	//
	// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
	ChecksListSuitesForRef(ctx context.Context, params ChecksListSuitesForRefParams) (*ChecksListSuitesForRefOKHeaders, error)
	// ChecksRerequestSuite invokes checks/rerequest-suite operation.
	//
	// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository.
	// This endpoint will trigger the [`check_suite` webhook](https://docs.github.
	// com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite
	// is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
	// To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private
	// repository or pull access to a public repository.
	//
	// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
	ChecksRerequestSuite(ctx context.Context, params ChecksRerequestSuiteParams) error
	// ChecksSetSuitesPreferences invokes checks/set-suites-preferences operation.
	//
	// Changes the default automatic flow when creating check suites. By default, a check suite is
	// automatically created each time code is pushed to a repository. When you disable the automatic
	// creation of check suites, you can manually [Create a check suite](https://docs.github.
	// com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository
	// to set preferences for check suites.
	//
	// PATCH /repos/{owner}/{repo}/check-suites/preferences
	ChecksSetSuitesPreferences(ctx context.Context, request *ChecksSetSuitesPreferencesReq, params ChecksSetSuitesPreferencesParams) (*CheckSuitePreference, error)
	// CodeScanningDeleteAnalysis invokes code-scanning/delete-analysis operation.
	//
	// Deletes a specified code scanning analysis from a repository. For
	// private repositories, you must use an access token with the `repo` scope. For public repositories,
	// you must use an access token with `public_repo` and `repo:security_events` scopes.
	// GitHub Apps must have the `security_events` write permission to use this endpoint.
	// You can delete one analysis at a time.
	// To delete a series of analyses, start with the most recent analysis and work backwards.
	// Conceptually, the process is similar to the undo function in a text editor.
	// When you list the analyses for a repository,
	// one or more will be identified as deletable in the response:
	// ```
	// "deletable": true
	// ```
	// An analysis is deletable when it's the most recent in a set of analyses.
	// Typically, a repository will have multiple sets of analyses
	// for each enabled code scanning tool,
	// where a set is determined by a unique combination of analysis values:
	// * `ref`
	// * `tool`
	// * `analysis_key`
	// * `environment`
	// If you attempt to delete an analysis that is not the most recent in a set,
	// you'll get a 400 response with the message:
	// ```
	// Analysis specified is not deletable.
	// ```
	// The response from a successful `DELETE` operation provides you with
	// two alternative URLs for deleting the next analysis in the set
	// (see the example default response below).
	// Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
	// in the set. This is a useful option if you want to preserve at least one analysis
	// for the specified tool in your repository.
	// Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
	// When you delete the last analysis in a set the value of `next_analysis_url` and
	// `confirm_delete_url`
	// in the 200 response is `null`.
	// As an example of the deletion process,
	// let's imagine that you added a workflow that configured a particular code scanning tool
	// to analyze the code in a repository. This tool has added 15 analyses:
	// 10 on the default branch, and another 5 on a topic branch.
	// You therefore have two separate sets of analyses for this tool.
	// You've now decided that you want to remove all of the analyses for the tool.
	// To do this you must make 15 separate deletion requests.
	// To start, you must find the deletable analysis for one of the sets,
	// step through deleting the analyses in that set,
	// and then repeat the process for the second set.
	// The procedure therefore consists of a nested loop:
	// **Outer loop**:
	// * List the analyses for the repository, filtered by tool.
	// * Parse this list to find a deletable analysis. If found:
	// **Inner loop**:
	// * Delete the identified analysis.
	// * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next
	// iteration.
	// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub
	// user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value.
	//  Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis
	// in each set undeleted to avoid removing a tool's analysis entirely.
	//
	// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
	CodeScanningDeleteAnalysis(ctx context.Context, params CodeScanningDeleteAnalysisParams) (CodeScanningDeleteAnalysisRes, error)
	// CodeScanningGetAlert invokes code-scanning/get-alert operation.
	//
	// Gets a single code scanning alert. You must use an access token with the `security_events` scope
	// to use this endpoint. GitHub Apps must have the `security_events` read permission to use this
	// endpoint.
	// **Deprecation notice**:
	// The instances field is deprecated and will, in future, not be included in the response for this
	// endpoint. The example response reflects this change. The same information can now be retrieved via
	// a GET request to the URL specified by `instances_url`.
	//
	// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
	CodeScanningGetAlert(ctx context.Context, params CodeScanningGetAlertParams) (CodeScanningGetAlertRes, error)
	// CodeScanningGetAnalysis invokes code-scanning/get-analysis operation.
	//
	// Gets a specified code scanning analysis for a repository.
	// You must use an access token with the `security_events` scope to use this endpoint.
	// GitHub Apps must have the `security_events` read permission to use this endpoint.
	// The default JSON response contains fields that describe the analysis.
	// This includes the Git reference and commit SHA to which the analysis relates,
	// the datetime of the analysis, the name of the code scanning tool,
	// and the number of alerts.
	// The `rules_count` field in the default response give the number of rules
	// that were run in the analysis.
	// For very old analyses this data is not available,
	// and `0` is returned in this field.
	// If you use the Accept header `application/sarif+json`,
	// the response contains the analysis data that was uploaded.
	// This is formatted as
	// [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
	// **Deprecation notice**:
	// The `tool_name` field is deprecated and will, in future, not be included in the response for this
	// endpoint. The example response reflects this change. The tool name can now be found inside the
	// `tool` field.
	//
	// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
	CodeScanningGetAnalysis(ctx context.Context, params CodeScanningGetAnalysisParams) (CodeScanningGetAnalysisRes, error)
	// CodeScanningGetSarif invokes code-scanning/get-sarif operation.
	//
	// Gets information about a SARIF upload, including the status and the URL of the analysis that was
	// uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code
	// scanning analysis for a
	// repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You
	// must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must
	// have the `security_events` read permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
	CodeScanningGetSarif(ctx context.Context, params CodeScanningGetSarifParams) (CodeScanningGetSarifRes, error)
	// CodeScanningListAlertInstances invokes code-scanning/list-alert-instances operation.
	//
	// Lists all instances of the specified code scanning alert. You must use an access token with the
	// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read
	// permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
	CodeScanningListAlertInstances(ctx context.Context, params CodeScanningListAlertInstancesParams) (CodeScanningListAlertInstancesRes, error)
	// CodeScanningListAlertsForRepo invokes code-scanning/list-alerts-for-repo operation.
	//
	// Lists all open code scanning alerts for the default branch (usually `main`
	// or `master`). You must use an access token with the `security_events` scope to use
	// this endpoint. GitHub Apps must have the `security_events` read permission to use
	// this endpoint.
	// The response includes a `most_recent_instance` object.
	// This provides details of the most recent instance of this alert
	// for the default branch or for the specified Git reference
	// (if you used `ref` in the request).
	//
	// GET /repos/{owner}/{repo}/code-scanning/alerts
	CodeScanningListAlertsForRepo(ctx context.Context, params CodeScanningListAlertsForRepoParams) (CodeScanningListAlertsForRepoRes, error)
	// CodeScanningListRecentAnalyses invokes code-scanning/list-recent-analyses operation.
	//
	// Lists the details of all code scanning analyses for a repository,
	// starting with the most recent.
	// The response is paginated and you can use the `page` and `per_page` parameters
	// to list the analyses you're interested in.
	// By default 30 analyses are listed per page.
	// The `rules_count` field in the response give the number of rules
	// that were run in the analysis.
	// For very old analyses this data is not available,
	// and `0` is returned in this field.
	// You must use an access token with the `security_events` scope to use this endpoint.
	// GitHub Apps must have the `security_events` read permission to use this endpoint.
	// **Deprecation notice**:
	// The `tool_name` field is deprecated and will, in future, not be included in the response for this
	// endpoint. The example response reflects this change. The tool name can now be found inside the
	// `tool` field.
	//
	// GET /repos/{owner}/{repo}/code-scanning/analyses
	CodeScanningListRecentAnalyses(ctx context.Context, params CodeScanningListRecentAnalysesParams) (CodeScanningListRecentAnalysesRes, error)
	// CodeScanningUpdateAlert invokes code-scanning/update-alert operation.
	//
	// Updates the status of a single code scanning alert. You must use an access token with the
	// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write
	// permission to use this endpoint.
	//
	// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
	CodeScanningUpdateAlert(ctx context.Context, request *CodeScanningUpdateAlertReq, params CodeScanningUpdateAlertParams) (CodeScanningUpdateAlertRes, error)
	// CodeScanningUploadSarif invokes code-scanning/upload-sarif operation.
	//
	// Uploads SARIF data containing the results of a code scanning analysis to make the results
	// available in a repository. You must use an access token with the `security_events` scope to use
	// this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
	// There are two places where you can upload code scanning results.
	// - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref
	// refs/pull/42/head`, then the results appear as alerts in a pull request check. For more
	// information, see "[Triaging code scanning alerts in pull
	// requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
	// - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in
	// the **Security** tab for your repository. For more information, see "[Managing code scanning
	// alerts for your
	// repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
	// You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and
	// then encode it as a Base64 format string. For example:
	// ```
	// gzip -c analysis-data.sarif | base64 -w0
	// ```
	// SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are
	// ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not
	// necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool
	// generates too many results, you should update the analysis configuration to run only the most
	// important rules or queries.
	// The `202 Accepted`, response includes an `id` value.
	// You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}`
	// endpoint.
	// For more information, see "[Get information about a SARIF
	// upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload).".
	//
	// POST /repos/{owner}/{repo}/code-scanning/sarifs
	CodeScanningUploadSarif(ctx context.Context, request *CodeScanningUploadSarifReq, params CodeScanningUploadSarifParams) (CodeScanningUploadSarifRes, error)
	// CodesOfConductGetAllCodesOfConduct invokes codes-of-conduct/get-all-codes-of-conduct operation.
	//
	// Get all codes of conduct.
	//
	// GET /codes_of_conduct
	CodesOfConductGetAllCodesOfConduct(ctx context.Context) (CodesOfConductGetAllCodesOfConductRes, error)
	// CodesOfConductGetConductCode invokes codes-of-conduct/get-conduct-code operation.
	//
	// Get a code of conduct.
	//
	// GET /codes_of_conduct/{key}
	CodesOfConductGetConductCode(ctx context.Context, params CodesOfConductGetConductCodeParams) (CodesOfConductGetConductCodeRes, error)
	// EmojisGet invokes emojis/get operation.
	//
	// Lists all the emojis available to use on GitHub.
	//
	// GET /emojis
	EmojisGet(ctx context.Context) (EmojisGetRes, error)
	// EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
	//
	// Adds an organization to the list of selected organizations that can access a self-hosted runner
	// group. The runner group must have `visibility` set to `selected`. For more information, see
	// "[Create a self-hosted runner group for an
	// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
	EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) error
	// EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise invokes enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
	//
	// Adds a self-hosted runner to a runner group configured in an enterprise.
	// You must authenticate using an access token with the `admin:enterprise`
	// scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
	EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) error
	// EnterpriseAdminCreateRegistrationTokenForEnterprise invokes enterprise-admin/create-registration-token-for-enterprise operation.
	//
	// Returns a token that you can pass to the `config` script. The token expires after one hour.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	// #### Example using registration token
	// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
	// endpoint.
	// ```
	// ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
	// ```.
	//
	// POST /enterprises/{enterprise}/actions/runners/registration-token
	EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) (*AuthenticationToken, error)
	// EnterpriseAdminCreateRemoveTokenForEnterprise invokes enterprise-admin/create-remove-token-for-enterprise operation.
	//
	// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
	// enterprise. The token expires after one hour.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	// #### Example using remove token
	// To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token
	// provided by this
	// endpoint.
	// ```
	// ./config.sh remove --token TOKEN
	// ```.
	//
	// POST /enterprises/{enterprise}/actions/runners/remove-token
	EnterpriseAdminCreateRemoveTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) (*AuthenticationToken, error)
	// EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
	//
	// Creates a new self-hosted runner group for an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// POST /enterprises/{enterprise}/actions/runner-groups
	EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) (*RunnerGroupsEnterprise, error)
	// EnterpriseAdminDeleteScimGroupFromEnterprise invokes enterprise-admin/delete-scim-group-from-enterprise operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	//
	// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
	EnterpriseAdminDeleteScimGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) error
	// EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise invokes enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
	//
	// Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to
	// completely remove the runner when the machine you were using no longer exists.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
	EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) error
	// EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise invokes enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
	//
	// Deletes a self-hosted runner group for an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
	EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) error
	// EnterpriseAdminDeleteUserFromEnterprise invokes enterprise-admin/delete-user-from-enterprise operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	//
	// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
	EnterpriseAdminDeleteUserFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteUserFromEnterpriseParams) error
	// EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise invokes enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
	//
	// Removes an organization from the list of selected organizations that are enabled for GitHub
	// Actions in an enterprise. To use this endpoint, the enterprise permission policy for
	// `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub
	// Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
	EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) error
	// EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise invokes enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
	//
	// Adds an organization to the list of selected organizations that are enabled for GitHub Actions in
	// an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations`
	// must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for
	// an enterprise](#set-github-actions-permissions-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
	EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) error
	// EnterpriseAdminGetAllowedActionsEnterprise invokes enterprise-admin/get-allowed-actions-enterprise operation.
	//
	// Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise
	// permission policy for `allowed_actions` must be configured to `selected`. For more information,
	// see "[Set GitHub Actions permissions for an
	// enterprise](#set-github-actions-permissions-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/permissions/selected-actions
	EnterpriseAdminGetAllowedActionsEnterprise(ctx context.Context, params EnterpriseAdminGetAllowedActionsEnterpriseParams) (*SelectedActions, error)
	// EnterpriseAdminGetAuditLog invokes enterprise-admin/get-audit-log operation.
	//
	// Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and
	// you must use an access token with the `admin:enterprise` scope.
	//
	// GET /enterprises/{enterprise}/audit-log
	EnterpriseAdminGetAuditLog(ctx context.Context, params EnterpriseAdminGetAuditLogParams) ([]AuditLogEvent, error)
	// EnterpriseAdminGetGithubActionsPermissionsEnterprise invokes enterprise-admin/get-github-actions-permissions-enterprise operation.
	//
	// Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/permissions
	EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx context.Context, params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) (*ActionsEnterprisePermissions, error)
	// EnterpriseAdminGetProvisioningInformationForEnterpriseGroup invokes enterprise-admin/get-provisioning-information-for-enterprise-group operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	//
	// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
	EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) (*ScimEnterpriseGroup, error)
	// EnterpriseAdminGetProvisioningInformationForEnterpriseUser invokes enterprise-admin/get-provisioning-information-for-enterprise-user operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	//
	// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
	EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) (*ScimEnterpriseUser, error)
	// EnterpriseAdminGetSelfHostedRunnerForEnterprise invokes enterprise-admin/get-self-hosted-runner-for-enterprise operation.
	//
	// Gets a specific self-hosted runner configured in an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runners/{runner_id}
	EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) (*Runner, error)
	// EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
	//
	// Gets a specific self-hosted runner group for an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
	EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) (*RunnerGroupsEnterprise, error)
	// EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
	//
	// Lists the organizations with access to a self-hosted runner group.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
	EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (*EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK, error)
	// EnterpriseAdminListProvisionedGroupsEnterprise invokes enterprise-admin/list-provisioned-groups-enterprise operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	//
	// GET /scim/v2/enterprises/{enterprise}/Groups
	EnterpriseAdminListProvisionedGroupsEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedGroupsEnterpriseParams) (*ScimGroupListEnterprise, error)
	// EnterpriseAdminListProvisionedIdentitiesEnterprise invokes enterprise-admin/list-provisioned-identities-enterprise operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
	// When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise,
	// the account's metadata is immediately removed. However, the returned list of user accounts might
	// not always match the organization or enterprise member list you see on GitHub. This can happen in
	// certain cases where an external identity associated with an organization will not match an
	// organization member:
	// - When a user with a SCIM-provisioned external identity is removed from an enterprise, the
	// account's metadata is preserved to allow the user to re-join the organization in the future.
	// - When inviting a user to join an organization, you can expect to see their external identity in
	// the results before they accept the invitation, or if the invitation is cancelled (or never
	// accepted).
	// - When a user is invited over SCIM, an external identity is created that matches with the
	// invitee's email address. However, this identity is only linked to a user account when the user
	// accepts the invitation by going through SAML SSO.
	// The returned list of external identities can include an entry for a `null` user. These are
	// unlinked SAML identities that are created when a user goes through the following Single Sign-On
	// (SSO) process but does not sign in to their GitHub account after completing SSO:
	// 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
	// 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is
	// not currently signed in to their GitHub account.
	// 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is
	// created and the user is prompted to sign in to their GitHub account:
	// - If the user signs in, their GitHub account is linked to this entry.
	// - If the user does not sign in (or does not create a new account when prompted), they are not
	// added to the GitHub enterprise, and the external identity `null` entry remains in place.
	//
	// GET /scim/v2/enterprises/{enterprise}/Users
	EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) (*ScimUserListEnterprise, error)
	// EnterpriseAdminListRunnerApplicationsForEnterprise invokes enterprise-admin/list-runner-applications-for-enterprise operation.
	//
	// Lists binaries for the runner application that you can download and run.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runners/downloads
	EnterpriseAdminListRunnerApplicationsForEnterprise(ctx context.Context, params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) ([]RunnerApplication, error)
	// EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise invokes enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
	//
	// Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use
	// this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to
	// `selected`. For more information, see "[Set GitHub Actions permissions for an
	// enterprise](#set-github-actions-permissions-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/permissions/organizations
	EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (*EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK, error)
	// EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise invokes enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
	//
	// Lists all self-hosted runner groups for an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runner-groups
	EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) (*EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK, error)
	// EnterpriseAdminListSelfHostedRunnersForEnterprise invokes enterprise-admin/list-self-hosted-runners-for-enterprise operation.
	//
	// Lists all self-hosted runners configured for an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runners
	EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) (*EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders, error)
	// EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise invokes enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
	//
	// Lists the self-hosted runners that are in a specific enterprise group.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
	EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) (*EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders, error)
	// EnterpriseAdminProvisionAndInviteEnterpriseGroup invokes enterprise-admin/provision-and-invite-enterprise-group operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Provision an enterprise group, and invite users to the group. This sends invitation emails to the
	// email address of the invited users to join the GitHub organization that the SCIM group corresponds
	// to.
	//
	// POST /scim/v2/enterprises/{enterprise}/Groups
	EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx context.Context, request *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq, params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) (*ScimEnterpriseGroup, error)
	// EnterpriseAdminProvisionAndInviteEnterpriseUser invokes enterprise-admin/provision-and-invite-enterprise-user operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Provision enterprise membership for a user, and send organization invitation emails to the email
	// address.
	// You can optionally include the groups a user will be invited to join. If you do not provide a list
	// of `groups`, the user is provisioned for the enterprise, but no organization invitation emails
	// will be sent.
	//
	// POST /scim/v2/enterprises/{enterprise}/Users
	EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx context.Context, request *EnterpriseAdminProvisionAndInviteEnterpriseUserReq, params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) (*ScimEnterpriseUser, error)
	// EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
	//
	// Removes an organization from the list of selected organizations that can access a self-hosted
	// runner group. The runner group must have `visibility` set to `selected`. For more information, see
	// "[Create a self-hosted runner group for an
	// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
	EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) error
	// EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise invokes enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
	//
	// Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned
	// to the default group.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
	EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) error
	// EnterpriseAdminSetAllowedActionsEnterprise invokes enterprise-admin/set-allowed-actions-enterprise operation.
	//
	// Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise
	// permission policy for `allowed_actions` must be configured to `selected`. For more information,
	// see "[Set GitHub Actions permissions for an
	// enterprise](#set-github-actions-permissions-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
	EnterpriseAdminSetAllowedActionsEnterprise(ctx context.Context, request *SelectedActions, params EnterpriseAdminSetAllowedActionsEnterpriseParams) error
	// EnterpriseAdminSetGithubActionsPermissionsEnterprise invokes enterprise-admin/set-github-actions-permissions-enterprise operation.
	//
	// Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/permissions
	EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx context.Context, request *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq, params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) error
	// EnterpriseAdminSetInformationForProvisionedEnterpriseGroup invokes enterprise-admin/set-information-for-provisioned-enterprise-group operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Replaces an existing provisioned group’s information. You must provide all the information
	// required for the group as if you were provisioning it for the first time. Any existing group
	// information that you don't provide will be removed, including group membership. If you want to
	// only update a specific attribute, use the [Update an attribute for a SCIM enterprise
	// group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
	//
	// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
	EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx context.Context, request *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) (*ScimEnterpriseGroup, error)
	// EnterpriseAdminSetInformationForProvisionedEnterpriseUser invokes enterprise-admin/set-information-for-provisioned-enterprise-user operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Replaces an existing provisioned user's information. You must provide all the information required
	// for the user as if you were provisioning them for the first time. Any existing user information
	// that you don't provide will be removed. If you want to only update a specific attribute, use the
	// [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint
	// instead.
	// You must at least provide the required values for the user: `userName`, `name`, and `emails`.
	// **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external
	// identity, and deletes the associated `{scim_user_id}`.
	//
	// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
	EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx context.Context, request *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) (*ScimEnterpriseUser, error)
	// EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
	//
	// Replaces the list of organizations that have access to a self-hosted runner configured in an
	// enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
	EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, request *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq, params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) error
	// EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise invokes enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
	//
	// Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise.
	// To use this endpoint, the enterprise permission policy for `enabled_organizations` must be
	// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
	// enterprise](#set-github-actions-permissions-for-an-enterprise)."
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/permissions/organizations
	EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, request *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq, params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) error
	// EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise invokes enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
	//
	// Replaces the list of self-hosted runners that are part of an enterprise runner group.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
	EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, request *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq, params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) error
	// EnterpriseAdminUpdateAttributeForEnterpriseGroup invokes enterprise-admin/update-attribute-for-enterprise-group operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Allows you to change a provisioned group’s individual attributes. To change a group’s values,
	// you must provide a specific Operations JSON format that contains at least one of the add, remove,
	// or replace operations. For examples and more information on the SCIM operations format, see the
	// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
	//
	// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
	EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx context.Context, request *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq, params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams) (*ScimEnterpriseGroup, error)
	// EnterpriseAdminUpdateAttributeForEnterpriseUser invokes enterprise-admin/update-attribute-for-enterprise-user operation.
	//
	// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
	// change.
	// Allows you to change a provisioned user's individual attributes. To change a user's values, you
	// must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`,
	//  or `replace` operations. For examples and more information on the SCIM operations format, see the
	// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
	// **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a
	// `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
	// **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example
	// below), it removes the user from the enterprise, deletes the external identity, and deletes the
	// associated `:scim_user_id`.
	// ```
	// {
	// "Operations":[{
	// "op":"replace",
	// "value":{
	// "active":false
	// }
	// }]
	// }
	// ```.
	//
	// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
	EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx context.Context, request *EnterpriseAdminUpdateAttributeForEnterpriseUserReq, params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) (*ScimEnterpriseUser, error)
	// EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
	//
	// Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
	// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
	//
	// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
	EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) (*RunnerGroupsEnterprise, error)
	// GistsCheckIsStarred invokes gists/check-is-starred operation.
	//
	// Check if a gist is starred.
	//
	// GET /gists/{gist_id}/star
	GistsCheckIsStarred(ctx context.Context, params GistsCheckIsStarredParams) (GistsCheckIsStarredRes, error)
	// GistsCreate invokes gists/create operation.
	//
	// Allows you to add a new gist with one or more files.
	// **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the
	// automatic naming scheme that Gist uses internally.
	//
	// POST /gists
	GistsCreate(ctx context.Context, request *GistsCreateReq) (GistsCreateRes, error)
	// GistsCreateComment invokes gists/create-comment operation.
	//
	// Create a gist comment.
	//
	// POST /gists/{gist_id}/comments
	GistsCreateComment(ctx context.Context, request *GistsCreateCommentReq, params GistsCreateCommentParams) (GistsCreateCommentRes, error)
	// GistsDelete invokes gists/delete operation.
	//
	// Delete a gist.
	//
	// DELETE /gists/{gist_id}
	GistsDelete(ctx context.Context, params GistsDeleteParams) (GistsDeleteRes, error)
	// GistsDeleteComment invokes gists/delete-comment operation.
	//
	// Delete a gist comment.
	//
	// DELETE /gists/{gist_id}/comments/{comment_id}
	GistsDeleteComment(ctx context.Context, params GistsDeleteCommentParams) (GistsDeleteCommentRes, error)
	// GistsFork invokes gists/fork operation.
	//
	// **Note**: This was previously `/gists/:gist_id/fork`.
	//
	// POST /gists/{gist_id}/forks
	GistsFork(ctx context.Context, params GistsForkParams) (GistsForkRes, error)
	// GistsGet invokes gists/get operation.
	//
	// Get a gist.
	//
	// GET /gists/{gist_id}
	GistsGet(ctx context.Context, params GistsGetParams) (GistsGetRes, error)
	// GistsGetComment invokes gists/get-comment operation.
	//
	// Get a gist comment.
	//
	// GET /gists/{gist_id}/comments/{comment_id}
	GistsGetComment(ctx context.Context, params GistsGetCommentParams) (GistsGetCommentRes, error)
	// GistsGetRevision invokes gists/get-revision operation.
	//
	// Get a gist revision.
	//
	// GET /gists/{gist_id}/{sha}
	GistsGetRevision(ctx context.Context, params GistsGetRevisionParams) (GistsGetRevisionRes, error)
	// GistsList invokes gists/list operation.
	//
	// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public
	// gists:.
	//
	// GET /gists
	GistsList(ctx context.Context, params GistsListParams) (GistsListRes, error)
	// GistsListComments invokes gists/list-comments operation.
	//
	// List gist comments.
	//
	// GET /gists/{gist_id}/comments
	GistsListComments(ctx context.Context, params GistsListCommentsParams) (GistsListCommentsRes, error)
	// GistsListCommits invokes gists/list-commits operation.
	//
	// List gist commits.
	//
	// GET /gists/{gist_id}/commits
	GistsListCommits(ctx context.Context, params GistsListCommitsParams) (GistsListCommitsRes, error)
	// GistsListForUser invokes gists/list-for-user operation.
	//
	// Lists public gists for the specified user:.
	//
	// GET /users/{username}/gists
	GistsListForUser(ctx context.Context, params GistsListForUserParams) (GistsListForUserRes, error)
	// GistsListForks invokes gists/list-forks operation.
	//
	// List gist forks.
	//
	// GET /gists/{gist_id}/forks
	GistsListForks(ctx context.Context, params GistsListForksParams) (GistsListForksRes, error)
	// GistsListPublic invokes gists/list-public operation.
	//
	// List public gists sorted by most recently updated to least recently updated.
	// Note: With [pagination](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For
	// example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
	//
	// GET /gists/public
	GistsListPublic(ctx context.Context, params GistsListPublicParams) (GistsListPublicRes, error)
	// GistsListStarred invokes gists/list-starred operation.
	//
	// List the authenticated user's starred gists:.
	//
	// GET /gists/starred
	GistsListStarred(ctx context.Context, params GistsListStarredParams) (GistsListStarredRes, error)
	// GistsStar invokes gists/star operation.
	//
	// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
	// information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs).".
	//
	// PUT /gists/{gist_id}/star
	GistsStar(ctx context.Context, params GistsStarParams) (GistsStarRes, error)
	// GistsUnstar invokes gists/unstar operation.
	//
	// Unstar a gist.
	//
	// DELETE /gists/{gist_id}/star
	GistsUnstar(ctx context.Context, params GistsUnstarParams) (GistsUnstarRes, error)
	// GistsUpdateComment invokes gists/update-comment operation.
	//
	// Update a gist comment.
	//
	// PATCH /gists/{gist_id}/comments/{comment_id}
	GistsUpdateComment(ctx context.Context, request *GistsUpdateCommentReq, params GistsUpdateCommentParams) (GistsUpdateCommentRes, error)
	// GitCreateBlob invokes git/create-blob operation.
	//
	// Create a blob.
	//
	// POST /repos/{owner}/{repo}/git/blobs
	GitCreateBlob(ctx context.Context, request *GitCreateBlobReq, params GitCreateBlobParams) (GitCreateBlobRes, error)
	// GitCreateCommit invokes git/create-commit operation.
	//
	// Creates a new Git [commit object](https://git-scm.
	// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// POST /repos/{owner}/{repo}/git/commits
	GitCreateCommit(ctx context.Context, request *GitCreateCommitReq, params GitCreateCommitParams) (GitCreateCommitRes, error)
	// GitCreateRef invokes git/create-ref operation.
	//
	// Creates a reference for your repository. You are unable to create new references for empty
	// repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
	// without branches.
	//
	// POST /repos/{owner}/{repo}/git/refs
	GitCreateRef(ctx context.Context, request *GitCreateRefReq, params GitCreateRefParams) (GitCreateRefRes, error)
	// GitCreateTag invokes git/create-tag operation.
	//
	// Note that creating a tag object does not create the reference that makes a tag in Git. If you want
	// to create an annotated tag in Git, you have to do this call to create the tag object, and then
	// [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]`
	// reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.
	// com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// POST /repos/{owner}/{repo}/git/tags
	GitCreateTag(ctx context.Context, request *GitCreateTagReq, params GitCreateTagParams) (GitCreateTagRes, error)
	// GitCreateTree invokes git/create-tree operation.
	//
	// The tree creation API accepts nested entries. If you specify both a tree and a nested path
	// modifying that tree, this endpoint will overwrite the contents of the tree with the new path
	// contents, and create a new tree structure.
	// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to
	// commit the tree and then update a branch to point to the commit. For more information see "[Create
	// a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
	// reference](https://docs.github.com/rest/reference/git#update-a-reference).".
	//
	// POST /repos/{owner}/{repo}/git/trees
	GitCreateTree(ctx context.Context, request *GitCreateTreeReq, params GitCreateTreeParams) (GitCreateTreeRes, error)
	// GitDeleteRef invokes git/delete-ref operation.
	//
	// Delete a reference.
	//
	// DELETE /repos/{owner}/{repo}/git/refs/{ref}
	GitDeleteRef(ctx context.Context, params GitDeleteRefParams) (GitDeleteRefRes, error)
	// GitGetBlob invokes git/get-blob operation.
	//
	// The `content` in the response will always be Base64 encoded.
	// _Note_: This API supports blobs up to 100 megabytes in size.
	//
	// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
	GitGetBlob(ctx context.Context, params GitGetBlobParams) (GitGetBlobRes, error)
	// GitGetCommit invokes git/get-commit operation.
	//
	// Gets a Git [commit object](https://git-scm.
	// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
	GitGetCommit(ctx context.Context, params GitGetCommitParams) (GitGetCommitRes, error)
	// GitGetRef invokes git/get-ref operation.
	//
	// Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
	// `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an
	// existing ref, a `404` is returned.
	// **Note:** You need to explicitly [request a pull request](https://docs.github.
	// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
	// mergeability of pull requests. For more information, see "[Checking mergeability of pull
	// requests](https://docs.github.
	// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
	//
	// GET /repos/{owner}/{repo}/git/ref/{ref}
	GitGetRef(ctx context.Context, params GitGetRefParams) (GitGetRefRes, error)
	// GitGetTag invokes git/get-tag operation.
	//
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
	GitGetTag(ctx context.Context, params GitGetTagParams) (GitGetTagRes, error)
	// GitGetTree invokes git/get-tree operation.
	//
	// Returns a single tree using the SHA1 value for that tree.
	// If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our
	// maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees,
	// and fetch one sub-tree at a time.
	//
	// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
	GitGetTree(ctx context.Context, params GitGetTreeParams) (GitGetTreeRes, error)
	// GitListMatchingRefs invokes git/list-matching-refs operation.
	//
	// Returns an array of references from your Git database that match the supplied name. The `:ref` in
	// the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If
	// the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be
	// returned as an array.
	// When you use this endpoint without providing a `:ref`, it will return an array of all the
	// references from your Git database, including notes and stashes if they exist on the server.
	// Anything in the namespace is returned, not just `heads` and `tags`.
	// **Note:** You need to explicitly [request a pull request](https://docs.github.
	// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
	// mergeability of pull requests. For more information, see "[Checking mergeability of pull
	// requests](https://docs.github.
	// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
	// If you request matching references for a branch named `feature` but the branch `feature` doesn't
	// exist, the response can still include other matching head refs that start with the word `feature`,
	// such as `featureA` and `featureB`.
	//
	// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
	GitListMatchingRefs(ctx context.Context, params GitListMatchingRefsParams) (*GitListMatchingRefsOKHeaders, error)
	// GitUpdateRef invokes git/update-ref operation.
	//
	// Update a reference.
	//
	// PATCH /repos/{owner}/{repo}/git/refs/{ref}
	GitUpdateRef(ctx context.Context, request *GitUpdateRefReq, params GitUpdateRefParams) (GitUpdateRefRes, error)
	// GitignoreGetAllTemplates invokes gitignore/get-all-templates operation.
	//
	// List all templates available to pass as an option when [creating a repository](https://docs.github.
	// com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
	//
	// GET /gitignore/templates
	GitignoreGetAllTemplates(ctx context.Context) (GitignoreGetAllTemplatesRes, error)
	// GitignoreGetTemplate invokes gitignore/get-template operation.
	//
	// The API also allows fetching the source of a single template.
	// Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw
	// contents.
	//
	// GET /gitignore/templates/{name}
	GitignoreGetTemplate(ctx context.Context, params GitignoreGetTemplateParams) (GitignoreGetTemplateRes, error)
	// InteractionsRemoveRestrictionsForAuthenticatedUser invokes interactions/remove-restrictions-for-authenticated-user operation.
	//
	// Removes any interaction restrictions from your public repositories.
	//
	// DELETE /user/interaction-limits
	InteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context) error
	// InteractionsRemoveRestrictionsForOrg invokes interactions/remove-restrictions-for-org operation.
	//
	// Removes all interaction restrictions from public repositories in the given organization. You must
	// be an organization owner to remove restrictions.
	//
	// DELETE /orgs/{org}/interaction-limits
	InteractionsRemoveRestrictionsForOrg(ctx context.Context, params InteractionsRemoveRestrictionsForOrgParams) error
	// InteractionsRemoveRestrictionsForRepo invokes interactions/remove-restrictions-for-repo operation.
	//
	// Removes all interaction restrictions from the given repository. You must have owner or admin
	// access to remove restrictions. If the interaction limit is set for the user or organization that
	// owns this repository, you will receive a `409 Conflict` response and will not be able to use this
	// endpoint to change the interaction limit for a single repository.
	//
	// DELETE /repos/{owner}/{repo}/interaction-limits
	InteractionsRemoveRestrictionsForRepo(ctx context.Context, params InteractionsRemoveRestrictionsForRepoParams) (InteractionsRemoveRestrictionsForRepoRes, error)
	// InteractionsSetRestrictionsForAuthenticatedUser invokes interactions/set-restrictions-for-authenticated-user operation.
	//
	// Temporarily restricts which type of GitHub user can interact with your public repositories.
	// Setting the interaction limit at the user level will overwrite any interaction limits that are set
	// for individual repositories owned by the user.
	//
	// PUT /user/interaction-limits
	InteractionsSetRestrictionsForAuthenticatedUser(ctx context.Context, request *InteractionLimit) (InteractionsSetRestrictionsForAuthenticatedUserRes, error)
	// InteractionsSetRestrictionsForOrg invokes interactions/set-restrictions-for-org operation.
	//
	// Temporarily restricts interactions to a certain type of GitHub user in any public repository in
	// the given organization. You must be an organization owner to set these restrictions. Setting the
	// interaction limit at the organization level will overwrite any interaction limits that are set for
	// individual repositories owned by the organization.
	//
	// PUT /orgs/{org}/interaction-limits
	InteractionsSetRestrictionsForOrg(ctx context.Context, request *InteractionLimit, params InteractionsSetRestrictionsForOrgParams) (InteractionsSetRestrictionsForOrgRes, error)
	// InteractionsSetRestrictionsForRepo invokes interactions/set-restrictions-for-repo operation.
	//
	// Temporarily restricts interactions to a certain type of GitHub user within the given repository.
	// You must have owner or admin access to set these restrictions. If an interaction limit is set for
	// the user or organization that owns this repository, you will receive a `409 Conflict` response and
	// will not be able to use this endpoint to change the interaction limit for a single repository.
	//
	// PUT /repos/{owner}/{repo}/interaction-limits
	InteractionsSetRestrictionsForRepo(ctx context.Context, request *InteractionLimit, params InteractionsSetRestrictionsForRepoParams) (InteractionsSetRestrictionsForRepoRes, error)
	// IssuesAddAssignees invokes issues/add-assignees operation.
	//
	// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
	//
	// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
	IssuesAddAssignees(ctx context.Context, request OptIssuesAddAssigneesReq, params IssuesAddAssigneesParams) (*IssueSimple, error)
	// IssuesCheckUserCanBeAssigned invokes issues/check-user-can-be-assigned operation.
	//
	// Checks if a user has permission to be assigned to an issue in this repository.
	// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is
	// returned.
	// Otherwise a `404` status code is returned.
	//
	// GET /repos/{owner}/{repo}/assignees/{assignee}
	IssuesCheckUserCanBeAssigned(ctx context.Context, params IssuesCheckUserCanBeAssignedParams) (IssuesCheckUserCanBeAssignedRes, error)
	// IssuesCreate invokes issues/create operation.
	//
	// Any user with pull access to a repository can create an issue. If [issues are disabled in the
	// repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone`
	// status.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/issues
	IssuesCreate(ctx context.Context, request *IssuesCreateReq, params IssuesCreateParams) (IssuesCreateRes, error)
	// IssuesCreateComment invokes issues/create-comment operation.
	//
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
	IssuesCreateComment(ctx context.Context, request *IssuesCreateCommentReq, params IssuesCreateCommentParams) (IssuesCreateCommentRes, error)
	// IssuesCreateLabel invokes issues/create-label operation.
	//
	// Create a label.
	//
	// POST /repos/{owner}/{repo}/labels
	IssuesCreateLabel(ctx context.Context, request *IssuesCreateLabelReq, params IssuesCreateLabelParams) (IssuesCreateLabelRes, error)
	// IssuesCreateMilestone invokes issues/create-milestone operation.
	//
	// Create a milestone.
	//
	// POST /repos/{owner}/{repo}/milestones
	IssuesCreateMilestone(ctx context.Context, request *IssuesCreateMilestoneReq, params IssuesCreateMilestoneParams) (IssuesCreateMilestoneRes, error)
	// IssuesDeleteComment invokes issues/delete-comment operation.
	//
	// Delete an issue comment.
	//
	// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
	IssuesDeleteComment(ctx context.Context, params IssuesDeleteCommentParams) error
	// IssuesDeleteLabel invokes issues/delete-label operation.
	//
	// Delete a label.
	//
	// DELETE /repos/{owner}/{repo}/labels/{name}
	IssuesDeleteLabel(ctx context.Context, params IssuesDeleteLabelParams) error
	// IssuesDeleteMilestone invokes issues/delete-milestone operation.
	//
	// Delete a milestone.
	//
	// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
	IssuesDeleteMilestone(ctx context.Context, params IssuesDeleteMilestoneParams) (IssuesDeleteMilestoneRes, error)
	// IssuesGet invokes issues/get operation.
	//
	// The API returns a [`301 Moved Permanently` status](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
	// [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to
	// another repository. If
	// the issue was transferred to or deleted from a repository where the authenticated user lacks read
	// access, the API
	// returns a `404 Not Found` status. If the issue was deleted from a repository where the
	// authenticated user has read
	// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted
	// issues, subscribe
	// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
	// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
	// pull request. For this
	// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
	// identify pull requests by
	// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
	// will be an _issue id_. To find out the pull
	// request id, use the "[List pull requests](https://docs.github.
	// com/rest/reference/pulls#list-pull-requests)" endpoint.
	//
	// GET /repos/{owner}/{repo}/issues/{issue_number}
	IssuesGet(ctx context.Context, params IssuesGetParams) (IssuesGetRes, error)
	// IssuesGetComment invokes issues/get-comment operation.
	//
	// Get an issue comment.
	//
	// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
	IssuesGetComment(ctx context.Context, params IssuesGetCommentParams) (IssuesGetCommentRes, error)
	// IssuesGetEvent invokes issues/get-event operation.
	//
	// Get an issue event.
	//
	// GET /repos/{owner}/{repo}/issues/events/{event_id}
	IssuesGetEvent(ctx context.Context, params IssuesGetEventParams) (IssuesGetEventRes, error)
	// IssuesGetLabel invokes issues/get-label operation.
	//
	// Get a label.
	//
	// GET /repos/{owner}/{repo}/labels/{name}
	IssuesGetLabel(ctx context.Context, params IssuesGetLabelParams) (IssuesGetLabelRes, error)
	// IssuesGetMilestone invokes issues/get-milestone operation.
	//
	// Get a milestone.
	//
	// GET /repos/{owner}/{repo}/milestones/{milestone_number}
	IssuesGetMilestone(ctx context.Context, params IssuesGetMilestoneParams) (IssuesGetMilestoneRes, error)
	// IssuesList invokes issues/list operation.
	//
	// List issues assigned to the authenticated user across all visible repositories including owned
	// repositories, member
	// repositories, and organization repositories. You can use the `filter` query parameter to fetch
	// issues that are not
	// necessarily assigned to you.
	// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
	// pull request. For this
	// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
	// identify pull requests by
	// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
	// will be an _issue id_. To find out the pull
	// request id, use the "[List pull requests](https://docs.github.
	// com/rest/reference/pulls#list-pull-requests)" endpoint.
	//
	// GET /issues
	IssuesList(ctx context.Context, params IssuesListParams) (IssuesListRes, error)
	// IssuesListAssignees invokes issues/list-assignees operation.
	//
	// Lists the [available assignees](https://help.github.
	// com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
	//
	// GET /repos/{owner}/{repo}/assignees
	IssuesListAssignees(ctx context.Context, params IssuesListAssigneesParams) (IssuesListAssigneesRes, error)
	// IssuesListComments invokes issues/list-comments operation.
	//
	// Issue Comments are ordered by ascending ID.
	//
	// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
	IssuesListComments(ctx context.Context, params IssuesListCommentsParams) (IssuesListCommentsRes, error)
	// IssuesListCommentsForRepo invokes issues/list-comments-for-repo operation.
	//
	// By default, Issue Comments are ordered by ascending ID.
	//
	// GET /repos/{owner}/{repo}/issues/comments
	IssuesListCommentsForRepo(ctx context.Context, params IssuesListCommentsForRepoParams) (IssuesListCommentsForRepoRes, error)
	// IssuesListEventsForRepo invokes issues/list-events-for-repo operation.
	//
	// List issue events for a repository.
	//
	// GET /repos/{owner}/{repo}/issues/events
	IssuesListEventsForRepo(ctx context.Context, params IssuesListEventsForRepoParams) (IssuesListEventsForRepoRes, error)
	// IssuesListForAuthenticatedUser invokes issues/list-for-authenticated-user operation.
	//
	// List issues across owned and member repositories assigned to the authenticated user.
	// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
	// pull request. For this
	// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
	// identify pull requests by
	// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
	// will be an _issue id_. To find out the pull
	// request id, use the "[List pull requests](https://docs.github.
	// com/rest/reference/pulls#list-pull-requests)" endpoint.
	//
	// GET /user/issues
	IssuesListForAuthenticatedUser(ctx context.Context, params IssuesListForAuthenticatedUserParams) (IssuesListForAuthenticatedUserRes, error)
	// IssuesListForOrg invokes issues/list-for-org operation.
	//
	// List issues in an organization assigned to the authenticated user.
	// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
	// pull request. For this
	// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
	// identify pull requests by
	// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
	// will be an _issue id_. To find out the pull
	// request id, use the "[List pull requests](https://docs.github.
	// com/rest/reference/pulls#list-pull-requests)" endpoint.
	//
	// GET /orgs/{org}/issues
	IssuesListForOrg(ctx context.Context, params IssuesListForOrgParams) (IssuesListForOrgRes, error)
	// IssuesListForRepo invokes issues/list-for-repo operation.
	//
	// List issues in a repository.
	// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
	// pull request. For this
	// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
	// identify pull requests by
	// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
	// will be an _issue id_. To find out the pull
	// request id, use the "[List pull requests](https://docs.github.
	// com/rest/reference/pulls#list-pull-requests)" endpoint.
	//
	// GET /repos/{owner}/{repo}/issues
	IssuesListForRepo(ctx context.Context, params IssuesListForRepoParams) (IssuesListForRepoRes, error)
	// IssuesListLabelsForMilestone invokes issues/list-labels-for-milestone operation.
	//
	// List labels for issues in a milestone.
	//
	// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
	IssuesListLabelsForMilestone(ctx context.Context, params IssuesListLabelsForMilestoneParams) (*IssuesListLabelsForMilestoneOKHeaders, error)
	// IssuesListLabelsForRepo invokes issues/list-labels-for-repo operation.
	//
	// List labels for a repository.
	//
	// GET /repos/{owner}/{repo}/labels
	IssuesListLabelsForRepo(ctx context.Context, params IssuesListLabelsForRepoParams) (IssuesListLabelsForRepoRes, error)
	// IssuesListLabelsOnIssue invokes issues/list-labels-on-issue operation.
	//
	// List labels for an issue.
	//
	// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
	IssuesListLabelsOnIssue(ctx context.Context, params IssuesListLabelsOnIssueParams) (IssuesListLabelsOnIssueRes, error)
	// IssuesListMilestones invokes issues/list-milestones operation.
	//
	// List milestones.
	//
	// GET /repos/{owner}/{repo}/milestones
	IssuesListMilestones(ctx context.Context, params IssuesListMilestonesParams) (IssuesListMilestonesRes, error)
	// IssuesLock invokes issues/lock operation.
	//
	// Users with push access can lock an issue or pull request's conversation.
	// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
	// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs).".
	//
	// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
	IssuesLock(ctx context.Context, request OptNilIssuesLockReq, params IssuesLockParams) (IssuesLockRes, error)
	// IssuesRemoveAllLabels invokes issues/remove-all-labels operation.
	//
	// Remove all labels from an issue.
	//
	// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
	IssuesRemoveAllLabels(ctx context.Context, params IssuesRemoveAllLabelsParams) (IssuesRemoveAllLabelsRes, error)
	// IssuesRemoveAssignees invokes issues/remove-assignees operation.
	//
	// Removes one or more assignees from an issue.
	//
	// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
	IssuesRemoveAssignees(ctx context.Context, request OptIssuesRemoveAssigneesReq, params IssuesRemoveAssigneesParams) (*IssueSimple, error)
	// IssuesRemoveLabel invokes issues/remove-label operation.
	//
	// Removes the specified label from the issue, and returns the remaining labels on the issue. This
	// endpoint returns a `404 Not Found` status if the label does not exist.
	//
	// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
	IssuesRemoveLabel(ctx context.Context, params IssuesRemoveLabelParams) (IssuesRemoveLabelRes, error)
	// IssuesUnlock invokes issues/unlock operation.
	//
	// Users with push access can unlock an issue's conversation.
	//
	// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
	IssuesUnlock(ctx context.Context, params IssuesUnlockParams) (IssuesUnlockRes, error)
	// IssuesUpdate invokes issues/update operation.
	//
	// Issue owners and users with push access can edit an issue.
	//
	// PATCH /repos/{owner}/{repo}/issues/{issue_number}
	IssuesUpdate(ctx context.Context, request OptIssuesUpdateReq, params IssuesUpdateParams) (IssuesUpdateRes, error)
	// IssuesUpdateComment invokes issues/update-comment operation.
	//
	// Update an issue comment.
	//
	// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
	IssuesUpdateComment(ctx context.Context, request *IssuesUpdateCommentReq, params IssuesUpdateCommentParams) (IssuesUpdateCommentRes, error)
	// IssuesUpdateLabel invokes issues/update-label operation.
	//
	// Update a label.
	//
	// PATCH /repos/{owner}/{repo}/labels/{name}
	IssuesUpdateLabel(ctx context.Context, request OptIssuesUpdateLabelReq, params IssuesUpdateLabelParams) (*Label, error)
	// IssuesUpdateMilestone invokes issues/update-milestone operation.
	//
	// Update a milestone.
	//
	// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
	IssuesUpdateMilestone(ctx context.Context, request OptIssuesUpdateMilestoneReq, params IssuesUpdateMilestoneParams) (*Milestone, error)
	// LicensesGet invokes licenses/get operation.
	//
	// Get a license.
	//
	// GET /licenses/{license}
	LicensesGet(ctx context.Context, params LicensesGetParams) (LicensesGetRes, error)
	// LicensesGetAllCommonlyUsed invokes licenses/get-all-commonly-used operation.
	//
	// Get all commonly used licenses.
	//
	// GET /licenses
	LicensesGetAllCommonlyUsed(ctx context.Context, params LicensesGetAllCommonlyUsedParams) (LicensesGetAllCommonlyUsedRes, error)
	// LicensesGetForRepo invokes licenses/get-for-repo operation.
	//
	// This method returns the contents of the repository's license file, if one is detected.
	// Similar to [Get repository content](https://docs.github.
	// com/rest/reference/repos#get-repository-content), this method also supports [custom media
	// types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content
	// or rendered license HTML.
	//
	// GET /repos/{owner}/{repo}/license
	LicensesGetForRepo(ctx context.Context, params LicensesGetForRepoParams) (*LicenseContent, error)
	// MarkdownRender invokes markdown/render operation.
	//
	// Render a Markdown document.
	//
	// POST /markdown
	MarkdownRender(ctx context.Context, request *MarkdownRenderReq) (MarkdownRenderRes, error)
	// MarkdownRenderRaw invokes markdown/render-raw operation.
	//
	// You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or
	// `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored
	// Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain
	// format like a README.md file. Markdown content must be 400 KB or less.
	//
	// POST /markdown/raw
	MarkdownRenderRaw(ctx context.Context, request MarkdownRenderRawReq) (MarkdownRenderRawRes, error)
	// MetaGet invokes meta/get operation.
	//
	// Returns meta information about GitHub, including a list of GitHub's IP addresses. For more
	// information, see "[About GitHub's IP addresses](https://help.github.
	// com/articles/about-github-s-ip-addresses/)."
	// **Note:** The IP addresses shown in the documentation's response are only example values. You must
	// always query the API directly to get the latest list of IP addresses.
	//
	// GET /meta
	MetaGet(ctx context.Context) (MetaGetRes, error)
	// MetaGetOctocat invokes meta/get-octocat operation.
	//
	// Get the octocat as ASCII art.
	//
	// GET /octocat
	MetaGetOctocat(ctx context.Context, params MetaGetOctocatParams) (MetaGetOctocatOK, error)
	// MetaGetZen invokes meta/get-zen operation.
	//
	// Get a random sentence from the Zen of GitHub.
	//
	// GET /zen
	MetaGetZen(ctx context.Context) (MetaGetZenOK, error)
	// MetaRoot invokes meta/root operation.
	//
	// Get Hypermedia links to resources accessible in GitHub's REST API.
	//
	// GET /
	MetaRoot(ctx context.Context) (*MetaRootOK, error)
	// MigrationsCancelImport invokes migrations/cancel-import operation.
	//
	// Stop an import for a repository.
	//
	// DELETE /repos/{owner}/{repo}/import
	MigrationsCancelImport(ctx context.Context, params MigrationsCancelImportParams) error
	// MigrationsDeleteArchiveForAuthenticatedUser invokes migrations/delete-archive-for-authenticated-user operation.
	//
	// Deletes a previous migration archive. Downloadable migration archives are automatically deleted
	// after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.
	// github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration
	// status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints,
	// will continue to be available even after an archive is deleted.
	//
	// DELETE /user/migrations/{migration_id}/archive
	MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, params MigrationsDeleteArchiveForAuthenticatedUserParams) (MigrationsDeleteArchiveForAuthenticatedUserRes, error)
	// MigrationsDeleteArchiveForOrg invokes migrations/delete-archive-for-org operation.
	//
	// Deletes a previous migration archive. Migration archives are automatically deleted after seven
	// days.
	//
	// DELETE /orgs/{org}/migrations/{migration_id}/archive
	MigrationsDeleteArchiveForOrg(ctx context.Context, params MigrationsDeleteArchiveForOrgParams) (MigrationsDeleteArchiveForOrgRes, error)
	// MigrationsDownloadArchiveForOrg invokes migrations/download-archive-for-org operation.
	//
	// Fetches the URL to a migration archive.
	//
	// GET /orgs/{org}/migrations/{migration_id}/archive
	MigrationsDownloadArchiveForOrg(ctx context.Context, params MigrationsDownloadArchiveForOrgParams) (MigrationsDownloadArchiveForOrgRes, error)
	// MigrationsGetArchiveForAuthenticatedUser invokes migrations/get-archive-for-authenticated-user operation.
	//
	// Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources
	// your repository uses, the migration archive can contain JSON files with data for these objects:
	// *   attachments
	// *   bases
	// *   commit\_comments
	// *   issue\_comments
	// *   issue\_events
	// *   issues
	// *   milestones
	// *   organizations
	// *   projects
	// *   protected\_branches
	// *   pull\_request\_reviews
	// *   pull\_requests
	// *   releases
	// *   repositories
	// *   review\_comments
	// *   schema
	// *   users
	// The archive will also contain an `attachments` directory that includes all attachment files
	// uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
	//
	// GET /user/migrations/{migration_id}/archive
	MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, params MigrationsGetArchiveForAuthenticatedUserParams) (MigrationsGetArchiveForAuthenticatedUserRes, error)
	// MigrationsGetCommitAuthors invokes migrations/get-commit-authors operation.
	//
	// Each type of source control system represents authors in a different way. For example, a Git
	// commit author has a display name and an email address, but a Subversion commit author just has a
	// username. The GitHub Importer will make the author information valid, but the author might not be
	// correct. For example, it will change the bare Subversion username `hubot` into something like
	// `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
	// This endpoint and the [Map a commit author](https://docs.github.
	// com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git
	// author information.
	//
	// GET /repos/{owner}/{repo}/import/authors
	MigrationsGetCommitAuthors(ctx context.Context, params MigrationsGetCommitAuthorsParams) (MigrationsGetCommitAuthorsRes, error)
	// MigrationsGetImportStatus invokes migrations/get-import-status operation.
	//
	// View the progress of an import.
	// **Import status**
	// This section includes details about the possible values of the `status` field of the Import
	// Progress response.
	// An import that does not have errors will progress through these steps:
	// *   `detecting` - the "detection" step of the import is in progress because the request did not
	// include a `vcs` parameter. The import is identifying the type of source control present at the URL.
	// *   `importing` - the "raw" step of the import is in progress. This is where commit data is
	// fetched from the original repository. The import progress response will include `commit_count`
	// (the total number of raw commits that will be imported) and `percent` (0 - 100, the current
	// progress through the import).
	// *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are
	// converted to Git branches, and where author updates are applied. The import progress response does
	// not include progress information.
	// *   `pushing` - the "push" step of the import is in progress. This is where the importer updates
	// the repository on GitHub. The import progress response will include `push_percent`, which is the
	// percent value reported by `git push` when it is "Writing objects".
	// *   `complete` - the import is complete, and the repository is ready on GitHub.
	// If there are problems, you will see one of these in the `status` field:
	// *   `auth_failed` - the import requires authentication in order to connect to the original
	// repository. To update authentication for the import, please see the [Update an
	// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
	// *   `error` - the import encountered an error. The import progress response will include the
	// `failed_step` and an error message. Contact [GitHub Support](https://support.github.
	// com/contact?tags=dotcom-rest-api) for more information.
	// *   `detection_needs_auth` - the importer requires authentication for the originating repository
	// to continue detection. To update authentication for the import, please see the [Update an
	// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
	// *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
	// resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import)
	// and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
	// URL.
	// *   `detection_found_multiple` - the importer found several projects or repositories at the
	// provided URL. When this is the case, the Import Progress response will also include a
	// `project_choices` field with the possible project choices as values. To update project choice,
	// please see the [Update an import](https://docs.github.
	// com/rest/reference/migrations#update-an-import) section.
	// **The project_choices field**
	// When multiple projects are found at the provided URL, the response hash will include a
	// `project_choices` field, the value of which is an array of hashes each representing a project
	// choice. The exact key/value pairs of the project hashes will differ depending on the version
	// control type.
	// **Git LFS related fields**
	// This section includes details about Git LFS related fields that may be present in the Import
	// Progress response.
	// *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
	// can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
	// *   `has_large_files` - the boolean value describing whether files larger than 100MB were found
	// during the `importing` step.
	// *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the
	// originating repository.
	// *   `large_files_count` - the total number of files larger than 100MB found in the originating
	// repository. To see a list of these files, make a "Get Large Files" request.
	//
	// GET /repos/{owner}/{repo}/import
	MigrationsGetImportStatus(ctx context.Context, params MigrationsGetImportStatusParams) (MigrationsGetImportStatusRes, error)
	// MigrationsGetLargeFiles invokes migrations/get-large-files operation.
	//
	// List files larger than 100MB found during the import.
	//
	// GET /repos/{owner}/{repo}/import/large_files
	MigrationsGetLargeFiles(ctx context.Context, params MigrationsGetLargeFilesParams) ([]PorterLargeFile, error)
	// MigrationsGetStatusForAuthenticatedUser invokes migrations/get-status-for-authenticated-user operation.
	//
	// Fetches a single user migration. The response includes the `state` of the migration, which can be
	// one of the following values:
	// *   `pending` - the migration hasn't started yet.
	// *   `exporting` - the migration is in progress.
	// *   `exported` - the migration finished successfully.
	// *   `failed` - the migration failed.
	// Once the migration has been `exported` you can [download the migration archive](https://docs.
	// github.com/rest/reference/migrations#download-a-user-migration-archive).
	//
	// GET /user/migrations/{migration_id}
	MigrationsGetStatusForAuthenticatedUser(ctx context.Context, params MigrationsGetStatusForAuthenticatedUserParams) (MigrationsGetStatusForAuthenticatedUserRes, error)
	// MigrationsGetStatusForOrg invokes migrations/get-status-for-org operation.
	//
	// Fetches the status of a migration.
	// The `state` of a migration can be one of the following values:
	// *   `pending`, which means the migration hasn't started yet.
	// *   `exporting`, which means the migration is in progress.
	// *   `exported`, which means the migration finished successfully.
	// *   `failed`, which means the migration failed.
	//
	// GET /orgs/{org}/migrations/{migration_id}
	MigrationsGetStatusForOrg(ctx context.Context, params MigrationsGetStatusForOrgParams) (MigrationsGetStatusForOrgRes, error)
	// MigrationsListForAuthenticatedUser invokes migrations/list-for-authenticated-user operation.
	//
	// Lists all migrations a user has started.
	//
	// GET /user/migrations
	MigrationsListForAuthenticatedUser(ctx context.Context, params MigrationsListForAuthenticatedUserParams) (MigrationsListForAuthenticatedUserRes, error)
	// MigrationsListForOrg invokes migrations/list-for-org operation.
	//
	// Lists the most recent migrations.
	//
	// GET /orgs/{org}/migrations
	MigrationsListForOrg(ctx context.Context, params MigrationsListForOrgParams) (*MigrationsListForOrgOKHeaders, error)
	// MigrationsListReposForOrg invokes migrations/list-repos-for-org operation.
	//
	// List all the repositories for this organization migration.
	//
	// GET /orgs/{org}/migrations/{migration_id}/repositories
	MigrationsListReposForOrg(ctx context.Context, params MigrationsListReposForOrgParams) (MigrationsListReposForOrgRes, error)
	// MigrationsListReposForUser invokes migrations/list-repos-for-user operation.
	//
	// Lists all the repositories for this user migration.
	//
	// GET /user/migrations/{migration_id}/repositories
	MigrationsListReposForUser(ctx context.Context, params MigrationsListReposForUserParams) (MigrationsListReposForUserRes, error)
	// MigrationsMapCommitAuthor invokes migrations/map-commit-author operation.
	//
	// Update an author's identity for the import. Your application can continue updating authors any
	// time before you push new commits to the repository.
	//
	// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
	MigrationsMapCommitAuthor(ctx context.Context, request OptMigrationsMapCommitAuthorReq, params MigrationsMapCommitAuthorParams) (MigrationsMapCommitAuthorRes, error)
	// MigrationsSetLfsPreference invokes migrations/set-lfs-preference operation.
	//
	// You can import repositories from Subversion, Mercurial, and TFS that include files larger than
	// 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about
	// our LFS feature and working with large files [on our help site](https://help.github.
	// com/articles/versioning-large-files/).
	//
	// PATCH /repos/{owner}/{repo}/import/lfs
	MigrationsSetLfsPreference(ctx context.Context, request *MigrationsSetLfsPreferenceReq, params MigrationsSetLfsPreferenceParams) (MigrationsSetLfsPreferenceRes, error)
	// MigrationsStartForAuthenticatedUser invokes migrations/start-for-authenticated-user operation.
	//
	// Initiates the generation of a user migration archive.
	//
	// POST /user/migrations
	MigrationsStartForAuthenticatedUser(ctx context.Context, request *MigrationsStartForAuthenticatedUserReq) (MigrationsStartForAuthenticatedUserRes, error)
	// MigrationsStartForOrg invokes migrations/start-for-org operation.
	//
	// Initiates the generation of a migration archive.
	//
	// POST /orgs/{org}/migrations
	MigrationsStartForOrg(ctx context.Context, request *MigrationsStartForOrgReq, params MigrationsStartForOrgParams) (MigrationsStartForOrgRes, error)
	// MigrationsStartImport invokes migrations/start-import operation.
	//
	// Start a source import to a GitHub repository using GitHub Importer.
	//
	// PUT /repos/{owner}/{repo}/import
	MigrationsStartImport(ctx context.Context, request *MigrationsStartImportReq, params MigrationsStartImportParams) (MigrationsStartImportRes, error)
	// MigrationsUnlockRepoForAuthenticatedUser invokes migrations/unlock-repo-for-authenticated-user operation.
	//
	// Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.
	// github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you
	// can unlock each repository to begin using it again or [delete the repository](https://docs.github.
	// com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a
	// status of `404 Not Found` if the repository is not locked.
	//
	// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
	MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, params MigrationsUnlockRepoForAuthenticatedUserParams) (MigrationsUnlockRepoForAuthenticatedUserRes, error)
	// MigrationsUnlockRepoForOrg invokes migrations/unlock-repo-for-org operation.
	//
	// Unlocks a repository that was locked for migration. You should unlock each migrated repository and
	// [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration
	// is complete and you no longer need the source data.
	//
	// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
	MigrationsUnlockRepoForOrg(ctx context.Context, params MigrationsUnlockRepoForOrgParams) (MigrationsUnlockRepoForOrgRes, error)
	// MigrationsUpdateImport invokes migrations/update-import operation.
	//
	// An import can be updated with credentials or a project choice by passing in the appropriate
	// parameters in this API
	// request. If no parameters are provided, the import will be restarted.
	//
	// PATCH /repos/{owner}/{repo}/import
	MigrationsUpdateImport(ctx context.Context, request OptNilMigrationsUpdateImportReq, params MigrationsUpdateImportParams) (*Import, error)
	// OAuthAuthorizationsCreateAuthorization invokes oauth-authorizations/create-authorization operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	// **Warning:** Apps must use the [web application flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
	// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
	// be unable to access GitHub SAML organizations. For more information, see the [blog
	// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
	// Creates OAuth tokens using [Basic Authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor
	// authentication setup, Basic Authentication for this endpoint requires that you use a one-time
	// password (OTP) and your username and password instead of tokens. For more information, see
	// "[Working with two-factor authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
	// To create tokens for a particular OAuth application using this endpoint, you must authenticate as
	// the user you want to create an authorization for and provide the app's client ID and secret, found
	// on your OAuth application's settings page. If your OAuth application intends to create multiple
	// tokens for one user, use `fingerprint` to differentiate between them.
	// You can also create tokens on GitHub from the [personal access tokens settings](https://github.
	// com/settings/tokens) page. Read more about these tokens in [the GitHub Help
	// documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
	// Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about
	// allowing tokens in [the GitHub Help documentation](https://help.github.
	// com/articles/about-identity-and-access-management-with-saml-single-sign-on).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /authorizations
	OAuthAuthorizationsCreateAuthorization(ctx context.Context, request OptOAuthAuthorizationsCreateAuthorizationReq) (OAuthAuthorizationsCreateAuthorizationRes, error)
	// OAuthAuthorizationsDeleteAuthorization invokes oauth-authorizations/delete-authorization operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
	// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
	// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /authorizations/{authorization_id}
	OAuthAuthorizationsDeleteAuthorization(ctx context.Context, params OAuthAuthorizationsDeleteAuthorizationParams) (OAuthAuthorizationsDeleteAuthorizationRes, error)
	// OAuthAuthorizationsDeleteGrant invokes oauth-authorizations/delete-grant operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
	// application for your user. Once deleted, the application has no access to your account and is no
	// longer listed on [the application authorizations settings screen within GitHub](https://github.
	// com/settings/applications#authorized).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /applications/grants/{grant_id}
	OAuthAuthorizationsDeleteGrant(ctx context.Context, params OAuthAuthorizationsDeleteGrantParams) (OAuthAuthorizationsDeleteGrantRes, error)
	// OAuthAuthorizationsGetAuthorization invokes oauth-authorizations/get-authorization operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
	// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
	// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /authorizations/{authorization_id}
	OAuthAuthorizationsGetAuthorization(ctx context.Context, params OAuthAuthorizationsGetAuthorizationParams) (OAuthAuthorizationsGetAuthorizationRes, error)
	// OAuthAuthorizationsGetGrant invokes oauth-authorizations/get-grant operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
	// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
	// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /applications/grants/{grant_id}
	OAuthAuthorizationsGetGrant(ctx context.Context, params OAuthAuthorizationsGetGrantParams) (OAuthAuthorizationsGetGrantRes, error)
	// OAuthAuthorizationsGetOrCreateAuthorizationForApp invokes oauth-authorizations/get-or-create-authorization-for-app operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	// **Warning:** Apps must use the [web application flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
	// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
	// be unable to access GitHub SAML organizations. For more information, see the [blog
	// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
	// Creates a new authorization for the specified OAuth application, only if an authorization for that
	// application doesn't already exist for the user. The URL includes the 20 character client ID for
	// the OAuth app that is requesting the token. It returns the user's existing authorization for the
	// application if one is present. Otherwise, it creates and returns a new one.
	// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
	// you use a one-time password (OTP) and your username and password instead of tokens. For more
	// information, see "[Working with two-factor authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /authorizations/clients/{client_id}
	OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, request *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams) (OAuthAuthorizationsGetOrCreateAuthorizationForAppRes, error)
	// OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint invokes oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	// **Warning:** Apps must use the [web application flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
	// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
	// be unable to access GitHub SAML organizations. For more information, see the [blog
	// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
	// This method will create a new authorization for the specified OAuth application, only if an
	// authorization for that application and fingerprint do not already exist for the user. The URL
	// includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint`
	// is a unique string to distinguish an authorization from others created for the same client ID and
	// user. It returns the user's existing authorization for the application if one is present.
	// Otherwise, it creates and returns a new one.
	// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
	// you use a one-time password (OTP) and your username and password instead of tokens. For more
	// information, see "[Working with two-factor authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication).".
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /authorizations/clients/{client_id}/{fingerprint}
	OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, request *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams) (OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes, error)
	// OAuthAuthorizationsListAuthorizations invokes oauth-authorizations/list-authorizations operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.
	// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
	// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
	// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /authorizations
	OAuthAuthorizationsListAuthorizations(ctx context.Context, params OAuthAuthorizationsListAuthorizationsParams) (OAuthAuthorizationsListAuthorizationsRes, error)
	// OAuthAuthorizationsListGrants invokes oauth-authorizations/list-grants operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	// You can use this API to list the set of OAuth applications that have been granted access to your
	// account. Unlike the [list your authorizations](https://docs.github.
	// com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage
	// individual tokens. This API will return one entry for each OAuth application that has been granted
	// access to your account, regardless of the number of tokens an application has generated for your
	// user. The list of OAuth applications returned matches what is shown on [the application
	// authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
	//  The `scopes` returned are the union of scopes authorized for the application. For example, if an
	// application has one token with `repo` scope and another token with `user` scope, the grant will
	// return `["repo", "user"]`.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /applications/grants
	OAuthAuthorizationsListGrants(ctx context.Context, params OAuthAuthorizationsListGrantsParams) (OAuthAuthorizationsListGrantsRes, error)
	// OAuthAuthorizationsUpdateAuthorization invokes oauth-authorizations/update-authorization operation.
	//
	// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
	// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
	// tokens and OAuth tokens, and you must now create these tokens using our [web application
	// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
	// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
	// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
	// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
	// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
	// you use a one-time password (OTP) and your username and password instead of tokens. For more
	// information, see "[Working with two-factor authentication](https://docs.github.
	// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
	// You can only send one of these scope keys at a time.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PATCH /authorizations/{authorization_id}
	OAuthAuthorizationsUpdateAuthorization(ctx context.Context, request OptOAuthAuthorizationsUpdateAuthorizationReq, params OAuthAuthorizationsUpdateAuthorizationParams) (OAuthAuthorizationsUpdateAuthorizationRes, error)
	// OrgsBlockUser invokes orgs/block-user operation.
	//
	// Block a user from an organization.
	//
	// PUT /orgs/{org}/blocks/{username}
	OrgsBlockUser(ctx context.Context, params OrgsBlockUserParams) (OrgsBlockUserRes, error)
	// OrgsCancelInvitation invokes orgs/cancel-invitation operation.
	//
	// Cancel an organization invitation. In order to cancel an organization invitation, the
	// authenticated user must be an organization owner.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
	//
	// DELETE /orgs/{org}/invitations/{invitation_id}
	OrgsCancelInvitation(ctx context.Context, params OrgsCancelInvitationParams) (OrgsCancelInvitationRes, error)
	// OrgsCheckBlockedUser invokes orgs/check-blocked-user operation.
	//
	// Check if a user is blocked by an organization.
	//
	// GET /orgs/{org}/blocks/{username}
	OrgsCheckBlockedUser(ctx context.Context, params OrgsCheckBlockedUserParams) (OrgsCheckBlockedUserRes, error)
	// OrgsCheckMembershipForUser invokes orgs/check-membership-for-user operation.
	//
	// Check if a user is, publicly or privately, a member of the organization.
	//
	// GET /orgs/{org}/members/{username}
	OrgsCheckMembershipForUser(ctx context.Context, params OrgsCheckMembershipForUserParams) (OrgsCheckMembershipForUserRes, error)
	// OrgsCheckPublicMembershipForUser invokes orgs/check-public-membership-for-user operation.
	//
	// Check public organization membership for a user.
	//
	// GET /orgs/{org}/public_members/{username}
	OrgsCheckPublicMembershipForUser(ctx context.Context, params OrgsCheckPublicMembershipForUserParams) (OrgsCheckPublicMembershipForUserRes, error)
	// OrgsConvertMemberToOutsideCollaborator invokes orgs/convert-member-to-outside-collaborator operation.
	//
	// When an organization member is converted to an outside collaborator, they'll only have access to
	// the repositories that their current team membership allows. The user will no longer be a member of
	// the organization. For more information, see "[Converting an organization member to an outside
	// collaborator](https://help.github.
	// com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
	//
	// PUT /orgs/{org}/outside_collaborators/{username}
	OrgsConvertMemberToOutsideCollaborator(ctx context.Context, params OrgsConvertMemberToOutsideCollaboratorParams) (OrgsConvertMemberToOutsideCollaboratorRes, error)
	// OrgsCreateInvitation invokes orgs/create-invitation operation.
	//
	// Invite people to an organization by using their GitHub user ID or their email address. In order to
	// create invitations in an organization, the authenticated user must be an organization owner.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /orgs/{org}/invitations
	OrgsCreateInvitation(ctx context.Context, request OptOrgsCreateInvitationReq, params OrgsCreateInvitationParams) (OrgsCreateInvitationRes, error)
	// OrgsCreateWebhook invokes orgs/create-webhook operation.
	//
	// Here's how you can create a hook that posts payloads in JSON format:.
	//
	// POST /orgs/{org}/hooks
	OrgsCreateWebhook(ctx context.Context, request *OrgsCreateWebhookReq, params OrgsCreateWebhookParams) (OrgsCreateWebhookRes, error)
	// OrgsDeleteWebhook invokes orgs/delete-webhook operation.
	//
	// Delete an organization webhook.
	//
	// DELETE /orgs/{org}/hooks/{hook_id}
	OrgsDeleteWebhook(ctx context.Context, params OrgsDeleteWebhookParams) (OrgsDeleteWebhookRes, error)
	// OrgsGet invokes orgs/get operation.
	//
	// To see many of the organization response values, you need to be an authenticated organization
	// owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`,
	// the organization requires all members, billing managers, and outside collaborators to enable
	// [two-factor authentication](https://help.github.
	// com/articles/securing-your-account-with-two-factor-authentication-2fa/).
	// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information
	// about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.
	// com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example
	// response, see 'Response with GitHub plan information' below.".
	//
	// GET /orgs/{org}
	OrgsGet(ctx context.Context, params OrgsGetParams) (OrgsGetRes, error)
	// OrgsGetAuditLog invokes orgs/get-audit-log operation.
	//
	// Gets the audit log for an organization. For more information, see "[Reviewing the audit log for
	// your organization](https://docs.github.
	// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
	// To use this endpoint, you must be an organization owner, and you must use an access token with the
	// `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use
	// this endpoint.
	//
	// GET /orgs/{org}/audit-log
	OrgsGetAuditLog(ctx context.Context, params OrgsGetAuditLogParams) ([]AuditLogEvent, error)
	// OrgsGetMembershipForAuthenticatedUser invokes orgs/get-membership-for-authenticated-user operation.
	//
	// Get an organization membership for the authenticated user.
	//
	// GET /user/memberships/orgs/{org}
	OrgsGetMembershipForAuthenticatedUser(ctx context.Context, params OrgsGetMembershipForAuthenticatedUserParams) (OrgsGetMembershipForAuthenticatedUserRes, error)
	// OrgsGetMembershipForUser invokes orgs/get-membership-for-user operation.
	//
	// In order to get a user's membership with an organization, the authenticated user must be an
	// organization member. The `state` parameter in the response can be used to identify the user's
	// membership status.
	//
	// GET /orgs/{org}/memberships/{username}
	OrgsGetMembershipForUser(ctx context.Context, params OrgsGetMembershipForUserParams) (OrgsGetMembershipForUserRes, error)
	// OrgsGetWebhook invokes orgs/get-webhook operation.
	//
	// Returns a webhook configured in an organization. To get only the webhook `config` properties, see
	// "[Get a webhook configuration for an
	// organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization).".
	//
	// GET /orgs/{org}/hooks/{hook_id}
	OrgsGetWebhook(ctx context.Context, params OrgsGetWebhookParams) (OrgsGetWebhookRes, error)
	// OrgsGetWebhookConfigForOrg invokes orgs/get-webhook-config-for-org operation.
	//
	// Returns the webhook configuration for an organization. To get more information about the webhook,
	// including the `active` state and `events`, use "[Get an organization webhook
	// ](/rest/reference/orgs#get-an-organization-webhook)."
	// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
	// `organization_hooks:read` permission.
	//
	// GET /orgs/{org}/hooks/{hook_id}/config
	OrgsGetWebhookConfigForOrg(ctx context.Context, params OrgsGetWebhookConfigForOrgParams) (*WebhookConfig, error)
	// OrgsGetWebhookDelivery invokes orgs/get-webhook-delivery operation.
	//
	// Returns a delivery for a webhook configured in an organization.
	//
	// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
	OrgsGetWebhookDelivery(ctx context.Context, params OrgsGetWebhookDeliveryParams) (OrgsGetWebhookDeliveryRes, error)
	// OrgsList invokes orgs/list operation.
	//
	// Lists all organizations, in the order that they were created on GitHub.
	// **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link
	// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
	// URL for the next page of organizations.
	//
	// GET /organizations
	OrgsList(ctx context.Context, params OrgsListParams) (OrgsListRes, error)
	// OrgsListBlockedUsers invokes orgs/list-blocked-users operation.
	//
	// List the users blocked by an organization.
	//
	// GET /orgs/{org}/blocks
	OrgsListBlockedUsers(ctx context.Context, params OrgsListBlockedUsersParams) (OrgsListBlockedUsersRes, error)
	// OrgsListFailedInvitations invokes orgs/list-failed-invitations operation.
	//
	// The return hash contains `failed_at` and `failed_reason` fields which represent the time at which
	// the invitation failed and the reason for the failure.
	//
	// GET /orgs/{org}/failed_invitations
	OrgsListFailedInvitations(ctx context.Context, params OrgsListFailedInvitationsParams) (OrgsListFailedInvitationsRes, error)
	// OrgsListForAuthenticatedUser invokes orgs/list-for-authenticated-user operation.
	//
	// List organizations for the authenticated user.
	// **OAuth scope requirements**
	// This only lists organizations that your authorization allows you to operate on in some way (e.g.,
	// you can list teams with `read:org` scope, you can publicize your organization membership with
	// `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth
	// requests with insufficient scope receive a `403 Forbidden` response.
	//
	// GET /user/orgs
	OrgsListForAuthenticatedUser(ctx context.Context, params OrgsListForAuthenticatedUserParams) (OrgsListForAuthenticatedUserRes, error)
	// OrgsListForUser invokes orgs/list-for-user operation.
	//
	// List [public organization memberships](https://help.github.
	// com/articles/publicizing-or-concealing-organization-membership) for the specified user.
	// This method only lists _public_ memberships, regardless of authentication. If you need to fetch
	// all of the organization memberships (public and private) for the authenticated user, use the [List
	// organizations for the authenticated user](https://docs.github.
	// com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
	//
	// GET /users/{username}/orgs
	OrgsListForUser(ctx context.Context, params OrgsListForUserParams) (*OrgsListForUserOKHeaders, error)
	// OrgsListInvitationTeams invokes orgs/list-invitation-teams operation.
	//
	// List all teams associated with an invitation. In order to see invitations in an organization, the
	// authenticated user must be an organization owner.
	//
	// GET /orgs/{org}/invitations/{invitation_id}/teams
	OrgsListInvitationTeams(ctx context.Context, params OrgsListInvitationTeamsParams) (OrgsListInvitationTeamsRes, error)
	// OrgsListMembers invokes orgs/list-members operation.
	//
	// List all users who are members of an organization. If the authenticated user is also a member of
	// this organization then both concealed and public members will be returned.
	//
	// GET /orgs/{org}/members
	OrgsListMembers(ctx context.Context, params OrgsListMembersParams) (OrgsListMembersRes, error)
	// OrgsListMembershipsForAuthenticatedUser invokes orgs/list-memberships-for-authenticated-user operation.
	//
	// List organization memberships for the authenticated user.
	//
	// GET /user/memberships/orgs
	OrgsListMembershipsForAuthenticatedUser(ctx context.Context, params OrgsListMembershipsForAuthenticatedUserParams) (OrgsListMembershipsForAuthenticatedUserRes, error)
	// OrgsListOutsideCollaborators invokes orgs/list-outside-collaborators operation.
	//
	// List all users who are outside collaborators of an organization.
	//
	// GET /orgs/{org}/outside_collaborators
	OrgsListOutsideCollaborators(ctx context.Context, params OrgsListOutsideCollaboratorsParams) (*OrgsListOutsideCollaboratorsOKHeaders, error)
	// OrgsListPendingInvitations invokes orgs/list-pending-invitations operation.
	//
	// The return hash contains a `role` field which refers to the Organization Invitation role and will
	// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
	// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
	// `null`.
	//
	// GET /orgs/{org}/invitations
	OrgsListPendingInvitations(ctx context.Context, params OrgsListPendingInvitationsParams) (OrgsListPendingInvitationsRes, error)
	// OrgsListPublicMembers invokes orgs/list-public-members operation.
	//
	// Members of an organization can choose to have their membership publicized or not.
	//
	// GET /orgs/{org}/public_members
	OrgsListPublicMembers(ctx context.Context, params OrgsListPublicMembersParams) (*OrgsListPublicMembersOKHeaders, error)
	// OrgsListSamlSSOAuthorizations invokes orgs/list-saml-sso-authorizations operation.
	//
	// Listing and deleting credential authorizations is available to organizations with GitHub
	// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products).
	// An authenticated organization owner with the `read:org` scope can list all credential
	// authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either
	// personal access tokens or SSH keys that organization members have authorized for the organization.
	// For more information, see [About authentication with SAML single sign-on](https://help.github.
	// com/en/articles/about-authentication-with-saml-single-sign-on).
	//
	// GET /orgs/{org}/credential-authorizations
	OrgsListSamlSSOAuthorizations(ctx context.Context, params OrgsListSamlSSOAuthorizationsParams) ([]CredentialAuthorization, error)
	// OrgsListWebhookDeliveries invokes orgs/list-webhook-deliveries operation.
	//
	// Returns a list of webhook deliveries for a webhook configured in an organization.
	//
	// GET /orgs/{org}/hooks/{hook_id}/deliveries
	OrgsListWebhookDeliveries(ctx context.Context, params OrgsListWebhookDeliveriesParams) (OrgsListWebhookDeliveriesRes, error)
	// OrgsListWebhooks invokes orgs/list-webhooks operation.
	//
	// List organization webhooks.
	//
	// GET /orgs/{org}/hooks
	OrgsListWebhooks(ctx context.Context, params OrgsListWebhooksParams) (OrgsListWebhooksRes, error)
	// OrgsPingWebhook invokes orgs/ping-webhook operation.
	//
	// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
	// hook.
	//
	// POST /orgs/{org}/hooks/{hook_id}/pings
	OrgsPingWebhook(ctx context.Context, params OrgsPingWebhookParams) (OrgsPingWebhookRes, error)
	// OrgsRedeliverWebhookDelivery invokes orgs/redeliver-webhook-delivery operation.
	//
	// Redeliver a delivery for a webhook configured in an organization.
	//
	// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
	OrgsRedeliverWebhookDelivery(ctx context.Context, params OrgsRedeliverWebhookDeliveryParams) (OrgsRedeliverWebhookDeliveryRes, error)
	// OrgsRemoveMember invokes orgs/remove-member operation.
	//
	// Removing a user from this list will remove them from all teams and they will no longer have any
	// access to the organization's repositories.
	//
	// DELETE /orgs/{org}/members/{username}
	OrgsRemoveMember(ctx context.Context, params OrgsRemoveMemberParams) (OrgsRemoveMemberRes, error)
	// OrgsRemoveMembershipForUser invokes orgs/remove-membership-for-user operation.
	//
	// In order to remove a user's membership with an organization, the authenticated user must be an
	// organization owner.
	// If the specified user is an active member of the organization, this will remove them from the
	// organization. If the specified user has been invited to the organization, this will cancel their
	// invitation. The specified user will receive an email notification in both cases.
	//
	// DELETE /orgs/{org}/memberships/{username}
	OrgsRemoveMembershipForUser(ctx context.Context, params OrgsRemoveMembershipForUserParams) (OrgsRemoveMembershipForUserRes, error)
	// OrgsRemoveOutsideCollaborator invokes orgs/remove-outside-collaborator operation.
	//
	// Removing a user from this list will remove them from all the organization's repositories.
	//
	// DELETE /orgs/{org}/outside_collaborators/{username}
	OrgsRemoveOutsideCollaborator(ctx context.Context, params OrgsRemoveOutsideCollaboratorParams) (OrgsRemoveOutsideCollaboratorRes, error)
	// OrgsRemovePublicMembershipForAuthenticatedUser invokes orgs/remove-public-membership-for-authenticated-user operation.
	//
	// Remove public organization membership for the authenticated user.
	//
	// DELETE /orgs/{org}/public_members/{username}
	OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsRemovePublicMembershipForAuthenticatedUserParams) error
	// OrgsRemoveSamlSSOAuthorization invokes orgs/remove-saml-sso-authorization operation.
	//
	// Listing and deleting credential authorizations is available to organizations with GitHub
	// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products).
	// An authenticated organization owner with the `admin:org` scope can remove a credential
	// authorization for an organization that uses SAML SSO. Once you remove someone's credential
	// authorization, they will need to create a new personal access token or SSH key and authorize it
	// for the organization they want to access.
	//
	// DELETE /orgs/{org}/credential-authorizations/{credential_id}
	OrgsRemoveSamlSSOAuthorization(ctx context.Context, params OrgsRemoveSamlSSOAuthorizationParams) (OrgsRemoveSamlSSOAuthorizationRes, error)
	// OrgsSetMembershipForUser invokes orgs/set-membership-for-user operation.
	//
	// Only authenticated organization owners can add a member to the organization or update the member's
	// role.
	// *   If the authenticated user is _adding_ a member to the organization, the invited user will
	// receive an email inviting them to the organization. The user's [membership status](https://docs.
	// github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until
	// they accept the invitation.
	// *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the
	// authenticated user changes a member's role to `admin`, the affected user will receive an email
	// notifying them that they've been made an organization owner. If the authenticated user changes an
	// owner's role to `member`, no email will be sent.
	// **Rate limits**
	// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour
	// period. If the organization is more than one month old or on a paid plan, the limit is 500
	// invitations per 24 hour period.
	//
	// PUT /orgs/{org}/memberships/{username}
	OrgsSetMembershipForUser(ctx context.Context, request OptOrgsSetMembershipForUserReq, params OrgsSetMembershipForUserParams) (OrgsSetMembershipForUserRes, error)
	// OrgsSetPublicMembershipForAuthenticatedUser invokes orgs/set-public-membership-for-authenticated-user operation.
	//
	// The user can publicize their own membership. (A user cannot publicize the membership for another
	// user.)
	// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
	// information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs).".
	//
	// PUT /orgs/{org}/public_members/{username}
	OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsSetPublicMembershipForAuthenticatedUserParams) (OrgsSetPublicMembershipForAuthenticatedUserRes, error)
	// OrgsUnblockUser invokes orgs/unblock-user operation.
	//
	// Unblock a user from an organization.
	//
	// DELETE /orgs/{org}/blocks/{username}
	OrgsUnblockUser(ctx context.Context, params OrgsUnblockUserParams) error
	// OrgsUpdateMembershipForAuthenticatedUser invokes orgs/update-membership-for-authenticated-user operation.
	//
	// Update an organization membership for the authenticated user.
	//
	// PATCH /user/memberships/orgs/{org}
	OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, request *OrgsUpdateMembershipForAuthenticatedUserReq, params OrgsUpdateMembershipForAuthenticatedUserParams) (OrgsUpdateMembershipForAuthenticatedUserRes, error)
	// OrgsUpdateWebhook invokes orgs/update-webhook operation.
	//
	// Updates a webhook configured in an organization. When you update a webhook, the `secret` will be
	// overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new
	// `secret` or the secret will be removed. If you are only updating individual webhook `config`
	// properties, use "[Update a webhook configuration for an
	// organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization).".
	//
	// PATCH /orgs/{org}/hooks/{hook_id}
	OrgsUpdateWebhook(ctx context.Context, request OptOrgsUpdateWebhookReq, params OrgsUpdateWebhookParams) (OrgsUpdateWebhookRes, error)
	// OrgsUpdateWebhookConfigForOrg invokes orgs/update-webhook-config-for-org operation.
	//
	// Updates the webhook configuration for an organization. To update more information about the
	// webhook, including the `active` state and `events`, use "[Update an organization webhook
	// ](/rest/reference/orgs#update-an-organization-webhook)."
	// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
	// `organization_hooks:write` permission.
	//
	// PATCH /orgs/{org}/hooks/{hook_id}/config
	OrgsUpdateWebhookConfigForOrg(ctx context.Context, request OptOrgsUpdateWebhookConfigForOrgReq, params OrgsUpdateWebhookConfigForOrgParams) (*WebhookConfig, error)
	// PackagesDeletePackageForAuthenticatedUser invokes packages/delete-package-for-authenticated-user operation.
	//
	// Deletes a package owned by the authenticated user. You cannot delete a public package if any
	// version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for
	// further assistance.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:delete` scopes.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// DELETE /user/packages/{package_type}/{package_name}
	PackagesDeletePackageForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageForAuthenticatedUserParams) (PackagesDeletePackageForAuthenticatedUserRes, error)
	// PackagesDeletePackageForOrg invokes packages/delete-package-for-org operation.
	//
	// Deletes an entire package in an organization. You cannot delete a public package if any version of
	// the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
	// assistance.
	// To use this endpoint, you must have admin permissions in the organization and authenticate using
	// an access token with the `packages:read` and `packages:delete` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container you want
	// to delete.
	//
	// DELETE /orgs/{org}/packages/{package_type}/{package_name}
	PackagesDeletePackageForOrg(ctx context.Context, params PackagesDeletePackageForOrgParams) (PackagesDeletePackageForOrgRes, error)
	// PackagesDeletePackageForUser invokes packages/delete-package-for-user operation.
	//
	// Deletes an entire package for a user. You cannot delete a public package if any version of the
	// package has more than 5,000 downloads. In this scenario, contact GitHub support for further
	// assistance.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:delete` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container you want
	// to delete.
	//
	// DELETE /users/{username}/packages/{package_type}/{package_name}
	PackagesDeletePackageForUser(ctx context.Context, params PackagesDeletePackageForUserParams) (PackagesDeletePackageForUserRes, error)
	// PackagesDeletePackageVersionForAuthenticatedUser invokes packages/delete-package-version-for-authenticated-user operation.
	//
	// Deletes a specific package version for a package owned by the authenticated user.  If the package
	// is public and the package version has more than 5,000 downloads, you cannot delete the package
	// version. In this scenario, contact GitHub support for further assistance.
	// To use this endpoint, you must have admin permissions in the organization and authenticate using
	// an access token with the `packages:read` and `packages:delete` scopes.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
	PackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageVersionForAuthenticatedUserParams) (PackagesDeletePackageVersionForAuthenticatedUserRes, error)
	// PackagesDeletePackageVersionForOrg invokes packages/delete-package-version-for-org operation.
	//
	// Deletes a specific package version in an organization. If the package is public and the package
	// version has more than 5,000 downloads, you cannot delete the package version. In this scenario,
	// contact GitHub support for further assistance.
	// To use this endpoint, you must have admin permissions in the organization and authenticate using
	// an access token with the `packages:read` and `packages:delete` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container you want
	// to delete.
	//
	// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
	PackagesDeletePackageVersionForOrg(ctx context.Context, params PackagesDeletePackageVersionForOrgParams) (PackagesDeletePackageVersionForOrgRes, error)
	// PackagesDeletePackageVersionForUser invokes packages/delete-package-version-for-user operation.
	//
	// Deletes a specific package version for a user. If the package is public and the package version
	// has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact
	// GitHub support for further assistance.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:delete` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container you want
	// to delete.
	//
	// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
	PackagesDeletePackageVersionForUser(ctx context.Context, params PackagesDeletePackageVersionForUserParams) (PackagesDeletePackageVersionForUserRes, error)
	// PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser invokes packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
	//
	// Returns all package versions for a package owned by the authenticated user.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /user/packages/{package_type}/{package_name}/versions
	PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) (PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes, error)
	// PackagesGetAllPackageVersionsForPackageOwnedByOrg invokes packages/get-all-package-versions-for-package-owned-by-org operation.
	//
	// Returns all package versions for a package owned by an organization.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
	PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams) (PackagesGetAllPackageVersionsForPackageOwnedByOrgRes, error)
	// PackagesGetAllPackageVersionsForPackageOwnedByUser invokes packages/get-all-package-versions-for-package-owned-by-user operation.
	//
	// Returns all package versions for a public package owned by a specified user.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /users/{username}/packages/{package_type}/{package_name}/versions
	PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByUserParams) (PackagesGetAllPackageVersionsForPackageOwnedByUserRes, error)
	// PackagesGetPackageForAuthenticatedUser invokes packages/get-package-for-authenticated-user operation.
	//
	// Gets a specific package for a package owned by the authenticated user.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /user/packages/{package_type}/{package_name}
	PackagesGetPackageForAuthenticatedUser(ctx context.Context, params PackagesGetPackageForAuthenticatedUserParams) (*Package, error)
	// PackagesGetPackageForOrganization invokes packages/get-package-for-organization operation.
	//
	// Gets a specific package in an organization.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /orgs/{org}/packages/{package_type}/{package_name}
	PackagesGetPackageForOrganization(ctx context.Context, params PackagesGetPackageForOrganizationParams) (*Package, error)
	// PackagesGetPackageForUser invokes packages/get-package-for-user operation.
	//
	// Gets a specific package metadata for a public package owned by a user.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /users/{username}/packages/{package_type}/{package_name}
	PackagesGetPackageForUser(ctx context.Context, params PackagesGetPackageForUserParams) (*Package, error)
	// PackagesGetPackageVersionForAuthenticatedUser invokes packages/get-package-version-for-authenticated-user operation.
	//
	// Gets a specific package version for a package owned by the authenticated user.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
	PackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, params PackagesGetPackageVersionForAuthenticatedUserParams) (*PackageVersion, error)
	// PackagesGetPackageVersionForOrganization invokes packages/get-package-version-for-organization operation.
	//
	// Gets a specific package version in an organization.
	// You must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
	PackagesGetPackageVersionForOrganization(ctx context.Context, params PackagesGetPackageVersionForOrganizationParams) (*PackageVersion, error)
	// PackagesGetPackageVersionForUser invokes packages/get-package-version-for-user operation.
	//
	// Gets a specific package version for a public package owned by a specified user.
	// At this time, to use this endpoint, you must authenticate using an access token with the
	// `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
	PackagesGetPackageVersionForUser(ctx context.Context, params PackagesGetPackageVersionForUserParams) (*PackageVersion, error)
	// PackagesListPackagesForAuthenticatedUser invokes packages/list-packages-for-authenticated-user operation.
	//
	// Lists packages owned by the authenticated user within the user's namespace.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /user/packages
	PackagesListPackagesForAuthenticatedUser(ctx context.Context, params PackagesListPackagesForAuthenticatedUserParams) ([]Package, error)
	// PackagesListPackagesForOrganization invokes packages/list-packages-for-organization operation.
	//
	// Lists all packages in an organization readable by the user.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /orgs/{org}/packages
	PackagesListPackagesForOrganization(ctx context.Context, params PackagesListPackagesForOrganizationParams) (PackagesListPackagesForOrganizationRes, error)
	// PackagesListPackagesForUser invokes packages/list-packages-for-user operation.
	//
	// Lists all packages in a user's namespace for which the requesting user has access.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
	// If `package_type` is not `container`, your token must also include the `repo` scope.
	//
	// GET /users/{username}/packages
	PackagesListPackagesForUser(ctx context.Context, params PackagesListPackagesForUserParams) (PackagesListPackagesForUserRes, error)
	// PackagesRestorePackageForAuthenticatedUser invokes packages/restore-package-for-authenticated-user operation.
	//
	// Restores a package owned by the authenticated user.
	// You can restore a deleted package under the following conditions:
	// - The package was deleted within the last 30 days.
	// - The same package namespace and version is still available and not reused for a new package. If
	// the same package namespace is not available, you will not be able to restore your package. In this
	// scenario, to restore the deleted package, you must delete the new package that uses the deleted
	// package's namespace first.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
	// `repo` scope.
	//
	// POST /user/packages/{package_type}/{package_name}/restore
	PackagesRestorePackageForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageForAuthenticatedUserParams) (PackagesRestorePackageForAuthenticatedUserRes, error)
	// PackagesRestorePackageForOrg invokes packages/restore-package-for-org operation.
	//
	// Restores an entire package in an organization.
	// You can restore a deleted package under the following conditions:
	// - The package was deleted within the last 30 days.
	// - The same package namespace and version is still available and not reused for a new package. If
	// the same package namespace is not available, you will not be able to restore your package. In this
	// scenario, to restore the deleted package, you must delete the new package that uses the deleted
	// package's namespace first.
	// To use this endpoint, you must have admin permissions in the organization and authenticate using
	// an access token with the `packages:read` and `packages:write` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container that you
	// want to restore.
	//
	// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
	PackagesRestorePackageForOrg(ctx context.Context, params PackagesRestorePackageForOrgParams) (PackagesRestorePackageForOrgRes, error)
	// PackagesRestorePackageForUser invokes packages/restore-package-for-user operation.
	//
	// Restores an entire package for a user.
	// You can restore a deleted package under the following conditions:
	// - The package was deleted within the last 30 days.
	// - The same package namespace and version is still available and not reused for a new package. If
	// the same package namespace is not available, you will not be able to restore your package. In this
	// scenario, to restore the deleted package, you must delete the new package that uses the deleted
	// package's namespace first.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:write` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container that you
	// want to restore.
	//
	// POST /users/{username}/packages/{package_type}/{package_name}/restore
	PackagesRestorePackageForUser(ctx context.Context, params PackagesRestorePackageForUserParams) (PackagesRestorePackageForUserRes, error)
	// PackagesRestorePackageVersionForAuthenticatedUser invokes packages/restore-package-version-for-authenticated-user operation.
	//
	// Restores a package version owned by the authenticated user.
	// You can restore a deleted package version under the following conditions:
	// - The package was deleted within the last 30 days.
	// - The same package namespace and version is still available and not reused for a new package. If
	// the same package namespace is not available, you will not be able to restore your package. In this
	// scenario, to restore the deleted package, you must delete the new package that uses the deleted
	// package's namespace first.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
	// `repo` scope.
	//
	// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
	PackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageVersionForAuthenticatedUserParams) (PackagesRestorePackageVersionForAuthenticatedUserRes, error)
	// PackagesRestorePackageVersionForOrg invokes packages/restore-package-version-for-org operation.
	//
	// Restores a specific package version in an organization.
	// You can restore a deleted package under the following conditions:
	// - The package was deleted within the last 30 days.
	// - The same package namespace and version is still available and not reused for a new package. If
	// the same package namespace is not available, you will not be able to restore your package. In this
	// scenario, to restore the deleted package, you must delete the new package that uses the deleted
	// package's namespace first.
	// To use this endpoint, you must have admin permissions in the organization and authenticate using
	// an access token with the `packages:read` and `packages:write` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container that you
	// want to restore.
	//
	// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
	PackagesRestorePackageVersionForOrg(ctx context.Context, params PackagesRestorePackageVersionForOrgParams) (PackagesRestorePackageVersionForOrgRes, error)
	// PackagesRestorePackageVersionForUser invokes packages/restore-package-version-for-user operation.
	//
	// Restores a specific package version for a user.
	// You can restore a deleted package under the following conditions:
	// - The package was deleted within the last 30 days.
	// - The same package namespace and version is still available and not reused for a new package. If
	// the same package namespace is not available, you will not be able to restore your package. In this
	// scenario, to restore the deleted package, you must delete the new package that uses the deleted
	// package's namespace first.
	// To use this endpoint, you must authenticate using an access token with the `packages:read` and
	// `packages:write` scopes. In addition:
	// - If `package_type` is not `container`, your token must also include the `repo` scope.
	// - If `package_type` is `container`, you must also have admin permissions to the container that you
	// want to restore.
	//
	// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
	PackagesRestorePackageVersionForUser(ctx context.Context, params PackagesRestorePackageVersionForUserParams) (PackagesRestorePackageVersionForUserRes, error)
	// ProjectsAddCollaborator invokes projects/add-collaborator operation.
	//
	// Adds a collaborator to an organization project and sets their permission level. You must be an
	// organization owner or a project `admin` to add a collaborator.
	//
	// PUT /projects/{project_id}/collaborators/{username}
	ProjectsAddCollaborator(ctx context.Context, request OptNilProjectsAddCollaboratorReq, params ProjectsAddCollaboratorParams) (ProjectsAddCollaboratorRes, error)
	// ProjectsCreateColumn invokes projects/create-column operation.
	//
	// Create a project column.
	//
	// POST /projects/{project_id}/columns
	ProjectsCreateColumn(ctx context.Context, request *ProjectsCreateColumnReq, params ProjectsCreateColumnParams) (ProjectsCreateColumnRes, error)
	// ProjectsCreateForAuthenticatedUser invokes projects/create-for-authenticated-user operation.
	//
	// Create a user project.
	//
	// POST /user/projects
	ProjectsCreateForAuthenticatedUser(ctx context.Context, request *ProjectsCreateForAuthenticatedUserReq) (ProjectsCreateForAuthenticatedUserRes, error)
	// ProjectsCreateForOrg invokes projects/create-for-org operation.
	//
	// Creates an organization project board. Returns a `404 Not Found` status if projects are disabled
	// in the organization. If you do not have sufficient privileges to perform this action, a `401
	// Unauthorized` or `410 Gone` status is returned.
	//
	// POST /orgs/{org}/projects
	ProjectsCreateForOrg(ctx context.Context, request *ProjectsCreateForOrgReq, params ProjectsCreateForOrgParams) (ProjectsCreateForOrgRes, error)
	// ProjectsCreateForRepo invokes projects/create-for-repo operation.
	//
	// Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in
	// the repository. If you do not have sufficient privileges to perform this action, a `401
	// Unauthorized` or `410 Gone` status is returned.
	//
	// POST /repos/{owner}/{repo}/projects
	ProjectsCreateForRepo(ctx context.Context, request *ProjectsCreateForRepoReq, params ProjectsCreateForRepoParams) (ProjectsCreateForRepoRes, error)
	// ProjectsDelete invokes projects/delete operation.
	//
	// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
	//
	// DELETE /projects/{project_id}
	ProjectsDelete(ctx context.Context, params ProjectsDeleteParams) (ProjectsDeleteRes, error)
	// ProjectsDeleteCard invokes projects/delete-card operation.
	//
	// Delete a project card.
	//
	// DELETE /projects/columns/cards/{card_id}
	ProjectsDeleteCard(ctx context.Context, params ProjectsDeleteCardParams) (ProjectsDeleteCardRes, error)
	// ProjectsDeleteColumn invokes projects/delete-column operation.
	//
	// Delete a project column.
	//
	// DELETE /projects/columns/{column_id}
	ProjectsDeleteColumn(ctx context.Context, params ProjectsDeleteColumnParams) (ProjectsDeleteColumnRes, error)
	// ProjectsGet invokes projects/get operation.
	//
	// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do
	// not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status
	// is returned.
	//
	// GET /projects/{project_id}
	ProjectsGet(ctx context.Context, params ProjectsGetParams) (ProjectsGetRes, error)
	// ProjectsGetCard invokes projects/get-card operation.
	//
	// Get a project card.
	//
	// GET /projects/columns/cards/{card_id}
	ProjectsGetCard(ctx context.Context, params ProjectsGetCardParams) (ProjectsGetCardRes, error)
	// ProjectsGetColumn invokes projects/get-column operation.
	//
	// Get a project column.
	//
	// GET /projects/columns/{column_id}
	ProjectsGetColumn(ctx context.Context, params ProjectsGetColumnParams) (ProjectsGetColumnRes, error)
	// ProjectsGetPermissionForUser invokes projects/get-permission-for-user operation.
	//
	// Returns the collaborator's permission level for an organization project. Possible values for the
	// `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project
	// `admin` to review a user's permission level.
	//
	// GET /projects/{project_id}/collaborators/{username}/permission
	ProjectsGetPermissionForUser(ctx context.Context, params ProjectsGetPermissionForUserParams) (ProjectsGetPermissionForUserRes, error)
	// ProjectsListCards invokes projects/list-cards operation.
	//
	// List project cards.
	//
	// GET /projects/columns/{column_id}/cards
	ProjectsListCards(ctx context.Context, params ProjectsListCardsParams) (ProjectsListCardsRes, error)
	// ProjectsListCollaborators invokes projects/list-collaborators operation.
	//
	// Lists the collaborators for an organization project. For a project, the list of collaborators
	// includes outside collaborators, organization members that are direct collaborators, organization
	// members with access through team memberships, organization members with access through default
	// organization permissions, and organization owners. You must be an organization owner or a project
	// `admin` to list collaborators.
	//
	// GET /projects/{project_id}/collaborators
	ProjectsListCollaborators(ctx context.Context, params ProjectsListCollaboratorsParams) (ProjectsListCollaboratorsRes, error)
	// ProjectsListColumns invokes projects/list-columns operation.
	//
	// List project columns.
	//
	// GET /projects/{project_id}/columns
	ProjectsListColumns(ctx context.Context, params ProjectsListColumnsParams) (ProjectsListColumnsRes, error)
	// ProjectsListForOrg invokes projects/list-for-org operation.
	//
	// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled
	// in the organization. If you do not have sufficient privileges to perform this action, a `401
	// Unauthorized` or `410 Gone` status is returned.
	//
	// GET /orgs/{org}/projects
	ProjectsListForOrg(ctx context.Context, params ProjectsListForOrgParams) (ProjectsListForOrgRes, error)
	// ProjectsListForRepo invokes projects/list-for-repo operation.
	//
	// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in
	// the repository. If you do not have sufficient privileges to perform this action, a `401
	// Unauthorized` or `410 Gone` status is returned.
	//
	// GET /repos/{owner}/{repo}/projects
	ProjectsListForRepo(ctx context.Context, params ProjectsListForRepoParams) (ProjectsListForRepoRes, error)
	// ProjectsListForUser invokes projects/list-for-user operation.
	//
	// List user projects.
	//
	// GET /users/{username}/projects
	ProjectsListForUser(ctx context.Context, params ProjectsListForUserParams) (ProjectsListForUserRes, error)
	// ProjectsMoveCard invokes projects/move-card operation.
	//
	// Move a project card.
	//
	// POST /projects/columns/cards/{card_id}/moves
	ProjectsMoveCard(ctx context.Context, request *ProjectsMoveCardReq, params ProjectsMoveCardParams) (ProjectsMoveCardRes, error)
	// ProjectsMoveColumn invokes projects/move-column operation.
	//
	// Move a project column.
	//
	// POST /projects/columns/{column_id}/moves
	ProjectsMoveColumn(ctx context.Context, request *ProjectsMoveColumnReq, params ProjectsMoveColumnParams) (ProjectsMoveColumnRes, error)
	// ProjectsRemoveCollaborator invokes projects/remove-collaborator operation.
	//
	// Removes a collaborator from an organization project. You must be an organization owner or a
	// project `admin` to remove a collaborator.
	//
	// DELETE /projects/{project_id}/collaborators/{username}
	ProjectsRemoveCollaborator(ctx context.Context, params ProjectsRemoveCollaboratorParams) (ProjectsRemoveCollaboratorRes, error)
	// ProjectsUpdate invokes projects/update operation.
	//
	// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled.
	// If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410
	// Gone` status is returned.
	//
	// PATCH /projects/{project_id}
	ProjectsUpdate(ctx context.Context, request OptProjectsUpdateReq, params ProjectsUpdateParams) (ProjectsUpdateRes, error)
	// ProjectsUpdateCard invokes projects/update-card operation.
	//
	// Update an existing project card.
	//
	// PATCH /projects/columns/cards/{card_id}
	ProjectsUpdateCard(ctx context.Context, request OptProjectsUpdateCardReq, params ProjectsUpdateCardParams) (ProjectsUpdateCardRes, error)
	// ProjectsUpdateColumn invokes projects/update-column operation.
	//
	// Update an existing project column.
	//
	// PATCH /projects/columns/{column_id}
	ProjectsUpdateColumn(ctx context.Context, request *ProjectsUpdateColumnReq, params ProjectsUpdateColumnParams) (ProjectsUpdateColumnRes, error)
	// PullsCheckIfMerged invokes pulls/check-if-merged operation.
	//
	// Check if a pull request has been merged.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
	PullsCheckIfMerged(ctx context.Context, params PullsCheckIfMergedParams) (PullsCheckIfMergedRes, error)
	// PullsCreate invokes pulls/create operation.
	//
	// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
	// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
	// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// To open or update a pull request in a public repository, you must have write access to the head or
	// the source branch. For organization-owned repositories, you must be a member of the organization
	// that owns the repository to open or update a pull request.
	// You can create a new pull request.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/pulls
	PullsCreate(ctx context.Context, request *PullsCreateReq, params PullsCreateParams) (PullsCreateRes, error)
	// PullsCreateReplyForReviewComment invokes pulls/create-reply-for-review-comment operation.
	//
	// Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of
	// the review comment you are replying to. This must be the ID of a _top-level review comment_, not a
	// reply to that comment. Replies to replies are not supported.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
	PullsCreateReplyForReviewComment(ctx context.Context, request *PullsCreateReplyForReviewCommentReq, params PullsCreateReplyForReviewCommentParams) (PullsCreateReplyForReviewCommentRes, error)
	// PullsCreateReview invokes pulls/create-review operation.
	//
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	// Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in
	// the response.
	// **Note:** To comment on a specific line in a file, you need to first determine the _position_ of
	// that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media
	// type](https://docs.github.
	// com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request
	// diff, add this media type to the `Accept` header of a call to the [single pull
	// request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
	// The `position` value equals the number of lines down from the first "@@" hunk header in the file
	// you want to add a comment. The line just below the "@@" line is position 1, the next line is
	// position 2, and so on. The position in the diff continues to increase through lines of whitespace
	// and additional hunks until the beginning of a new file.
	//
	// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
	PullsCreateReview(ctx context.Context, request OptPullsCreateReviewReq, params PullsCreateReviewParams) (PullsCreateReviewRes, error)
	// PullsCreateReviewComment invokes pulls/create-review-comment operation.
	//
	// Creates a review comment in the pull request diff. To add a regular comment to a pull request
	// timeline, see "[Create an issue comment](https://docs.github.
	// com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using
	// `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than
	// one line in the pull request diff.
	// You can still create a review comment using the `position` parameter. When you use `position`, the
	// `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information,
	// see the [`comfort-fade` preview notice](https://docs.github.
	// com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
	// **Note:** The position value equals the number of lines down from the first "@@" hunk header in
	// the file you want to add a comment. The line just below the "@@" line is position 1, the next line
	// is position 2, and so on. The position in the diff continues to increase through lines of
	// whitespace and additional hunks until the beginning of a new file.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
	PullsCreateReviewComment(ctx context.Context, request *PullsCreateReviewCommentReq, params PullsCreateReviewCommentParams) (PullsCreateReviewCommentRes, error)
	// PullsDeletePendingReview invokes pulls/delete-pending-review operation.
	//
	// Delete a pending review for a pull request.
	//
	// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
	PullsDeletePendingReview(ctx context.Context, params PullsDeletePendingReviewParams) (PullsDeletePendingReviewRes, error)
	// PullsDeleteReviewComment invokes pulls/delete-review-comment operation.
	//
	// Deletes a review comment.
	//
	// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
	PullsDeleteReviewComment(ctx context.Context, params PullsDeleteReviewCommentParams) (PullsDeleteReviewCommentRes, error)
	// PullsDismissReview invokes pulls/dismiss-review operation.
	//
	// **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.
	// com/rest/reference/repos#branches), you must be a repository administrator or be included in the
	// list of people or teams who can dismiss pull request reviews.
	//
	// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
	PullsDismissReview(ctx context.Context, request *PullsDismissReviewReq, params PullsDismissReviewParams) (PullsDismissReviewRes, error)
	// PullsGet invokes pulls/get operation.
	//
	// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
	// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
	// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Lists details of a pull request by providing its number.
	// When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or
	// [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub
	// creates a merge commit to test whether the pull request can be automatically merged into the base
	// branch. This test commit is not added to the base branch or the head branch. You can review the
	// status of the test commit using the `mergeable` key. For more information, see "[Checking
	// mergeability of pull requests](https://docs.github.
	// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
	// The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`,
	// then GitHub has started a background job to compute the mergeability. After giving the job time to
	// complete, resubmit the request. When the job finishes, you will see a non-`null` value for the
	// `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be
	// the SHA of the _test_ merge commit.
	// The value of the `merge_commit_sha` attribute changes depending on the state of the pull request.
	// Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge
	// commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how
	// you merged the pull request:
	// *   If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/),
	//  `merge_commit_sha` represents the SHA of the merge commit.
	// *   If merged via a [squash](https://help.github.
	// com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha`
	// represents the SHA of the squashed commit on the base branch.
	// *   If [rebased](https://help.github.
	// com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha`
	// represents the commit that the base branch was updated to.
	// Pass the appropriate [media type](https://docs.github.
	// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
	// patch formats.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}
	PullsGet(ctx context.Context, params PullsGetParams) (PullsGetRes, error)
	// PullsGetReview invokes pulls/get-review operation.
	//
	// Get a review for a pull request.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
	PullsGetReview(ctx context.Context, params PullsGetReviewParams) (PullsGetReviewRes, error)
	// PullsGetReviewComment invokes pulls/get-review-comment operation.
	//
	// Provides details for a review comment.
	//
	// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
	PullsGetReviewComment(ctx context.Context, params PullsGetReviewCommentParams) (PullsGetReviewCommentRes, error)
	// PullsList invokes pulls/list operation.
	//
	// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
	// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
	// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// GET /repos/{owner}/{repo}/pulls
	PullsList(ctx context.Context, params PullsListParams) (PullsListRes, error)
	// PullsListCommentsForReview invokes pulls/list-comments-for-review operation.
	//
	// List comments for a specific pull request review.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
	PullsListCommentsForReview(ctx context.Context, params PullsListCommentsForReviewParams) (PullsListCommentsForReviewRes, error)
	// PullsListCommits invokes pulls/list-commits operation.
	//
	// Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull
	// requests with more than 250 commits, use the [List commits](https://docs.github.
	// com/rest/reference/repos#list-commits) endpoint.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
	PullsListCommits(ctx context.Context, params PullsListCommitsParams) (*PullsListCommitsOKHeaders, error)
	// PullsListFiles invokes pulls/list-files operation.
	//
	// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per
	// page by default.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
	PullsListFiles(ctx context.Context, params PullsListFilesParams) (PullsListFilesRes, error)
	// PullsListRequestedReviewers invokes pulls/list-requested-reviewers operation.
	//
	// List requested reviewers for a pull request.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
	PullsListRequestedReviewers(ctx context.Context, params PullsListRequestedReviewersParams) (*PullRequestReviewRequestHeaders, error)
	// PullsListReviewComments invokes pulls/list-review-comments operation.
	//
	// Lists all review comments for a pull request. By default, review comments are in ascending order
	// by ID.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
	PullsListReviewComments(ctx context.Context, params PullsListReviewCommentsParams) (*PullsListReviewCommentsOKHeaders, error)
	// PullsListReviewCommentsForRepo invokes pulls/list-review-comments-for-repo operation.
	//
	// Lists review comments for all pull requests in a repository. By default, review comments are in
	// ascending order by ID.
	//
	// GET /repos/{owner}/{repo}/pulls/comments
	PullsListReviewCommentsForRepo(ctx context.Context, params PullsListReviewCommentsForRepoParams) (*PullsListReviewCommentsForRepoOKHeaders, error)
	// PullsListReviews invokes pulls/list-reviews operation.
	//
	// The list of reviews returns in chronological order.
	//
	// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
	PullsListReviews(ctx context.Context, params PullsListReviewsParams) (*PullsListReviewsOKHeaders, error)
	// PullsMerge invokes pulls/merge operation.
	//
	// This endpoint triggers [notifications](https://docs.github.
	// com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
	PullsMerge(ctx context.Context, request OptNilPullsMergeReq, params PullsMergeParams) (PullsMergeRes, error)
	// PullsRemoveRequestedReviewers invokes pulls/remove-requested-reviewers operation.
	//
	// Remove requested reviewers from a pull request.
	//
	// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
	PullsRemoveRequestedReviewers(ctx context.Context, request *PullsRemoveRequestedReviewersReq, params PullsRemoveRequestedReviewersParams) (PullsRemoveRequestedReviewersRes, error)
	// PullsSubmitReview invokes pulls/submit-review operation.
	//
	// Submit a review for a pull request.
	//
	// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
	PullsSubmitReview(ctx context.Context, request *PullsSubmitReviewReq, params PullsSubmitReviewParams) (PullsSubmitReviewRes, error)
	// PullsUpdate invokes pulls/update operation.
	//
	// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
	// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
	// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// To open or update a pull request in a public repository, you must have write access to the head or
	// the source branch. For organization-owned repositories, you must be a member of the organization
	// that owns the repository to open or update a pull request.
	//
	// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
	PullsUpdate(ctx context.Context, request OptPullsUpdateReq, params PullsUpdateParams) (PullsUpdateRes, error)
	// PullsUpdateBranch invokes pulls/update-branch operation.
	//
	// Updates the pull request branch with the latest upstream changes by merging HEAD from the base
	// branch into the pull request branch.
	//
	// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
	PullsUpdateBranch(ctx context.Context, request OptNilPullsUpdateBranchReq, params PullsUpdateBranchParams) (PullsUpdateBranchRes, error)
	// PullsUpdateReview invokes pulls/update-review operation.
	//
	// Update the review summary comment with new text.
	//
	// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
	PullsUpdateReview(ctx context.Context, request *PullsUpdateReviewReq, params PullsUpdateReviewParams) (PullsUpdateReviewRes, error)
	// PullsUpdateReviewComment invokes pulls/update-review-comment operation.
	//
	// Enables you to edit a review comment.
	//
	// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
	PullsUpdateReviewComment(ctx context.Context, request *PullsUpdateReviewCommentReq, params PullsUpdateReviewCommentParams) (*PullRequestReviewComment, error)
	// RateLimitGet invokes rate-limit/get operation.
	//
	// **Note:** Accessing this endpoint does not count against your REST API rate limit.
	// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating
	// existing code, you should use the `core` object instead of the `rate` object. The `core` object
	// contains the same information that is present in the `rate` object.
	//
	// GET /rate_limit
	RateLimitGet(ctx context.Context) (RateLimitGetRes, error)
	// ReactionsCreateForCommitComment invokes reactions/create-for-commit-comment operation.
	//
	// Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A
	// response with an HTTP `200` status means that you already added the reaction type to this commit
	// comment.
	//
	// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
	ReactionsCreateForCommitComment(ctx context.Context, request *ReactionsCreateForCommitCommentReq, params ReactionsCreateForCommitCommentParams) (ReactionsCreateForCommitCommentRes, error)
	// ReactionsCreateForIssue invokes reactions/create-for-issue operation.
	//
	// Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with
	// an HTTP `200` status means that you already added the reaction type to this issue.
	//
	// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
	ReactionsCreateForIssue(ctx context.Context, request *ReactionsCreateForIssueReq, params ReactionsCreateForIssueParams) (ReactionsCreateForIssueRes, error)
	// ReactionsCreateForIssueComment invokes reactions/create-for-issue-comment operation.
	//
	// Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A
	// response with an HTTP `200` status means that you already added the reaction type to this issue
	// comment.
	//
	// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
	ReactionsCreateForIssueComment(ctx context.Context, request *ReactionsCreateForIssueCommentReq, params ReactionsCreateForIssueCommentParams) (ReactionsCreateForIssueCommentRes, error)
	// ReactionsCreateForPullRequestReviewComment invokes reactions/create-for-pull-request-review-comment operation.
	//
	// Create a reaction to a [pull request review comment](https://docs.github.
	// com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already
	// added the reaction type to this pull request review comment.
	//
	// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
	ReactionsCreateForPullRequestReviewComment(ctx context.Context, request *ReactionsCreateForPullRequestReviewCommentReq, params ReactionsCreateForPullRequestReviewCommentParams) (ReactionsCreateForPullRequestReviewCommentRes, error)
	// ReactionsCreateForRelease invokes reactions/create-for-release operation.
	//
	// Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A
	// response with a `Status: 200 OK` means that you already added the reaction type to this release.
	//
	// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
	ReactionsCreateForRelease(ctx context.Context, request *ReactionsCreateForReleaseReq, params ReactionsCreateForReleaseParams) (ReactionsCreateForReleaseRes, error)
	// ReactionsCreateForTeamDiscussionCommentInOrg invokes reactions/create-for-team-discussion-comment-in-org operation.
	//
	// Create a reaction to a [team discussion comment](https://docs.github.
	// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
	// response with an HTTP `200` status means that you already added the reaction type to this team
	// discussion comment.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
	// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
	//
	// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
	ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, request *ReactionsCreateForTeamDiscussionCommentInOrgReq, params ReactionsCreateForTeamDiscussionCommentInOrgParams) (ReactionsCreateForTeamDiscussionCommentInOrgRes, error)
	// ReactionsCreateForTeamDiscussionCommentLegacy invokes reactions/create-for-team-discussion-comment-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new "[Create reaction for a team discussion
	// comment](https://docs.github.
	// com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
	// Create a reaction to a [team discussion comment](https://docs.github.
	// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
	// response with an HTTP `200` status means that you already added the reaction type to this team
	// discussion comment.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
	ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, request *ReactionsCreateForTeamDiscussionCommentLegacyReq, params ReactionsCreateForTeamDiscussionCommentLegacyParams) (*Reaction, error)
	// ReactionsCreateForTeamDiscussionInOrg invokes reactions/create-for-team-discussion-in-org operation.
	//
	// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
	//  OAuth access tokens require the `write:discussion` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
	// status means that you already added the reaction type to this team discussion.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
	// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
	//
	// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
	ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, request *ReactionsCreateForTeamDiscussionInOrgReq, params ReactionsCreateForTeamDiscussionInOrgParams) (ReactionsCreateForTeamDiscussionInOrgRes, error)
	// ReactionsCreateForTeamDiscussionLegacy invokes reactions/create-for-team-discussion-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`Create reaction for a team
	// discussion`](https://docs.github.
	// com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
	// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
	//  OAuth access tokens require the `write:discussion` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
	// status means that you already added the reaction type to this team discussion.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /teams/{team_id}/discussions/{discussion_number}/reactions
	ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, request *ReactionsCreateForTeamDiscussionLegacyReq, params ReactionsCreateForTeamDiscussionLegacyParams) (*Reaction, error)
	// ReactionsDeleteForCommitComment invokes reactions/delete-for-commit-comment operation.
	//
	// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
	// /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
	// Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
	//
	// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
	ReactionsDeleteForCommitComment(ctx context.Context, params ReactionsDeleteForCommitCommentParams) error
	// ReactionsDeleteForIssue invokes reactions/delete-for-issue operation.
	//
	// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
	// /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
	// Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
	//
	// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
	ReactionsDeleteForIssue(ctx context.Context, params ReactionsDeleteForIssueParams) error
	// ReactionsDeleteForIssueComment invokes reactions/delete-for-issue-comment operation.
	//
	// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete
	// /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
	// Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
	//
	// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
	ReactionsDeleteForIssueComment(ctx context.Context, params ReactionsDeleteForIssueCommentParams) error
	// ReactionsDeleteForPullRequestComment invokes reactions/delete-for-pull-request-comment operation.
	//
	// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
	// /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
	// Delete a reaction to a [pull request review comment](https://docs.github.
	// com/rest/reference/pulls#review-comments).
	//
	// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
	ReactionsDeleteForPullRequestComment(ctx context.Context, params ReactionsDeleteForPullRequestCommentParams) error
	// ReactionsDeleteForTeamDiscussion invokes reactions/delete-for-team-discussion operation.
	//
	// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
	// `DELETE
	// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
	// Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
	//  OAuth access tokens require the `write:discussion` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
	ReactionsDeleteForTeamDiscussion(ctx context.Context, params ReactionsDeleteForTeamDiscussionParams) error
	// ReactionsDeleteForTeamDiscussionComment invokes reactions/delete-for-team-discussion-comment operation.
	//
	// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
	// `DELETE
	// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
	// Delete a reaction to a [team discussion comment](https://docs.github.
	// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
	ReactionsDeleteForTeamDiscussionComment(ctx context.Context, params ReactionsDeleteForTeamDiscussionCommentParams) error
	// ReactionsDeleteLegacy invokes reactions/delete-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions
	// API. We recommend migrating your existing code to use the new delete reactions endpoints. For more
	// information, see this [blog post](https://developer.github.
	// com/changes/2020-02-26-new-delete-reactions-endpoints/).
	// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team
	// discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion
	// comment](https://docs.github.com/rest/reference/teams#discussion-comments).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /reactions/{reaction_id}
	ReactionsDeleteLegacy(ctx context.Context, params ReactionsDeleteLegacyParams) (ReactionsDeleteLegacyRes, error)
	// ReactionsListForCommitComment invokes reactions/list-for-commit-comment operation.
	//
	// List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
	//
	// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
	ReactionsListForCommitComment(ctx context.Context, params ReactionsListForCommitCommentParams) (ReactionsListForCommitCommentRes, error)
	// ReactionsListForIssue invokes reactions/list-for-issue operation.
	//
	// List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
	//
	// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
	ReactionsListForIssue(ctx context.Context, params ReactionsListForIssueParams) (ReactionsListForIssueRes, error)
	// ReactionsListForIssueComment invokes reactions/list-for-issue-comment operation.
	//
	// List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
	//
	// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
	ReactionsListForIssueComment(ctx context.Context, params ReactionsListForIssueCommentParams) (ReactionsListForIssueCommentRes, error)
	// ReactionsListForPullRequestReviewComment invokes reactions/list-for-pull-request-review-comment operation.
	//
	// List the reactions to a [pull request review comment](https://docs.github.
	// com/rest/reference/pulls#review-comments).
	//
	// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
	ReactionsListForPullRequestReviewComment(ctx context.Context, params ReactionsListForPullRequestReviewCommentParams) (ReactionsListForPullRequestReviewCommentRes, error)
	// ReactionsListForTeamDiscussionCommentInOrg invokes reactions/list-for-team-discussion-comment-in-org operation.
	//
	// List the reactions to a [team discussion comment](https://docs.github.
	// com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
	//
	// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
	ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, params ReactionsListForTeamDiscussionCommentInOrgParams) (*ReactionsListForTeamDiscussionCommentInOrgOKHeaders, error)
	// ReactionsListForTeamDiscussionCommentLegacy invokes reactions/list-for-team-discussion-comment-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List reactions for a team discussion
	// comment`](https://docs.github.
	// com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
	// List the reactions to a [team discussion comment](https://docs.github.
	// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
	ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, params ReactionsListForTeamDiscussionCommentLegacyParams) (*ReactionsListForTeamDiscussionCommentLegacyOKHeaders, error)
	// ReactionsListForTeamDiscussionInOrg invokes reactions/list-for-team-discussion-in-org operation.
	//
	// List the reactions to a [team discussion](https://docs.github.
	// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
	//
	// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
	ReactionsListForTeamDiscussionInOrg(ctx context.Context, params ReactionsListForTeamDiscussionInOrgParams) (*ReactionsListForTeamDiscussionInOrgOKHeaders, error)
	// ReactionsListForTeamDiscussionLegacy invokes reactions/list-for-team-discussion-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List reactions for a team
	// discussion`](https://docs.github.
	// com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
	// List the reactions to a [team discussion](https://docs.github.
	// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/discussions/{discussion_number}/reactions
	ReactionsListForTeamDiscussionLegacy(ctx context.Context, params ReactionsListForTeamDiscussionLegacyParams) (*ReactionsListForTeamDiscussionLegacyOKHeaders, error)
	// ReposAcceptInvitation invokes repos/accept-invitation operation.
	//
	// Accept a repository invitation.
	//
	// PATCH /user/repository_invitations/{invitation_id}
	ReposAcceptInvitation(ctx context.Context, params ReposAcceptInvitationParams) (ReposAcceptInvitationRes, error)
	// ReposAddAppAccessRestrictions invokes repos/add-app-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Grants the specified apps push access for this branch. Only installed GitHub Apps with `write`
	// access to the `contents` permission can be added as authorized actors on a protected branch.
	// | Type    | Description
	//                                                                     |
	// | ------- |
	// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
	// The list of users, apps, and teams in total is limited to 100 items. |.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
	ReposAddAppAccessRestrictions(ctx context.Context, request OptReposAddAppAccessRestrictionsReq, params ReposAddAppAccessRestrictionsParams) (ReposAddAppAccessRestrictionsRes, error)
	// ReposAddCollaborator invokes repos/add-collaborator operation.
	//
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	// For more information the permission levels, see "[Repository permission levels for an
	// organization](https://help.github.
	// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
	// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
	// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs)."
	// The invitee will receive a notification that they have been invited to the repository, which they
	// must accept or decline. They may do this via the notifications page, the email they receive, or by
	// using the [repository invitations API endpoints](https://docs.github.
	// com/rest/reference/repos#invitations).
	// **Rate limits**
	// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no
	// limit if you are inviting organization members to an organization repository.
	//
	// PUT /repos/{owner}/{repo}/collaborators/{username}
	ReposAddCollaborator(ctx context.Context, request OptReposAddCollaboratorReq, params ReposAddCollaboratorParams) (ReposAddCollaboratorRes, error)
	// ReposAddStatusCheckContexts invokes repos/add-status-check-contexts operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
	ReposAddStatusCheckContexts(ctx context.Context, request OptReposAddStatusCheckContextsReq, params ReposAddStatusCheckContextsParams) (ReposAddStatusCheckContextsRes, error)
	// ReposAddTeamAccessRestrictions invokes repos/add-team-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Grants the specified teams push access for this branch. You can also give push access to child
	// teams.
	// | Type    | Description
	//                                                     |
	// | ------- |
	// ------------------------------------------------------------------------------------------------------------------------------------------ |
	// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
	// users, apps, and teams in total is limited to 100 items. |.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
	ReposAddTeamAccessRestrictions(ctx context.Context, request OptReposAddTeamAccessRestrictionsReq, params ReposAddTeamAccessRestrictionsParams) (ReposAddTeamAccessRestrictionsRes, error)
	// ReposAddUserAccessRestrictions invokes repos/add-user-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Grants the specified people push access for this branch.
	// | Type    | Description
	//                                        |
	// | ------- |
	// ----------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
	// teams in total is limited to 100 items. |.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
	ReposAddUserAccessRestrictions(ctx context.Context, request OptReposAddUserAccessRestrictionsReq, params ReposAddUserAccessRestrictionsParams) (ReposAddUserAccessRestrictionsRes, error)
	// ReposCheckCollaborator invokes repos/check-collaborator operation.
	//
	// For organization-owned repositories, the list of collaborators includes outside collaborators,
	// organization members that are direct collaborators, organization members with access through team
	// memberships, organization members with access through default organization permissions, and
	// organization owners.
	// Team members will include the members of child teams.
	//
	// GET /repos/{owner}/{repo}/collaborators/{username}
	ReposCheckCollaborator(ctx context.Context, params ReposCheckCollaboratorParams) (ReposCheckCollaboratorRes, error)
	// ReposCheckVulnerabilityAlerts invokes repos/check-vulnerability-alerts operation.
	//
	// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user
	// must have admin access to the repository. For more information, see "[About security alerts for
	// vulnerable dependencies](https://help.github.
	// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
	//
	// GET /repos/{owner}/{repo}/vulnerability-alerts
	ReposCheckVulnerabilityAlerts(ctx context.Context, params ReposCheckVulnerabilityAlertsParams) (ReposCheckVulnerabilityAlertsRes, error)
	// ReposCompareCommits invokes repos/compare-commits operation.
	//
	// The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in
	// `repo`. To compare branches across other repositories in the same network as `repo`, use the
	// format `<USERNAME>:branch`.
	// The response from the API is equivalent to running the `git log base..head` command; however,
	// commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.
	// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
	// patch formats.
	// The response also includes details on the files that were changed between the two commits. This
	// includes the status of the change (for example, if a file was added, removed, modified, or
	// renamed), and details of the change itself. For example, files with a `renamed` status have a
	// `previous_filename` field showing the previous filename of the file, and files with a `modified`
	// status have a `patch` field showing the changes made to the file.
	// **Working with large comparisons**
	// To process a response with a large number of commits, you can use (`per_page` or `page`) to
	// paginate the results. When using paging, the list of changed files is only returned with page 1,
	// but includes all changed files for the entire comparison. For more information on working with
	// pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
	// When calling this API without any paging parameters (`per_page` or `page`), the returned list is
	// limited to 250 commits and the last commit in the list is the most recent of the entire comparison.
	//  When a paging parameter is specified, the first commit in the returned list of each page is the
	// earliest.
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// GET /repos/{owner}/{repo}/compare/{basehead}
	ReposCompareCommits(ctx context.Context, params ReposCompareCommitsParams) (ReposCompareCommitsRes, error)
	// ReposCreateAutolink invokes repos/create-autolink operation.
	//
	// Users with admin access to the repository can create an autolink.
	//
	// POST /repos/{owner}/{repo}/autolinks
	ReposCreateAutolink(ctx context.Context, request *ReposCreateAutolinkReq, params ReposCreateAutolinkParams) (ReposCreateAutolinkRes, error)
	// ReposCreateCommitComment invokes repos/create-commit-comment operation.
	//
	// Create a comment for a commit using its `:commit_sha`.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
	ReposCreateCommitComment(ctx context.Context, request *ReposCreateCommitCommentReq, params ReposCreateCommitCommentParams) (ReposCreateCommitCommentRes, error)
	// ReposCreateCommitSignatureProtection invokes repos/create-commit-signature-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
	// require signed commits on a branch. You must enable branch protection to require signed commits.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
	ReposCreateCommitSignatureProtection(ctx context.Context, params ReposCreateCommitSignatureProtectionParams) (ReposCreateCommitSignatureProtectionRes, error)
	// ReposCreateCommitStatus invokes repos/create-commit-status operation.
	//
	// Users with push access in a repository can create commit statuses for a given SHA.
	// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
	// create more than 1000 statuses will result in a validation error.
	//
	// POST /repos/{owner}/{repo}/statuses/{sha}
	ReposCreateCommitStatus(ctx context.Context, request *ReposCreateCommitStatusReq, params ReposCreateCommitStatusParams) (*StatusHeaders, error)
	// ReposCreateDeployKey invokes repos/create-deploy-key operation.
	//
	// You can create a read-only deploy key.
	//
	// POST /repos/{owner}/{repo}/keys
	ReposCreateDeployKey(ctx context.Context, request *ReposCreateDeployKeyReq, params ReposCreateDeployKeyParams) (ReposCreateDeployKeyRes, error)
	// ReposCreateDeployment invokes repos/create-deployment operation.
	//
	// Deployments offer a few configurable parameters with certain defaults.
	// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and
	// verify them
	// before we merge a pull request.
	// The `environment` parameter allows deployments to be issued to different runtime environments.
	// Teams often have
	// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`.
	// This parameter
	// makes it easier to track which environments have requested deployments. The default environment is
	// `production`.
	// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's
	// default branch. If
	// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If
	// the merge succeeds,
	// the API will return a successful merge commit. If merge conflicts prevent the merge from
	// succeeding, the API will
	// return a failure response.
	// By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every
	// submitted context must be in a `success`
	// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be
	// `success`, or to
	// specify contexts that have not yet been submitted. You are not required to use commit statuses to
	// deploy. If you do
	// not require any contexts or create any commit statuses, the deployment will always succeed.
	// The `payload` parameter is available for any extra information that a deployment system might need.
	//  It is a JSON text
	// field that will be passed on when a deployment event is dispatched.
	// The `task` parameter is used by the deployment system to allow different execution paths. In the
	// web world this might
	// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a
	// flag to compile an
	// application with debugging enabled.
	// Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
	// #### Merged branch response
	// You will see this response when GitHub automatically merges the base branch into the topic branch
	// instead of creating
	// a deployment. This auto-merge happens when:
	// *   Auto-merge option is enabled in the repository
	// *   Topic branch does not include the latest changes on the base branch, which is `master` in the
	// response example
	// *   There are no merge conflicts
	// If there are no new commits in the base branch, a new request to create a deployment should give a
	// successful
	// response.
	// #### Merge conflict response
	// This error happens when the `auto_merge` option is enabled and when the default branch (in this
	// case `master`), can't
	// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge
	// conflicts.
	// #### Failed commit status checks
	// This error happens when the `required_contexts` parameter indicates that one or more contexts need
	// to have a `success`
	// status for the commit to be deployed, but one or more of the required contexts do not have a state
	// of `success`.
	//
	// POST /repos/{owner}/{repo}/deployments
	ReposCreateDeployment(ctx context.Context, request *ReposCreateDeploymentReq, params ReposCreateDeploymentParams) (ReposCreateDeploymentRes, error)
	// ReposCreateDeploymentStatus invokes repos/create-deployment-status operation.
	//
	// Users with `push` access can create deployment statuses for a given deployment.
	// GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo
	// contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
	//
	// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
	ReposCreateDeploymentStatus(ctx context.Context, request *ReposCreateDeploymentStatusReq, params ReposCreateDeploymentStatusParams) (ReposCreateDeploymentStatusRes, error)
	// ReposCreateDispatchEvent invokes repos/create-dispatch-event operation.
	//
	// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want
	// activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook.
	//  You must configure your GitHub Actions workflow or GitHub App to run when the
	// `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
	// "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
	// The `client_payload` parameter is available for any extra information that your workflow might
	// need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched.
	//  For example, the `client_payload` can include a message that a user would like to send using a
	// GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
	// This endpoint requires write access to the repository by providing either:
	// - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access
	// token for the command line](https://help.github.
	// com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help
	// documentation.
	// - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
	// This input example shows how you can use the `client_payload` as a test to debug your workflow.
	//
	// POST /repos/{owner}/{repo}/dispatches
	ReposCreateDispatchEvent(ctx context.Context, request *ReposCreateDispatchEventReq, params ReposCreateDispatchEventParams) (ReposCreateDispatchEventRes, error)
	// ReposCreateForAuthenticatedUser invokes repos/create-for-authenticated-user operation.
	//
	// Creates a new repository for the authenticated user.
	// **OAuth scope requirements**
	// When using [OAuth](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
	// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
	// `repo` scope to create an internal repository.
	// *   `repo` scope to create a private repository.
	//
	// POST /user/repos
	ReposCreateForAuthenticatedUser(ctx context.Context, request *ReposCreateForAuthenticatedUserReq) (ReposCreateForAuthenticatedUserRes, error)
	// ReposCreateFork invokes repos/create-fork operation.
	//
	// Create a fork for the authenticated user.
	// **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time
	// before you can access the git objects. If this takes longer than 5 minutes, be sure to contact
	// [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
	//
	// POST /repos/{owner}/{repo}/forks
	ReposCreateFork(ctx context.Context, request OptNilReposCreateForkReq, params ReposCreateForkParams) (ReposCreateForkRes, error)
	// ReposCreateInOrg invokes repos/create-in-org operation.
	//
	// Creates a new repository in the specified organization. The authenticated user must be a member of
	// the organization.
	// **OAuth scope requirements**
	// When using [OAuth](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
	// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
	// `repo` scope to create an internal repository.
	// *   `repo` scope to create a private repository.
	//
	// POST /orgs/{org}/repos
	ReposCreateInOrg(ctx context.Context, request *ReposCreateInOrgReq, params ReposCreateInOrgParams) (ReposCreateInOrgRes, error)
	// ReposCreateOrUpdateFileContents invokes repos/create-or-update-file-contents operation.
	//
	// Creates a new file or replaces an existing file in a repository.
	//
	// PUT /repos/{owner}/{repo}/contents/{path}
	ReposCreateOrUpdateFileContents(ctx context.Context, request *ReposCreateOrUpdateFileContentsReq, params ReposCreateOrUpdateFileContentsParams) (ReposCreateOrUpdateFileContentsRes, error)
	// ReposCreatePagesSite invokes repos/create-pages-site operation.
	//
	// Configures a GitHub Pages site. For more information, see "[About GitHub
	// Pages](/github/working-with-github-pages/about-github-pages).".
	//
	// POST /repos/{owner}/{repo}/pages
	ReposCreatePagesSite(ctx context.Context, request NilReposCreatePagesSiteReq, params ReposCreatePagesSiteParams) (ReposCreatePagesSiteRes, error)
	// ReposCreateRelease invokes repos/create-release operation.
	//
	// Users with push access to the repository can create a release.
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// POST /repos/{owner}/{repo}/releases
	ReposCreateRelease(ctx context.Context, request *ReposCreateReleaseReq, params ReposCreateReleaseParams) (ReposCreateReleaseRes, error)
	// ReposCreateUsingTemplate invokes repos/create-using-template operation.
	//
	// Creates a new repository using a repository template. Use the `template_owner` and `template_repo`
	// route parameters to specify the repository to use as the template. The authenticated user must own
	// or be a member of an organization that owns the repository. To check if a repository is available
	// to use as a template, get the repository's information using the [Get a repository](https://docs.
	// github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is
	// `true`.
	// **OAuth scope requirements**
	// When using [OAuth](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
	// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
	// `repo` scope to create an internal repository.
	// *   `repo` scope to create a private repository.
	//
	// POST /repos/{template_owner}/{template_repo}/generate
	ReposCreateUsingTemplate(ctx context.Context, request *ReposCreateUsingTemplateReq, params ReposCreateUsingTemplateParams) (*RepositoryHeaders, error)
	// ReposCreateWebhook invokes repos/create-webhook operation.
	//
	// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`.
	// Multiple webhooks can
	// share the same `config` as long as those webhooks do not have any `events` that overlap.
	//
	// POST /repos/{owner}/{repo}/hooks
	ReposCreateWebhook(ctx context.Context, request OptNilReposCreateWebhookReq, params ReposCreateWebhookParams) (ReposCreateWebhookRes, error)
	// ReposDeclineInvitation invokes repos/decline-invitation operation.
	//
	// Decline a repository invitation.
	//
	// DELETE /user/repository_invitations/{invitation_id}
	ReposDeclineInvitation(ctx context.Context, params ReposDeclineInvitationParams) (ReposDeclineInvitationRes, error)
	// ReposDelete invokes repos/delete operation.
	//
	// Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
	// If an organization owner has configured the organization to prevent members from deleting
	// organization-owned
	// repositories, you will get a `403 Forbidden` response.
	//
	// DELETE /repos/{owner}/{repo}
	ReposDelete(ctx context.Context, params ReposDeleteParams) (ReposDeleteRes, error)
	// ReposDeleteAccessRestrictions invokes repos/delete-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Disables the ability to restrict who can push to this branch.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
	ReposDeleteAccessRestrictions(ctx context.Context, params ReposDeleteAccessRestrictionsParams) error
	// ReposDeleteAdminBranchProtection invokes repos/delete-admin-branch-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Removing admin enforcement requires admin or owner permissions to the repository and branch
	// protection to be enabled.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
	ReposDeleteAdminBranchProtection(ctx context.Context, params ReposDeleteAdminBranchProtectionParams) (ReposDeleteAdminBranchProtectionRes, error)
	// ReposDeleteAnEnvironment invokes repos/delete-an-environment operation.
	//
	// You must authenticate using an access token with the repo scope to use this endpoint.
	//
	// DELETE /repos/{owner}/{repo}/environments/{environment_name}
	ReposDeleteAnEnvironment(ctx context.Context, params ReposDeleteAnEnvironmentParams) error
	// ReposDeleteAutolink invokes repos/delete-autolink operation.
	//
	// This deletes a single autolink reference by ID that was configured for the given repository.
	// Information about autolinks are only available to repository administrators.
	//
	// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
	ReposDeleteAutolink(ctx context.Context, params ReposDeleteAutolinkParams) (ReposDeleteAutolinkRes, error)
	// ReposDeleteBranchProtection invokes repos/delete-branch-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
	ReposDeleteBranchProtection(ctx context.Context, params ReposDeleteBranchProtectionParams) (ReposDeleteBranchProtectionRes, error)
	// ReposDeleteCommitComment invokes repos/delete-commit-comment operation.
	//
	// Delete a commit comment.
	//
	// DELETE /repos/{owner}/{repo}/comments/{comment_id}
	ReposDeleteCommitComment(ctx context.Context, params ReposDeleteCommitCommentParams) (ReposDeleteCommitCommentRes, error)
	// ReposDeleteCommitSignatureProtection invokes repos/delete-commit-signature-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
	// disable required signed commits on a branch. You must enable branch protection to require signed
	// commits.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
	ReposDeleteCommitSignatureProtection(ctx context.Context, params ReposDeleteCommitSignatureProtectionParams) (ReposDeleteCommitSignatureProtectionRes, error)
	// ReposDeleteDeployKey invokes repos/delete-deploy-key operation.
	//
	// Deploy keys are immutable. If you need to update a key, remove the key and create a new one
	// instead.
	//
	// DELETE /repos/{owner}/{repo}/keys/{key_id}
	ReposDeleteDeployKey(ctx context.Context, params ReposDeleteDeployKeyParams) error
	// ReposDeleteDeployment invokes repos/delete-deployment operation.
	//
	// To ensure there can always be an active deployment, you can only delete an _inactive_ deployment.
	// Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
	// To set a deployment as inactive, you must:
	// *   Create a new deployment that is active so that the system has a record of the current state,
	// then delete the previously active deployment.
	// *   Mark the active deployment as inactive by adding any non-successful deployment status.
	// For more information, see "[Create a deployment](https://docs.github.
	// com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.
	// github.com/rest/reference/repos#create-a-deployment-status).".
	//
	// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
	ReposDeleteDeployment(ctx context.Context, params ReposDeleteDeploymentParams) (ReposDeleteDeploymentRes, error)
	// ReposDeleteFile invokes repos/delete-file operation.
	//
	// Deletes a file in a repository.
	// You can provide an additional `committer` parameter, which is an object containing information
	// about the committer. Or, you can provide an `author` parameter, which is an object containing
	// information about the author.
	// The `author` section is optional and is filled in with the `committer` information if omitted. If
	// the `committer` information is omitted, the authenticated user's information is used.
	// You must provide values for both `name` and `email`, whether you choose to use `author` or
	// `committer`. Otherwise, you'll receive a `422` status code.
	//
	// DELETE /repos/{owner}/{repo}/contents/{path}
	ReposDeleteFile(ctx context.Context, request *ReposDeleteFileReq, params ReposDeleteFileParams) (ReposDeleteFileRes, error)
	// ReposDeleteInvitation invokes repos/delete-invitation operation.
	//
	// Delete a repository invitation.
	//
	// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
	ReposDeleteInvitation(ctx context.Context, params ReposDeleteInvitationParams) error
	// ReposDeletePagesSite invokes repos/delete-pages-site operation.
	//
	// Delete a GitHub Pages site.
	//
	// DELETE /repos/{owner}/{repo}/pages
	ReposDeletePagesSite(ctx context.Context, params ReposDeletePagesSiteParams) (ReposDeletePagesSiteRes, error)
	// ReposDeletePullRequestReviewProtection invokes repos/delete-pull-request-review-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
	ReposDeletePullRequestReviewProtection(ctx context.Context, params ReposDeletePullRequestReviewProtectionParams) (ReposDeletePullRequestReviewProtectionRes, error)
	// ReposDeleteRelease invokes repos/delete-release operation.
	//
	// Users with push access to the repository can delete a release.
	//
	// DELETE /repos/{owner}/{repo}/releases/{release_id}
	ReposDeleteRelease(ctx context.Context, params ReposDeleteReleaseParams) error
	// ReposDeleteReleaseAsset invokes repos/delete-release-asset operation.
	//
	// Delete a release asset.
	//
	// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
	ReposDeleteReleaseAsset(ctx context.Context, params ReposDeleteReleaseAssetParams) error
	// ReposDeleteWebhook invokes repos/delete-webhook operation.
	//
	// Delete a repository webhook.
	//
	// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
	ReposDeleteWebhook(ctx context.Context, params ReposDeleteWebhookParams) (ReposDeleteWebhookRes, error)
	// ReposDisableAutomatedSecurityFixes invokes repos/disable-automated-security-fixes operation.
	//
	// Disables automated security fixes for a repository. The authenticated user must have admin access
	// to the repository. For more information, see "[Configuring automated security fixes](https://help.
	// github.com/en/articles/configuring-automated-security-fixes)".
	//
	// DELETE /repos/{owner}/{repo}/automated-security-fixes
	ReposDisableAutomatedSecurityFixes(ctx context.Context, params ReposDisableAutomatedSecurityFixesParams) error
	// ReposDisableLfsForRepo invokes repos/disable-lfs-for-repo operation.
	//
	// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
	//
	// DELETE /repos/{owner}/{repo}/lfs
	ReposDisableLfsForRepo(ctx context.Context, params ReposDisableLfsForRepoParams) error
	// ReposDisableVulnerabilityAlerts invokes repos/disable-vulnerability-alerts operation.
	//
	// Disables dependency alerts and the dependency graph for a repository. The authenticated user must
	// have admin access to the repository. For more information, see "[About security alerts for
	// vulnerable dependencies](https://help.github.
	// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
	//
	// DELETE /repos/{owner}/{repo}/vulnerability-alerts
	ReposDisableVulnerabilityAlerts(ctx context.Context, params ReposDisableVulnerabilityAlertsParams) error
	// ReposDownloadTarballArchive invokes repos/download-tarball-archive operation.
	//
	// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
	// repository’s default branch (usually
	// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
	// you will need to use
	// the `Location` header to make a second `GET` request.
	// **Note**: For private repositories, these links are temporary and expire after five minutes.
	//
	// GET /repos/{owner}/{repo}/tarball/{ref}
	ReposDownloadTarballArchive(ctx context.Context, params ReposDownloadTarballArchiveParams) (*ReposDownloadTarballArchiveFound, error)
	// ReposDownloadZipballArchive invokes repos/download-zipball-archive operation.
	//
	// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
	// repository’s default branch (usually
	// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
	// you will need to use
	// the `Location` header to make a second `GET` request.
	// **Note**: For private repositories, these links are temporary and expire after five minutes.
	//
	// GET /repos/{owner}/{repo}/zipball/{ref}
	ReposDownloadZipballArchive(ctx context.Context, params ReposDownloadZipballArchiveParams) (*ReposDownloadZipballArchiveFound, error)
	// ReposEnableAutomatedSecurityFixes invokes repos/enable-automated-security-fixes operation.
	//
	// Enables automated security fixes for a repository. The authenticated user must have admin access
	// to the repository. For more information, see "[Configuring automated security fixes](https://help.
	// github.com/en/articles/configuring-automated-security-fixes)".
	//
	// PUT /repos/{owner}/{repo}/automated-security-fixes
	ReposEnableAutomatedSecurityFixes(ctx context.Context, params ReposEnableAutomatedSecurityFixesParams) error
	// ReposEnableLfsForRepo invokes repos/enable-lfs-for-repo operation.
	//
	// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
	//
	// PUT /repos/{owner}/{repo}/lfs
	ReposEnableLfsForRepo(ctx context.Context, params ReposEnableLfsForRepoParams) (ReposEnableLfsForRepoRes, error)
	// ReposEnableVulnerabilityAlerts invokes repos/enable-vulnerability-alerts operation.
	//
	// Enables dependency alerts and the dependency graph for a repository. The authenticated user must
	// have admin access to the repository. For more information, see "[About security alerts for
	// vulnerable dependencies](https://help.github.
	// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
	//
	// PUT /repos/{owner}/{repo}/vulnerability-alerts
	ReposEnableVulnerabilityAlerts(ctx context.Context, params ReposEnableVulnerabilityAlertsParams) error
	// ReposGet invokes repos/get operation.
	//
	// The `parent` and `source` objects are present when the repository is a fork. `parent` is the
	// repository this repository was forked from, `source` is the ultimate source for the network.
	//
	// GET /repos/{owner}/{repo}
	ReposGet(ctx context.Context, params ReposGetParams) (ReposGetRes, error)
	// ReposGetAccessRestrictions invokes repos/get-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Lists who has access to this protected branch.
	// **Note**: Users, apps, and teams `restrictions` are only available for organization-owned
	// repositories.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
	ReposGetAccessRestrictions(ctx context.Context, params ReposGetAccessRestrictionsParams) (ReposGetAccessRestrictionsRes, error)
	// ReposGetAdminBranchProtection invokes repos/get-admin-branch-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
	ReposGetAdminBranchProtection(ctx context.Context, params ReposGetAdminBranchProtectionParams) (*ProtectedBranchAdminEnforced, error)
	// ReposGetAllStatusCheckContexts invokes repos/get-all-status-check-contexts operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
	ReposGetAllStatusCheckContexts(ctx context.Context, params ReposGetAllStatusCheckContextsParams) (ReposGetAllStatusCheckContextsRes, error)
	// ReposGetAllTopics invokes repos/get-all-topics operation.
	//
	// Get all repository topics.
	//
	// GET /repos/{owner}/{repo}/topics
	ReposGetAllTopics(ctx context.Context, params ReposGetAllTopicsParams) (ReposGetAllTopicsRes, error)
	// ReposGetAppsWithAccessToProtectedBranch invokes repos/get-apps-with-access-to-protected-branch operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with
	// `write` access to the `contents` permission can be added as authorized actors on a protected
	// branch.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
	ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, params ReposGetAppsWithAccessToProtectedBranchParams) (ReposGetAppsWithAccessToProtectedBranchRes, error)
	// ReposGetAutolink invokes repos/get-autolink operation.
	//
	// This returns a single autolink reference by ID that was configured for the given repository.
	// Information about autolinks are only available to repository administrators.
	//
	// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
	ReposGetAutolink(ctx context.Context, params ReposGetAutolinkParams) (ReposGetAutolinkRes, error)
	// ReposGetBranch invokes repos/get-branch operation.
	//
	// Get a branch.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}
	ReposGetBranch(ctx context.Context, params ReposGetBranchParams) (ReposGetBranchRes, error)
	// ReposGetBranchProtection invokes repos/get-branch-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection
	ReposGetBranchProtection(ctx context.Context, params ReposGetBranchProtectionParams) (ReposGetBranchProtectionRes, error)
	// ReposGetClones invokes repos/get-clones operation.
	//
	// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are
	// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
	//
	// GET /repos/{owner}/{repo}/traffic/clones
	ReposGetClones(ctx context.Context, params ReposGetClonesParams) (ReposGetClonesRes, error)
	// ReposGetCodeFrequencyStats invokes repos/get-code-frequency-stats operation.
	//
	// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
	//
	// GET /repos/{owner}/{repo}/stats/code_frequency
	ReposGetCodeFrequencyStats(ctx context.Context, params ReposGetCodeFrequencyStatsParams) (ReposGetCodeFrequencyStatsRes, error)
	// ReposGetCollaboratorPermissionLevel invokes repos/get-collaborator-permission-level operation.
	//
	// Checks the repository permission of a collaborator. The possible repository permissions are
	// `admin`, `write`, `read`, and `none`.
	//
	// GET /repos/{owner}/{repo}/collaborators/{username}/permission
	ReposGetCollaboratorPermissionLevel(ctx context.Context, params ReposGetCollaboratorPermissionLevelParams) (ReposGetCollaboratorPermissionLevelRes, error)
	// ReposGetCombinedStatusForRef invokes repos/get-combined-status-for-ref operation.
	//
	// Users with pull access in a repository can access a combined view of commit statuses for a given
	// ref. The ref can be a SHA, a branch name, or a tag name.
	// The most recent status for each context is returned, up to 100. This field
	// [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there
	// are over 100 contexts.
	// Additionally, a combined `state` is returned. The `state` is one of:
	// *   **failure** if any of the contexts report as `error` or `failure`
	// *   **pending** if there are no statuses or a context is `pending`
	// *   **success** if the latest status for all contexts is `success`.
	//
	// GET /repos/{owner}/{repo}/commits/{ref}/status
	ReposGetCombinedStatusForRef(ctx context.Context, params ReposGetCombinedStatusForRefParams) (ReposGetCombinedStatusForRefRes, error)
	// ReposGetCommit invokes repos/get-commit operation.
	//
	// Returns the contents of a single commit reference. You must have `read` access for the repository
	// to use this endpoint.
	// **Note:** If there are more than 300 files in the commit diff, the response will include
	// pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains
	// the static commit information, and the only changes are to the file listing.
	// You can pass the appropriate [media type](https://docs.github.
	// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and
	// `patch` formats. Diffs with binary data will have no `patch` property.
	// To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
	// type](https://docs.github.
	// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header.
	//  You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local
	// reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// GET /repos/{owner}/{repo}/commits/{ref}
	ReposGetCommit(ctx context.Context, params ReposGetCommitParams) (ReposGetCommitRes, error)
	// ReposGetCommitActivityStats invokes repos/get-commit-activity-stats operation.
	//
	// Returns the last year of commit activity grouped by week. The `days` array is a group of commits
	// per day, starting on `Sunday`.
	//
	// GET /repos/{owner}/{repo}/stats/commit_activity
	ReposGetCommitActivityStats(ctx context.Context, params ReposGetCommitActivityStatsParams) (ReposGetCommitActivityStatsRes, error)
	// ReposGetCommitComment invokes repos/get-commit-comment operation.
	//
	// Get a commit comment.
	//
	// GET /repos/{owner}/{repo}/comments/{comment_id}
	ReposGetCommitComment(ctx context.Context, params ReposGetCommitCommentParams) (ReposGetCommitCommentRes, error)
	// ReposGetCommitSignatureProtection invokes repos/get-commit-signature-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
	// check whether a branch requires signed commits. An enabled status of `true` indicates you must
	// sign commits on this branch. For more information, see [Signing commits with GPG](https://help.
	// github.com/articles/signing-commits-with-gpg) in GitHub Help.
	// **Note**: You must enable branch protection to require signed commits.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
	ReposGetCommitSignatureProtection(ctx context.Context, params ReposGetCommitSignatureProtectionParams) (ReposGetCommitSignatureProtectionRes, error)
	// ReposGetCommunityProfileMetrics invokes repos/get-community-profile-metrics operation.
	//
	// This endpoint will return all community profile metrics, including an
	// overall health score, repository description, the presence of documentation, detected
	// code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
	// README, and CONTRIBUTING files.
	// The `health_percentage` score is defined as a percentage of how many of
	// these four documents are present: README, CONTRIBUTING, LICENSE, and
	// CODE_OF_CONDUCT. For example, if all four documents are present, then
	// the `health_percentage` is `100`. If only one is present, then the
	// `health_percentage` is `25`.
	// `content_reports_enabled` is only returned for organization-owned repositories.
	//
	// GET /repos/{owner}/{repo}/community/profile
	ReposGetCommunityProfileMetrics(ctx context.Context, params ReposGetCommunityProfileMetricsParams) (*CommunityProfile, error)
	// ReposGetContributorsStats invokes repos/get-contributors-stats operation.
	//
	// Returns the `total` number of commits authored by the contributor. In addition, the response
	// includes a Weekly Hash (`weeks` array) with the following information:
	// *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
	// *   `a` - Number of additions
	// *   `d` - Number of deletions
	// *   `c` - Number of commits.
	//
	// GET /repos/{owner}/{repo}/stats/contributors
	ReposGetContributorsStats(ctx context.Context, params ReposGetContributorsStatsParams) (ReposGetContributorsStatsRes, error)
	// ReposGetDeployKey invokes repos/get-deploy-key operation.
	//
	// Get a deploy key.
	//
	// GET /repos/{owner}/{repo}/keys/{key_id}
	ReposGetDeployKey(ctx context.Context, params ReposGetDeployKeyParams) (ReposGetDeployKeyRes, error)
	// ReposGetDeployment invokes repos/get-deployment operation.
	//
	// Get a deployment.
	//
	// GET /repos/{owner}/{repo}/deployments/{deployment_id}
	ReposGetDeployment(ctx context.Context, params ReposGetDeploymentParams) (ReposGetDeploymentRes, error)
	// ReposGetDeploymentStatus invokes repos/get-deployment-status operation.
	//
	// Users with pull access can view a deployment status for a deployment:.
	//
	// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
	ReposGetDeploymentStatus(ctx context.Context, params ReposGetDeploymentStatusParams) (ReposGetDeploymentStatusRes, error)
	// ReposGetLatestPagesBuild invokes repos/get-latest-pages-build operation.
	//
	// Get latest Pages build.
	//
	// GET /repos/{owner}/{repo}/pages/builds/latest
	ReposGetLatestPagesBuild(ctx context.Context, params ReposGetLatestPagesBuildParams) (*PageBuild, error)
	// ReposGetLatestRelease invokes repos/get-latest-release operation.
	//
	// View the latest published full release for the repository.
	// The latest release is the most recent non-prerelease, non-draft release, sorted by the
	// `created_at` attribute. The `created_at` attribute is the date of the commit used for the release,
	// and not the date when the release was drafted or published.
	//
	// GET /repos/{owner}/{repo}/releases/latest
	ReposGetLatestRelease(ctx context.Context, params ReposGetLatestReleaseParams) (*Release, error)
	// ReposGetPages invokes repos/get-pages operation.
	//
	// Get a GitHub Pages site.
	//
	// GET /repos/{owner}/{repo}/pages
	ReposGetPages(ctx context.Context, params ReposGetPagesParams) (ReposGetPagesRes, error)
	// ReposGetPagesBuild invokes repos/get-pages-build operation.
	//
	// Get GitHub Pages build.
	//
	// GET /repos/{owner}/{repo}/pages/builds/{build_id}
	ReposGetPagesBuild(ctx context.Context, params ReposGetPagesBuildParams) (*PageBuild, error)
	// ReposGetPagesHealthCheck invokes repos/get-pages-health-check operation.
	//
	// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
	// GitHub Pages.
	// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous
	// background task to get the results for the domain. After the background task completes, subsequent
	// requests to this endpoint return a `200 OK` status with the health check results in the response.
	// Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and
	// `administration:write` permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/pages/health
	ReposGetPagesHealthCheck(ctx context.Context, params ReposGetPagesHealthCheckParams) (ReposGetPagesHealthCheckRes, error)
	// ReposGetParticipationStats invokes repos/get-participation-stats operation.
	//
	// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
	// everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit
	// counts for non-owners, you can subtract `owner` from `all`.
	// The array order is oldest week (index 0) to most recent week.
	//
	// GET /repos/{owner}/{repo}/stats/participation
	ReposGetParticipationStats(ctx context.Context, params ReposGetParticipationStatsParams) (ReposGetParticipationStatsRes, error)
	// ReposGetPullRequestReviewProtection invokes repos/get-pull-request-review-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
	ReposGetPullRequestReviewProtection(ctx context.Context, params ReposGetPullRequestReviewProtectionParams) (*ProtectedBranchPullRequestReview, error)
	// ReposGetPunchCardStats invokes repos/get-punch-card-stats operation.
	//
	// Each array contains the day number, hour number, and number of commits:
	// *   `0-6`: Sunday - Saturday
	// *   `0-23`: Hour of day
	// *   Number of commits
	// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on
	// Tuesdays. All times are based on the time zone of individual commits.
	//
	// GET /repos/{owner}/{repo}/stats/punch_card
	ReposGetPunchCardStats(ctx context.Context, params ReposGetPunchCardStatsParams) (ReposGetPunchCardStatsRes, error)
	// ReposGetReadme invokes repos/get-readme operation.
	//
	// Gets the preferred README for a repository.
	// READMEs support [custom media types](https://docs.github.
	// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
	//
	// GET /repos/{owner}/{repo}/readme
	ReposGetReadme(ctx context.Context, params ReposGetReadmeParams) (ReposGetReadmeRes, error)
	// ReposGetReadmeInDirectory invokes repos/get-readme-in-directory operation.
	//
	// Gets the README from a repository directory.
	// READMEs support [custom media types](https://docs.github.
	// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
	//
	// GET /repos/{owner}/{repo}/readme/{dir}
	ReposGetReadmeInDirectory(ctx context.Context, params ReposGetReadmeInDirectoryParams) (ReposGetReadmeInDirectoryRes, error)
	// ReposGetRelease invokes repos/get-release operation.
	//
	// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release
	// assets. This key is a [hypermedia resource](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#hypermedia).
	//
	// GET /repos/{owner}/{repo}/releases/{release_id}
	ReposGetRelease(ctx context.Context, params ReposGetReleaseParams) (ReposGetReleaseRes, error)
	// ReposGetReleaseAsset invokes repos/get-release-asset operation.
	//
	// To download the asset's binary content, set the `Accept` header of the request to
	// [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
	// either redirect the client to the location, or stream it directly if possible. API clients should
	// handle both a `200` or `302` response.
	//
	// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
	ReposGetReleaseAsset(ctx context.Context, params ReposGetReleaseAssetParams) (ReposGetReleaseAssetRes, error)
	// ReposGetReleaseByTag invokes repos/get-release-by-tag operation.
	//
	// Get a published release with the specified tag.
	//
	// GET /repos/{owner}/{repo}/releases/tags/{tag}
	ReposGetReleaseByTag(ctx context.Context, params ReposGetReleaseByTagParams) (ReposGetReleaseByTagRes, error)
	// ReposGetStatusChecksProtection invokes repos/get-status-checks-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
	ReposGetStatusChecksProtection(ctx context.Context, params ReposGetStatusChecksProtectionParams) (ReposGetStatusChecksProtectionRes, error)
	// ReposGetTeamsWithAccessToProtectedBranch invokes repos/get-teams-with-access-to-protected-branch operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Lists the teams who have push access to this branch. The list includes child teams.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
	ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, params ReposGetTeamsWithAccessToProtectedBranchParams) (ReposGetTeamsWithAccessToProtectedBranchRes, error)
	// ReposGetTopPaths invokes repos/get-top-paths operation.
	//
	// Get the top 10 popular contents over the last 14 days.
	//
	// GET /repos/{owner}/{repo}/traffic/popular/paths
	ReposGetTopPaths(ctx context.Context, params ReposGetTopPathsParams) (ReposGetTopPathsRes, error)
	// ReposGetTopReferrers invokes repos/get-top-referrers operation.
	//
	// Get the top 10 referrers over the last 14 days.
	//
	// GET /repos/{owner}/{repo}/traffic/popular/referrers
	ReposGetTopReferrers(ctx context.Context, params ReposGetTopReferrersParams) (ReposGetTopReferrersRes, error)
	// ReposGetUsersWithAccessToProtectedBranch invokes repos/get-users-with-access-to-protected-branch operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Lists the people who have push access to this branch.
	//
	// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
	ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, params ReposGetUsersWithAccessToProtectedBranchParams) (ReposGetUsersWithAccessToProtectedBranchRes, error)
	// ReposGetViews invokes repos/get-views operation.
	//
	// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are
	// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
	//
	// GET /repos/{owner}/{repo}/traffic/views
	ReposGetViews(ctx context.Context, params ReposGetViewsParams) (ReposGetViewsRes, error)
	// ReposGetWebhook invokes repos/get-webhook operation.
	//
	// Returns a webhook configured in a repository. To get only the webhook `config` properties, see
	// "[Get a webhook configuration for a
	// repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
	//
	// GET /repos/{owner}/{repo}/hooks/{hook_id}
	ReposGetWebhook(ctx context.Context, params ReposGetWebhookParams) (ReposGetWebhookRes, error)
	// ReposGetWebhookConfigForRepo invokes repos/get-webhook-config-for-repo operation.
	//
	// Returns the webhook configuration for a repository. To get more information about the webhook,
	// including the `active` state and `events`, use "[Get a repository
	// webhook](/rest/reference/orgs#get-a-repository-webhook)."
	// Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the
	// `repository_hooks:read` permission.
	//
	// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
	ReposGetWebhookConfigForRepo(ctx context.Context, params ReposGetWebhookConfigForRepoParams) (*WebhookConfig, error)
	// ReposGetWebhookDelivery invokes repos/get-webhook-delivery operation.
	//
	// Returns a delivery for a webhook configured in a repository.
	//
	// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
	ReposGetWebhookDelivery(ctx context.Context, params ReposGetWebhookDeliveryParams) (ReposGetWebhookDeliveryRes, error)
	// ReposListAutolinks invokes repos/list-autolinks operation.
	//
	// This returns a list of autolinks configured for the given repository.
	// Information about autolinks are only available to repository administrators.
	//
	// GET /repos/{owner}/{repo}/autolinks
	ReposListAutolinks(ctx context.Context, params ReposListAutolinksParams) ([]Autolink, error)
	// ReposListBranches invokes repos/list-branches operation.
	//
	// List branches.
	//
	// GET /repos/{owner}/{repo}/branches
	ReposListBranches(ctx context.Context, params ReposListBranchesParams) (ReposListBranchesRes, error)
	// ReposListBranchesForHeadCommit invokes repos/list-branches-for-head-commit operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
	//
	// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
	ReposListBranchesForHeadCommit(ctx context.Context, params ReposListBranchesForHeadCommitParams) (ReposListBranchesForHeadCommitRes, error)
	// ReposListCollaborators invokes repos/list-collaborators operation.
	//
	// For organization-owned repositories, the list of collaborators includes outside collaborators,
	// organization members that are direct collaborators, organization members with access through team
	// memberships, organization members with access through default organization permissions, and
	// organization owners.
	// Team members will include the members of child teams.
	//
	// GET /repos/{owner}/{repo}/collaborators
	ReposListCollaborators(ctx context.Context, params ReposListCollaboratorsParams) (ReposListCollaboratorsRes, error)
	// ReposListCommentsForCommit invokes repos/list-comments-for-commit operation.
	//
	// Use the `:commit_sha` to specify the commit that will have its comments listed.
	//
	// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
	ReposListCommentsForCommit(ctx context.Context, params ReposListCommentsForCommitParams) (*ReposListCommentsForCommitOKHeaders, error)
	// ReposListCommitCommentsForRepo invokes repos/list-commit-comments-for-repo operation.
	//
	// Commit Comments use [these custom media types](https://docs.github.
	// com/rest/reference/repos#custom-media-types). You can read more about the use of media types in
	// the API [here](https://docs.github.com/rest/overview/media-types/).
	// Comments are ordered by ascending ID.
	//
	// GET /repos/{owner}/{repo}/comments
	ReposListCommitCommentsForRepo(ctx context.Context, params ReposListCommitCommentsForRepoParams) (*ReposListCommitCommentsForRepoOKHeaders, error)
	// ReposListCommitStatusesForRef invokes repos/list-commit-statuses-for-ref operation.
	//
	// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a
	// SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first
	// status in the list will be the latest one.
	// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
	//
	// GET /repos/{owner}/{repo}/commits/{ref}/statuses
	ReposListCommitStatusesForRef(ctx context.Context, params ReposListCommitStatusesForRefParams) (ReposListCommitStatusesForRefRes, error)
	// ReposListCommits invokes repos/list-commits operation.
	//
	// **Signature verification object**
	// The response will include a `verification` object that describes the result of verifying the
	// commit's signature. The following fields are included in the `verification` object:
	// | Name | Type | Description |
	// | ---- | ---- | ----------- |
	// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
	// verified. |
	// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
	// enumerated in table below. |
	// | `signature` | `string` | The signature that was extracted from the commit. |
	// | `payload` | `string` | The value that was signed. |
	// These are the possible values for `reason` in the `verification` object:
	// | Value | Description |
	// | ----- | ----------- |
	// | `expired_key` | The key that made the signature is expired. |
	// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
	// signature. |
	// | `gpgverify_error` | There was an error communicating with the signature verification service. |
	// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
	// | `unsigned` | The object does not include a signature. |
	// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
	// | `no_user` | No user was associated with the `committer` email address in the commit. |
	// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
	// the email address is not verified on her/his account. |
	// | `bad_email` | The `committer` email address in the commit is not included in the identities of
	// the PGP key that made the signature. |
	// | `unknown_key` | The key that made the signature has not been registered with any user's account.
	// |
	// | `malformed_signature` | There was an error parsing the signature. |
	// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
	// found in the signature. |
	// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
	//
	// GET /repos/{owner}/{repo}/commits
	ReposListCommits(ctx context.Context, params ReposListCommitsParams) (ReposListCommitsRes, error)
	// ReposListContributors invokes repos/list-contributors operation.
	//
	// Lists contributors to the specified repository and sorts them by the number of commits per
	// contributor in descending order. This endpoint may return information that is a few hours old
	// because the GitHub REST API v3 caches contributor data to improve performance.
	// GitHub identifies contributors by author email address. This endpoint groups contribution counts
	// by GitHub user, which includes all associated email addresses. To improve performance, only the
	// first 500 author email addresses in the repository link to GitHub users. The rest will appear as
	// anonymous contributors without associated GitHub user information.
	//
	// GET /repos/{owner}/{repo}/contributors
	ReposListContributors(ctx context.Context, params ReposListContributorsParams) (ReposListContributorsRes, error)
	// ReposListDeployKeys invokes repos/list-deploy-keys operation.
	//
	// List deploy keys.
	//
	// GET /repos/{owner}/{repo}/keys
	ReposListDeployKeys(ctx context.Context, params ReposListDeployKeysParams) (*ReposListDeployKeysOKHeaders, error)
	// ReposListDeploymentStatuses invokes repos/list-deployment-statuses operation.
	//
	// Users with pull access can view deployment statuses for a deployment:.
	//
	// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
	ReposListDeploymentStatuses(ctx context.Context, params ReposListDeploymentStatusesParams) (ReposListDeploymentStatusesRes, error)
	// ReposListDeployments invokes repos/list-deployments operation.
	//
	// Simple filtering of deployments is available via query parameters:.
	//
	// GET /repos/{owner}/{repo}/deployments
	ReposListDeployments(ctx context.Context, params ReposListDeploymentsParams) (*ReposListDeploymentsOKHeaders, error)
	// ReposListForAuthenticatedUser invokes repos/list-for-authenticated-user operation.
	//
	// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
	// `:admin`) to access.
	// The authenticated user has explicit permission to access repositories they own, repositories where
	// they are a collaborator, and repositories that they can access through an organization membership.
	//
	// GET /user/repos
	ReposListForAuthenticatedUser(ctx context.Context, params ReposListForAuthenticatedUserParams) (ReposListForAuthenticatedUserRes, error)
	// ReposListForOrg invokes repos/list-for-org operation.
	//
	// Lists repositories for the specified organization.
	//
	// GET /orgs/{org}/repos
	ReposListForOrg(ctx context.Context, params ReposListForOrgParams) (*ReposListForOrgOKHeaders, error)
	// ReposListForUser invokes repos/list-for-user operation.
	//
	// Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list
	// internal repositories for the specified user.
	//
	// GET /users/{username}/repos
	ReposListForUser(ctx context.Context, params ReposListForUserParams) (*ReposListForUserOKHeaders, error)
	// ReposListForks invokes repos/list-forks operation.
	//
	// List forks.
	//
	// GET /repos/{owner}/{repo}/forks
	ReposListForks(ctx context.Context, params ReposListForksParams) (ReposListForksRes, error)
	// ReposListInvitations invokes repos/list-invitations operation.
	//
	// When authenticating as a user with admin rights to a repository, this endpoint will list all
	// currently open repository invitations.
	//
	// GET /repos/{owner}/{repo}/invitations
	ReposListInvitations(ctx context.Context, params ReposListInvitationsParams) (*ReposListInvitationsOKHeaders, error)
	// ReposListInvitationsForAuthenticatedUser invokes repos/list-invitations-for-authenticated-user operation.
	//
	// When authenticating as a user, this endpoint will list all currently open repository invitations
	// for that user.
	//
	// GET /user/repository_invitations
	ReposListInvitationsForAuthenticatedUser(ctx context.Context, params ReposListInvitationsForAuthenticatedUserParams) (ReposListInvitationsForAuthenticatedUserRes, error)
	// ReposListLanguages invokes repos/list-languages operation.
	//
	// Lists languages for the specified repository. The value shown for each language is the number of
	// bytes of code written in that language.
	//
	// GET /repos/{owner}/{repo}/languages
	ReposListLanguages(ctx context.Context, params ReposListLanguagesParams) (Language, error)
	// ReposListPagesBuilds invokes repos/list-pages-builds operation.
	//
	// List GitHub Pages builds.
	//
	// GET /repos/{owner}/{repo}/pages/builds
	ReposListPagesBuilds(ctx context.Context, params ReposListPagesBuildsParams) (*ReposListPagesBuildsOKHeaders, error)
	// ReposListPublic invokes repos/list-public operation.
	//
	// Lists all public repositories in the order that they were created.
	// Note:
	// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users
	// on the enterprise.
	// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.
	// github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page
	// of repositories.
	//
	// GET /repositories
	ReposListPublic(ctx context.Context, params ReposListPublicParams) (ReposListPublicRes, error)
	// ReposListPullRequestsAssociatedWithCommit invokes repos/list-pull-requests-associated-with-commit operation.
	//
	// Lists the merged pull request that introduced the commit to the repository. If the commit is not
	// present in the default branch, additionally returns open pull requests associated with the commit.
	// The results may include open and closed pull requests. Additional preview headers may be required
	// to see certain details for associated pull requests, such as whether a pull request is in a draft
	// state. For more information about previews that might affect this endpoint, see the [List pull
	// requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
	//
	// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
	ReposListPullRequestsAssociatedWithCommit(ctx context.Context, params ReposListPullRequestsAssociatedWithCommitParams) (*ReposListPullRequestsAssociatedWithCommitOKHeaders, error)
	// ReposListReleaseAssets invokes repos/list-release-assets operation.
	//
	// List release assets.
	//
	// GET /repos/{owner}/{repo}/releases/{release_id}/assets
	ReposListReleaseAssets(ctx context.Context, params ReposListReleaseAssetsParams) (*ReposListReleaseAssetsOKHeaders, error)
	// ReposListReleases invokes repos/list-releases operation.
	//
	// This returns a list of releases, which does not include regular Git tags that have not been
	// associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.
	// github.com/rest/reference/repos#list-repository-tags).
	// Information about published releases are available to everyone. Only users with push access will
	// receive listings for draft releases.
	//
	// GET /repos/{owner}/{repo}/releases
	ReposListReleases(ctx context.Context, params ReposListReleasesParams) (ReposListReleasesRes, error)
	// ReposListTags invokes repos/list-tags operation.
	//
	// List repository tags.
	//
	// GET /repos/{owner}/{repo}/tags
	ReposListTags(ctx context.Context, params ReposListTagsParams) (*ReposListTagsOKHeaders, error)
	// ReposListTeams invokes repos/list-teams operation.
	//
	// List repository teams.
	//
	// GET /repos/{owner}/{repo}/teams
	ReposListTeams(ctx context.Context, params ReposListTeamsParams) (*ReposListTeamsOKHeaders, error)
	// ReposListWebhookDeliveries invokes repos/list-webhook-deliveries operation.
	//
	// Returns a list of webhook deliveries for a webhook configured in a repository.
	//
	// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
	ReposListWebhookDeliveries(ctx context.Context, params ReposListWebhookDeliveriesParams) (ReposListWebhookDeliveriesRes, error)
	// ReposListWebhooks invokes repos/list-webhooks operation.
	//
	// List repository webhooks.
	//
	// GET /repos/{owner}/{repo}/hooks
	ReposListWebhooks(ctx context.Context, params ReposListWebhooksParams) (ReposListWebhooksRes, error)
	// ReposMerge invokes repos/merge operation.
	//
	// Merge a branch.
	//
	// POST /repos/{owner}/{repo}/merges
	ReposMerge(ctx context.Context, request *ReposMergeReq, params ReposMergeParams) (ReposMergeRes, error)
	// ReposMergeUpstream invokes repos/merge-upstream operation.
	//
	// **Note:** This endpoint is currently in beta and subject to change.
	// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
	//
	// POST /repos/{owner}/{repo}/merge-upstream
	ReposMergeUpstream(ctx context.Context, request *ReposMergeUpstreamReq, params ReposMergeUpstreamParams) (ReposMergeUpstreamRes, error)
	// ReposPingWebhook invokes repos/ping-webhook operation.
	//
	// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
	// hook.
	//
	// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
	ReposPingWebhook(ctx context.Context, params ReposPingWebhookParams) (ReposPingWebhookRes, error)
	// ReposRedeliverWebhookDelivery invokes repos/redeliver-webhook-delivery operation.
	//
	// Redeliver a webhook delivery for a webhook configured in a repository.
	//
	// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
	ReposRedeliverWebhookDelivery(ctx context.Context, params ReposRedeliverWebhookDeliveryParams) (ReposRedeliverWebhookDeliveryRes, error)
	// ReposRemoveAppAccessRestrictions invokes repos/remove-app-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write`
	// access to the `contents` permission can be added as authorized actors on a protected branch.
	// | Type    | Description
	//                                                                     |
	// | ------- |
	// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
	// The list of users, apps, and teams in total is limited to 100 items. |.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
	ReposRemoveAppAccessRestrictions(ctx context.Context, request OptReposRemoveAppAccessRestrictionsReq, params ReposRemoveAppAccessRestrictionsParams) (ReposRemoveAppAccessRestrictionsRes, error)
	// ReposRemoveCollaborator invokes repos/remove-collaborator operation.
	//
	// Remove a repository collaborator.
	//
	// DELETE /repos/{owner}/{repo}/collaborators/{username}
	ReposRemoveCollaborator(ctx context.Context, params ReposRemoveCollaboratorParams) error
	// ReposRemoveStatusCheckContexts invokes repos/remove-status-check-contexts operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
	ReposRemoveStatusCheckContexts(ctx context.Context, request OptReposRemoveStatusCheckContextsReq, params ReposRemoveStatusCheckContextsParams) (ReposRemoveStatusCheckContextsRes, error)
	// ReposRemoveStatusCheckProtection invokes repos/remove-status-check-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
	ReposRemoveStatusCheckProtection(ctx context.Context, params ReposRemoveStatusCheckProtectionParams) error
	// ReposRemoveTeamAccessRestrictions invokes repos/remove-team-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Removes the ability of a team to push to this branch. You can also remove push access for child
	// teams.
	// | Type    | Description
	//                                                              |
	// | ------- |
	// --------------------------------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The
	// list of users, apps, and teams in total is limited to 100 items. |.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
	ReposRemoveTeamAccessRestrictions(ctx context.Context, request OptReposRemoveTeamAccessRestrictionsReq, params ReposRemoveTeamAccessRestrictionsParams) (ReposRemoveTeamAccessRestrictionsRes, error)
	// ReposRemoveUserAccessRestrictions invokes repos/remove-user-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Removes the ability of a user to push to this branch.
	// | Type    | Description
	//                                                        |
	// | ------- |
	// --------------------------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of
	// users, apps, and teams in total is limited to 100 items. |.
	//
	// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
	ReposRemoveUserAccessRestrictions(ctx context.Context, request OptReposRemoveUserAccessRestrictionsReq, params ReposRemoveUserAccessRestrictionsParams) (ReposRemoveUserAccessRestrictionsRes, error)
	// ReposRenameBranch invokes repos/rename-branch operation.
	//
	// Renames a branch in a repository.
	// **Note:** Although the API responds immediately, the branch rename process might take some extra
	// time to complete in the background. You won't be able to push to the old branch name while the
	// rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.
	// com/github/administering-a-repository/renaming-a-branch)".
	// The permissions required to use this endpoint depends on whether you are renaming the default
	// branch.
	// To rename a non-default branch:
	// * Users must have push access.
	// * GitHub Apps must have the `contents:write` repository permission.
	// To rename the default branch:
	// * Users must have admin or owner permissions.
	// * GitHub Apps must have the `administration:write` repository permission.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/rename
	ReposRenameBranch(ctx context.Context, request OptReposRenameBranchReq, params ReposRenameBranchParams) (ReposRenameBranchRes, error)
	// ReposReplaceAllTopics invokes repos/replace-all-topics operation.
	//
	// Replace all repository topics.
	//
	// PUT /repos/{owner}/{repo}/topics
	ReposReplaceAllTopics(ctx context.Context, request *ReposReplaceAllTopicsReq, params ReposReplaceAllTopicsParams) (ReposReplaceAllTopicsRes, error)
	// ReposRequestPagesBuild invokes repos/request-pages-build operation.
	//
	// You can request that your site be built from the latest revision on the default branch. This has
	// the same effect as pushing a commit to your default branch, but does not require an additional
	// commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
	// Build requests are limited to one concurrent build per repository and one concurrent build per
	// requester. If you request a build while another is still in progress, the second request will be
	// queued until the first completes.
	//
	// POST /repos/{owner}/{repo}/pages/builds
	ReposRequestPagesBuild(ctx context.Context, params ReposRequestPagesBuildParams) (*PageBuildStatus, error)
	// ReposSetAdminBranchProtection invokes repos/set-admin-branch-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Adding admin enforcement requires admin or owner permissions to the repository and branch
	// protection to be enabled.
	//
	// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
	ReposSetAdminBranchProtection(ctx context.Context, params ReposSetAdminBranchProtectionParams) (*ProtectedBranchAdminEnforced, error)
	// ReposSetAppAccessRestrictions invokes repos/set-app-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Replaces the list of apps that have push access to this branch. This removes all apps that
	// previously had push access and grants push access to the new list of apps. Only installed GitHub
	// Apps with `write` access to the `contents` permission can be added as authorized actors on a
	// protected branch.
	// | Type    | Description
	//                                                                     |
	// | ------- |
	// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
	// The list of users, apps, and teams in total is limited to 100 items. |.
	//
	// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
	ReposSetAppAccessRestrictions(ctx context.Context, request OptReposSetAppAccessRestrictionsReq, params ReposSetAppAccessRestrictionsParams) (ReposSetAppAccessRestrictionsRes, error)
	// ReposSetStatusCheckContexts invokes repos/set-status-check-contexts operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	//
	// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
	ReposSetStatusCheckContexts(ctx context.Context, request OptReposSetStatusCheckContextsReq, params ReposSetStatusCheckContextsParams) (ReposSetStatusCheckContextsRes, error)
	// ReposSetTeamAccessRestrictions invokes repos/set-team-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Replaces the list of teams that have push access to this branch. This removes all teams that
	// previously had push access and grants push access to the new list of teams. Team restrictions
	// include child teams.
	// | Type    | Description
	//                                                     |
	// | ------- |
	// ------------------------------------------------------------------------------------------------------------------------------------------ |
	// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
	// users, apps, and teams in total is limited to 100 items. |.
	//
	// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
	ReposSetTeamAccessRestrictions(ctx context.Context, request OptReposSetTeamAccessRestrictionsReq, params ReposSetTeamAccessRestrictionsParams) (ReposSetTeamAccessRestrictionsRes, error)
	// ReposSetUserAccessRestrictions invokes repos/set-user-access-restrictions operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Replaces the list of people that have push access to this branch. This removes all people that
	// previously had push access and grants push access to the new list of people.
	// | Type    | Description
	//                                        |
	// | ------- |
	// ----------------------------------------------------------------------------------------------------------------------------- |
	// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
	// teams in total is limited to 100 items. |.
	//
	// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
	ReposSetUserAccessRestrictions(ctx context.Context, request OptReposSetUserAccessRestrictionsReq, params ReposSetUserAccessRestrictionsParams) (ReposSetUserAccessRestrictionsRes, error)
	// ReposTestPushWebhook invokes repos/test-push-webhook operation.
	//
	// This will trigger the hook with the latest push to the current repository if the hook is
	// subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
	// respond with 204 but no test POST will be generated.
	// **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`.
	//
	// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
	ReposTestPushWebhook(ctx context.Context, params ReposTestPushWebhookParams) (ReposTestPushWebhookRes, error)
	// ReposTransfer invokes repos/transfer operation.
	//
	// A transfer request will need to be accepted by the new owner when transferring a personal
	// repository to another user. The response will contain the original `owner`, and the transfer will
	// continue asynchronously. For more details on the requirements to transfer personal and
	// organization-owned repositories, see [about repository transfers](https://help.github.
	// com/articles/about-repository-transfers/).
	//
	// POST /repos/{owner}/{repo}/transfer
	ReposTransfer(ctx context.Context, request *ReposTransferReq, params ReposTransferParams) (*MinimalRepository, error)
	// ReposUpdate invokes repos/update operation.
	//
	// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.
	// github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
	//
	// PATCH /repos/{owner}/{repo}
	ReposUpdate(ctx context.Context, request OptReposUpdateReq, params ReposUpdateParams) (ReposUpdateRes, error)
	// ReposUpdateBranchProtection invokes repos/update-branch-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Protecting a branch requires admin or owner permissions to the repository.
	// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
	// **Note**: The list of users, apps, and teams in total is limited to 100 items.
	//
	// PUT /repos/{owner}/{repo}/branches/{branch}/protection
	ReposUpdateBranchProtection(ctx context.Context, request *ReposUpdateBranchProtectionReq, params ReposUpdateBranchProtectionParams) (ReposUpdateBranchProtectionRes, error)
	// ReposUpdateCommitComment invokes repos/update-commit-comment operation.
	//
	// Update a commit comment.
	//
	// PATCH /repos/{owner}/{repo}/comments/{comment_id}
	ReposUpdateCommitComment(ctx context.Context, request *ReposUpdateCommitCommentReq, params ReposUpdateCommitCommentParams) (ReposUpdateCommitCommentRes, error)
	// ReposUpdateInvitation invokes repos/update-invitation operation.
	//
	// Update a repository invitation.
	//
	// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
	ReposUpdateInvitation(ctx context.Context, request OptReposUpdateInvitationReq, params ReposUpdateInvitationParams) (*RepositoryInvitation, error)
	// ReposUpdatePullRequestReviewProtection invokes repos/update-pull-request-review-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Updating pull request review enforcement requires admin or owner permissions to the repository and
	// branch protection to be enabled.
	// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
	//
	// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
	ReposUpdatePullRequestReviewProtection(ctx context.Context, request OptReposUpdatePullRequestReviewProtectionReq, params ReposUpdatePullRequestReviewProtectionParams) (ReposUpdatePullRequestReviewProtectionRes, error)
	// ReposUpdateRelease invokes repos/update-release operation.
	//
	// Users with push access to the repository can edit a release.
	//
	// PATCH /repos/{owner}/{repo}/releases/{release_id}
	ReposUpdateRelease(ctx context.Context, request OptReposUpdateReleaseReq, params ReposUpdateReleaseParams) (ReposUpdateReleaseRes, error)
	// ReposUpdateReleaseAsset invokes repos/update-release-asset operation.
	//
	// Users with push access to the repository can edit a release asset.
	//
	// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
	ReposUpdateReleaseAsset(ctx context.Context, request OptReposUpdateReleaseAssetReq, params ReposUpdateReleaseAssetParams) (*ReleaseAsset, error)
	// ReposUpdateStatusCheckProtection invokes repos/update-status-check-protection operation.
	//
	// Protected branches are available in public repositories with GitHub Free and GitHub Free for
	// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
	// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
	// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
	// GitHub Help documentation.
	// Updating required status checks requires admin or owner permissions to the repository and branch
	// protection to be enabled.
	//
	// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
	ReposUpdateStatusCheckProtection(ctx context.Context, request OptReposUpdateStatusCheckProtectionReq, params ReposUpdateStatusCheckProtectionParams) (ReposUpdateStatusCheckProtectionRes, error)
	// ReposUpdateWebhook invokes repos/update-webhook operation.
	//
	// Updates a webhook configured in a repository. If you previously had a `secret` set, you must
	// provide the same `secret` or set a new `secret` or the secret will be removed. If you are only
	// updating individual webhook `config` properties, use "[Update a webhook configuration for a
	// repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
	//
	// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
	ReposUpdateWebhook(ctx context.Context, request OptReposUpdateWebhookReq, params ReposUpdateWebhookParams) (ReposUpdateWebhookRes, error)
	// ReposUpdateWebhookConfigForRepo invokes repos/update-webhook-config-for-repo operation.
	//
	// Updates the webhook configuration for a repository. To update more information about the webhook,
	// including the `active` state and `events`, use "[Update a repository
	// webhook](/rest/reference/orgs#update-a-repository-webhook)."
	// Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the
	// `repository_hooks:write` permission.
	//
	// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
	ReposUpdateWebhookConfigForRepo(ctx context.Context, request OptReposUpdateWebhookConfigForRepoReq, params ReposUpdateWebhookConfigForRepoParams) (*WebhookConfig, error)
	// ReposUploadReleaseAsset invokes repos/upload-release-asset operation.
	//
	// This endpoint makes use of [a Hypermedia relation](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The
	// endpoint you call to upload release assets is specific to your release. Use the `upload_url`
	// returned in
	// the response of the [Create a release endpoint](https://docs.github.
	// com/rest/reference/repos#create-a-release) to upload a release asset.
	// You need to use an HTTP client which supports [SNI](http://en.wikipedia.
	// org/wiki/Server_Name_Indication) to make calls to this endpoint.
	// Most libraries will set the required `Content-Length` header automatically. Use the required
	// `Content-Type` header to provide the media type of the asset. For a list of media types, see
	// [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
	// `application/zip`
	// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw
	// binary content of the asset as the request body. Everything else about the endpoint is the same as
	// the rest of the API. For example,
	// you'll still need to pass your authentication to be able to upload an asset.
	// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an
	// empty asset with a state of `starter`. It can be safely deleted.
	// **Notes:**
	// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and
	// leading or trailing periods. The "[List assets for a release](https://docs.github.
	// com/rest/reference/repos#list-assets-for-a-release)"
	// endpoint lists the renamed filenames. For more information and help, contact [GitHub
	// Support](https://support.github.com/contact?tags=dotcom-rest-api).
	// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an
	// error and must delete the old file before you can re-upload the new asset.
	//
	// POST /repos/{owner}/{repo}/releases/{release_id}/assets
	ReposUploadReleaseAsset(ctx context.Context, request *ReposUploadReleaseAssetReqWithContentType, params ReposUploadReleaseAssetParams) (*ReleaseAsset, error)
	// ScimDeleteUserFromOrg invokes scim/delete-user-from-org operation.
	//
	// Delete a SCIM user from an organization.
	//
	// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
	ScimDeleteUserFromOrg(ctx context.Context, params ScimDeleteUserFromOrgParams) (ScimDeleteUserFromOrgRes, error)
	// SearchCode invokes search/code operation.
	//
	// Searches for query terms inside of a file. This method returns up to 100 results [per
	// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
	// When searching for code, you can get text match metadata for the file **content** and file
	// **path** fields when you pass the `text-match` media type. For more details about how to receive
	// highlighted search results, see [Text match metadata](https://docs.github.
	// com/rest/reference/search#text-match-metadata).
	// For example, if you want to find the definition of the `addClass` function inside
	// [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
	// `q=addClass+in:file+language:js+repo:jquery/jquery`
	// This query searches for the keyword `addClass` within a file's contents. The query limits the
	// search to files where the language is JavaScript in the `jquery/jquery` repository.
	// #### Considerations for code search
	// Due to the complexity of searching code, there are a few restrictions on how searches are
	// performed:
	// *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
	// *   Only files smaller than 384 KB are searchable.
	// *   You must always include at least one search term when searching source code. For example,
	// searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code)
	// is not valid, while [`amazing
	// language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
	//
	// GET /search/code
	SearchCode(ctx context.Context, params SearchCodeParams) (SearchCodeRes, error)
	// SearchCommits invokes search/commits operation.
	//
	// Find commits via various criteria on the default branch (usually `master`). This method returns up
	// to 100 results [per page](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#pagination).
	// When searching for commits, you can get text match metadata for the **message** field when you
	// provide the `text-match` media type. For more details about how to receive highlighted search
	// results, see [Text match
	// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
	// For example, if you want to find commits related to CSS in the
	// [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look
	// something like this:
	// `q=repo:octocat/Spoon-Knife+css`.
	//
	// GET /search/commits
	SearchCommits(ctx context.Context, params SearchCommitsParams) (SearchCommitsRes, error)
	// SearchIssuesAndPullRequests invokes search/issues-and-pull-requests operation.
	//
	// Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.
	// github.com/rest/overview/resources-in-the-rest-api#pagination).
	// When searching for issues, you can get text match metadata for the issue **title**, issue **body**,
	//  and issue **comment body** fields when you pass the `text-match` media type. For more details
	// about how to receive highlighted
	// search results, see [Text match metadata](https://docs.github.
	// com/rest/reference/search#text-match-metadata).
	// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might
	// look something like this.
	// `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
	// This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The
	// search runs across repositories whose primary language is Python. The results are sorted by
	// creation date in ascending order, which means the oldest issues appear first in the search results.
	// **Note:** For [user-to-server](https://docs.github.
	// com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests)
	// GitHub App requests, you can't retrieve a combination of issues and pull requests in a single
	// query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an
	// HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you
	// must send separate queries for issues and pull requests. For more information about the `is`
	// qualifier, see "[Searching only issues or pull requests](https://docs.github.
	// com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests).".
	//
	// GET /search/issues
	SearchIssuesAndPullRequests(ctx context.Context, params SearchIssuesAndPullRequestsParams) (SearchIssuesAndPullRequestsRes, error)
	// SearchLabels invokes search/labels operation.
	//
	// Find labels in a repository with names or descriptions that match search keywords. Returns up to
	// 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
	// When searching for labels, you can get text match metadata for the label **name** and
	// **description** fields when you pass the `text-match` media type. For more details about how to
	// receive highlighted search results, see [Text match metadata](https://docs.github.
	// com/rest/reference/search#text-match-metadata).
	// For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`,
	// or `enhancement`. Your query might look like this:
	// `q=bug+defect+enhancement&repository_id=64778136`
	// The labels that best match the query appear first in the search results.
	//
	// GET /search/labels
	SearchLabels(ctx context.Context, params SearchLabelsParams) (SearchLabelsRes, error)
	// SearchRepos invokes search/repos operation.
	//
	// Find repositories via various criteria. This method returns up to 100 results [per
	// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
	// When searching for repositories, you can get text match metadata for the **name** and
	// **description** fields when you pass the `text-match` media type. For more details about how to
	// receive highlighted search results, see [Text match metadata](https://docs.github.
	// com/rest/reference/search#text-match-metadata).
	// For example, if you want to search for popular Tetris repositories written in assembly code, your
	// query might look like this:
	// `q=tetris+language:assembly&sort=stars&order=desc`
	// This query searches for repositories with the word `tetris` in the name, the description, or the
	// README. The results are limited to repositories where the primary language is assembly. The
	// results are sorted by stars in descending order, so that the most popular repositories appear
	// first in the search results.
	// When you include the `mercy` preview header, you can also search for multiple topics by adding
	// more `topic:` instances. For example, your query might look like this:
	// `q=topic:ruby+topic:rails`.
	//
	// GET /search/repositories
	SearchRepos(ctx context.Context, params SearchReposParams) (SearchReposRes, error)
	// SearchTopics invokes search/topics operation.
	//
	// Find topics via various criteria. Results are sorted by best match. This method returns up to 100
	// results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
	// See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list
	// of qualifiers.
	// When searching for topics, you can get text match metadata for the topic's **short\_description**,
	// **description**, **name**, or **display\_name** field when you pass the `text-match` media type.
	// For more details about how to receive highlighted search results, see [Text match
	// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
	// For example, if you want to search for topics related to Ruby that are featured on https://github.
	// com/topics. Your query might look like this:
	// `q=ruby+is:featured`
	// This query searches for topics with the keyword `ruby` and limits the results to find only topics
	// that are featured. The topics that are the best match for the query appear first in the search
	// results.
	//
	// GET /search/topics
	SearchTopics(ctx context.Context, params SearchTopicsParams) (SearchTopicsRes, error)
	// SearchUsers invokes search/users operation.
	//
	// Find users via various criteria. This method returns up to 100 results [per page](https://docs.
	// github.com/rest/overview/resources-in-the-rest-api#pagination).
	// When searching for users, you can get text match metadata for the issue **login**, **email**, and
	// **name** fields when you pass the `text-match` media type. For more details about highlighting
	// search results, see [Text match metadata](https://docs.github.
	// com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted
	// search results, see [Text match metadata](https://docs.github.
	// com/rest/reference/search#text-match-metadata).
	// For example, if you're looking for a list of popular users, you might try this query:
	// `q=tom+repos:%3E42+followers:%3E1000`
	// This query searches for users with the name `tom`. The results are restricted to users with more
	// than 42 repositories and over 1,000 followers.
	//
	// GET /search/users
	SearchUsers(ctx context.Context, params SearchUsersParams) (SearchUsersRes, error)
	// SecretScanningGetAlert invokes secret-scanning/get-alert operation.
	//
	// Gets a single secret scanning alert detected in a private repository. To use this endpoint, you
	// must be an administrator for the repository or organization, and you must use an access token with
	// the `repo` scope or `security_events` scope.
	// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
	SecretScanningGetAlert(ctx context.Context, params SecretScanningGetAlertParams) (SecretScanningGetAlertRes, error)
	// SecretScanningListAlertsForOrg invokes secret-scanning/list-alerts-for-org operation.
	//
	// Lists all secret scanning alerts for all eligible repositories in an organization, from newest to
	// oldest.
	// To use this endpoint, you must be an administrator for the repository or organization, and you
	// must use an access token with the `repo` scope or `security_events` scope.
	// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
	//
	// GET /orgs/{org}/secret-scanning/alerts
	SecretScanningListAlertsForOrg(ctx context.Context, params SecretScanningListAlertsForOrgParams) (SecretScanningListAlertsForOrgRes, error)
	// SecretScanningListAlertsForRepo invokes secret-scanning/list-alerts-for-repo operation.
	//
	// Lists all secret scanning alerts for a private repository, from newest to oldest. To use this
	// endpoint, you must be an administrator for the repository or organization, and you must use an
	// access token with the `repo` scope or `security_events` scope.
	// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
	//
	// GET /repos/{owner}/{repo}/secret-scanning/alerts
	SecretScanningListAlertsForRepo(ctx context.Context, params SecretScanningListAlertsForRepoParams) (SecretScanningListAlertsForRepoRes, error)
	// SecretScanningUpdateAlert invokes secret-scanning/update-alert operation.
	//
	// Updates the status of a secret scanning alert in a private repository. To use this endpoint, you
	// must be an administrator for the repository or organization, and you must use an access token with
	// the `repo` scope or `security_events` scope.
	// GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
	//
	// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
	SecretScanningUpdateAlert(ctx context.Context, request *SecretScanningUpdateAlertReq, params SecretScanningUpdateAlertParams) (SecretScanningUpdateAlertRes, error)
	// TeamsAddMemberLegacy invokes teams/add-member-legacy operation.
	//
	// The "Add team member" endpoint (described below) is deprecated.
	// We recommend using the [Add or update team membership for a user](https://docs.github.
	// com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you
	// to invite new organization members to your teams.
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// To add someone to a team, the authenticated user must be an organization owner or a team
	// maintainer in the team they're changing. The person being added to the team must be a member of
	// the team's organization.
	// **Note:** When you have team synchronization set up for a team with your organization's identity
	// provider (IdP), you will see an error if you attempt to use the API for making changes to the
	// team's membership. If you have access to manage group membership in your IdP, you can manage
	// GitHub team membership through your identity provider, which automatically adds and removes team
	// members in an organization. For more information, see "[Synchronizing teams between your identity
	// provider and GitHub](https://help.github.
	// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
	// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
	// information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs).".
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /teams/{team_id}/members/{username}
	TeamsAddMemberLegacy(ctx context.Context, params TeamsAddMemberLegacyParams) (TeamsAddMemberLegacyRes, error)
	// TeamsAddOrUpdateMembershipForUserInOrg invokes teams/add-or-update-membership-for-user-in-org operation.
	//
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// Adds an organization member to a team. An authenticated organization owner or team maintainer can
	// add organization members to a team.
	// **Note:** When you have team synchronization set up for a team with your organization's identity
	// provider (IdP), you will see an error if you attempt to use the API for making changes to the
	// team's membership. If you have access to manage group membership in your IdP, you can manage
	// GitHub team membership through your identity provider, which automatically adds and removes team
	// members in an organization. For more information, see "[Synchronizing teams between your identity
	// provider and GitHub](https://help.github.
	// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
	// An organization owner can add someone who is not part of the team's organization to a team. When
	// an organization owner adds someone to a team who is not an organization member, this endpoint will
	// send an invitation to the person via email. This newly-created membership will be in the "pending"
	// state until the person accepts the invitation, at which point the membership will transition to
	// the "active" state and the user will be added as a member of the team.
	// If the user is already a member of the team, this endpoint will update the role of the team
	// member's role. To update the membership of a team member, the authenticated user must be an
	// organization owner or a team maintainer.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
	// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
	//
	// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
	TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserInOrgReq, params TeamsAddOrUpdateMembershipForUserInOrgParams) (TeamsAddOrUpdateMembershipForUserInOrgRes, error)
	// TeamsAddOrUpdateMembershipForUserLegacy invokes teams/add-or-update-membership-for-user-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Add or update team membership for a
	// user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user)
	// endpoint.
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// If the user is already a member of the team's organization, this endpoint will add the user to the
	// team. To add a membership between an organization member and a team, the authenticated user must
	// be an organization owner or a team maintainer.
	// **Note:** When you have team synchronization set up for a team with your organization's identity
	// provider (IdP), you will see an error if you attempt to use the API for making changes to the
	// team's membership. If you have access to manage group membership in your IdP, you can manage
	// GitHub team membership through your identity provider, which automatically adds and removes team
	// members in an organization. For more information, see "[Synchronizing teams between your identity
	// provider and GitHub](https://help.github.
	// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
	// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to
	// the user via email. This newly-created membership will be in the "pending" state until the user
	// accepts the invitation, at which point the membership will transition to the "active" state and
	// the user will be added as a member of the team. To add a membership between an unaffiliated user
	// and a team, the authenticated user must be an organization owner.
	// If the user is already a member of the team, this endpoint will update the role of the team
	// member's role. To update the membership of a team member, the authenticated user must be an
	// organization owner or a team maintainer.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /teams/{team_id}/memberships/{username}
	TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserLegacyReq, params TeamsAddOrUpdateMembershipForUserLegacyParams) (TeamsAddOrUpdateMembershipForUserLegacyRes, error)
	// TeamsAddOrUpdateProjectPermissionsInOrg invokes teams/add-or-update-project-permissions-in-org operation.
	//
	// Adds an organization project to a team. To add a project to a team or update the team's permission
	// on a project, the authenticated user must have `admin` permissions for the project. The project
	// and team must be part of the same organization.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
	// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
	//
	// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
	TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, request OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq, params TeamsAddOrUpdateProjectPermissionsInOrgParams) (TeamsAddOrUpdateProjectPermissionsInOrgRes, error)
	// TeamsAddOrUpdateProjectPermissionsLegacy invokes teams/add-or-update-project-permissions-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Add or update team project
	// permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions)
	// endpoint.
	// Adds an organization project to a team. To add a project to a team or update the team's permission
	// on a project, the authenticated user must have `admin` permissions for the project. The project
	// and team must be part of the same organization.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /teams/{team_id}/projects/{project_id}
	TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateProjectPermissionsLegacyReq, params TeamsAddOrUpdateProjectPermissionsLegacyParams) (TeamsAddOrUpdateProjectPermissionsLegacyRes, error)
	// TeamsAddOrUpdateRepoPermissionsInOrg invokes teams/add-or-update-repo-permissions-in-org operation.
	//
	// To add a repository to a team or update the team's permission on a repository, the authenticated
	// user must have admin access to the repository, and must be able to see the team. The repository
	// must be owned by the organization, or a direct fork of a repository owned by the organization. You
	// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
	// not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to
	// set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP
	// verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
	// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
	// For more information about the permission levels, see "[Repository permission levels for an
	// organization](https://help.github.
	// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
	//
	// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
	TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsInOrgReq, params TeamsAddOrUpdateRepoPermissionsInOrgParams) error
	// TeamsAddOrUpdateRepoPermissionsLegacy invokes teams/add-or-update-repo-permissions-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new "[Add or update team repository
	// permissions](https://docs.github.
	// com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
	// To add a repository to a team or update the team's permission on a repository, the authenticated
	// user must have admin access to the repository, and must be able to see the team. The repository
	// must be owned by the organization, or a direct fork of a repository owned by the organization. You
	// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
	// not owned by the organization.
	// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
	// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs).".
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /teams/{team_id}/repos/{owner}/{repo}
	TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsLegacyReq, params TeamsAddOrUpdateRepoPermissionsLegacyParams) (TeamsAddOrUpdateRepoPermissionsLegacyRes, error)
	// TeamsCheckPermissionsForProjectInOrg invokes teams/check-permissions-for-project-in-org operation.
	//
	// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
	// response includes projects inherited from a parent team.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
	//
	// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
	TeamsCheckPermissionsForProjectInOrg(ctx context.Context, params TeamsCheckPermissionsForProjectInOrgParams) (TeamsCheckPermissionsForProjectInOrgRes, error)
	// TeamsCheckPermissionsForProjectLegacy invokes teams/check-permissions-for-project-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Check team permissions for a
	// project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project)
	// endpoint.
	// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
	// response includes projects inherited from a parent team.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/projects/{project_id}
	TeamsCheckPermissionsForProjectLegacy(ctx context.Context, params TeamsCheckPermissionsForProjectLegacyParams) (TeamsCheckPermissionsForProjectLegacyRes, error)
	// TeamsCheckPermissionsForRepoInOrg invokes teams/check-permissions-for-repo-in-org operation.
	//
	// Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a
	// repository. Repositories inherited through a parent team will also be checked.
	// You can also get information about the specified repository, including what permissions the team
	// grants on it, by passing the following custom [media type](https://docs.github.
	// com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
	// If a team doesn't have permission for the repository, you will receive a `404 Not Found` response
	// status.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
	//
	// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
	TeamsCheckPermissionsForRepoInOrg(ctx context.Context, params TeamsCheckPermissionsForRepoInOrgParams) (TeamsCheckPermissionsForRepoInOrgRes, error)
	// TeamsCheckPermissionsForRepoLegacy invokes teams/check-permissions-for-repo-legacy operation.
	//
	// **Note**: Repositories inherited through a parent team will also be checked.
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Check team permissions for a
	// repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository)
	// endpoint.
	// You can also get information about the specified repository, including what permissions the team
	// grants on it, by passing the following custom [media type](https://docs.github.
	// com/rest/overview/media-types/) via the `Accept` header:.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/repos/{owner}/{repo}
	TeamsCheckPermissionsForRepoLegacy(ctx context.Context, params TeamsCheckPermissionsForRepoLegacyParams) (TeamsCheckPermissionsForRepoLegacyRes, error)
	// TeamsCreate invokes teams/create operation.
	//
	// To create a team, the authenticated user must be a member or owner of `{org}`. By default,
	// organization members can create teams. Organization owners can limit team creation to organization
	// owners. For more information, see "[Setting team creation permissions](https://help.github.
	// com/en/articles/setting-team-creation-permissions-in-your-organization)."
	// When you create a new team, you automatically become a team maintainer without explicitly adding
	// yourself to the optional array of `maintainers`. For more information, see "[About
	// teams](https://help.github.
	// com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
	//
	// POST /orgs/{org}/teams
	TeamsCreate(ctx context.Context, request *TeamsCreateReq, params TeamsCreateParams) (TeamsCreateRes, error)
	// TeamsCreateDiscussionCommentInOrg invokes teams/create-discussion-comment-in-org operation.
	//
	// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
	//
	// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
	TeamsCreateDiscussionCommentInOrg(ctx context.Context, request *TeamsCreateDiscussionCommentInOrgReq, params TeamsCreateDiscussionCommentInOrgParams) (*TeamDiscussionComment, error)
	// TeamsCreateDiscussionCommentLegacy invokes teams/create-discussion-comment-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Create a discussion
	// comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
	// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /teams/{team_id}/discussions/{discussion_number}/comments
	TeamsCreateDiscussionCommentLegacy(ctx context.Context, request *TeamsCreateDiscussionCommentLegacyReq, params TeamsCreateDiscussionCommentLegacyParams) (*TeamDiscussionComment, error)
	// TeamsCreateDiscussionInOrg invokes teams/create-discussion-in-org operation.
	//
	// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
	// /organizations/{org_id}/team/{team_id}/discussions`.
	//
	// POST /orgs/{org}/teams/{team_slug}/discussions
	TeamsCreateDiscussionInOrg(ctx context.Context, request *TeamsCreateDiscussionInOrgReq, params TeamsCreateDiscussionInOrgParams) (*TeamDiscussion, error)
	// TeamsCreateDiscussionLegacy invokes teams/create-discussion-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.
	// github.com/rest/reference/teams#create-a-discussion) endpoint.
	// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// This endpoint triggers [notifications](https://docs.github.
	// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
	// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
	// rate limits](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
	// rate limits](https://docs.github.
	// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /teams/{team_id}/discussions
	TeamsCreateDiscussionLegacy(ctx context.Context, request *TeamsCreateDiscussionLegacyReq, params TeamsCreateDiscussionLegacyParams) (*TeamDiscussion, error)
	// TeamsCreateOrUpdateIdpGroupConnectionsInOrg invokes teams/create-or-update-idp-group-connections-in-org operation.
	//
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
	// team, you must include all new and existing groups to avoid replacing existing groups with the new
	// ones. Specifying an empty `groups` array will remove all connections for a team.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
	// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
	//
	// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
	TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, request *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq, params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) (*GroupMapping, error)
	// TeamsCreateOrUpdateIdpGroupConnectionsLegacy invokes teams/create-or-update-idp-group-connections-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`Create or update IdP group
	// connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections)
	// endpoint.
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
	// team, you must include all new and existing groups to avoid replacing existing groups with the new
	// ones. Specifying an empty `groups` array will remove all connections for a team.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PATCH /teams/{team_id}/team-sync/group-mappings
	TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, request *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq, params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams) (TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes, error)
	// TeamsDeleteDiscussionCommentInOrg invokes teams/delete-discussion-comment-in-org operation.
	//
	// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
	//
	// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
	TeamsDeleteDiscussionCommentInOrg(ctx context.Context, params TeamsDeleteDiscussionCommentInOrgParams) error
	// TeamsDeleteDiscussionCommentLegacy invokes teams/delete-discussion-comment-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Delete a discussion
	// comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
	// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
	TeamsDeleteDiscussionCommentLegacy(ctx context.Context, params TeamsDeleteDiscussionCommentLegacyParams) error
	// TeamsDeleteDiscussionInOrg invokes teams/delete-discussion-in-org operation.
	//
	// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
	//
	// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
	TeamsDeleteDiscussionInOrg(ctx context.Context, params TeamsDeleteDiscussionInOrgParams) error
	// TeamsDeleteDiscussionLegacy invokes teams/delete-discussion-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.
	// github.com/rest/reference/teams#delete-a-discussion) endpoint.
	// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}/discussions/{discussion_number}
	TeamsDeleteDiscussionLegacy(ctx context.Context, params TeamsDeleteDiscussionLegacyParams) error
	// TeamsDeleteInOrg invokes teams/delete-in-org operation.
	//
	// To delete a team, the authenticated user must be an organization owner or team maintainer.
	// If you are an organization owner, deleting a parent team will delete all of its child teams as
	// well.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
	// /organizations/{org_id}/team/{team_id}`.
	//
	// DELETE /orgs/{org}/teams/{team_slug}
	TeamsDeleteInOrg(ctx context.Context, params TeamsDeleteInOrgParams) error
	// TeamsDeleteLegacy invokes teams/delete-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Delete a team](https://docs.github.
	// com/rest/reference/teams#delete-a-team) endpoint.
	// To delete a team, the authenticated user must be an organization owner or team maintainer.
	// If you are an organization owner, deleting a parent team will delete all of its child teams as
	// well.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}
	TeamsDeleteLegacy(ctx context.Context, params TeamsDeleteLegacyParams) (TeamsDeleteLegacyRes, error)
	// TeamsGetByName invokes teams/get-by-name operation.
	//
	// Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}`.
	//
	// GET /orgs/{org}/teams/{team_slug}
	TeamsGetByName(ctx context.Context, params TeamsGetByNameParams) (TeamsGetByNameRes, error)
	// TeamsGetDiscussionCommentInOrg invokes teams/get-discussion-comment-in-org operation.
	//
	// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
	//
	// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
	TeamsGetDiscussionCommentInOrg(ctx context.Context, params TeamsGetDiscussionCommentInOrgParams) (*TeamDiscussionComment, error)
	// TeamsGetDiscussionCommentLegacy invokes teams/get-discussion-comment-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.
	// github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
	// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
	TeamsGetDiscussionCommentLegacy(ctx context.Context, params TeamsGetDiscussionCommentLegacyParams) (*TeamDiscussionComment, error)
	// TeamsGetDiscussionInOrg invokes teams/get-discussion-in-org operation.
	//
	// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
	//
	// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
	TeamsGetDiscussionInOrg(ctx context.Context, params TeamsGetDiscussionInOrgParams) (*TeamDiscussion, error)
	// TeamsGetDiscussionLegacy invokes teams/get-discussion-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.
	// com/rest/reference/teams#get-a-discussion) endpoint.
	// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/discussions/{discussion_number}
	TeamsGetDiscussionLegacy(ctx context.Context, params TeamsGetDiscussionLegacyParams) (*TeamDiscussion, error)
	// TeamsGetLegacy invokes teams/get-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the [Get a team by name](https://docs.github.
	// com/rest/reference/teams#get-a-team-by-name) endpoint.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}
	TeamsGetLegacy(ctx context.Context, params TeamsGetLegacyParams) (TeamsGetLegacyRes, error)
	// TeamsGetMemberLegacy invokes teams/get-member-legacy operation.
	//
	// The "Get team member" endpoint (described below) is deprecated.
	// We recommend using the [Get team membership for a user](https://docs.github.
	// com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get
	// both active and pending memberships.
	// To list members in a team, the team must be visible to the authenticated user.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/members/{username}
	TeamsGetMemberLegacy(ctx context.Context, params TeamsGetMemberLegacyParams) (TeamsGetMemberLegacyRes, error)
	// TeamsGetMembershipForUserInOrg invokes teams/get-membership-for-user-in-org operation.
	//
	// Team members will include the members of child teams.
	// To get a user's membership with a team, the team must be visible to the authenticated user.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
	// **Note:**
	// The response contains the `state` of the membership and the member's `role`.
	// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
	// roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
	//
	// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
	TeamsGetMembershipForUserInOrg(ctx context.Context, params TeamsGetMembershipForUserInOrgParams) (TeamsGetMembershipForUserInOrgRes, error)
	// TeamsGetMembershipForUserLegacy invokes teams/get-membership-for-user-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Get team membership for a
	// user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
	// Team members will include the members of child teams.
	// To get a user's membership with a team, the team must be visible to the authenticated user.
	// **Note:**
	// The response contains the `state` of the membership and the member's `role`.
	// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
	// roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/memberships/{username}
	TeamsGetMembershipForUserLegacy(ctx context.Context, params TeamsGetMembershipForUserLegacyParams) (TeamsGetMembershipForUserLegacyRes, error)
	// TeamsList invokes teams/list operation.
	//
	// Lists all teams in an organization that are visible to the authenticated user.
	//
	// GET /orgs/{org}/teams
	TeamsList(ctx context.Context, params TeamsListParams) (TeamsListRes, error)
	// TeamsListChildInOrg invokes teams/list-child-in-org operation.
	//
	// Lists the child teams of the team specified by `{team_slug}`.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/teams`.
	//
	// GET /orgs/{org}/teams/{team_slug}/teams
	TeamsListChildInOrg(ctx context.Context, params TeamsListChildInOrgParams) (*TeamsListChildInOrgOKHeaders, error)
	// TeamsListChildLegacy invokes teams/list-child-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.
	// com/rest/reference/teams#list-child-teams) endpoint.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/teams
	TeamsListChildLegacy(ctx context.Context, params TeamsListChildLegacyParams) (TeamsListChildLegacyRes, error)
	// TeamsListDiscussionCommentsInOrg invokes teams/list-discussion-comments-in-org operation.
	//
	// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
	//
	// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
	TeamsListDiscussionCommentsInOrg(ctx context.Context, params TeamsListDiscussionCommentsInOrgParams) (*TeamsListDiscussionCommentsInOrgOKHeaders, error)
	// TeamsListDiscussionCommentsLegacy invokes teams/list-discussion-comments-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [List discussion comments](https://docs.
	// github.com/rest/reference/teams#list-discussion-comments) endpoint.
	// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/discussions/{discussion_number}/comments
	TeamsListDiscussionCommentsLegacy(ctx context.Context, params TeamsListDiscussionCommentsLegacyParams) (*TeamsListDiscussionCommentsLegacyOKHeaders, error)
	// TeamsListDiscussionsInOrg invokes teams/list-discussions-in-org operation.
	//
	// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/discussions`.
	//
	// GET /orgs/{org}/teams/{team_slug}/discussions
	TeamsListDiscussionsInOrg(ctx context.Context, params TeamsListDiscussionsInOrgParams) (*TeamsListDiscussionsInOrgOKHeaders, error)
	// TeamsListDiscussionsLegacy invokes teams/list-discussions-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.
	// com/rest/reference/teams#list-discussions) endpoint.
	// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/discussions
	TeamsListDiscussionsLegacy(ctx context.Context, params TeamsListDiscussionsLegacyParams) (*TeamsListDiscussionsLegacyOKHeaders, error)
	// TeamsListForAuthenticatedUser invokes teams/list-for-authenticated-user operation.
	//
	// List all of the teams across all of the organizations to which the authenticated user belongs.
	// This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via
	// [OAuth](https://docs.github.com/apps/building-oauth-apps/).
	//
	// GET /user/teams
	TeamsListForAuthenticatedUser(ctx context.Context, params TeamsListForAuthenticatedUserParams) (TeamsListForAuthenticatedUserRes, error)
	// TeamsListIdpGroupsForLegacy invokes teams/list-idp-groups-for-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List IdP groups for a
	// team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// List IdP groups connected to a team on GitHub.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/team-sync/group-mappings
	TeamsListIdpGroupsForLegacy(ctx context.Context, params TeamsListIdpGroupsForLegacyParams) (TeamsListIdpGroupsForLegacyRes, error)
	// TeamsListIdpGroupsForOrg invokes teams/list-idp-groups-for-org operation.
	//
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// List IdP groups available in an organization. You can limit your page results using the `per_page`
	// parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next
	// page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination
	// explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89).".
	//
	// GET /orgs/{org}/team-sync/groups
	TeamsListIdpGroupsForOrg(ctx context.Context, params TeamsListIdpGroupsForOrgParams) (*GroupMappingHeaders, error)
	// TeamsListIdpGroupsInOrg invokes teams/list-idp-groups-in-org operation.
	//
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// List IdP groups connected to a team on GitHub.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
	//
	// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
	TeamsListIdpGroupsInOrg(ctx context.Context, params TeamsListIdpGroupsInOrgParams) (*GroupMapping, error)
	// TeamsListMembersInOrg invokes teams/list-members-in-org operation.
	//
	// Team members will include the members of child teams.
	// To list members in a team, the team must be visible to the authenticated user.
	//
	// GET /orgs/{org}/teams/{team_slug}/members
	TeamsListMembersInOrg(ctx context.Context, params TeamsListMembersInOrgParams) (*TeamsListMembersInOrgOKHeaders, error)
	// TeamsListMembersLegacy invokes teams/list-members-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List team members`](https://docs.github.
	// com/rest/reference/teams#list-team-members) endpoint.
	// Team members will include the members of child teams.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/members
	TeamsListMembersLegacy(ctx context.Context, params TeamsListMembersLegacyParams) (TeamsListMembersLegacyRes, error)
	// TeamsListPendingInvitationsInOrg invokes teams/list-pending-invitations-in-org operation.
	//
	// The return hash contains a `role` field which refers to the Organization Invitation role and will
	// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
	// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
	// `null`.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/invitations`.
	//
	// GET /orgs/{org}/teams/{team_slug}/invitations
	TeamsListPendingInvitationsInOrg(ctx context.Context, params TeamsListPendingInvitationsInOrgParams) (*TeamsListPendingInvitationsInOrgOKHeaders, error)
	// TeamsListPendingInvitationsLegacy invokes teams/list-pending-invitations-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List pending team
	// invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
	// The return hash contains a `role` field which refers to the Organization Invitation role and will
	// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
	// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
	// `null`.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/invitations
	TeamsListPendingInvitationsLegacy(ctx context.Context, params TeamsListPendingInvitationsLegacyParams) (*TeamsListPendingInvitationsLegacyOKHeaders, error)
	// TeamsListProjectsInOrg invokes teams/list-projects-in-org operation.
	//
	// Lists the organization projects for a team.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/projects`.
	//
	// GET /orgs/{org}/teams/{team_slug}/projects
	TeamsListProjectsInOrg(ctx context.Context, params TeamsListProjectsInOrgParams) (*TeamsListProjectsInOrgOKHeaders, error)
	// TeamsListProjectsLegacy invokes teams/list-projects-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [`List team projects`](https://docs.
	// github.com/rest/reference/teams#list-team-projects) endpoint.
	// Lists the organization projects for a team.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/projects
	TeamsListProjectsLegacy(ctx context.Context, params TeamsListProjectsLegacyParams) (TeamsListProjectsLegacyRes, error)
	// TeamsListReposInOrg invokes teams/list-repos-in-org operation.
	//
	// Lists a team's repositories visible to the authenticated user.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
	// /organizations/{org_id}/team/{team_id}/repos`.
	//
	// GET /orgs/{org}/teams/{team_slug}/repos
	TeamsListReposInOrg(ctx context.Context, params TeamsListReposInOrgParams) (*TeamsListReposInOrgOKHeaders, error)
	// TeamsListReposLegacy invokes teams/list-repos-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [List team repositories](https://docs.
	// github.com/rest/reference/teams#list-team-repositories) endpoint.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /teams/{team_id}/repos
	TeamsListReposLegacy(ctx context.Context, params TeamsListReposLegacyParams) (TeamsListReposLegacyRes, error)
	// TeamsRemoveMemberLegacy invokes teams/remove-member-legacy operation.
	//
	// The "Remove team member" endpoint (described below) is deprecated.
	// We recommend using the [Remove team membership for a user](https://docs.github.
	// com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to
	// remove both active and pending memberships.
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an
	// owner of the org that the team is associated with. Removing a team member does not delete the user,
	//  it just removes them from the team.
	// **Note:** When you have team synchronization set up for a team with your organization's identity
	// provider (IdP), you will see an error if you attempt to use the API for making changes to the
	// team's membership. If you have access to manage group membership in your IdP, you can manage
	// GitHub team membership through your identity provider, which automatically adds and removes team
	// members in an organization. For more information, see "[Synchronizing teams between your identity
	// provider and GitHub](https://help.github.
	// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}/members/{username}
	TeamsRemoveMemberLegacy(ctx context.Context, params TeamsRemoveMemberLegacyParams) (TeamsRemoveMemberLegacyRes, error)
	// TeamsRemoveMembershipForUserInOrg invokes teams/remove-membership-for-user-in-org operation.
	//
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// To remove a membership between a user and a team, the authenticated user must have 'admin'
	// permissions to the team or be an owner of the organization that the team is associated with.
	// Removing team membership does not delete the user, it just removes their membership from the team.
	// **Note:** When you have team synchronization set up for a team with your organization's identity
	// provider (IdP), you will see an error if you attempt to use the API for making changes to the
	// team's membership. If you have access to manage group membership in your IdP, you can manage
	// GitHub team membership through your identity provider, which automatically adds and removes team
	// members in an organization. For more information, see "[Synchronizing teams between your identity
	// provider and GitHub](https://help.github.
	// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
	// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
	//
	// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
	TeamsRemoveMembershipForUserInOrg(ctx context.Context, params TeamsRemoveMembershipForUserInOrgParams) (TeamsRemoveMembershipForUserInOrgRes, error)
	// TeamsRemoveMembershipForUserLegacy invokes teams/remove-membership-for-user-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Remove team membership for a
	// user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
	// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
	// information, see [GitHub's products](https://help.github.
	// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
	// To remove a membership between a user and a team, the authenticated user must have 'admin'
	// permissions to the team or be an owner of the organization that the team is associated with.
	// Removing team membership does not delete the user, it just removes their membership from the team.
	// **Note:** When you have team synchronization set up for a team with your organization's identity
	// provider (IdP), you will see an error if you attempt to use the API for making changes to the
	// team's membership. If you have access to manage group membership in your IdP, you can manage
	// GitHub team membership through your identity provider, which automatically adds and removes team
	// members in an organization. For more information, see "[Synchronizing teams between your identity
	// provider and GitHub](https://help.github.
	// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}/memberships/{username}
	TeamsRemoveMembershipForUserLegacy(ctx context.Context, params TeamsRemoveMembershipForUserLegacyParams) (TeamsRemoveMembershipForUserLegacyRes, error)
	// TeamsRemoveProjectInOrg invokes teams/remove-project-in-org operation.
	//
	// Removes an organization project from a team. An organization owner or a team maintainer can remove
	// any project from the team. To remove a project from a team as an organization member, the
	// authenticated user must have `read` access to both the team and project, or `admin` access to the
	// team or project. This endpoint removes the project from the team, but does not delete the project.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
	// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
	//
	// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
	TeamsRemoveProjectInOrg(ctx context.Context, params TeamsRemoveProjectInOrgParams) error
	// TeamsRemoveProjectLegacy invokes teams/remove-project-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Remove a project from a
	// team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
	// Removes an organization project from a team. An organization owner or a team maintainer can remove
	// any project from the team. To remove a project from a team as an organization member, the
	// authenticated user must have `read` access to both the team and project, or `admin` access to the
	// team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}/projects/{project_id}
	TeamsRemoveProjectLegacy(ctx context.Context, params TeamsRemoveProjectLegacyParams) (TeamsRemoveProjectLegacyRes, error)
	// TeamsRemoveRepoInOrg invokes teams/remove-repo-in-org operation.
	//
	// If the authenticated user is an organization owner or a team maintainer, they can remove any
	// repositories from the team. To remove a repository from a team as an organization member, the
	// authenticated user must have admin access to the repository and must be able to see the team. This
	// does not delete the repository, it just removes it from the team.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
	// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
	//
	// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
	TeamsRemoveRepoInOrg(ctx context.Context, params TeamsRemoveRepoInOrgParams) error
	// TeamsRemoveRepoLegacy invokes teams/remove-repo-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Remove a repository from a
	// team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
	// If the authenticated user is an organization owner or a team maintainer, they can remove any
	// repositories from the team. To remove a repository from a team as an organization member, the
	// authenticated user must have admin access to the repository and must be able to see the team.
	// NOTE: This does not delete the repository, it just removes it from the team.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /teams/{team_id}/repos/{owner}/{repo}
	TeamsRemoveRepoLegacy(ctx context.Context, params TeamsRemoveRepoLegacyParams) error
	// TeamsUpdateDiscussionCommentInOrg invokes teams/update-discussion-comment-in-org operation.
	//
	// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
	//
	// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
	TeamsUpdateDiscussionCommentInOrg(ctx context.Context, request *TeamsUpdateDiscussionCommentInOrgReq, params TeamsUpdateDiscussionCommentInOrgParams) (*TeamDiscussionComment, error)
	// TeamsUpdateDiscussionCommentLegacy invokes teams/update-discussion-comment-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Update a discussion
	// comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
	// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
	// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
	TeamsUpdateDiscussionCommentLegacy(ctx context.Context, request *TeamsUpdateDiscussionCommentLegacyReq, params TeamsUpdateDiscussionCommentLegacyParams) (*TeamDiscussionComment, error)
	// TeamsUpdateDiscussionInOrg invokes teams/update-discussion-in-org operation.
	//
	// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
	// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
	// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
	//
	// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
	TeamsUpdateDiscussionInOrg(ctx context.Context, request OptTeamsUpdateDiscussionInOrgReq, params TeamsUpdateDiscussionInOrgParams) (*TeamDiscussion, error)
	// TeamsUpdateDiscussionLegacy invokes teams/update-discussion-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.
	// com/rest/reference/teams#update-a-discussion) endpoint.
	// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
	// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PATCH /teams/{team_id}/discussions/{discussion_number}
	TeamsUpdateDiscussionLegacy(ctx context.Context, request OptTeamsUpdateDiscussionLegacyReq, params TeamsUpdateDiscussionLegacyParams) (*TeamDiscussion, error)
	// TeamsUpdateInOrg invokes teams/update-in-org operation.
	//
	// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
	// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
	// /organizations/{org_id}/team/{team_id}`.
	//
	// PATCH /orgs/{org}/teams/{team_slug}
	TeamsUpdateInOrg(ctx context.Context, request OptTeamsUpdateInOrgReq, params TeamsUpdateInOrgParams) (*TeamFull, error)
	// TeamsUpdateLegacy invokes teams/update-legacy operation.
	//
	// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
	// We recommend migrating your existing code to use the new [Update a team](https://docs.github.
	// com/rest/reference/teams#update-a-team) endpoint.
	// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
	// **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PATCH /teams/{team_id}
	TeamsUpdateLegacy(ctx context.Context, request *TeamsUpdateLegacyReq, params TeamsUpdateLegacyParams) (TeamsUpdateLegacyRes, error)
	// UsersAddEmailForAuthenticated invokes users/add-email-for-authenticated operation.
	//
	// This endpoint is accessible with the `user` scope.
	//
	// POST /user/emails
	UsersAddEmailForAuthenticated(ctx context.Context, request OptUsersAddEmailForAuthenticatedReq) (UsersAddEmailForAuthenticatedRes, error)
	// UsersBlock invokes users/block operation.
	//
	// Block a user.
	//
	// PUT /user/blocks/{username}
	UsersBlock(ctx context.Context, params UsersBlockParams) (UsersBlockRes, error)
	// UsersCheckBlocked invokes users/check-blocked operation.
	//
	// Check if a user is blocked by the authenticated user.
	//
	// GET /user/blocks/{username}
	UsersCheckBlocked(ctx context.Context, params UsersCheckBlockedParams) (UsersCheckBlockedRes, error)
	// UsersCheckFollowingForUser invokes users/check-following-for-user operation.
	//
	// Check if a user follows another user.
	//
	// GET /users/{username}/following/{target_user}
	UsersCheckFollowingForUser(ctx context.Context, params UsersCheckFollowingForUserParams) (UsersCheckFollowingForUserRes, error)
	// UsersCheckPersonIsFollowedByAuthenticated invokes users/check-person-is-followed-by-authenticated operation.
	//
	// Check if a person is followed by the authenticated user.
	//
	// GET /user/following/{username}
	UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, params UsersCheckPersonIsFollowedByAuthenticatedParams) (UsersCheckPersonIsFollowedByAuthenticatedRes, error)
	// UsersCreateGpgKeyForAuthenticated invokes users/create-gpg-key-for-authenticated operation.
	//
	// Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via
	// Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// POST /user/gpg_keys
	UsersCreateGpgKeyForAuthenticated(ctx context.Context, request *UsersCreateGpgKeyForAuthenticatedReq) (UsersCreateGpgKeyForAuthenticatedRes, error)
	// UsersCreatePublicSSHKeyForAuthenticated invokes users/create-public-ssh-key-for-authenticated operation.
	//
	// Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
	// authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.
	// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// POST /user/keys
	UsersCreatePublicSSHKeyForAuthenticated(ctx context.Context, request *UsersCreatePublicSSHKeyForAuthenticatedReq) (UsersCreatePublicSSHKeyForAuthenticatedRes, error)
	// UsersDeleteEmailForAuthenticated invokes users/delete-email-for-authenticated operation.
	//
	// This endpoint is accessible with the `user` scope.
	//
	// DELETE /user/emails
	UsersDeleteEmailForAuthenticated(ctx context.Context, request OptUsersDeleteEmailForAuthenticatedReq) (UsersDeleteEmailForAuthenticatedRes, error)
	// UsersDeleteGpgKeyForAuthenticated invokes users/delete-gpg-key-for-authenticated operation.
	//
	// Removes a GPG key from the authenticated user's GitHub account. Requires that you are
	// authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.
	// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// DELETE /user/gpg_keys/{gpg_key_id}
	UsersDeleteGpgKeyForAuthenticated(ctx context.Context, params UsersDeleteGpgKeyForAuthenticatedParams) (UsersDeleteGpgKeyForAuthenticatedRes, error)
	// UsersDeletePublicSSHKeyForAuthenticated invokes users/delete-public-ssh-key-for-authenticated operation.
	//
	// Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
	// authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.
	// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// DELETE /user/keys/{key_id}
	UsersDeletePublicSSHKeyForAuthenticated(ctx context.Context, params UsersDeletePublicSSHKeyForAuthenticatedParams) (UsersDeletePublicSSHKeyForAuthenticatedRes, error)
	// UsersFollow invokes users/follow operation.
	//
	// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
	// information, see "[HTTP verbs](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#http-verbs)."
	// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with
	// the `user:follow` scope.
	//
	// PUT /user/following/{username}
	UsersFollow(ctx context.Context, params UsersFollowParams) (UsersFollowRes, error)
	// UsersGetAuthenticated invokes users/get-authenticated operation.
	//
	// If the authenticated user is authenticated through basic authentication or OAuth with the `user`
	// scope, then the response lists public and private profile information.
	// If the authenticated user is authenticated through OAuth without the `user` scope, then the
	// response lists only public profile information.
	//
	// GET /user
	UsersGetAuthenticated(ctx context.Context) (UsersGetAuthenticatedRes, error)
	// UsersGetByUsername invokes users/get-by-username operation.
	//
	// Provides publicly available information about someone with a GitHub account.
	// GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a
	// user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
	// authorizing users for GitHub Apps](https://docs.github.
	// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details
	// about authentication. For an example response, see 'Response with GitHub plan information' below"
	// The `email` key in the following response is the publicly visible email address from your GitHub
	// [profile page](https://github.com/settings/profile). When setting up your profile, you can select
	// a primary email address to be “public” which provides an email entry for this endpoint. If you
	// do not set a public email address for `email`, then it will have a value of `null`. You only see
	// publicly visible email addresses when authenticated with GitHub. For more information, see
	// [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
	// The Emails API enables you to list all of your email addresses, and toggle a primary email to be
	// visible publicly. For more information, see "[Emails API](https://docs.github.
	// com/rest/reference/users#emails)".
	//
	// GET /users/{username}
	UsersGetByUsername(ctx context.Context, params UsersGetByUsernameParams) (UsersGetByUsernameRes, error)
	// UsersGetContextForUser invokes users/get-context-for-user operation.
	//
	// Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
	// scope. You can find out more about someone in relation to their pull requests, issues,
	// repositories, and organizations.
	// The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which
	// returns more information than without the parameters. For example, if you wanted to find out more
	// about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
	// ```shell
	// curl -u username:token
	// https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
	// ```.
	//
	// GET /users/{username}/hovercard
	UsersGetContextForUser(ctx context.Context, params UsersGetContextForUserParams) (UsersGetContextForUserRes, error)
	// UsersGetGpgKeyForAuthenticated invokes users/get-gpg-key-for-authenticated operation.
	//
	// View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or
	// via OAuth with at least `read:gpg_key` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// GET /user/gpg_keys/{gpg_key_id}
	UsersGetGpgKeyForAuthenticated(ctx context.Context, params UsersGetGpgKeyForAuthenticatedParams) (UsersGetGpgKeyForAuthenticatedRes, error)
	// UsersGetPublicSSHKeyForAuthenticated invokes users/get-public-ssh-key-for-authenticated operation.
	//
	// View extended details for a single public SSH key. Requires that you are authenticated via Basic
	// Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// GET /user/keys/{key_id}
	UsersGetPublicSSHKeyForAuthenticated(ctx context.Context, params UsersGetPublicSSHKeyForAuthenticatedParams) (UsersGetPublicSSHKeyForAuthenticatedRes, error)
	// UsersList invokes users/list operation.
	//
	// Lists all users, in the order that they signed up on GitHub. This list includes personal user
	// accounts and organization accounts.
	// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link
	// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
	// URL for the next page of users.
	//
	// GET /users
	UsersList(ctx context.Context, params UsersListParams) (UsersListRes, error)
	// UsersListBlockedByAuthenticated invokes users/list-blocked-by-authenticated operation.
	//
	// List the users you've blocked on your personal account.
	//
	// GET /user/blocks
	UsersListBlockedByAuthenticated(ctx context.Context) (UsersListBlockedByAuthenticatedRes, error)
	// UsersListEmailsForAuthenticated invokes users/list-emails-for-authenticated operation.
	//
	// Lists all of your email addresses, and specifies which one is visible to the public. This endpoint
	// is accessible with the `user:email` scope.
	//
	// GET /user/emails
	UsersListEmailsForAuthenticated(ctx context.Context, params UsersListEmailsForAuthenticatedParams) (UsersListEmailsForAuthenticatedRes, error)
	// UsersListFollowedByAuthenticated invokes users/list-followed-by-authenticated operation.
	//
	// Lists the people who the authenticated user follows.
	//
	// GET /user/following
	UsersListFollowedByAuthenticated(ctx context.Context, params UsersListFollowedByAuthenticatedParams) (UsersListFollowedByAuthenticatedRes, error)
	// UsersListFollowersForAuthenticatedUser invokes users/list-followers-for-authenticated-user operation.
	//
	// Lists the people following the authenticated user.
	//
	// GET /user/followers
	UsersListFollowersForAuthenticatedUser(ctx context.Context, params UsersListFollowersForAuthenticatedUserParams) (UsersListFollowersForAuthenticatedUserRes, error)
	// UsersListFollowersForUser invokes users/list-followers-for-user operation.
	//
	// Lists the people following the specified user.
	//
	// GET /users/{username}/followers
	UsersListFollowersForUser(ctx context.Context, params UsersListFollowersForUserParams) (*UsersListFollowersForUserOKHeaders, error)
	// UsersListFollowingForUser invokes users/list-following-for-user operation.
	//
	// Lists the people who the specified user follows.
	//
	// GET /users/{username}/following
	UsersListFollowingForUser(ctx context.Context, params UsersListFollowingForUserParams) (*UsersListFollowingForUserOKHeaders, error)
	// UsersListGpgKeysForAuthenticated invokes users/list-gpg-keys-for-authenticated operation.
	//
	// Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth
	// with at least `read:gpg_key` [scope](https://docs.github.
	// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// GET /user/gpg_keys
	UsersListGpgKeysForAuthenticated(ctx context.Context, params UsersListGpgKeysForAuthenticatedParams) (UsersListGpgKeysForAuthenticatedRes, error)
	// UsersListGpgKeysForUser invokes users/list-gpg-keys-for-user operation.
	//
	// Lists the GPG keys for a user. This information is accessible by anyone.
	//
	// GET /users/{username}/gpg_keys
	UsersListGpgKeysForUser(ctx context.Context, params UsersListGpgKeysForUserParams) (*UsersListGpgKeysForUserOKHeaders, error)
	// UsersListPublicEmailsForAuthenticated invokes users/list-public-emails-for-authenticated operation.
	//
	// Lists your publicly visible email address, which you can set with the [Set primary email
	// visibility for the authenticated user](https://docs.github.
	// com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This
	// endpoint is accessible with the `user:email` scope.
	//
	// GET /user/public_emails
	UsersListPublicEmailsForAuthenticated(ctx context.Context, params UsersListPublicEmailsForAuthenticatedParams) (UsersListPublicEmailsForAuthenticatedRes, error)
	// UsersListPublicKeysForUser invokes users/list-public-keys-for-user operation.
	//
	// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
	//
	// GET /users/{username}/keys
	UsersListPublicKeysForUser(ctx context.Context, params UsersListPublicKeysForUserParams) (*UsersListPublicKeysForUserOKHeaders, error)
	// UsersListPublicSSHKeysForAuthenticated invokes users/list-public-ssh-keys-for-authenticated operation.
	//
	// Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
	// authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.
	// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
	//
	// GET /user/keys
	UsersListPublicSSHKeysForAuthenticated(ctx context.Context, params UsersListPublicSSHKeysForAuthenticatedParams) (UsersListPublicSSHKeysForAuthenticatedRes, error)
	// UsersSetPrimaryEmailVisibilityForAuthenticated invokes users/set-primary-email-visibility-for-authenticated operation.
	//
	// Sets the visibility for your primary email addresses.
	//
	// PATCH /user/email/visibility
	UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, request *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) (UsersSetPrimaryEmailVisibilityForAuthenticatedRes, error)
	// UsersUnblock invokes users/unblock operation.
	//
	// Unblock a user.
	//
	// DELETE /user/blocks/{username}
	UsersUnblock(ctx context.Context, params UsersUnblockParams) (UsersUnblockRes, error)
	// UsersUnfollow invokes users/unfollow operation.
	//
	// Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth
	// with the `user:follow` scope.
	//
	// DELETE /user/following/{username}
	UsersUnfollow(ctx context.Context, params UsersUnfollowParams) (UsersUnfollowRes, error)
	// UsersUpdateAuthenticated invokes users/update-authenticated operation.
	//
	// **Note:** If your email is set to private and you send an `email` parameter as part of this
	// request to update your profile, your privacy settings are still enforced: the email address will
	// not be displayed on your public profile or via the API.
	//
	// PATCH /user
	UsersUpdateAuthenticated(ctx context.Context, request OptUsersUpdateAuthenticatedReq) (UsersUpdateAuthenticatedRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a repository to the list of selected repositories that can access a self-hosted runner group.
// The runner group must have `visibility` set to `selected`. For more information, see "[Create a
// self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (c *Client) ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) error {
	_, err := c.sendActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	return err
}

func (c *Client) sendActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) (res *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsAddSelectedRepoToOrgSecret invokes actions/add-selected-repo-to-org-secret operation.
//
// Adds a repository to an organization secret when the `visibility` for repository access is set to
// `selected`. The visibility is set when you [Create or update an organization secret](https://docs.
// github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (c *Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, params ActionsAddSelectedRepoToOrgSecretParams) (ActionsAddSelectedRepoToOrgSecretRes, error) {
	res, err := c.sendActionsAddSelectedRepoToOrgSecret(ctx, params)
	return res, err
}

func (c *Client) sendActionsAddSelectedRepoToOrgSecret(ctx context.Context, params ActionsAddSelectedRepoToOrgSecretParams) (res ActionsAddSelectedRepoToOrgSecretRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-selected-repo-to-org-secret"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsAddSelectedRepoToOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsAddSelectedRepoToOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsAddSelfHostedRunnerToGroupForOrg invokes actions/add-self-hosted-runner-to-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a self-hosted runner to a runner group configured in an organization.
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) ActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, params ActionsAddSelfHostedRunnerToGroupForOrgParams) error {
	_, err := c.sendActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
	return err
}

func (c *Client) sendActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, params ActionsAddSelfHostedRunnerToGroupForOrgParams) (res *ActionsAddSelfHostedRunnerToGroupForOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-self-hosted-runner-to-group-for-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsAddSelfHostedRunnerToGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsAddSelfHostedRunnerToGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsApproveWorkflowRun invokes actions/approve-workflow-run operation.
//
// Approves a workflow run for a pull request from a public fork of a first time contributor. For
// more information, see ["Approving workflow runs from public forks](https://docs.github.
// com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `actions:write` permission to use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (c *Client) ActionsApproveWorkflowRun(ctx context.Context, params ActionsApproveWorkflowRunParams) (ActionsApproveWorkflowRunRes, error) {
	res, err := c.sendActionsApproveWorkflowRun(ctx, params)
	return res, err
}

func (c *Client) sendActionsApproveWorkflowRun(ctx context.Context, params ActionsApproveWorkflowRunParams) (res ActionsApproveWorkflowRunRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/approve-workflow-run"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/approve"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsApproveWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/approve"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsApproveWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCancelWorkflowRun invokes actions/cancel-workflow-run operation.
//
// Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (c *Client) ActionsCancelWorkflowRun(ctx context.Context, params ActionsCancelWorkflowRunParams) error {
	_, err := c.sendActionsCancelWorkflowRun(ctx, params)
	return err
}

func (c *Client) sendActionsCancelWorkflowRun(ctx context.Context, params ActionsCancelWorkflowRunParams) (res *ActionsCancelWorkflowRunAccepted, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/cancel-workflow-run"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCancelWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCancelWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateOrUpdateEnvironmentSecret invokes actions/create-or-update-environment-secret operation.
//
// Creates or updates an environment secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (c *Client) ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, request *ActionsCreateOrUpdateEnvironmentSecretReq, params ActionsCreateOrUpdateEnvironmentSecretParams) (ActionsCreateOrUpdateEnvironmentSecretRes, error) {
	res, err := c.sendActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
	return res, err
}

func (c *Client) sendActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, request *ActionsCreateOrUpdateEnvironmentSecretReq, params ActionsCreateOrUpdateEnvironmentSecretParams) (res ActionsCreateOrUpdateEnvironmentSecretRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-environment-secret"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateOrUpdateEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsCreateOrUpdateEnvironmentSecretRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateOrUpdateEnvironmentSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateOrUpdateOrgSecret invokes actions/create-or-update-org-secret operation.
//
// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to
// use this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (c *Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, request *ActionsCreateOrUpdateOrgSecretReq, params ActionsCreateOrUpdateOrgSecretParams) (ActionsCreateOrUpdateOrgSecretRes, error) {
	res, err := c.sendActionsCreateOrUpdateOrgSecret(ctx, request, params)
	return res, err
}

func (c *Client) sendActionsCreateOrUpdateOrgSecret(ctx context.Context, request *ActionsCreateOrUpdateOrgSecretReq, params ActionsCreateOrUpdateOrgSecretParams) (res ActionsCreateOrUpdateOrgSecretRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-org-secret"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateOrUpdateOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsCreateOrUpdateOrgSecretRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateOrUpdateOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateOrUpdateRepoSecret invokes actions/create-or-update-repo-secret operation.
//
// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (c *Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, request *ActionsCreateOrUpdateRepoSecretReq, params ActionsCreateOrUpdateRepoSecretParams) (ActionsCreateOrUpdateRepoSecretRes, error) {
	res, err := c.sendActionsCreateOrUpdateRepoSecret(ctx, request, params)
	return res, err
}

func (c *Client) sendActionsCreateOrUpdateRepoSecret(ctx context.Context, request *ActionsCreateOrUpdateRepoSecretReq, params ActionsCreateOrUpdateRepoSecretParams) (res ActionsCreateOrUpdateRepoSecretRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-repo-secret"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/{secret_name}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateOrUpdateRepoSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsCreateOrUpdateRepoSecretRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateOrUpdateRepoSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRegistrationTokenForOrg invokes actions/create-registration-token-for-org operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/registration-token
func (c *Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, params ActionsCreateRegistrationTokenForOrgParams) (*AuthenticationToken, error) {
	res, err := c.sendActionsCreateRegistrationTokenForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsCreateRegistrationTokenForOrg(ctx context.Context, params ActionsCreateRegistrationTokenForOrgParams) (res *AuthenticationToken, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/registration-token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRegistrationTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/registration-token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateRegistrationTokenForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRegistrationTokenForRepo invokes actions/create-registration-token-for-repo operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour. You
// must authenticate
// using an access token with the `repo` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (c *Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, params ActionsCreateRegistrationTokenForRepoParams) (*AuthenticationToken, error) {
	res, err := c.sendActionsCreateRegistrationTokenForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsCreateRegistrationTokenForRepo(ctx context.Context, params ActionsCreateRegistrationTokenForRepoParams) (res *AuthenticationToken, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-repo"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/registration-token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRegistrationTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runners/registration-token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateRegistrationTokenForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRemoveTokenForOrg invokes actions/create-remove-token-for-org operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// organization. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/remove-token
func (c *Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, params ActionsCreateRemoveTokenForOrgParams) (*AuthenticationToken, error) {
	res, err := c.sendActionsCreateRemoveTokenForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsCreateRemoveTokenForOrg(ctx context.Context, params ActionsCreateRemoveTokenForOrgParams) (res *AuthenticationToken, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/remove-token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRemoveTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/remove-token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateRemoveTokenForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRemoveTokenForRepo invokes actions/create-remove-token-for-repo operation.
//
// Returns a token that you can pass to remove a self-hosted runner from a repository. The token
// expires after one hour.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided
// by this endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (c *Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, params ActionsCreateRemoveTokenForRepoParams) (*AuthenticationToken, error) {
	res, err := c.sendActionsCreateRemoveTokenForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsCreateRemoveTokenForRepo(ctx context.Context, params ActionsCreateRemoveTokenForRepoParams) (res *AuthenticationToken, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-repo"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/remove-token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRemoveTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runners/remove-token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateRemoveTokenForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateSelfHostedRunnerGroupForOrg invokes actions/create-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Creates a new self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// POST /orgs/{org}/actions/runner-groups
func (c *Client) ActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, request *ActionsCreateSelfHostedRunnerGroupForOrgReq, params ActionsCreateSelfHostedRunnerGroupForOrgParams) (*RunnerGroupsOrg, error) {
	res, err := c.sendActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, request *ActionsCreateSelfHostedRunnerGroupForOrgReq, params ActionsCreateSelfHostedRunnerGroupForOrgParams) (res *RunnerGroupsOrg, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-self-hosted-runner-group-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsCreateSelfHostedRunnerGroupForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsCreateSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteArtifact invokes actions/delete-artifact operation.
//
// Deletes an artifact for a workflow run. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (c *Client) ActionsDeleteArtifact(ctx context.Context, params ActionsDeleteArtifactParams) error {
	_, err := c.sendActionsDeleteArtifact(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteArtifact(ctx context.Context, params ActionsDeleteArtifactParams) (res *ActionsDeleteArtifactNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-artifact"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteArtifact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/artifacts/"
	{
		// Encode "artifact_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ArtifactID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteArtifactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteEnvironmentSecret invokes actions/delete-environment-secret operation.
//
// Deletes a secret in an environment using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (c *Client) ActionsDeleteEnvironmentSecret(ctx context.Context, params ActionsDeleteEnvironmentSecretParams) error {
	_, err := c.sendActionsDeleteEnvironmentSecret(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteEnvironmentSecret(ctx context.Context, params ActionsDeleteEnvironmentSecretParams) (res *ActionsDeleteEnvironmentSecretNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-environment-secret"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteEnvironmentSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteOrgSecret invokes actions/delete-org-secret operation.
//
// Deletes a secret in an organization using the secret name. You must authenticate using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (c *Client) ActionsDeleteOrgSecret(ctx context.Context, params ActionsDeleteOrgSecretParams) error {
	_, err := c.sendActionsDeleteOrgSecret(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteOrgSecret(ctx context.Context, params ActionsDeleteOrgSecretParams) (res *ActionsDeleteOrgSecretNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-org-secret"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteRepoSecret invokes actions/delete-repo-secret operation.
//
// Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (c *Client) ActionsDeleteRepoSecret(ctx context.Context, params ActionsDeleteRepoSecretParams) error {
	_, err := c.sendActionsDeleteRepoSecret(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteRepoSecret(ctx context.Context, params ActionsDeleteRepoSecretParams) (res *ActionsDeleteRepoSecretNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-repo-secret"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/{secret_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteRepoSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteRepoSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteSelfHostedRunnerFromOrg invokes actions/delete-self-hosted-runner-from-org operation.
//
// Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (c *Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromOrgParams) error {
	_, err := c.sendActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromOrgParams) (res *ActionsDeleteSelfHostedRunnerFromOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteSelfHostedRunnerFromOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteSelfHostedRunnerFromOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteSelfHostedRunnerFromRepo invokes actions/delete-self-hosted-runner-from-repo operation.
//
// Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `repo`
// scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (c *Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromRepoParams) error {
	_, err := c.sendActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromRepoParams) (res *ActionsDeleteSelfHostedRunnerFromRepoNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-repo"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteSelfHostedRunnerFromRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteSelfHostedRunnerFromRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteSelfHostedRunnerGroupFromOrg invokes actions/delete-self-hosted-runner-group-from-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Deletes a self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (c *Client) ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) error {
	_, err := c.sendActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) (res *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-group-from-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteSelfHostedRunnerGroupFromOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteWorkflowRun invokes actions/delete-workflow-run operation.
//
// Delete a specific workflow run. Anyone with write access to the repository can use this endpoint.
// If the repository is
// private you must use an access token with the `repo` scope. GitHub Apps must have the
// `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (c *Client) ActionsDeleteWorkflowRun(ctx context.Context, params ActionsDeleteWorkflowRunParams) error {
	_, err := c.sendActionsDeleteWorkflowRun(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteWorkflowRun(ctx context.Context, params ActionsDeleteWorkflowRunParams) (res *ActionsDeleteWorkflowRunNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteWorkflowRunLogs invokes actions/delete-workflow-run-logs operation.
//
// Deletes all logs for a workflow run. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (c *Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, params ActionsDeleteWorkflowRunLogsParams) error {
	_, err := c.sendActionsDeleteWorkflowRunLogs(ctx, params)
	return err
}

func (c *Client) sendActionsDeleteWorkflowRunLogs(ctx context.Context, params ActionsDeleteWorkflowRunLogsParams) (res *ActionsDeleteWorkflowRunLogsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run-logs"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDeleteWorkflowRunLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDisableSelectedRepositoryGithubActionsOrganization invokes actions/disable-selected-repository-github-actions-organization operation.
//
// Removes a repository from the list of selected repositories that are enabled for GitHub Actions in
// an organization. To use this endpoint, the organization permission policy for
// `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (c *Client) ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) error {
	_, err := c.sendActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
	return err
}

func (c *Client) sendActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) (res *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/disable-selected-repository-github-actions-organization"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDisableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDownloadArtifact invokes actions/download-artifact operation.
//
// Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look
// for `Location:` in
// the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone
// with read access to
// the repository can use this endpoint. If the repository is private you must use an access token
// with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (c *Client) ActionsDownloadArtifact(ctx context.Context, params ActionsDownloadArtifactParams) (*ActionsDownloadArtifactFound, error) {
	res, err := c.sendActionsDownloadArtifact(ctx, params)
	return res, err
}

func (c *Client) sendActionsDownloadArtifact(ctx context.Context, params ActionsDownloadArtifactParams) (res *ActionsDownloadArtifactFound, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-artifact"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDownloadArtifact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/artifacts/"
	{
		// Encode "artifact_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ArtifactID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "archive_format" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "archive_format",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ArchiveFormat))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDownloadArtifactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDownloadJobLogsForWorkflowRun invokes actions/download-job-logs-for-workflow-run operation.
//
// Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires
// after 1 minute. Look
// for `Location:` in the response header to find the URL for the download. Anyone with read access
// to the repository can
// use this endpoint. If the repository is private you must use an access token with the `repo` scope.
//
//	GitHub Apps must
//
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (c *Client) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, params ActionsDownloadJobLogsForWorkflowRunParams) (*ActionsDownloadJobLogsForWorkflowRunFound, error) {
	res, err := c.sendActionsDownloadJobLogsForWorkflowRun(ctx, params)
	return res, err
}

func (c *Client) sendActionsDownloadJobLogsForWorkflowRun(ctx context.Context, params ActionsDownloadJobLogsForWorkflowRunParams) (res *ActionsDownloadJobLogsForWorkflowRunFound, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-job-logs-for-workflow-run"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/jobs/{job_id}/logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDownloadJobLogsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/jobs/"
	{
		// Encode "job_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "job_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.JobID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDownloadJobLogsForWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDownloadWorkflowRunLogs invokes actions/download-workflow-run-logs operation.
//
// Gets a redirect URL to download an archive of log files for a workflow run. This link expires
// after 1 minute. Look for
// `Location:` in the response header to find the URL for the download. Anyone with read access to
// the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have
// the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (c *Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, params ActionsDownloadWorkflowRunLogsParams) (*ActionsDownloadWorkflowRunLogsFound, error) {
	res, err := c.sendActionsDownloadWorkflowRunLogs(ctx, params)
	return res, err
}

func (c *Client) sendActionsDownloadWorkflowRunLogs(ctx context.Context, params ActionsDownloadWorkflowRunLogsParams) (res *ActionsDownloadWorkflowRunLogsFound, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-workflow-run-logs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDownloadWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsDownloadWorkflowRunLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsEnableSelectedRepositoryGithubActionsOrganization invokes actions/enable-selected-repository-github-actions-organization operation.
//
// Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an
// organization. To use this endpoint, the organization permission policy for `enabled_repositories`
// must be must be configured to `selected`. For more information, see "[Set GitHub Actions
// permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (c *Client) ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) error {
	_, err := c.sendActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
	return err
}

func (c *Client) sendActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) (res *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/enable-selected-repository-github-actions-organization"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsEnableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetAllowedActionsOrganization invokes actions/get-allowed-actions-organization operation.
//
// Gets the selected actions that are allowed in an organization. To use this endpoint, the
// organization permission policy for `allowed_actions` must be configured to `selected`. For more
// information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization).""
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (c *Client) ActionsGetAllowedActionsOrganization(ctx context.Context, params ActionsGetAllowedActionsOrganizationParams) (*SelectedActions, error) {
	res, err := c.sendActionsGetAllowedActionsOrganization(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetAllowedActionsOrganization(ctx context.Context, params ActionsGetAllowedActionsOrganizationParams) (res *SelectedActions, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-organization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/selected-actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/selected-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetAllowedActionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetAllowedActionsRepository invokes actions/get-allowed-actions-repository operation.
//
// Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the
// repository policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for a
// repository](#set-github-actions-permissions-for-a-repository)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (c *Client) ActionsGetAllowedActionsRepository(ctx context.Context, params ActionsGetAllowedActionsRepositoryParams) (*SelectedActions, error) {
	res, err := c.sendActionsGetAllowedActionsRepository(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetAllowedActionsRepository(ctx context.Context, params ActionsGetAllowedActionsRepositoryParams) (res *SelectedActions, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-repository"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions/selected-actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/permissions/selected-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetAllowedActionsRepositoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetArtifact invokes actions/get-artifact operation.
//
// Gets a specific artifact for a workflow run. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (c *Client) ActionsGetArtifact(ctx context.Context, params ActionsGetArtifactParams) (*Artifact, error) {
	res, err := c.sendActionsGetArtifact(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetArtifact(ctx context.Context, params ActionsGetArtifactParams) (res *Artifact, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-artifact"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetArtifact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/artifacts/"
	{
		// Encode "artifact_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ArtifactID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetArtifactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetEnvironmentPublicKey invokes actions/get-environment-public-key operation.
//
// Get the public key for an environment, which you need to encrypt environment secrets. You need to
// encrypt a secret before you can create or update secrets. Anyone with read access to the
// repository can use this endpoint. If the repository is private you must use an access token with
// the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (c *Client) ActionsGetEnvironmentPublicKey(ctx context.Context, params ActionsGetEnvironmentPublicKeyParams) (*ActionsPublicKey, error) {
	res, err := c.sendActionsGetEnvironmentPublicKey(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetEnvironmentPublicKey(ctx context.Context, params ActionsGetEnvironmentPublicKeyParams) (res *ActionsPublicKey, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-public-key"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/public-key"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetEnvironmentPublicKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secrets/public-key"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetEnvironmentPublicKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetEnvironmentSecret invokes actions/get-environment-secret operation.
//
// Gets a single environment secret without revealing its encrypted value. You must authenticate
// using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
// `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (c *Client) ActionsGetEnvironmentSecret(ctx context.Context, params ActionsGetEnvironmentSecretParams) (*ActionsSecret, error) {
	res, err := c.sendActionsGetEnvironmentSecret(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetEnvironmentSecret(ctx context.Context, params ActionsGetEnvironmentSecretParams) (res *ActionsSecret, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-secret"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetEnvironmentSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetGithubActionsPermissionsOrganization invokes actions/get-github-actions-permissions-organization operation.
//
// Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions
func (c *Client) ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, params ActionsGetGithubActionsPermissionsOrganizationParams) (*ActionsOrganizationPermissions, error) {
	res, err := c.sendActionsGetGithubActionsPermissionsOrganization(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetGithubActionsPermissionsOrganization(ctx context.Context, params ActionsGetGithubActionsPermissionsOrganizationParams) (res *ActionsOrganizationPermissions, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-organization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetGithubActionsPermissionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetGithubActionsPermissionsRepository invokes actions/get-github-actions-permissions-repository operation.
//
// Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is
// enabled and the actions allowed to run in the repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint. GitHub Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (c *Client) ActionsGetGithubActionsPermissionsRepository(ctx context.Context, params ActionsGetGithubActionsPermissionsRepositoryParams) (*ActionsRepositoryPermissions, error) {
	res, err := c.sendActionsGetGithubActionsPermissionsRepository(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetGithubActionsPermissionsRepository(ctx context.Context, params ActionsGetGithubActionsPermissionsRepositoryParams) (res *ActionsRepositoryPermissions, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-repository"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetGithubActionsPermissionsRepositoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetJobForWorkflowRun invokes actions/get-job-for-workflow-run operation.
//
// Gets a specific job in a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (c *Client) ActionsGetJobForWorkflowRun(ctx context.Context, params ActionsGetJobForWorkflowRunParams) (*Job, error) {
	res, err := c.sendActionsGetJobForWorkflowRun(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetJobForWorkflowRun(ctx context.Context, params ActionsGetJobForWorkflowRunParams) (res *Job, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-job-for-workflow-run"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/jobs/{job_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetJobForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/jobs/"
	{
		// Encode "job_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "job_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.JobID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetJobForWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetOrgPublicKey invokes actions/get-org-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/public-key
func (c *Client) ActionsGetOrgPublicKey(ctx context.Context, params ActionsGetOrgPublicKeyParams) (*ActionsPublicKey, error) {
	res, err := c.sendActionsGetOrgPublicKey(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetOrgPublicKey(ctx context.Context, params ActionsGetOrgPublicKeyParams) (res *ActionsPublicKey, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-public-key"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/public-key"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetOrgPublicKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/public-key"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetOrgPublicKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetOrgSecret invokes actions/get-org-secret operation.
//
// Gets a single organization secret without revealing its encrypted value. You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (c *Client) ActionsGetOrgSecret(ctx context.Context, params ActionsGetOrgSecretParams) (*OrganizationActionsSecret, error) {
	res, err := c.sendActionsGetOrgSecret(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetOrgSecret(ctx context.Context, params ActionsGetOrgSecretParams) (res *OrganizationActionsSecret, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-secret"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetRepoPublicKey invokes actions/get-repo-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (c *Client) ActionsGetRepoPublicKey(ctx context.Context, params ActionsGetRepoPublicKeyParams) (*ActionsPublicKey, error) {
	res, err := c.sendActionsGetRepoPublicKey(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetRepoPublicKey(ctx context.Context, params ActionsGetRepoPublicKeyParams) (res *ActionsPublicKey, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-public-key"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/public-key"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetRepoPublicKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/secrets/public-key"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetRepoPublicKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetRepoSecret invokes actions/get-repo-secret operation.
//
// Gets a single repository secret without revealing its encrypted value. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
// repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (c *Client) ActionsGetRepoSecret(ctx context.Context, params ActionsGetRepoSecretParams) (*ActionsSecret, error) {
	res, err := c.sendActionsGetRepoSecret(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetRepoSecret(ctx context.Context, params ActionsGetRepoSecretParams) (res *ActionsSecret, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-secret"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/{secret_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetRepoSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetRepoSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetReviewsForRun invokes actions/get-reviews-for-run operation.
//
// Anyone with read access to the repository can use this endpoint. If the repository is private, you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (c *Client) ActionsGetReviewsForRun(ctx context.Context, params ActionsGetReviewsForRunParams) ([]EnvironmentApprovals, error) {
	res, err := c.sendActionsGetReviewsForRun(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetReviewsForRun(ctx context.Context, params ActionsGetReviewsForRunParams) (res []EnvironmentApprovals, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-reviews-for-run"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetReviewsForRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/approvals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetReviewsForRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetSelfHostedRunnerForOrg invokes actions/get-self-hosted-runner-for-org operation.
//
// Gets a specific self-hosted runner configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (c *Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerForOrgParams) (*Runner, error) {
	res, err := c.sendActionsGetSelfHostedRunnerForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetSelfHostedRunnerForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerForOrgParams) (res *Runner, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetSelfHostedRunnerForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetSelfHostedRunnerForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetSelfHostedRunnerForRepo invokes actions/get-self-hosted-runner-for-repo operation.
//
// Gets a specific self-hosted runner configured in a repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (c *Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, params ActionsGetSelfHostedRunnerForRepoParams) (*Runner, error) {
	res, err := c.sendActionsGetSelfHostedRunnerForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetSelfHostedRunnerForRepo(ctx context.Context, params ActionsGetSelfHostedRunnerForRepoParams) (res *Runner, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetSelfHostedRunnerForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetSelfHostedRunnerForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetSelfHostedRunnerGroupForOrg invokes actions/get-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Gets a specific self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (c *Client) ActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerGroupForOrgParams) (*RunnerGroupsOrg, error) {
	res, err := c.sendActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerGroupForOrgParams) (res *RunnerGroupsOrg, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-group-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetWorkflowRun invokes actions/get-workflow-run operation.
//
// Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (c *Client) ActionsGetWorkflowRun(ctx context.Context, params ActionsGetWorkflowRunParams) (*WorkflowRun, error) {
	res, err := c.sendActionsGetWorkflowRun(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetWorkflowRun(ctx context.Context, params ActionsGetWorkflowRunParams) (res *WorkflowRun, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetWorkflowRunUsage invokes actions/get-workflow-run-usage operation.
//
// Gets the number of billable minutes and total run time for a specific workflow run. Billable
// minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is
// listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (c *Client) ActionsGetWorkflowRunUsage(ctx context.Context, params ActionsGetWorkflowRunUsageParams) (*WorkflowRunUsage, error) {
	res, err := c.sendActionsGetWorkflowRunUsage(ctx, params)
	return res, err
}

func (c *Client) sendActionsGetWorkflowRunUsage(ctx context.Context, params ActionsGetWorkflowRunUsageParams) (res *WorkflowRunUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run-usage"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/timing"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetWorkflowRunUsage",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/timing"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsGetWorkflowRunUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListArtifactsForRepo invokes actions/list-artifacts-for-repo operation.
//
// Lists all artifacts for a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (c *Client) ActionsListArtifactsForRepo(ctx context.Context, params ActionsListArtifactsForRepoParams) (*ActionsListArtifactsForRepoOKHeaders, error) {
	res, err := c.sendActionsListArtifactsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsListArtifactsForRepo(ctx context.Context, params ActionsListArtifactsForRepoParams) (res *ActionsListArtifactsForRepoOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-artifacts-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListArtifactsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/artifacts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListArtifactsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListEnvironmentSecrets invokes actions/list-environment-secrets operation.
//
// Lists all secrets available in an environment without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (c *Client) ActionsListEnvironmentSecrets(ctx context.Context, params ActionsListEnvironmentSecretsParams) (*ActionsListEnvironmentSecretsOKHeaders, error) {
	res, err := c.sendActionsListEnvironmentSecrets(ctx, params)
	return res, err
}

func (c *Client) sendActionsListEnvironmentSecrets(ctx context.Context, params ActionsListEnvironmentSecretsParams) (res *ActionsListEnvironmentSecretsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-environment-secrets"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListEnvironmentSecrets",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListEnvironmentSecretsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListJobsForWorkflowRun invokes actions/list-jobs-for-workflow-run operation.
//
// Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list
// of results. For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (c *Client) ActionsListJobsForWorkflowRun(ctx context.Context, params ActionsListJobsForWorkflowRunParams) (*ActionsListJobsForWorkflowRunOKHeaders, error) {
	res, err := c.sendActionsListJobsForWorkflowRun(ctx, params)
	return res, err
}

func (c *Client) sendActionsListJobsForWorkflowRun(ctx context.Context, params ActionsListJobsForWorkflowRunParams) (res *ActionsListJobsForWorkflowRunOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-jobs-for-workflow-run"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListJobsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListJobsForWorkflowRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListOrgSecrets invokes actions/list-org-secrets operation.
//
// Lists all secrets available in an organization without revealing their encrypted values. You must
// authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps
// must have the `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets
func (c *Client) ActionsListOrgSecrets(ctx context.Context, params ActionsListOrgSecretsParams) (*ActionsListOrgSecretsOKHeaders, error) {
	res, err := c.sendActionsListOrgSecrets(ctx, params)
	return res, err
}

func (c *Client) sendActionsListOrgSecrets(ctx context.Context, params ActionsListOrgSecretsParams) (res *ActionsListOrgSecretsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-org-secrets"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListOrgSecrets",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListOrgSecretsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists the repositories with access to a self-hosted runner group configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (c *Client) ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) (*ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK, error) {
	res, err := c.sendActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) (res *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRepoSecrets invokes actions/list-repo-secrets operation.
//
// Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (c *Client) ActionsListRepoSecrets(ctx context.Context, params ActionsListRepoSecretsParams) (*ActionsListRepoSecretsOKHeaders, error) {
	res, err := c.sendActionsListRepoSecrets(ctx, params)
	return res, err
}

func (c *Client) sendActionsListRepoSecrets(ctx context.Context, params ActionsListRepoSecretsParams) (res *ActionsListRepoSecretsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-secrets"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRepoSecrets",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListRepoSecretsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRepoWorkflows invokes actions/list-repo-workflows operation.
//
// Lists the workflows in a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (c *Client) ActionsListRepoWorkflows(ctx context.Context, params ActionsListRepoWorkflowsParams) (*ActionsListRepoWorkflowsOKHeaders, error) {
	res, err := c.sendActionsListRepoWorkflows(ctx, params)
	return res, err
}

func (c *Client) sendActionsListRepoWorkflows(ctx context.Context, params ActionsListRepoWorkflowsParams) (res *ActionsListRepoWorkflowsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-workflows"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/workflows"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRepoWorkflows",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListRepoWorkflowsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRunnerApplicationsForOrg invokes actions/list-runner-applications-for-org operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/downloads
func (c *Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, params ActionsListRunnerApplicationsForOrgParams) ([]RunnerApplication, error) {
	res, err := c.sendActionsListRunnerApplicationsForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsListRunnerApplicationsForOrg(ctx context.Context, params ActionsListRunnerApplicationsForOrgParams) (res []RunnerApplication, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/downloads"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRunnerApplicationsForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/downloads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListRunnerApplicationsForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRunnerApplicationsForRepo invokes actions/list-runner-applications-for-repo operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (c *Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, params ActionsListRunnerApplicationsForRepoParams) ([]RunnerApplication, error) {
	res, err := c.sendActionsListRunnerApplicationsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsListRunnerApplicationsForRepo(ctx context.Context, params ActionsListRunnerApplicationsForRepoParams) (res []RunnerApplication, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/downloads"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRunnerApplicationsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runners/downloads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListRunnerApplicationsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelectedReposForOrgSecret invokes actions/list-selected-repos-for-org-secret operation.
//
// Lists all repositories that have been selected when the `visibility` for repository access to a
// secret is set to `selected`. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (c *Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, params ActionsListSelectedReposForOrgSecretParams) (*ActionsListSelectedReposForOrgSecretOK, error) {
	res, err := c.sendActionsListSelectedReposForOrgSecret(ctx, params)
	return res, err
}

func (c *Client) sendActionsListSelectedReposForOrgSecret(ctx context.Context, params ActionsListSelectedReposForOrgSecretParams) (res *ActionsListSelectedReposForOrgSecretOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repos-for-org-secret"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListSelectedReposForOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelectedRepositoriesEnabledGithubActionsOrganization invokes actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// Lists the selected repositories that are enabled for GitHub Actions in an organization. To use
// this endpoint, the organization permission policy for `enabled_repositories` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/repositories
func (c *Client) ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) (*ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK, error) {
	res, err := c.sendActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
	return res, err
}

func (c *Client) sendActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) (res *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repositories-enabled-github-actions-organization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnerGroupsForOrg invokes actions/list-self-hosted-runner-groups-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups
func (c *Client) ActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, params ActionsListSelfHostedRunnerGroupsForOrgParams) (*ActionsListSelfHostedRunnerGroupsForOrgOK, error) {
	res, err := c.sendActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, params ActionsListSelfHostedRunnerGroupsForOrgParams) (res *ActionsListSelfHostedRunnerGroupsForOrgOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runner-groups-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnerGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListSelfHostedRunnerGroupsForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnersForOrg invokes actions/list-self-hosted-runners-for-org operation.
//
// Lists all self-hosted runners configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners
func (c *Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, params ActionsListSelfHostedRunnersForOrgParams) (*ActionsListSelfHostedRunnersForOrgOKHeaders, error) {
	res, err := c.sendActionsListSelfHostedRunnersForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsListSelfHostedRunnersForOrg(ctx context.Context, params ActionsListSelfHostedRunnersForOrgParams) (res *ActionsListSelfHostedRunnersForOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnersForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListSelfHostedRunnersForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnersForRepo invokes actions/list-self-hosted-runners-for-repo operation.
//
// Lists all self-hosted runners configured in a repository. You must authenticate using an access
// token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners
func (c *Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, params ActionsListSelfHostedRunnersForRepoParams) (*ActionsListSelfHostedRunnersForRepoOKHeaders, error) {
	res, err := c.sendActionsListSelfHostedRunnersForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsListSelfHostedRunnersForRepo(ctx context.Context, params ActionsListSelfHostedRunnersForRepoParams) (res *ActionsListSelfHostedRunnersForRepoOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnersForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListSelfHostedRunnersForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnersInGroupForOrg invokes actions/list-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists self-hosted runners that are in a specific organization group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) ActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, params ActionsListSelfHostedRunnersInGroupForOrgParams) (*ActionsListSelfHostedRunnersInGroupForOrgOKHeaders, error) {
	res, err := c.sendActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
	return res, err
}

func (c *Client) sendActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, params ActionsListSelfHostedRunnersInGroupForOrgParams) (res *ActionsListSelfHostedRunnersInGroupForOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-in-group-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListSelfHostedRunnersInGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListWorkflowRunArtifacts invokes actions/list-workflow-run-artifacts operation.
//
// Lists artifacts for a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (c *Client) ActionsListWorkflowRunArtifacts(ctx context.Context, params ActionsListWorkflowRunArtifactsParams) (*ActionsListWorkflowRunArtifactsOKHeaders, error) {
	res, err := c.sendActionsListWorkflowRunArtifacts(ctx, params)
	return res, err
}

func (c *Client) sendActionsListWorkflowRunArtifacts(ctx context.Context, params ActionsListWorkflowRunArtifactsParams) (res *ActionsListWorkflowRunArtifactsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-run-artifacts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListWorkflowRunArtifacts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/artifacts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListWorkflowRunArtifactsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListWorkflowRunsForRepo invokes actions/list-workflow-runs-for-repo operation.
//
// Lists all workflow runs for a repository. You can use parameters to narrow the list of results.
// For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs
func (c *Client) ActionsListWorkflowRunsForRepo(ctx context.Context, params ActionsListWorkflowRunsForRepoParams) (*ActionsListWorkflowRunsForRepoOKHeaders, error) {
	res, err := c.sendActionsListWorkflowRunsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActionsListWorkflowRunsForRepo(ctx context.Context, params ActionsListWorkflowRunsForRepoParams) (res *ActionsListWorkflowRunsForRepoOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-runs-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListWorkflowRunsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "actor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "actor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Actor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "branch" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "branch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Branch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Event.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "created" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "created",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Created.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsListWorkflowRunsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsReRunWorkflow invokes actions/re-run-workflow operation.
//
// **Deprecation Notice:** This endpoint is deprecated.
// We recommend migrating your existing code to use the new [retry workflow](https://docs.github.
// com/rest/reference/actions#retry-a-workflow) endpoint.
// Re-runs your workflow run using its `id`. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have
// the `actions:write` permission to use this endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (c *Client) ActionsReRunWorkflow(ctx context.Context, params ActionsReRunWorkflowParams) error {
	_, err := c.sendActionsReRunWorkflow(ctx, params)
	return err
}

func (c *Client) sendActionsReRunWorkflow(ctx context.Context, params ActionsReRunWorkflowParams) (res *ActionsReRunWorkflowCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/re-run-workflow"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsReRunWorkflow",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/rerun"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsReRunWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a repository from the list of selected repositories that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (c *Client) ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) error {
	_, err := c.sendActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	return err
}

func (c *Client) sendActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) (res *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRemoveSelectedRepoFromOrgSecret invokes actions/remove-selected-repo-from-org-secret operation.
//
// Removes a repository from an organization secret when the `visibility` for repository access is
// set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (c *Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, params ActionsRemoveSelectedRepoFromOrgSecretParams) (ActionsRemoveSelectedRepoFromOrgSecretRes, error) {
	res, err := c.sendActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
	return res, err
}

func (c *Client) sendActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, params ActionsRemoveSelectedRepoFromOrgSecretParams) (res ActionsRemoveSelectedRepoFromOrgSecretRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-selected-repo-from-org-secret"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRemoveSelectedRepoFromOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsRemoveSelectedRepoFromOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRemoveSelfHostedRunnerFromGroupForOrg invokes actions/remove-self-hosted-runner-from-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a self-hosted runner from a group configured in an organization. The runner is then
// returned to the default group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) error {
	_, err := c.sendActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
	return err
}

func (c *Client) sendActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) (res *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-self-hosted-runner-from-group-for-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRetryWorkflow invokes actions/retry-workflow operation.
//
// Retry your workflow run using its `id`. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (c *Client) ActionsRetryWorkflow(ctx context.Context, params ActionsRetryWorkflowParams) error {
	_, err := c.sendActionsRetryWorkflow(ctx, params)
	return err
}

func (c *Client) sendActionsRetryWorkflow(ctx context.Context, params ActionsRetryWorkflowParams) (res *ActionsRetryWorkflowCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/retry-workflow"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/retry"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRetryWorkflow",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/retry"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsRetryWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsReviewPendingDeploymentsForRun invokes actions/review-pending-deployments-for-run operation.
//
// Approve or reject pending deployments that are waiting on approval by a required reviewer.
// Anyone with read access to the repository contents and deployments can use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
func (c *Client) ActionsReviewPendingDeploymentsForRun(ctx context.Context, request *ActionsReviewPendingDeploymentsForRunReq, params ActionsReviewPendingDeploymentsForRunParams) ([]Deployment, error) {
	res, err := c.sendActionsReviewPendingDeploymentsForRun(ctx, request, params)
	return res, err
}

func (c *Client) sendActionsReviewPendingDeploymentsForRun(ctx context.Context, request *ActionsReviewPendingDeploymentsForRunReq, params ActionsReviewPendingDeploymentsForRunParams) (res []Deployment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/review-pending-deployments-for-run"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsReviewPendingDeploymentsForRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/pending_deployments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsReviewPendingDeploymentsForRunRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsReviewPendingDeploymentsForRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetAllowedActionsOrganization invokes actions/set-allowed-actions-organization operation.
//
// Sets the actions that are allowed in an organization. To use this endpoint, the organization
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// If the organization belongs to an enterprise that has `selected` actions set at the enterprise
// level, then you cannot override any of the enterprise's allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the organization must belong to an
// enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories in the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (c *Client) ActionsSetAllowedActionsOrganization(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsOrganizationParams) error {
	_, err := c.sendActionsSetAllowedActionsOrganization(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetAllowedActionsOrganization(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsOrganizationParams) (res *ActionsSetAllowedActionsOrganizationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-organization"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/selected-actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/selected-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetAllowedActionsOrganizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetAllowedActionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetAllowedActionsRepository invokes actions/set-allowed-actions-repository operation.
//
// Sets the actions that are allowed in a repository. To use this endpoint, the repository permission
// policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set
// GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
// If the repository belongs to an organization or enterprise that has `selected` actions set at the
// organization or enterprise levels, then you cannot override any of the allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the repository must belong to an
// enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (c *Client) ActionsSetAllowedActionsRepository(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsRepositoryParams) error {
	_, err := c.sendActionsSetAllowedActionsRepository(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetAllowedActionsRepository(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsRepositoryParams) (res *ActionsSetAllowedActionsRepositoryNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-repository"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions/selected-actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/permissions/selected-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetAllowedActionsRepositoryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetAllowedActionsRepositoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetGithubActionsPermissionsOrganization invokes actions/set-github-actions-permissions-organization operation.
//
// Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// If the organization belongs to an enterprise that has set restrictive permissions at the
// enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them
// for the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions
func (c *Client) ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, request *ActionsSetGithubActionsPermissionsOrganizationReq, params ActionsSetGithubActionsPermissionsOrganizationParams) error {
	_, err := c.sendActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetGithubActionsPermissionsOrganization(ctx context.Context, request *ActionsSetGithubActionsPermissionsOrganizationReq, params ActionsSetGithubActionsPermissionsOrganizationParams) (res *ActionsSetGithubActionsPermissionsOrganizationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-organization"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetGithubActionsPermissionsOrganizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetGithubActionsPermissionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetGithubActionsPermissionsRepository invokes actions/set-github-actions-permissions-repository operation.
//
// Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the
// repository.
// If the repository belongs to an organization or enterprise that has set restrictive permissions at
// the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you
// cannot override them for the repository.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (c *Client) ActionsSetGithubActionsPermissionsRepository(ctx context.Context, request *ActionsSetGithubActionsPermissionsRepositoryReq, params ActionsSetGithubActionsPermissionsRepositoryParams) error {
	_, err := c.sendActionsSetGithubActionsPermissionsRepository(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetGithubActionsPermissionsRepository(ctx context.Context, request *ActionsSetGithubActionsPermissionsRepositoryReq, params ActionsSetGithubActionsPermissionsRepositoryParams) (res *ActionsSetGithubActionsPermissionsRepositoryNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-repository"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/actions/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetGithubActionsPermissionsRepositoryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetGithubActionsPermissionsRepositoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of repositories that have access to a self-hosted runner group configured in an
// organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (c *Client) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, request *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq, params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) error {
	_, err := c.sendActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, request *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq, params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) (res *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetSelectedReposForOrgSecret invokes actions/set-selected-repos-for-org-secret operation.
//
// Replaces all repositories for an organization secret when the `visibility` for repository access
// is set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (c *Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, request *ActionsSetSelectedReposForOrgSecretReq, params ActionsSetSelectedReposForOrgSecretParams) error {
	_, err := c.sendActionsSetSelectedReposForOrgSecret(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetSelectedReposForOrgSecret(ctx context.Context, request *ActionsSetSelectedReposForOrgSecretReq, params ActionsSetSelectedReposForOrgSecretParams) (res *ActionsSetSelectedReposForOrgSecretNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repos-for-org-secret"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetSelectedReposForOrgSecretRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetSelectedReposForOrgSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization invokes actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// Replaces the list of selected repositories that are enabled for GitHub Actions in an organization.
// To use this endpoint, the organization permission policy for `enabled_repositories` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (c *Client) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, request *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq, params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) error {
	_, err := c.sendActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, request *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq, params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) (res *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repositories-enabled-github-actions-organization"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetSelfHostedRunnersInGroupForOrg invokes actions/set-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of self-hosted runners that are part of an organization runner group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) ActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, request *ActionsSetSelfHostedRunnersInGroupForOrgReq, params ActionsSetSelfHostedRunnersInGroupForOrgParams) error {
	_, err := c.sendActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
	return err
}

func (c *Client) sendActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, request *ActionsSetSelfHostedRunnersInGroupForOrgReq, params ActionsSetSelfHostedRunnersInGroupForOrgParams) (res *ActionsSetSelfHostedRunnersInGroupForOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-self-hosted-runners-in-group-for-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsSetSelfHostedRunnersInGroupForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsSetSelfHostedRunnersInGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsUpdateSelfHostedRunnerGroupForOrg invokes actions/update-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Updates the `name` and `visibility` of a self-hosted runner group in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (c *Client) ActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, request *ActionsUpdateSelfHostedRunnerGroupForOrgReq, params ActionsUpdateSelfHostedRunnerGroupForOrgParams) (*RunnerGroupsOrg, error) {
	res, err := c.sendActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, request *ActionsUpdateSelfHostedRunnerGroupForOrgReq, params ActionsUpdateSelfHostedRunnerGroupForOrgParams) (res *RunnerGroupsOrg, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/update-self-hosted-runner-group-for-org"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsUpdateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityCheckRepoIsStarredByAuthenticatedUser invokes activity/check-repo-is-starred-by-authenticated-user operation.
//
// Check if a repository is starred by the authenticated user.
//
// GET /user/starred/{owner}/{repo}
func (c *Client) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, params ActivityCheckRepoIsStarredByAuthenticatedUserParams) (ActivityCheckRepoIsStarredByAuthenticatedUserRes, error) {
	res, err := c.sendActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, params ActivityCheckRepoIsStarredByAuthenticatedUserParams) (res ActivityCheckRepoIsStarredByAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/check-repo-is-starred-by-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/starred/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityCheckRepoIsStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/starred/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityDeleteRepoSubscription invokes activity/delete-repo-subscription operation.
//
// This endpoint should only be used to stop watching a repository. To control whether or not you
// wish to receive notifications from a repository, [set the repository's subscription
// manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
//
// DELETE /repos/{owner}/{repo}/subscription
func (c *Client) ActivityDeleteRepoSubscription(ctx context.Context, params ActivityDeleteRepoSubscriptionParams) error {
	_, err := c.sendActivityDeleteRepoSubscription(ctx, params)
	return err
}

func (c *Client) sendActivityDeleteRepoSubscription(ctx context.Context, params ActivityDeleteRepoSubscriptionParams) (res *ActivityDeleteRepoSubscriptionNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-repo-subscription"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityDeleteRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityDeleteRepoSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityDeleteThreadSubscription invokes activity/delete-thread-subscription operation.
//
// Mutes all future notifications for a conversation until you comment on the thread or get an
// **@mention**. If you are watching the repository of the thread, you will still receive
// notifications. To ignore future notifications for a repository you are watching, use the [Set a
// thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
// endpoint and set `ignore` to `true`.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (c *Client) ActivityDeleteThreadSubscription(ctx context.Context, params ActivityDeleteThreadSubscriptionParams) (ActivityDeleteThreadSubscriptionRes, error) {
	res, err := c.sendActivityDeleteThreadSubscription(ctx, params)
	return res, err
}

func (c *Client) sendActivityDeleteThreadSubscription(ctx context.Context, params ActivityDeleteThreadSubscriptionParams) (res ActivityDeleteThreadSubscriptionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-thread-subscription"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityDeleteThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityDeleteThreadSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetFeeds invokes activity/get-feeds operation.
//
// GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard))
// format. The Feeds API lists all the feeds available to the authenticated user:
// *   **Timeline**: The GitHub global public timeline
// *   **User**: The public timeline for any user, using [URI template](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia)
// *   **Current user public**: The public timeline for the authenticated user
// *   **Current user**: The private timeline for the authenticated user
// *   **Current user actor**: The private timeline for activity created by the authenticated user
// *   **Current user organizations**: The private timeline for the organizations the authenticated
// user is a member of.
// *   **Security advisories**: A collection of public announcements that provide information about
// security-related vulnerabilities in software on GitHub.
// **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use
// the older, non revocable auth tokens.
//
// GET /feeds
func (c *Client) ActivityGetFeeds(ctx context.Context) (*Feed, error) {
	res, err := c.sendActivityGetFeeds(ctx)
	return res, err
}

func (c *Client) sendActivityGetFeeds(ctx context.Context) (res *Feed, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-feeds"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/feeds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetFeeds",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/feeds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityGetFeedsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetRepoSubscription invokes activity/get-repo-subscription operation.
//
// Get a repository subscription.
//
// GET /repos/{owner}/{repo}/subscription
func (c *Client) ActivityGetRepoSubscription(ctx context.Context, params ActivityGetRepoSubscriptionParams) (ActivityGetRepoSubscriptionRes, error) {
	res, err := c.sendActivityGetRepoSubscription(ctx, params)
	return res, err
}

func (c *Client) sendActivityGetRepoSubscription(ctx context.Context, params ActivityGetRepoSubscriptionParams) (res ActivityGetRepoSubscriptionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-repo-subscription"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityGetRepoSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetThread invokes activity/get-thread operation.
//
// Get a thread.
//
// GET /notifications/threads/{thread_id}
func (c *Client) ActivityGetThread(ctx context.Context, params ActivityGetThreadParams) (ActivityGetThreadRes, error) {
	res, err := c.sendActivityGetThread(ctx, params)
	return res, err
}

func (c *Client) sendActivityGetThread(ctx context.Context, params ActivityGetThreadParams) (res ActivityGetThreadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetThread",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityGetThreadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetThreadSubscriptionForAuthenticatedUser invokes activity/get-thread-subscription-for-authenticated-user operation.
//
// This checks to see if the current user is subscribed to a thread. You can also [get a repository
// subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
// Note that subscriptions are only generated if a user is participating in a conversation--for
// example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
//
// GET /notifications/threads/{thread_id}/subscription
func (c *Client) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, params ActivityGetThreadSubscriptionForAuthenticatedUserParams) (ActivityGetThreadSubscriptionForAuthenticatedUserRes, error) {
	res, err := c.sendActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, params ActivityGetThreadSubscriptionForAuthenticatedUserParams) (res ActivityGetThreadSubscriptionForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread-subscription-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetThreadSubscriptionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListEventsForAuthenticatedUser invokes activity/list-events-for-authenticated-user operation.
//
// If you are authenticated as the given user, you will see your private events. Otherwise, you'll
// only see public events.
//
// GET /users/{username}/events
func (c *Client) ActivityListEventsForAuthenticatedUser(ctx context.Context, params ActivityListEventsForAuthenticatedUserParams) ([]Event, error) {
	res, err := c.sendActivityListEventsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListEventsForAuthenticatedUser(ctx context.Context, params ActivityListEventsForAuthenticatedUserParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-events-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListEventsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListNotificationsForAuthenticatedUser invokes activity/list-notifications-for-authenticated-user operation.
//
// List all notifications for the current user, sorted by most recently updated.
//
// GET /notifications
func (c *Client) ActivityListNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListNotificationsForAuthenticatedUserParams) (ActivityListNotificationsForAuthenticatedUserRes, error) {
	res, err := c.sendActivityListNotificationsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListNotificationsForAuthenticatedUserParams) (res ActivityListNotificationsForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-notifications-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/notifications"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "participating" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "participating",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Participating.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "before" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListNotificationsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListOrgEventsForAuthenticatedUser invokes activity/list-org-events-for-authenticated-user operation.
//
// This is the user's organization dashboard. You must be authenticated as the user to view this.
//
// GET /users/{username}/events/orgs/{org}
func (c *Client) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, params ActivityListOrgEventsForAuthenticatedUserParams) ([]Event, error) {
	res, err := c.sendActivityListOrgEventsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListOrgEventsForAuthenticatedUser(ctx context.Context, params ActivityListOrgEventsForAuthenticatedUserParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-org-events-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/events/orgs/{org}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListOrgEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/events/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListOrgEventsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicEvents invokes activity/list-public-events operation.
//
// We delay the public events feed by five minutes, which means the most recent event returned by the
// public events API actually occurred at least five minutes ago.
//
// GET /events
func (c *Client) ActivityListPublicEvents(ctx context.Context, params ActivityListPublicEventsParams) (ActivityListPublicEventsRes, error) {
	res, err := c.sendActivityListPublicEvents(ctx, params)
	return res, err
}

func (c *Client) sendActivityListPublicEvents(ctx context.Context, params ActivityListPublicEventsParams) (res ActivityListPublicEventsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicEvents",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListPublicEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicEventsForRepoNetwork invokes activity/list-public-events-for-repo-network operation.
//
// List public events for a network of repositories.
//
// GET /networks/{owner}/{repo}/events
func (c *Client) ActivityListPublicEventsForRepoNetwork(ctx context.Context, params ActivityListPublicEventsForRepoNetworkParams) (ActivityListPublicEventsForRepoNetworkRes, error) {
	res, err := c.sendActivityListPublicEventsForRepoNetwork(ctx, params)
	return res, err
}

func (c *Client) sendActivityListPublicEventsForRepoNetwork(ctx context.Context, params ActivityListPublicEventsForRepoNetworkParams) (res ActivityListPublicEventsForRepoNetworkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-repo-network"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/networks/{owner}/{repo}/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicEventsForRepoNetwork",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/networks/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListPublicEventsForRepoNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicEventsForUser invokes activity/list-public-events-for-user operation.
//
// List public events for a user.
//
// GET /users/{username}/events/public
func (c *Client) ActivityListPublicEventsForUser(ctx context.Context, params ActivityListPublicEventsForUserParams) ([]Event, error) {
	res, err := c.sendActivityListPublicEventsForUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListPublicEventsForUser(ctx context.Context, params ActivityListPublicEventsForUserParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/events/public"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/events/public"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListPublicEventsForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicOrgEvents invokes activity/list-public-org-events operation.
//
// List public organization events.
//
// GET /orgs/{org}/events
func (c *Client) ActivityListPublicOrgEvents(ctx context.Context, params ActivityListPublicOrgEventsParams) ([]Event, error) {
	res, err := c.sendActivityListPublicOrgEvents(ctx, params)
	return res, err
}

func (c *Client) sendActivityListPublicOrgEvents(ctx context.Context, params ActivityListPublicOrgEventsParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-org-events"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicOrgEvents",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListPublicOrgEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReceivedEventsForUser invokes activity/list-received-events-for-user operation.
//
// These are events that you've received by watching repos and following users. If you are
// authenticated as the given user, you will see private events. Otherwise, you'll only see public
// events.
//
// GET /users/{username}/received_events
func (c *Client) ActivityListReceivedEventsForUser(ctx context.Context, params ActivityListReceivedEventsForUserParams) ([]Event, error) {
	res, err := c.sendActivityListReceivedEventsForUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListReceivedEventsForUser(ctx context.Context, params ActivityListReceivedEventsForUserParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-events-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/received_events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReceivedEventsForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/received_events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListReceivedEventsForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReceivedPublicEventsForUser invokes activity/list-received-public-events-for-user operation.
//
// List public events received by a user.
//
// GET /users/{username}/received_events/public
func (c *Client) ActivityListReceivedPublicEventsForUser(ctx context.Context, params ActivityListReceivedPublicEventsForUserParams) ([]Event, error) {
	res, err := c.sendActivityListReceivedPublicEventsForUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListReceivedPublicEventsForUser(ctx context.Context, params ActivityListReceivedPublicEventsForUserParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-public-events-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/received_events/public"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReceivedPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/received_events/public"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListReceivedPublicEventsForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListRepoEvents invokes activity/list-repo-events operation.
//
// List repository events.
//
// GET /repos/{owner}/{repo}/events
func (c *Client) ActivityListRepoEvents(ctx context.Context, params ActivityListRepoEventsParams) ([]Event, error) {
	res, err := c.sendActivityListRepoEvents(ctx, params)
	return res, err
}

func (c *Client) sendActivityListRepoEvents(ctx context.Context, params ActivityListRepoEventsParams) (res []Event, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-events"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListRepoEvents",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListRepoEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListRepoNotificationsForAuthenticatedUser invokes activity/list-repo-notifications-for-authenticated-user operation.
//
// List all notifications for the current user.
//
// GET /repos/{owner}/{repo}/notifications
func (c *Client) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListRepoNotificationsForAuthenticatedUserParams) (*ActivityListRepoNotificationsForAuthenticatedUserOKHeaders, error) {
	res, err := c.sendActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListRepoNotificationsForAuthenticatedUserParams) (res *ActivityListRepoNotificationsForAuthenticatedUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-notifications-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/notifications"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListRepoNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "participating" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "participating",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Participating.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "before" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListRepoNotificationsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReposStarredByAuthenticatedUser invokes activity/list-repos-starred-by-authenticated-user operation.
//
// Lists repositories the authenticated user has starred.
// You can also find out _when_ stars were created by passing the following custom [media
// type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:.
//
// GET /user/starred
func (c *Client) ActivityListReposStarredByAuthenticatedUser(ctx context.Context, params ActivityListReposStarredByAuthenticatedUserParams) (ActivityListReposStarredByAuthenticatedUserRes, error) {
	res, err := c.sendActivityListReposStarredByAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListReposStarredByAuthenticatedUser(ctx context.Context, params ActivityListReposStarredByAuthenticatedUserParams) (res ActivityListReposStarredByAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-starred-by-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/starred"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReposStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/starred"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListReposStarredByAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReposWatchedByUser invokes activity/list-repos-watched-by-user operation.
//
// Lists repositories a user is watching.
//
// GET /users/{username}/subscriptions
func (c *Client) ActivityListReposWatchedByUser(ctx context.Context, params ActivityListReposWatchedByUserParams) (*ActivityListReposWatchedByUserOKHeaders, error) {
	res, err := c.sendActivityListReposWatchedByUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListReposWatchedByUser(ctx context.Context, params ActivityListReposWatchedByUserParams) (res *ActivityListReposWatchedByUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-watched-by-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/subscriptions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReposWatchedByUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListReposWatchedByUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListWatchedReposForAuthenticatedUser invokes activity/list-watched-repos-for-authenticated-user operation.
//
// Lists repositories the authenticated user is watching.
//
// GET /user/subscriptions
func (c *Client) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, params ActivityListWatchedReposForAuthenticatedUserParams) (ActivityListWatchedReposForAuthenticatedUserRes, error) {
	res, err := c.sendActivityListWatchedReposForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityListWatchedReposForAuthenticatedUser(ctx context.Context, params ActivityListWatchedReposForAuthenticatedUserParams) (res ActivityListWatchedReposForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watched-repos-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/subscriptions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListWatchedReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListWatchedReposForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListWatchersForRepo invokes activity/list-watchers-for-repo operation.
//
// Lists the people watching the specified repository.
//
// GET /repos/{owner}/{repo}/subscribers
func (c *Client) ActivityListWatchersForRepo(ctx context.Context, params ActivityListWatchersForRepoParams) (*ActivityListWatchersForRepoOKHeaders, error) {
	res, err := c.sendActivityListWatchersForRepo(ctx, params)
	return res, err
}

func (c *Client) sendActivityListWatchersForRepo(ctx context.Context, params ActivityListWatchersForRepoParams) (res *ActivityListWatchersForRepoOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watchers-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscribers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListWatchersForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/subscribers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityListWatchersForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityMarkNotificationsAsRead invokes activity/mark-notifications-as-read operation.
//
// Marks all notifications as "read" removes it from the [default view on GitHub](https://github.
// com/notifications). If the number of notifications is too large to complete in one request, you
// will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark
// notifications as "read." To check whether any "unread" notifications remain, you can use the [List
// notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the
// query parameter `all=false`.
//
// PUT /notifications
func (c *Client) ActivityMarkNotificationsAsRead(ctx context.Context, request OptActivityMarkNotificationsAsReadReq) (ActivityMarkNotificationsAsReadRes, error) {
	res, err := c.sendActivityMarkNotificationsAsRead(ctx, request)
	return res, err
}

func (c *Client) sendActivityMarkNotificationsAsRead(ctx context.Context, request OptActivityMarkNotificationsAsReadReq) (res ActivityMarkNotificationsAsReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-notifications-as-read"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/notifications"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityMarkNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActivityMarkNotificationsAsReadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityMarkNotificationsAsReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityMarkRepoNotificationsAsRead invokes activity/mark-repo-notifications-as-read operation.
//
// Marks all notifications in a repository as "read" removes them from the [default view on
// GitHub](https://github.com/notifications). If the number of notifications is too large to complete
// in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous
// process to mark notifications as "read." To check whether any "unread" notifications remain, you
// can use the [List repository notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and
// pass the query parameter `all=false`.
//
// PUT /repos/{owner}/{repo}/notifications
func (c *Client) ActivityMarkRepoNotificationsAsRead(ctx context.Context, request OptActivityMarkRepoNotificationsAsReadReq, params ActivityMarkRepoNotificationsAsReadParams) (ActivityMarkRepoNotificationsAsReadRes, error) {
	res, err := c.sendActivityMarkRepoNotificationsAsRead(ctx, request, params)
	return res, err
}

func (c *Client) sendActivityMarkRepoNotificationsAsRead(ctx context.Context, request OptActivityMarkRepoNotificationsAsReadReq, params ActivityMarkRepoNotificationsAsReadParams) (res ActivityMarkRepoNotificationsAsReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-repo-notifications-as-read"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/notifications"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityMarkRepoNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActivityMarkRepoNotificationsAsReadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityMarkRepoNotificationsAsReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityMarkThreadAsRead invokes activity/mark-thread-as-read operation.
//
// Mark a thread as read.
//
// PATCH /notifications/threads/{thread_id}
func (c *Client) ActivityMarkThreadAsRead(ctx context.Context, params ActivityMarkThreadAsReadParams) (ActivityMarkThreadAsReadRes, error) {
	res, err := c.sendActivityMarkThreadAsRead(ctx, params)
	return res, err
}

func (c *Client) sendActivityMarkThreadAsRead(ctx context.Context, params ActivityMarkThreadAsReadParams) (res ActivityMarkThreadAsReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-thread-as-read"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityMarkThreadAsRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityMarkThreadAsReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivitySetRepoSubscription invokes activity/set-repo-subscription operation.
//
// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore
// notifications made within a repository, set `ignored` to `true`. If you would like to stop
// watching a repository, [delete the repository's subscription](https://docs.github.
// com/rest/reference/activity#delete-a-repository-subscription) completely.
//
// PUT /repos/{owner}/{repo}/subscription
func (c *Client) ActivitySetRepoSubscription(ctx context.Context, request OptActivitySetRepoSubscriptionReq, params ActivitySetRepoSubscriptionParams) (*RepositorySubscription, error) {
	res, err := c.sendActivitySetRepoSubscription(ctx, request, params)
	return res, err
}

func (c *Client) sendActivitySetRepoSubscription(ctx context.Context, request OptActivitySetRepoSubscriptionReq, params ActivitySetRepoSubscriptionParams) (res *RepositorySubscription, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-repo-subscription"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivitySetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActivitySetRepoSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivitySetRepoSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivitySetThreadSubscription invokes activity/set-thread-subscription operation.
//
// If you are watching a repository, you receive notifications for all threads by default. Use this
// endpoint to ignore future notifications for threads until you comment on the thread or get an
// **@mention**.
// You can also use this endpoint to subscribe to threads that you are currently not receiving
// notifications for or to subscribed to threads that you have previously ignored.
// Unsubscribing from a conversation in a repository that you are not watching is functionally
// equivalent to the [Delete a thread subscription](https://docs.github.
// com/rest/reference/activity#delete-a-thread-subscription) endpoint.
//
// PUT /notifications/threads/{thread_id}/subscription
func (c *Client) ActivitySetThreadSubscription(ctx context.Context, request OptActivitySetThreadSubscriptionReq, params ActivitySetThreadSubscriptionParams) (ActivitySetThreadSubscriptionRes, error) {
	res, err := c.sendActivitySetThreadSubscription(ctx, request, params)
	return res, err
}

func (c *Client) sendActivitySetThreadSubscription(ctx context.Context, request OptActivitySetThreadSubscriptionReq, params ActivitySetThreadSubscriptionParams) (res ActivitySetThreadSubscriptionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-thread-subscription"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivitySetThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActivitySetThreadSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivitySetThreadSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityStarRepoForAuthenticatedUser invokes activity/star-repo-for-authenticated-user operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /user/starred/{owner}/{repo}
func (c *Client) ActivityStarRepoForAuthenticatedUser(ctx context.Context, params ActivityStarRepoForAuthenticatedUserParams) (ActivityStarRepoForAuthenticatedUserRes, error) {
	res, err := c.sendActivityStarRepoForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityStarRepoForAuthenticatedUser(ctx context.Context, params ActivityStarRepoForAuthenticatedUserParams) (res ActivityStarRepoForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/star-repo-for-authenticated-user"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/starred/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityStarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/starred/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityStarRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityUnstarRepoForAuthenticatedUser invokes activity/unstar-repo-for-authenticated-user operation.
//
// Unstar a repository for the authenticated user.
//
// DELETE /user/starred/{owner}/{repo}
func (c *Client) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, params ActivityUnstarRepoForAuthenticatedUserParams) (ActivityUnstarRepoForAuthenticatedUserRes, error) {
	res, err := c.sendActivityUnstarRepoForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendActivityUnstarRepoForAuthenticatedUser(ctx context.Context, params ActivityUnstarRepoForAuthenticatedUserParams) (res ActivityUnstarRepoForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/unstar-repo-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/starred/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityUnstarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/starred/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActivityUnstarRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsAddRepoToInstallation invokes apps/add-repo-to-installation operation.
//
// Add a single repository to an installation. The authenticated user must have admin access to the
// repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (c *Client) AppsAddRepoToInstallation(ctx context.Context, params AppsAddRepoToInstallationParams) (AppsAddRepoToInstallationRes, error) {
	res, err := c.sendAppsAddRepoToInstallation(ctx, params)
	return res, err
}

func (c *Client) sendAppsAddRepoToInstallation(ctx context.Context, params AppsAddRepoToInstallationParams) (res AppsAddRepoToInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/add-repo-to-installation"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/installations/{installation_id}/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsAddRepoToInstallation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsAddRepoToInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCheckToken invokes apps/check-token operation.
//
// OAuth applications can use a special API method for checking OAuth token validity without
// exceeding the normal rate limits for failed login attempts. Authentication works differently with
// this particular endpoint. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where
// the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid
// tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token
func (c *Client) AppsCheckToken(ctx context.Context, request *AppsCheckTokenReq, params AppsCheckTokenParams) (AppsCheckTokenRes, error) {
	res, err := c.sendAppsCheckToken(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsCheckToken(ctx context.Context, request *AppsCheckTokenReq, params AppsCheckTokenParams) (res AppsCheckTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/check-token"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCheckToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsCheckTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsCheckTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCreateContentAttachment invokes apps/create-content-attachment operation.
//
// Creates an attachment under a content reference URL in the body or comment of an issue or pull
// request. Use the `id` and `repository` `full_name` of the content reference from the
// [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to
// create an attachment.
// The app must create a content attachment within six hours of the content reference URL being
// posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)"
// for details about content attachments.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
func (c *Client) AppsCreateContentAttachment(ctx context.Context, request *AppsCreateContentAttachmentReq, params AppsCreateContentAttachmentParams) (AppsCreateContentAttachmentRes, error) {
	res, err := c.sendAppsCreateContentAttachment(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsCreateContentAttachment(ctx context.Context, request *AppsCreateContentAttachmentReq, params AppsCreateContentAttachmentParams) (res AppsCreateContentAttachmentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-content-attachment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCreateContentAttachment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/content_references/"
	{
		// Encode "content_reference_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "content_reference_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ContentReferenceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/attachments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsCreateContentAttachmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsCreateContentAttachmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCreateFromManifest invokes apps/create-from-manifest operation.
//
// Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest
// flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/).
// When you create a GitHub App with the manifest flow, you receive a temporary `code` used to
// retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
//
// POST /app-manifests/{code}/conversions
func (c *Client) AppsCreateFromManifest(ctx context.Context, request *AppsCreateFromManifestReq, params AppsCreateFromManifestParams) (AppsCreateFromManifestRes, error) {
	res, err := c.sendAppsCreateFromManifest(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsCreateFromManifest(ctx context.Context, request *AppsCreateFromManifestReq, params AppsCreateFromManifestParams) (res AppsCreateFromManifestRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-from-manifest"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/app-manifests/{code}/conversions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCreateFromManifest",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/app-manifests/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/conversions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsCreateFromManifestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsCreateFromManifestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCreateInstallationAccessToken invokes apps/create-installation-access-token operation.
//
// Creates an installation access token that enables a GitHub App to make authenticated API requests
// for the app's installation on an organization or individual account. Installation tokens expire
// one hour from the time you create them. Using an expired token produces a status code of `401 -
// Unauthorized`, and requires creating a new installation token. By default the installation token
// has access to all repositories that the installation can access. To restrict the access to
// specific repositories, you can provide the `repository_ids` when creating the token. When you omit
// `repository_ids`, the response does not contain the `repositories` key.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/installations/{installation_id}/access_tokens
func (c *Client) AppsCreateInstallationAccessToken(ctx context.Context, request OptAppsCreateInstallationAccessTokenReq, params AppsCreateInstallationAccessTokenParams) (AppsCreateInstallationAccessTokenRes, error) {
	res, err := c.sendAppsCreateInstallationAccessToken(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsCreateInstallationAccessToken(ctx context.Context, request OptAppsCreateInstallationAccessTokenReq, params AppsCreateInstallationAccessTokenParams) (res AppsCreateInstallationAccessTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-installation-access-token"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}/access_tokens"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCreateInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access_tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsCreateInstallationAccessTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsCreateInstallationAccessTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsDeleteAuthorization invokes apps/delete-authorization operation.
//
// OAuth application owners can revoke a grant for their OAuth application and a specific user. You
// must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password. You
// must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's
// owner will be deleted.
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for the user. Once deleted, the application will have no access to the user's account
// and will no longer be listed on [the application authorizations settings screen within
// GitHub](https://github.com/settings/applications#authorized).
//
// DELETE /applications/{client_id}/grant
func (c *Client) AppsDeleteAuthorization(ctx context.Context, request *AppsDeleteAuthorizationReq, params AppsDeleteAuthorizationParams) (AppsDeleteAuthorizationRes, error) {
	res, err := c.sendAppsDeleteAuthorization(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsDeleteAuthorization(ctx context.Context, request *AppsDeleteAuthorizationReq, params AppsDeleteAuthorizationParams) (res AppsDeleteAuthorizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-authorization"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/grant"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/grant"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsDeleteAuthorizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsDeleteAuthorizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsDeleteInstallation invokes apps/delete-installation operation.
//
// Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily
// suspend an app's access to your account's resources, then we recommend the "[Suspend an app
// installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}
func (c *Client) AppsDeleteInstallation(ctx context.Context, params AppsDeleteInstallationParams) (AppsDeleteInstallationRes, error) {
	res, err := c.sendAppsDeleteInstallation(ctx, params)
	return res, err
}

func (c *Client) sendAppsDeleteInstallation(ctx context.Context, params AppsDeleteInstallationParams) (res AppsDeleteInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-installation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsDeleteInstallation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsDeleteInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsDeleteToken invokes apps/delete-token operation.
//
// OAuth application owners can revoke a single token for an OAuth application. You must use [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
//
// DELETE /applications/{client_id}/token
func (c *Client) AppsDeleteToken(ctx context.Context, request *AppsDeleteTokenReq, params AppsDeleteTokenParams) (AppsDeleteTokenRes, error) {
	res, err := c.sendAppsDeleteToken(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsDeleteToken(ctx context.Context, request *AppsDeleteTokenReq, params AppsDeleteTokenParams) (res AppsDeleteTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-token"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsDeleteToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsDeleteTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsDeleteTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetAuthenticated invokes apps/get-authenticated operation.
//
// Returns the GitHub App associated with the authentication credentials used. To see how many app
// installations are associated with this GitHub App, see the `installations_count` in the response.
// For more details about your app's installations, see the "[List installations for the
// authenticated app](https://docs.github.
// com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app
func (c *Client) AppsGetAuthenticated(ctx context.Context) (*Integration, error) {
	res, err := c.sendAppsGetAuthenticated(ctx)
	return res, err
}

func (c *Client) sendAppsGetAuthenticated(ctx context.Context) (res *Integration, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/app"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsGetAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetBySlug invokes apps/get-by-slug operation.
//
// **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on
// the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
// If the GitHub App you specify is public, you can access this endpoint without authenticating. If
// the GitHub App you specify is private, you must authenticate with a [personal access
// token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or
// an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /apps/{app_slug}
func (c *Client) AppsGetBySlug(ctx context.Context, params AppsGetBySlugParams) (AppsGetBySlugRes, error) {
	res, err := c.sendAppsGetBySlug(ctx, params)
	return res, err
}

func (c *Client) sendAppsGetBySlug(ctx context.Context, params AppsGetBySlugParams) (res AppsGetBySlugRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-by-slug"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apps/{app_slug}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetBySlug",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/apps/"
	{
		// Encode "app_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "app_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AppSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsGetBySlugResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetSubscriptionPlanForAccount invokes apps/get-subscription-plan-for-account operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/accounts/{account_id}
func (c *Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, params AppsGetSubscriptionPlanForAccountParams) (AppsGetSubscriptionPlanForAccountRes, error) {
	res, err := c.sendAppsGetSubscriptionPlanForAccount(ctx, params)
	return res, err
}

func (c *Client) sendAppsGetSubscriptionPlanForAccount(ctx context.Context, params AppsGetSubscriptionPlanForAccountParams) (res AppsGetSubscriptionPlanForAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/accounts/{account_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetSubscriptionPlanForAccount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/marketplace_listing/accounts/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AccountID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsGetSubscriptionPlanForAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetSubscriptionPlanForAccountStubbed invokes apps/get-subscription-plan-for-account-stubbed operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (c *Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, params AppsGetSubscriptionPlanForAccountStubbedParams) (AppsGetSubscriptionPlanForAccountStubbedRes, error) {
	res, err := c.sendAppsGetSubscriptionPlanForAccountStubbed(ctx, params)
	return res, err
}

func (c *Client) sendAppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, params AppsGetSubscriptionPlanForAccountStubbedParams) (res AppsGetSubscriptionPlanForAccountStubbedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account-stubbed"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/stubbed/accounts/{account_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetSubscriptionPlanForAccountStubbed",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/marketplace_listing/stubbed/accounts/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AccountID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsGetSubscriptionPlanForAccountStubbedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetWebhookConfigForApp invokes apps/get-webhook-config-for-app operation.
//
// Returns the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/config
func (c *Client) AppsGetWebhookConfigForApp(ctx context.Context) (*WebhookConfig, error) {
	res, err := c.sendAppsGetWebhookConfigForApp(ctx)
	return res, err
}

func (c *Client) sendAppsGetWebhookConfigForApp(ctx context.Context) (res *WebhookConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-config-for-app"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app/hook/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/app/hook/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsGetWebhookConfigForAppResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetWebhookDelivery invokes apps/get-webhook-delivery operation.
//
// Returns a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries/{delivery_id}
func (c *Client) AppsGetWebhookDelivery(ctx context.Context, params AppsGetWebhookDeliveryParams) (AppsGetWebhookDeliveryRes, error) {
	res, err := c.sendAppsGetWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendAppsGetWebhookDelivery(ctx context.Context, params AppsGetWebhookDeliveryParams) (res AppsGetWebhookDeliveryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-delivery"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app/hook/deliveries/{delivery_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/app/hook/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsGetWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListAccountsForPlan invokes apps/list-accounts-for-plan operation.
//
// Returns user and organization accounts associated with the specified plan, including free plans.
// For per-seat pricing, you see the list of accounts that have purchased the plan, including the
// number of seats purchased. When someone submits a plan change that won't be processed until the
// end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans/{plan_id}/accounts
func (c *Client) AppsListAccountsForPlan(ctx context.Context, params AppsListAccountsForPlanParams) (AppsListAccountsForPlanRes, error) {
	res, err := c.sendAppsListAccountsForPlan(ctx, params)
	return res, err
}

func (c *Client) sendAppsListAccountsForPlan(ctx context.Context, params AppsListAccountsForPlanParams) (res AppsListAccountsForPlanRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/plans/{plan_id}/accounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListAccountsForPlan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/marketplace_listing/plans/"
	{
		// Encode "plan_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "plan_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PlanID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListAccountsForPlanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListAccountsForPlanStubbed invokes apps/list-accounts-for-plan-stubbed operation.
//
// Returns repository and organization accounts associated with the specified plan, including free
// plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including
// the number of seats purchased. When someone submits a plan change that won't be processed until
// the end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (c *Client) AppsListAccountsForPlanStubbed(ctx context.Context, params AppsListAccountsForPlanStubbedParams) (AppsListAccountsForPlanStubbedRes, error) {
	res, err := c.sendAppsListAccountsForPlanStubbed(ctx, params)
	return res, err
}

func (c *Client) sendAppsListAccountsForPlanStubbed(ctx context.Context, params AppsListAccountsForPlanStubbedParams) (res AppsListAccountsForPlanStubbedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan-stubbed"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/stubbed/plans/{plan_id}/accounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListAccountsForPlanStubbed",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/marketplace_listing/stubbed/plans/"
	{
		// Encode "plan_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "plan_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PlanID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListAccountsForPlanStubbedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListInstallationReposForAuthenticatedUser invokes apps/list-installation-repos-for-authenticated-user operation.
//
// List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access for an installation.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
// You must use a [user-to-server OAuth access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
// The access the user has to each repository is included in the hash under the `permissions` key.
//
// GET /user/installations/{installation_id}/repositories
func (c *Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, params AppsListInstallationReposForAuthenticatedUserParams) (AppsListInstallationReposForAuthenticatedUserRes, error) {
	res, err := c.sendAppsListInstallationReposForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendAppsListInstallationReposForAuthenticatedUser(ctx context.Context, params AppsListInstallationReposForAuthenticatedUserParams) (res AppsListInstallationReposForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-installation-repos-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/installations/{installation_id}/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListInstallationReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListInstallationReposForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListPlans invokes apps/list-plans operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans
func (c *Client) AppsListPlans(ctx context.Context, params AppsListPlansParams) (AppsListPlansRes, error) {
	res, err := c.sendAppsListPlans(ctx, params)
	return res, err
}

func (c *Client) sendAppsListPlans(ctx context.Context, params AppsListPlansParams) (res AppsListPlansRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListPlans",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/marketplace_listing/plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListPlansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListPlansStubbed invokes apps/list-plans-stubbed operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans
func (c *Client) AppsListPlansStubbed(ctx context.Context, params AppsListPlansStubbedParams) (AppsListPlansStubbedRes, error) {
	res, err := c.sendAppsListPlansStubbed(ctx, params)
	return res, err
}

func (c *Client) sendAppsListPlansStubbed(ctx context.Context, params AppsListPlansStubbedParams) (res AppsListPlansStubbedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans-stubbed"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/stubbed/plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListPlansStubbed",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/marketplace_listing/stubbed/plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListPlansStubbedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListReposAccessibleToInstallation invokes apps/list-repos-accessible-to-installation operation.
//
// List repositories that an app installation can access.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /installation/repositories
func (c *Client) AppsListReposAccessibleToInstallation(ctx context.Context, params AppsListReposAccessibleToInstallationParams) (AppsListReposAccessibleToInstallationRes, error) {
	res, err := c.sendAppsListReposAccessibleToInstallation(ctx, params)
	return res, err
}

func (c *Client) sendAppsListReposAccessibleToInstallation(ctx context.Context, params AppsListReposAccessibleToInstallationParams) (res AppsListReposAccessibleToInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-repos-accessible-to-installation"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/installation/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListReposAccessibleToInstallation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/installation/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListReposAccessibleToInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListSubscriptionsForAuthenticatedUser invokes apps/list-subscriptions-for-authenticated-user operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases
func (c *Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserParams) (AppsListSubscriptionsForAuthenticatedUserRes, error) {
	res, err := c.sendAppsListSubscriptionsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendAppsListSubscriptionsForAuthenticatedUser(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserParams) (res AppsListSubscriptionsForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/marketplace_purchases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListSubscriptionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/marketplace_purchases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListSubscriptionsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListSubscriptionsForAuthenticatedUserStubbed invokes apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases/stubbed
func (c *Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserStubbedParams) (AppsListSubscriptionsForAuthenticatedUserStubbedRes, error) {
	res, err := c.sendAppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
	return res, err
}

func (c *Client) sendAppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserStubbedParams) (res AppsListSubscriptionsForAuthenticatedUserStubbedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user-stubbed"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/marketplace_purchases/stubbed"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListSubscriptionsForAuthenticatedUserStubbed",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/marketplace_purchases/stubbed"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListWebhookDeliveries invokes apps/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries
func (c *Client) AppsListWebhookDeliveries(ctx context.Context, params AppsListWebhookDeliveriesParams) (AppsListWebhookDeliveriesRes, error) {
	res, err := c.sendAppsListWebhookDeliveries(ctx, params)
	return res, err
}

func (c *Client) sendAppsListWebhookDeliveries(ctx context.Context, params AppsListWebhookDeliveriesParams) (res AppsListWebhookDeliveriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-webhook-deliveries"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app/hook/deliveries"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/app/hook/deliveries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsListWebhookDeliveriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsRedeliverWebhookDelivery invokes apps/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/hook/deliveries/{delivery_id}/attempts
func (c *Client) AppsRedeliverWebhookDelivery(ctx context.Context, params AppsRedeliverWebhookDeliveryParams) (AppsRedeliverWebhookDeliveryRes, error) {
	res, err := c.sendAppsRedeliverWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendAppsRedeliverWebhookDelivery(ctx context.Context, params AppsRedeliverWebhookDeliveryParams) (res AppsRedeliverWebhookDeliveryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/redeliver-webhook-delivery"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/app/hook/deliveries/{delivery_id}/attempts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/app/hook/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/attempts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsRedeliverWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsRemoveRepoFromInstallation invokes apps/remove-repo-from-installation operation.
//
// Remove a single repository from an installation. The authenticated user must have admin access to
// the repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (c *Client) AppsRemoveRepoFromInstallation(ctx context.Context, params AppsRemoveRepoFromInstallationParams) (AppsRemoveRepoFromInstallationRes, error) {
	res, err := c.sendAppsRemoveRepoFromInstallation(ctx, params)
	return res, err
}

func (c *Client) sendAppsRemoveRepoFromInstallation(ctx context.Context, params AppsRemoveRepoFromInstallationParams) (res AppsRemoveRepoFromInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/remove-repo-from-installation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/installations/{installation_id}/repositories/{repository_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsRemoveRepoFromInstallation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsRemoveRepoFromInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsResetToken invokes apps/reset-token operation.
//
// OAuth applications can use this API method to reset a valid OAuth token without end-user
// involvement. Applications must save the "token" property in the response because changes take
// effect immediately. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
// Invalid tokens will return `404 NOT FOUND`.
//
// PATCH /applications/{client_id}/token
func (c *Client) AppsResetToken(ctx context.Context, request *AppsResetTokenReq, params AppsResetTokenParams) (AppsResetTokenRes, error) {
	res, err := c.sendAppsResetToken(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsResetToken(ctx context.Context, request *AppsResetTokenReq, params AppsResetTokenParams) (res AppsResetTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/reset-token"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsResetToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsResetTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsResetTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsRevokeInstallationAccessToken invokes apps/revoke-installation-access-token operation.
//
// Revokes the installation token you're using to authenticate as an installation and access this
// endpoint.
// Once an installation token is revoked, the token is invalidated and cannot be used. Other
// endpoints that require the revoked installation token must have a new installation token to work.
// You can create a new token using the "[Create an installation access token for an
// app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
// endpoint.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// DELETE /installation/token
func (c *Client) AppsRevokeInstallationAccessToken(ctx context.Context) error {
	_, err := c.sendAppsRevokeInstallationAccessToken(ctx)
	return err
}

func (c *Client) sendAppsRevokeInstallationAccessToken(ctx context.Context) (res *AppsRevokeInstallationAccessTokenNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/revoke-installation-access-token"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/installation/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsRevokeInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/installation/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsRevokeInstallationAccessTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsScopeToken invokes apps/scope-token operation.
//
// Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission
// scoped user-to-server OAuth access token. You can specify which repositories the token can access
// and which permissions are granted to the token. You must use [Basic Authentication](https://docs.
// github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this
// endpoint, using the OAuth application's `client_id` and `client_secret` as the username and
// password. Invalid tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token/scoped
func (c *Client) AppsScopeToken(ctx context.Context, request *AppsScopeTokenReq, params AppsScopeTokenParams) (AppsScopeTokenRes, error) {
	res, err := c.sendAppsScopeToken(ctx, request, params)
	return res, err
}

func (c *Client) sendAppsScopeToken(ctx context.Context, request *AppsScopeTokenReq, params AppsScopeTokenParams) (res AppsScopeTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/scope-token"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token/scoped"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsScopeToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token/scoped"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsScopeTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsScopeTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsSuspendInstallation invokes apps/suspend-installation operation.
//
// Suspends a GitHub App on a user, organization, or business account, which blocks the app from
// accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub
// API or webhook events is blocked for that account.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PUT /app/installations/{installation_id}/suspended
func (c *Client) AppsSuspendInstallation(ctx context.Context, params AppsSuspendInstallationParams) (AppsSuspendInstallationRes, error) {
	res, err := c.sendAppsSuspendInstallation(ctx, params)
	return res, err
}

func (c *Client) sendAppsSuspendInstallation(ctx context.Context, params AppsSuspendInstallationParams) (res AppsSuspendInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/suspend-installation"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}/suspended"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsSuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/suspended"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsSuspendInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsUnsuspendInstallation invokes apps/unsuspend-installation operation.
//
// Removes a GitHub App installation suspension.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}/suspended
func (c *Client) AppsUnsuspendInstallation(ctx context.Context, params AppsUnsuspendInstallationParams) (AppsUnsuspendInstallationRes, error) {
	res, err := c.sendAppsUnsuspendInstallation(ctx, params)
	return res, err
}

func (c *Client) sendAppsUnsuspendInstallation(ctx context.Context, params AppsUnsuspendInstallationParams) (res AppsUnsuspendInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/unsuspend-installation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}/suspended"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsUnsuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/suspended"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsUnsuspendInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsUpdateWebhookConfigForApp invokes apps/update-webhook-config-for-app operation.
//
// Updates the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PATCH /app/hook/config
func (c *Client) AppsUpdateWebhookConfigForApp(ctx context.Context, request OptAppsUpdateWebhookConfigForAppReq) (*WebhookConfig, error) {
	res, err := c.sendAppsUpdateWebhookConfigForApp(ctx, request)
	return res, err
}

func (c *Client) sendAppsUpdateWebhookConfigForApp(ctx context.Context, request OptAppsUpdateWebhookConfigForAppReq) (res *WebhookConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/update-webhook-config-for-app"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/app/hook/config"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsUpdateWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/app/hook/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppsUpdateWebhookConfigForAppRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppsUpdateWebhookConfigForAppResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubActionsBillingGhe invokes billing/get-github-actions-billing-ghe operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (c *Client) BillingGetGithubActionsBillingGhe(ctx context.Context, params BillingGetGithubActionsBillingGheParams) (*ActionsBillingUsage, error) {
	res, err := c.sendBillingGetGithubActionsBillingGhe(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetGithubActionsBillingGhe(ctx context.Context, params BillingGetGithubActionsBillingGheParams) (res *ActionsBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-ghe"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/settings/billing/actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubActionsBillingGhe",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetGithubActionsBillingGheResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubActionsBillingOrg invokes billing/get-github-actions-billing-org operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/actions
func (c *Client) BillingGetGithubActionsBillingOrg(ctx context.Context, params BillingGetGithubActionsBillingOrgParams) (*ActionsBillingUsage, error) {
	res, err := c.sendBillingGetGithubActionsBillingOrg(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetGithubActionsBillingOrg(ctx context.Context, params BillingGetGithubActionsBillingOrgParams) (res *ActionsBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/settings/billing/actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubActionsBillingOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetGithubActionsBillingOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubActionsBillingUser invokes billing/get-github-actions-billing-user operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/actions
func (c *Client) BillingGetGithubActionsBillingUser(ctx context.Context, params BillingGetGithubActionsBillingUserParams) (*ActionsBillingUsage, error) {
	res, err := c.sendBillingGetGithubActionsBillingUser(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetGithubActionsBillingUser(ctx context.Context, params BillingGetGithubActionsBillingUserParams) (res *ActionsBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/settings/billing/actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubActionsBillingUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetGithubActionsBillingUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubPackagesBillingGhe invokes billing/get-github-packages-billing-ghe operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (c *Client) BillingGetGithubPackagesBillingGhe(ctx context.Context, params BillingGetGithubPackagesBillingGheParams) (*PackagesBillingUsage, error) {
	res, err := c.sendBillingGetGithubPackagesBillingGhe(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetGithubPackagesBillingGhe(ctx context.Context, params BillingGetGithubPackagesBillingGheParams) (res *PackagesBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-ghe"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/settings/billing/packages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubPackagesBillingGhe",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/packages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetGithubPackagesBillingGheResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubPackagesBillingOrg invokes billing/get-github-packages-billing-org operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/packages
func (c *Client) BillingGetGithubPackagesBillingOrg(ctx context.Context, params BillingGetGithubPackagesBillingOrgParams) (*PackagesBillingUsage, error) {
	res, err := c.sendBillingGetGithubPackagesBillingOrg(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetGithubPackagesBillingOrg(ctx context.Context, params BillingGetGithubPackagesBillingOrgParams) (res *PackagesBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/settings/billing/packages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubPackagesBillingOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/packages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetGithubPackagesBillingOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubPackagesBillingUser invokes billing/get-github-packages-billing-user operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/packages
func (c *Client) BillingGetGithubPackagesBillingUser(ctx context.Context, params BillingGetGithubPackagesBillingUserParams) (*PackagesBillingUsage, error) {
	res, err := c.sendBillingGetGithubPackagesBillingUser(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetGithubPackagesBillingUser(ctx context.Context, params BillingGetGithubPackagesBillingUserParams) (res *PackagesBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/settings/billing/packages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubPackagesBillingUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/packages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetGithubPackagesBillingUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetSharedStorageBillingGhe invokes billing/get-shared-storage-billing-ghe operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (c *Client) BillingGetSharedStorageBillingGhe(ctx context.Context, params BillingGetSharedStorageBillingGheParams) (*CombinedBillingUsage, error) {
	res, err := c.sendBillingGetSharedStorageBillingGhe(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetSharedStorageBillingGhe(ctx context.Context, params BillingGetSharedStorageBillingGheParams) (res *CombinedBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-ghe"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/settings/billing/shared-storage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetSharedStorageBillingGhe",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/shared-storage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetSharedStorageBillingGheResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetSharedStorageBillingOrg invokes billing/get-shared-storage-billing-org operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (c *Client) BillingGetSharedStorageBillingOrg(ctx context.Context, params BillingGetSharedStorageBillingOrgParams) (*CombinedBillingUsage, error) {
	res, err := c.sendBillingGetSharedStorageBillingOrg(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetSharedStorageBillingOrg(ctx context.Context, params BillingGetSharedStorageBillingOrgParams) (res *CombinedBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/settings/billing/shared-storage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetSharedStorageBillingOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/shared-storage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetSharedStorageBillingOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetSharedStorageBillingUser invokes billing/get-shared-storage-billing-user operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/shared-storage
func (c *Client) BillingGetSharedStorageBillingUser(ctx context.Context, params BillingGetSharedStorageBillingUserParams) (*CombinedBillingUsage, error) {
	res, err := c.sendBillingGetSharedStorageBillingUser(ctx, params)
	return res, err
}

func (c *Client) sendBillingGetSharedStorageBillingUser(ctx context.Context, params BillingGetSharedStorageBillingUserParams) (res *CombinedBillingUsage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/settings/billing/shared-storage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetSharedStorageBillingUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/billing/shared-storage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBillingGetSharedStorageBillingUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksCreateSuite invokes checks/create-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// By default, check suites are automatically created when you create a [check run](https://docs.
// github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually
// creating check suites when you've disabled automatic creation using "[Update repository
// preferences for check suites](https://docs.github.
// com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must
// have the `checks:write` permission to create check suites.
//
// POST /repos/{owner}/{repo}/check-suites
func (c *Client) ChecksCreateSuite(ctx context.Context, request *ChecksCreateSuiteReq, params ChecksCreateSuiteParams) (ChecksCreateSuiteRes, error) {
	res, err := c.sendChecksCreateSuite(ctx, request, params)
	return res, err
}

func (c *Client) sendChecksCreateSuite(ctx context.Context, request *ChecksCreateSuiteReq, params ChecksCreateSuiteParams) (res ChecksCreateSuiteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/create-suite"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksCreateSuite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-suites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChecksCreateSuiteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksCreateSuiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksGet invokes checks/get operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check runs. OAuth Apps and
// authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (c *Client) ChecksGet(ctx context.Context, params ChecksGetParams) (*CheckRun, error) {
	res, err := c.sendChecksGet(ctx, params)
	return res, err
}

func (c *Client) sendChecksGet(ctx context.Context, params ChecksGetParams) (res *CheckRun, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-runs/{check_run_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-runs/"
	{
		// Encode "check_run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckRunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksGetSuite invokes checks/get-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check suites. OAuth Apps and
// authenticated users must have the `repo` scope to get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (c *Client) ChecksGetSuite(ctx context.Context, params ChecksGetSuiteParams) (*CheckSuite, error) {
	res, err := c.sendChecksGetSuite(ctx, params)
	return res, err
}

func (c *Client) sendChecksGetSuite(ctx context.Context, params ChecksGetSuiteParams) (res *CheckSuite, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get-suite"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/{check_suite_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksGetSuite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-suites/"
	{
		// Encode "check_suite_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckSuiteID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksGetSuiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListAnnotations invokes checks/list-annotations operation.
//
// Lists annotations for a check run using the annotation `id`. GitHub Apps must have the
// `checks:read` permission on a private repository or pull access to a public repository to get
// annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get
// annotations for a check run in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (c *Client) ChecksListAnnotations(ctx context.Context, params ChecksListAnnotationsParams) (*ChecksListAnnotationsOKHeaders, error) {
	res, err := c.sendChecksListAnnotations(ctx, params)
	return res, err
}

func (c *Client) sendChecksListAnnotations(ctx context.Context, params ChecksListAnnotationsParams) (res *ChecksListAnnotationsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-annotations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListAnnotations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-runs/"
	{
		// Encode "check_run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckRunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksListAnnotationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListForRef invokes checks/list-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps
// must have the `checks:read` permission on a private repository or pull access to a public
// repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get
// check runs in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (c *Client) ChecksListForRef(ctx context.Context, params ChecksListForRefParams) (*ChecksListForRefOKHeaders, error) {
	res, err := c.sendChecksListForRef(ctx, params)
	return res, err
}

func (c *Client) sendChecksListForRef(ctx context.Context, params ChecksListForRefParams) (res *ChecksListForRefOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-ref"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/check-runs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListForRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/check-runs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "check_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CheckName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "app_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "app_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksListForRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListForSuite invokes checks/list-for-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read`
// permission on a private repository or pull access to a public repository to get check runs. OAuth
// Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (c *Client) ChecksListForSuite(ctx context.Context, params ChecksListForSuiteParams) (*ChecksListForSuiteOKHeaders, error) {
	res, err := c.sendChecksListForSuite(ctx, params)
	return res, err
}

func (c *Client) sendChecksListForSuite(ctx context.Context, params ChecksListForSuiteParams) (res *ChecksListForSuiteOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-suite"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListForSuite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-suites/"
	{
		// Encode "check_suite_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckSuiteID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/check-runs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "check_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CheckName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksListForSuiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListSuitesForRef invokes checks/list-suites-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub
// Apps must have the `checks:read` permission on a private repository or pull access to a public
// repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to
// get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (c *Client) ChecksListSuitesForRef(ctx context.Context, params ChecksListSuitesForRefParams) (*ChecksListSuitesForRefOKHeaders, error) {
	res, err := c.sendChecksListSuitesForRef(ctx, params)
	return res, err
}

func (c *Client) sendChecksListSuitesForRef(ctx context.Context, params ChecksListSuitesForRefParams) (res *ChecksListSuitesForRefOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-suites-for-ref"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/check-suites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListSuitesForRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/check-suites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "app_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "app_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "check_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CheckName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksListSuitesForRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksRerequestSuite invokes checks/rerequest-suite operation.
//
// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository.
// This endpoint will trigger the [`check_suite` webhook](https://docs.github.
// com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite
// is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
// To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private
// repository or pull access to a public repository.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (c *Client) ChecksRerequestSuite(ctx context.Context, params ChecksRerequestSuiteParams) error {
	_, err := c.sendChecksRerequestSuite(ctx, params)
	return err
}

func (c *Client) sendChecksRerequestSuite(ctx context.Context, params ChecksRerequestSuiteParams) (res *ChecksRerequestSuiteCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/rerequest-suite"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksRerequestSuite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-suites/"
	{
		// Encode "check_suite_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckSuiteID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/rerequest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksRerequestSuiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksSetSuitesPreferences invokes checks/set-suites-preferences operation.
//
// Changes the default automatic flow when creating check suites. By default, a check suite is
// automatically created each time code is pushed to a repository. When you disable the automatic
// creation of check suites, you can manually [Create a check suite](https://docs.github.
// com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository
// to set preferences for check suites.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (c *Client) ChecksSetSuitesPreferences(ctx context.Context, request *ChecksSetSuitesPreferencesReq, params ChecksSetSuitesPreferencesParams) (*CheckSuitePreference, error) {
	res, err := c.sendChecksSetSuitesPreferences(ctx, request, params)
	return res, err
}

func (c *Client) sendChecksSetSuitesPreferences(ctx context.Context, request *ChecksSetSuitesPreferencesReq, params ChecksSetSuitesPreferencesParams) (res *CheckSuitePreference, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/set-suites-preferences"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/preferences"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksSetSuitesPreferences",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/check-suites/preferences"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChecksSetSuitesPreferencesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChecksSetSuitesPreferencesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningDeleteAnalysis invokes code-scanning/delete-analysis operation.
//
// Deletes a specified code scanning analysis from a repository. For
// private repositories, you must use an access token with the `repo` scope. For public repositories,
// you must use an access token with `public_repo` and `repo:security_events` scopes.
// GitHub Apps must have the `security_events` write permission to use this endpoint.
// You can delete one analysis at a time.
// To delete a series of analyses, start with the most recent analysis and work backwards.
// Conceptually, the process is similar to the undo function in a text editor.
// When you list the analyses for a repository,
// one or more will be identified as deletable in the response:
// ```
// "deletable": true
// ```
// An analysis is deletable when it's the most recent in a set of analyses.
// Typically, a repository will have multiple sets of analyses
// for each enabled code scanning tool,
// where a set is determined by a unique combination of analysis values:
// * `ref`
// * `tool`
// * `analysis_key`
// * `environment`
// If you attempt to delete an analysis that is not the most recent in a set,
// you'll get a 400 response with the message:
// ```
// Analysis specified is not deletable.
// ```
// The response from a successful `DELETE` operation provides you with
// two alternative URLs for deleting the next analysis in the set
// (see the example default response below).
// Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
// in the set. This is a useful option if you want to preserve at least one analysis
// for the specified tool in your repository.
// Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
// When you delete the last analysis in a set the value of `next_analysis_url` and
// `confirm_delete_url`
// in the 200 response is `null`.
// As an example of the deletion process,
// let's imagine that you added a workflow that configured a particular code scanning tool
// to analyze the code in a repository. This tool has added 15 analyses:
// 10 on the default branch, and another 5 on a topic branch.
// You therefore have two separate sets of analyses for this tool.
// You've now decided that you want to remove all of the analyses for the tool.
// To do this you must make 15 separate deletion requests.
// To start, you must find the deletable analysis for one of the sets,
// step through deleting the analyses in that set,
// and then repeat the process for the second set.
// The procedure therefore consists of a nested loop:
// **Outer loop**:
// * List the analyses for the repository, filtered by tool.
// * Parse this list to find a deletable analysis. If found:
// **Inner loop**:
// * Delete the identified analysis.
// * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next
// iteration.
// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub
// user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value.
//
//	Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis
//
// in each set undeleted to avoid removing a tool's analysis entirely.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (c *Client) CodeScanningDeleteAnalysis(ctx context.Context, params CodeScanningDeleteAnalysisParams) (CodeScanningDeleteAnalysisRes, error) {
	res, err := c.sendCodeScanningDeleteAnalysis(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningDeleteAnalysis(ctx context.Context, params CodeScanningDeleteAnalysisParams) (res CodeScanningDeleteAnalysisRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/delete-analysis"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningDeleteAnalysis",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/analyses/"
	{
		// Encode "analysis_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "analysis_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AnalysisID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "confirm_delete" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "confirm_delete",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ConfirmDelete.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningDeleteAnalysisResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningGetAlert invokes code-scanning/get-alert operation.
//
// Gets a single code scanning alert. You must use an access token with the `security_events` scope
// to use this endpoint. GitHub Apps must have the `security_events` read permission to use this
// endpoint.
// **Deprecation notice**:
// The instances field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The same information can now be retrieved via
// a GET request to the URL specified by `instances_url`.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (c *Client) CodeScanningGetAlert(ctx context.Context, params CodeScanningGetAlertParams) (CodeScanningGetAlertRes, error) {
	res, err := c.sendCodeScanningGetAlert(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningGetAlert(ctx context.Context, params CodeScanningGetAlertParams) (res CodeScanningGetAlertRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-alert"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningGetAlertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningGetAnalysis invokes code-scanning/get-analysis operation.
//
// Gets a specified code scanning analysis for a repository.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// The default JSON response contains fields that describe the analysis.
// This includes the Git reference and commit SHA to which the analysis relates,
// the datetime of the analysis, the name of the code scanning tool,
// and the number of alerts.
// The `rules_count` field in the default response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// If you use the Accept header `application/sarif+json`,
// the response contains the analysis data that was uploaded.
// This is formatted as
// [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (c *Client) CodeScanningGetAnalysis(ctx context.Context, params CodeScanningGetAnalysisParams) (CodeScanningGetAnalysisRes, error) {
	res, err := c.sendCodeScanningGetAnalysis(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningGetAnalysis(ctx context.Context, params CodeScanningGetAnalysisParams) (res CodeScanningGetAnalysisRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-analysis"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningGetAnalysis",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/analyses/"
	{
		// Encode "analysis_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "analysis_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AnalysisID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningGetAnalysisResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningGetSarif invokes code-scanning/get-sarif operation.
//
// Gets information about a SARIF upload, including the status and the URL of the analysis that was
// uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code
// scanning analysis for a
// repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You
// must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must
// have the `security_events` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (c *Client) CodeScanningGetSarif(ctx context.Context, params CodeScanningGetSarifParams) (CodeScanningGetSarifRes, error) {
	res, err := c.sendCodeScanningGetSarif(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningGetSarif(ctx context.Context, params CodeScanningGetSarifParams) (res CodeScanningGetSarifRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-sarif"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningGetSarif",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/sarifs/"
	{
		// Encode "sarif_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sarif_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SarifID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningGetSarifResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningListAlertInstances invokes code-scanning/list-alert-instances operation.
//
// Lists all instances of the specified code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (c *Client) CodeScanningListAlertInstances(ctx context.Context, params CodeScanningListAlertInstancesParams) (CodeScanningListAlertInstancesRes, error) {
	res, err := c.sendCodeScanningListAlertInstances(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningListAlertInstances(ctx context.Context, params CodeScanningListAlertInstancesParams) (res CodeScanningListAlertInstancesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alert-instances"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningListAlertInstances",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ref" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ref.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningListAlertInstancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningListAlertsForRepo invokes code-scanning/list-alerts-for-repo operation.
//
// Lists all open code scanning alerts for the default branch (usually `main`
// or `master`). You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` read permission to use
// this endpoint.
// The response includes a `most_recent_instance` object.
// This provides details of the most recent instance of this alert
// for the default branch or for the specified Git reference
// (if you used `ref` in the request).
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (c *Client) CodeScanningListAlertsForRepo(ctx context.Context, params CodeScanningListAlertsForRepoParams) (CodeScanningListAlertsForRepoRes, error) {
	res, err := c.sendCodeScanningListAlertsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningListAlertsForRepo(ctx context.Context, params CodeScanningListAlertsForRepoParams) (res CodeScanningListAlertsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alerts-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "tool_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToolName.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tool_guid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tool_guid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToolGUID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ref" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ref.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningListAlertsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningListRecentAnalyses invokes code-scanning/list-recent-analyses operation.
//
// Lists the details of all code scanning analyses for a repository,
// starting with the most recent.
// The response is paginated and you can use the `page` and `per_page` parameters
// to list the analyses you're interested in.
// By default 30 analyses are listed per page.
// The `rules_count` field in the response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (c *Client) CodeScanningListRecentAnalyses(ctx context.Context, params CodeScanningListRecentAnalysesParams) (CodeScanningListRecentAnalysesRes, error) {
	res, err := c.sendCodeScanningListRecentAnalyses(ctx, params)
	return res, err
}

func (c *Client) sendCodeScanningListRecentAnalyses(ctx context.Context, params CodeScanningListRecentAnalysesParams) (res CodeScanningListRecentAnalysesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-recent-analyses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/analyses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningListRecentAnalyses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/analyses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "tool_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToolName.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tool_guid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tool_guid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToolGUID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ref" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ref.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sarif_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sarif_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SarifID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningListRecentAnalysesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningUpdateAlert invokes code-scanning/update-alert operation.
//
// Updates the status of a single code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write
// permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (c *Client) CodeScanningUpdateAlert(ctx context.Context, request *CodeScanningUpdateAlertReq, params CodeScanningUpdateAlertParams) (CodeScanningUpdateAlertRes, error) {
	res, err := c.sendCodeScanningUpdateAlert(ctx, request, params)
	return res, err
}

func (c *Client) sendCodeScanningUpdateAlert(ctx context.Context, request *CodeScanningUpdateAlertReq, params CodeScanningUpdateAlertParams) (res CodeScanningUpdateAlertRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/update-alert"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCodeScanningUpdateAlertRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningUpdateAlertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningUploadSarif invokes code-scanning/upload-sarif operation.
//
// Uploads SARIF data containing the results of a code scanning analysis to make the results
// available in a repository. You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
// There are two places where you can upload code scanning results.
// - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref
// refs/pull/42/head`, then the results appear as alerts in a pull request check. For more
// information, see "[Triaging code scanning alerts in pull
// requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
// - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in
// the **Security** tab for your repository. For more information, see "[Managing code scanning
// alerts for your
// repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
// You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and
// then encode it as a Base64 format string. For example:
// ```
// gzip -c analysis-data.sarif | base64 -w0
// ```
// SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are
// ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not
// necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool
// generates too many results, you should update the analysis configuration to run only the most
// important rules or queries.
// The `202 Accepted`, response includes an `id` value.
// You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}`
// endpoint.
// For more information, see "[Get information about a SARIF
// upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload).".
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (c *Client) CodeScanningUploadSarif(ctx context.Context, request *CodeScanningUploadSarifReq, params CodeScanningUploadSarifParams) (CodeScanningUploadSarifRes, error) {
	res, err := c.sendCodeScanningUploadSarif(ctx, request, params)
	return res, err
}

func (c *Client) sendCodeScanningUploadSarif(ctx context.Context, request *CodeScanningUploadSarifReq, params CodeScanningUploadSarifParams) (res CodeScanningUploadSarifRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/upload-sarif"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/sarifs"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningUploadSarif",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/code-scanning/sarifs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCodeScanningUploadSarifRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodeScanningUploadSarifResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodesOfConductGetAllCodesOfConduct invokes codes-of-conduct/get-all-codes-of-conduct operation.
//
// Get all codes of conduct.
//
// GET /codes_of_conduct
func (c *Client) CodesOfConductGetAllCodesOfConduct(ctx context.Context) (CodesOfConductGetAllCodesOfConductRes, error) {
	res, err := c.sendCodesOfConductGetAllCodesOfConduct(ctx)
	return res, err
}

func (c *Client) sendCodesOfConductGetAllCodesOfConduct(ctx context.Context) (res CodesOfConductGetAllCodesOfConductRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-all-codes-of-conduct"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/codes_of_conduct"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodesOfConductGetAllCodesOfConduct",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/codes_of_conduct"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodesOfConductGetAllCodesOfConductResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodesOfConductGetConductCode invokes codes-of-conduct/get-conduct-code operation.
//
// Get a code of conduct.
//
// GET /codes_of_conduct/{key}
func (c *Client) CodesOfConductGetConductCode(ctx context.Context, params CodesOfConductGetConductCodeParams) (CodesOfConductGetConductCodeRes, error) {
	res, err := c.sendCodesOfConductGetConductCode(ctx, params)
	return res, err
}

func (c *Client) sendCodesOfConductGetConductCode(ctx context.Context, params CodesOfConductGetConductCodeParams) (res CodesOfConductGetConductCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-conduct-code"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/codes_of_conduct/{key}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CodesOfConductGetConductCode",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/codes_of_conduct/"
	{
		// Encode "key" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Key))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCodesOfConductGetConductCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EmojisGet invokes emojis/get operation.
//
// Lists all the emojis available to use on GitHub.
//
// GET /emojis
func (c *Client) EmojisGet(ctx context.Context) (EmojisGetRes, error) {
	res, err := c.sendEmojisGet(ctx)
	return res, err
}

func (c *Client) sendEmojisGet(ctx context.Context) (res EmojisGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emojis/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/emojis"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EmojisGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/emojis"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEmojisGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Adds an organization to the list of selected organizations that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (c *Client) EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise invokes enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// Adds a self-hosted runner to a runner group configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise`
// scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) (res *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminCreateRegistrationTokenForEnterprise invokes enterprise-admin/create-registration-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (c *Client) EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) (*AuthenticationToken, error) {
	res, err := c.sendEnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminCreateRegistrationTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) (res *AuthenticationToken, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-registration-token-for-enterprise"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/registration-token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminCreateRegistrationTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/registration-token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminCreateRemoveTokenForEnterprise invokes enterprise-admin/create-remove-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// enterprise. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (c *Client) EnterpriseAdminCreateRemoveTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) (*AuthenticationToken, error) {
	res, err := c.sendEnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminCreateRemoveTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) (res *AuthenticationToken, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-remove-token-for-enterprise"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/remove-token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminCreateRemoveTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/remove-token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// Creates a new self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (c *Client) EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) (*RunnerGroupsEnterprise, error) {
	res, err := c.sendEnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) (res *RunnerGroupsEnterprise, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-self-hosted-runner-group-for-enterprise"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteScimGroupFromEnterprise invokes enterprise-admin/delete-scim-group-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminDeleteScimGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminDeleteScimGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) (res *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-scim-group-from-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteScimGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise invokes enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) (res *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-from-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise invokes enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// Deletes a self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) (res *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-group-from-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteUserFromEnterprise invokes enterprise-admin/delete-user-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminDeleteUserFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteUserFromEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminDeleteUserFromEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminDeleteUserFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteUserFromEnterpriseParams) (res *EnterpriseAdminDeleteUserFromEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-user-from-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteUserFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminDeleteUserFromEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise invokes enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// Removes an organization from the list of selected organizations that are enabled for GitHub
// Actions in an enterprise. To use this endpoint, the enterprise permission policy for
// `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (c *Client) EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) (res *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/disable-selected-organization-github-actions-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise invokes enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// Adds an organization to the list of selected organizations that are enabled for GitHub Actions in
// an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations`
// must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for
// an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (c *Client) EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) (res *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/enable-selected-organization-github-actions-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetAllowedActionsEnterprise invokes enterprise-admin/get-allowed-actions-enterprise operation.
//
// Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (c *Client) EnterpriseAdminGetAllowedActionsEnterprise(ctx context.Context, params EnterpriseAdminGetAllowedActionsEnterpriseParams) (*SelectedActions, error) {
	res, err := c.sendEnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetAllowedActionsEnterprise(ctx context.Context, params EnterpriseAdminGetAllowedActionsEnterpriseParams) (res *SelectedActions, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-allowed-actions-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/selected-actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/selected-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetAuditLog invokes enterprise-admin/get-audit-log operation.
//
// Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and
// you must use an access token with the `admin:enterprise` scope.
//
// GET /enterprises/{enterprise}/audit-log
func (c *Client) EnterpriseAdminGetAuditLog(ctx context.Context, params EnterpriseAdminGetAuditLogParams) ([]AuditLogEvent, error) {
	res, err := c.sendEnterpriseAdminGetAuditLog(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetAuditLog(ctx context.Context, params EnterpriseAdminGetAuditLogParams) (res []AuditLogEvent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-audit-log"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/audit-log"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audit-log"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "phrase" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phrase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Phrase.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Include.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "before" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetAuditLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetGithubActionsPermissionsEnterprise invokes enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions
func (c *Client) EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx context.Context, params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) (*ActionsEnterprisePermissions, error) {
	res, err := c.sendEnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx context.Context, params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) (res *ActionsEnterprisePermissions, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-github-actions-permissions-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetProvisioningInformationForEnterpriseGroup invokes enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) (*ScimEnterpriseGroup, error) {
	res, err := c.sendEnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) (res *ScimEnterpriseGroup, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-group"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "excludedAttributes" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "excludedAttributes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExcludedAttributes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetProvisioningInformationForEnterpriseUser invokes enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) (*ScimEnterpriseUser, error) {
	res, err := c.sendEnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) (res *ScimEnterpriseUser, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetSelfHostedRunnerForEnterprise invokes enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// Gets a specific self-hosted runner configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (c *Client) EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) (*Runner, error) {
	res, err := c.sendEnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) (res *Runner, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-for-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// Gets a specific self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (c *Client) EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) (*RunnerGroupsEnterprise, error) {
	res, err := c.sendEnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) (res *RunnerGroupsEnterprise, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-group-for-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Lists the organizations with access to a self-hosted runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (c *Client) EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (*EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK, error) {
	res, err := c.sendEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListProvisionedGroupsEnterprise invokes enterprise-admin/list-provisioned-groups-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (c *Client) EnterpriseAdminListProvisionedGroupsEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedGroupsEnterpriseParams) (*ScimGroupListEnterprise, error) {
	res, err := c.sendEnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListProvisionedGroupsEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedGroupsEnterpriseParams) (res *ScimGroupListEnterprise, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-groups-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListProvisionedGroupsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "startIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartIndex.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "excludedAttributes" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "excludedAttributes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExcludedAttributes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListProvisionedIdentitiesEnterprise invokes enterprise-admin/list-provisioned-identities-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
// When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise,
// the account's metadata is immediately removed. However, the returned list of user accounts might
// not always match the organization or enterprise member list you see on GitHub. This can happen in
// certain cases where an external identity associated with an organization will not match an
// organization member:
// - When a user with a SCIM-provisioned external identity is removed from an enterprise, the
// account's metadata is preserved to allow the user to re-join the organization in the future.
// - When inviting a user to join an organization, you can expect to see their external identity in
// the results before they accept the invitation, or if the invitation is cancelled (or never
// accepted).
// - When a user is invited over SCIM, an external identity is created that matches with the
// invitee's email address. However, this identity is only linked to a user account when the user
// accepts the invitation by going through SAML SSO.
// The returned list of external identities can include an entry for a `null` user. These are
// unlinked SAML identities that are created when a user goes through the following Single Sign-On
// (SSO) process but does not sign in to their GitHub account after completing SSO:
// 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
// 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is
// not currently signed in to their GitHub account.
// 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is
// created and the user is prompted to sign in to their GitHub account:
// - If the user signs in, their GitHub account is linked to this entry.
// - If the user does not sign in (or does not create a new account when prompted), they are not
// added to the GitHub enterprise, and the external identity `null` entry remains in place.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (c *Client) EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) (*ScimUserListEnterprise, error) {
	res, err := c.sendEnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListProvisionedIdentitiesEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) (res *ScimUserListEnterprise, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-identities-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListProvisionedIdentitiesEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "startIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartIndex.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListRunnerApplicationsForEnterprise invokes enterprise-admin/list-runner-applications-for-enterprise operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (c *Client) EnterpriseAdminListRunnerApplicationsForEnterprise(ctx context.Context, params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) ([]RunnerApplication, error) {
	res, err := c.sendEnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListRunnerApplicationsForEnterprise(ctx context.Context, params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) (res []RunnerApplication, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-runner-applications-for-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/downloads"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListRunnerApplicationsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners/downloads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise invokes enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use
// this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (c *Client) EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (*EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK, error) {
	res, err := c.sendEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (res *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise invokes enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// Lists all self-hosted runner groups for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (c *Client) EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) (*EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK, error) {
	res, err := c.sendEnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) (res *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runner-groups-for-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelfHostedRunnersForEnterprise invokes enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// Lists all self-hosted runners configured for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners
func (c *Client) EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) (*EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders, error) {
	res, err := c.sendEnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListSelfHostedRunnersForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) (res *EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-for-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelfHostedRunnersForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise invokes enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// Lists the self-hosted runners that are in a specific enterprise group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) (*EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders, error) {
	res, err := c.sendEnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) (res *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminProvisionAndInviteEnterpriseGroup invokes enterprise-admin/provision-and-invite-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision an enterprise group, and invite users to the group. This sends invitation emails to the
// email address of the invited users to join the GitHub organization that the SCIM group corresponds
// to.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx context.Context, request *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq, params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) (*ScimEnterpriseGroup, error) {
	res, err := c.sendEnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx context.Context, request *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq, params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) (res *ScimEnterpriseGroup, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-group"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminProvisionAndInviteEnterpriseUser invokes enterprise-admin/provision-and-invite-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision enterprise membership for a user, and send organization invitation emails to the email
// address.
// You can optionally include the groups a user will be invited to join. If you do not provide a list
// of `groups`, the user is provisioned for the enterprise, but no organization invitation emails
// will be sent.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx context.Context, request *EnterpriseAdminProvisionAndInviteEnterpriseUserReq, params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) (*ScimEnterpriseUser, error) {
	res, err := c.sendEnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminProvisionAndInviteEnterpriseUser(ctx context.Context, request *EnterpriseAdminProvisionAndInviteEnterpriseUserReq, params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) (res *ScimEnterpriseUser, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminProvisionAndInviteEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Removes an organization from the list of selected organizations that can access a self-hosted
// runner group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (c *Client) EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise invokes enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned
// to the default group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
	return err
}

func (c *Client) sendEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) (res *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetAllowedActionsEnterprise invokes enterprise-admin/set-allowed-actions-enterprise operation.
//
// Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (c *Client) EnterpriseAdminSetAllowedActionsEnterprise(ctx context.Context, request *SelectedActions, params EnterpriseAdminSetAllowedActionsEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
	return err
}

func (c *Client) sendEnterpriseAdminSetAllowedActionsEnterprise(ctx context.Context, request *SelectedActions, params EnterpriseAdminSetAllowedActionsEnterpriseParams) (res *EnterpriseAdminSetAllowedActionsEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-allowed-actions-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/selected-actions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/selected-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetGithubActionsPermissionsEnterprise invokes enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (c *Client) EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx context.Context, request *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq, params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
	return err
}

func (c *Client) sendEnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx context.Context, request *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq, params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) (res *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-github-actions-permissions-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetInformationForProvisionedEnterpriseGroup invokes enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned group’s information. You must provide all the information
// required for the group as if you were provisioning it for the first time. Any existing group
// information that you don't provide will be removed, including group membership. If you want to
// only update a specific attribute, use the [Update an attribute for a SCIM enterprise
// group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx context.Context, request *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) (*ScimEnterpriseGroup, error) {
	res, err := c.sendEnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx context.Context, request *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) (res *ScimEnterpriseGroup, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-group"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetInformationForProvisionedEnterpriseUser invokes enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned user's information. You must provide all the information required
// for the user as if you were provisioning them for the first time. Any existing user information
// that you don't provide will be removed. If you want to only update a specific attribute, use the
// [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint
// instead.
// You must at least provide the required values for the user: `userName`, `name`, and `emails`.
// **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external
// identity, and deletes the associated `{scim_user_id}`.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx context.Context, request *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) (*ScimEnterpriseUser, error) {
	res, err := c.sendEnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx context.Context, request *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) (res *ScimEnterpriseUser, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-user"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Replaces the list of organizations that have access to a self-hosted runner configured in an
// enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (c *Client) EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, request *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq, params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
	return err
}

func (c *Client) sendEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, request *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq, params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise invokes enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise.
// To use this endpoint, the enterprise permission policy for `enabled_organizations` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (c *Client) EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, request *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq, params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
	return err
}

func (c *Client) sendEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, request *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq, params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (res *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/permissions/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise invokes enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// Replaces the list of self-hosted runners that are part of an enterprise runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, request *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq, params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) error {
	_, err := c.sendEnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
	return err
}

func (c *Client) sendEnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, request *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq, params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) (res *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/runners"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminUpdateAttributeForEnterpriseGroup invokes enterprise-admin/update-attribute-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned group’s individual attributes. To change a group’s values,
// you must provide a specific Operations JSON format that contains at least one of the add, remove,
// or replace operations. For examples and more information on the SCIM operations format, see the
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
//
// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx context.Context, request *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq, params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams) (*ScimEnterpriseGroup, error) {
	res, err := c.sendEnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx context.Context, request *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq, params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams) (res *ScimEnterpriseGroup, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-group"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminUpdateAttributeForEnterpriseUser invokes enterprise-admin/update-attribute-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned user's individual attributes. To change a user's values, you
// must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`,
//
//	or `replace` operations. For examples and more information on the SCIM operations format, see the
//
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
// **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a
// `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
// **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example
// below), it removes the user from the enterprise, deletes the external identity, and deletes the
// associated `:scim_user_id`.
// ```
// {
// "Operations":[{
// "op":"replace",
// "value":{
// "active":false
// }
// }]
// }
// ```.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx context.Context, request *EnterpriseAdminUpdateAttributeForEnterpriseUserReq, params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) (*ScimEnterpriseUser, error) {
	res, err := c.sendEnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminUpdateAttributeForEnterpriseUser(ctx context.Context, request *EnterpriseAdminUpdateAttributeForEnterpriseUserReq, params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) (res *ScimEnterpriseUser, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-user"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminUpdateAttributeForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (c *Client) EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) (*RunnerGroupsEnterprise, error) {
	res, err := c.sendEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	return res, err
}

func (c *Client) sendEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) (res *RunnerGroupsEnterprise, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-self-hosted-runner-group-for-enterprise"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsCheckIsStarred invokes gists/check-is-starred operation.
//
// Check if a gist is starred.
//
// GET /gists/{gist_id}/star
func (c *Client) GistsCheckIsStarred(ctx context.Context, params GistsCheckIsStarredParams) (GistsCheckIsStarredRes, error) {
	res, err := c.sendGistsCheckIsStarred(ctx, params)
	return res, err
}

func (c *Client) sendGistsCheckIsStarred(ctx context.Context, params GistsCheckIsStarredParams) (res GistsCheckIsStarredRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/check-is-starred"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/star"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsCheckIsStarred",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/star"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsCheckIsStarredResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsCreate invokes gists/create operation.
//
// Allows you to add a new gist with one or more files.
// **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the
// automatic naming scheme that Gist uses internally.
//
// POST /gists
func (c *Client) GistsCreate(ctx context.Context, request *GistsCreateReq) (GistsCreateRes, error) {
	res, err := c.sendGistsCreate(ctx, request)
	return res, err
}

func (c *Client) sendGistsCreate(ctx context.Context, request *GistsCreateReq) (res GistsCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/gists"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGistsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsCreateComment invokes gists/create-comment operation.
//
// Create a gist comment.
//
// POST /gists/{gist_id}/comments
func (c *Client) GistsCreateComment(ctx context.Context, request *GistsCreateCommentReq, params GistsCreateCommentParams) (GistsCreateCommentRes, error) {
	res, err := c.sendGistsCreateComment(ctx, request, params)
	return res, err
}

func (c *Client) sendGistsCreateComment(ctx context.Context, request *GistsCreateCommentReq, params GistsCreateCommentParams) (res GistsCreateCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsCreateComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGistsCreateCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsCreateCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsDelete invokes gists/delete operation.
//
// Delete a gist.
//
// DELETE /gists/{gist_id}
func (c *Client) GistsDelete(ctx context.Context, params GistsDeleteParams) (GistsDeleteRes, error) {
	res, err := c.sendGistsDelete(ctx, params)
	return res, err
}

func (c *Client) sendGistsDelete(ctx context.Context, params GistsDeleteParams) (res GistsDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsDeleteComment invokes gists/delete-comment operation.
//
// Delete a gist comment.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (c *Client) GistsDeleteComment(ctx context.Context, params GistsDeleteCommentParams) (GistsDeleteCommentRes, error) {
	res, err := c.sendGistsDeleteComment(ctx, params)
	return res, err
}

func (c *Client) sendGistsDeleteComment(ctx context.Context, params GistsDeleteCommentParams) (res GistsDeleteCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsDeleteComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsDeleteCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsFork invokes gists/fork operation.
//
// **Note**: This was previously `/gists/:gist_id/fork`.
//
// POST /gists/{gist_id}/forks
func (c *Client) GistsFork(ctx context.Context, params GistsForkParams) (GistsForkRes, error) {
	res, err := c.sendGistsFork(ctx, params)
	return res, err
}

func (c *Client) sendGistsFork(ctx context.Context, params GistsForkParams) (res GistsForkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/fork"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/forks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsFork",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/forks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsGet invokes gists/get operation.
//
// Get a gist.
//
// GET /gists/{gist_id}
func (c *Client) GistsGet(ctx context.Context, params GistsGetParams) (GistsGetRes, error) {
	res, err := c.sendGistsGet(ctx, params)
	return res, err
}

func (c *Client) sendGistsGet(ctx context.Context, params GistsGetParams) (res GistsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsGetComment invokes gists/get-comment operation.
//
// Get a gist comment.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (c *Client) GistsGetComment(ctx context.Context, params GistsGetCommentParams) (GistsGetCommentRes, error) {
	res, err := c.sendGistsGetComment(ctx, params)
	return res, err
}

func (c *Client) sendGistsGetComment(ctx context.Context, params GistsGetCommentParams) (res GistsGetCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsGetComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsGetCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsGetRevision invokes gists/get-revision operation.
//
// Get a gist revision.
//
// GET /gists/{gist_id}/{sha}
func (c *Client) GistsGetRevision(ctx context.Context, params GistsGetRevisionParams) (GistsGetRevisionRes, error) {
	res, err := c.sendGistsGetRevision(ctx, params)
	return res, err
}

func (c *Client) sendGistsGetRevision(ctx context.Context, params GistsGetRevisionParams) (res GistsGetRevisionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-revision"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/{sha}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsGetRevision",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Sha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsGetRevisionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsList invokes gists/list operation.
//
// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public
// gists:.
//
// GET /gists
func (c *Client) GistsList(ctx context.Context, params GistsListParams) (GistsListRes, error) {
	res, err := c.sendGistsList(ctx, params)
	return res, err
}

func (c *Client) sendGistsList(ctx context.Context, params GistsListParams) (res GistsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListComments invokes gists/list-comments operation.
//
// List gist comments.
//
// GET /gists/{gist_id}/comments
func (c *Client) GistsListComments(ctx context.Context, params GistsListCommentsParams) (GistsListCommentsRes, error) {
	res, err := c.sendGistsListComments(ctx, params)
	return res, err
}

func (c *Client) sendGistsListComments(ctx context.Context, params GistsListCommentsParams) (res GistsListCommentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-comments"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListComments",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListCommits invokes gists/list-commits operation.
//
// List gist commits.
//
// GET /gists/{gist_id}/commits
func (c *Client) GistsListCommits(ctx context.Context, params GistsListCommitsParams) (GistsListCommitsRes, error) {
	res, err := c.sendGistsListCommits(ctx, params)
	return res, err
}

func (c *Client) sendGistsListCommits(ctx context.Context, params GistsListCommitsParams) (res GistsListCommitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-commits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/commits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListCommits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/commits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListCommitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListForUser invokes gists/list-for-user operation.
//
// Lists public gists for the specified user:.
//
// GET /users/{username}/gists
func (c *Client) GistsListForUser(ctx context.Context, params GistsListForUserParams) (GistsListForUserRes, error) {
	res, err := c.sendGistsListForUser(ctx, params)
	return res, err
}

func (c *Client) sendGistsListForUser(ctx context.Context, params GistsListForUserParams) (res GistsListForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/gists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/gists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListForks invokes gists/list-forks operation.
//
// List gist forks.
//
// GET /gists/{gist_id}/forks
func (c *Client) GistsListForks(ctx context.Context, params GistsListForksParams) (GistsListForksRes, error) {
	res, err := c.sendGistsListForks(ctx, params)
	return res, err
}

func (c *Client) sendGistsListForks(ctx context.Context, params GistsListForksParams) (res GistsListForksRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-forks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/forks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListForks",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/forks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListForksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListPublic invokes gists/list-public operation.
//
// List public gists sorted by most recently updated to least recently updated.
// Note: With [pagination](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For
// example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
//
// GET /gists/public
func (c *Client) GistsListPublic(ctx context.Context, params GistsListPublicParams) (GistsListPublicRes, error) {
	res, err := c.sendGistsListPublic(ctx, params)
	return res, err
}

func (c *Client) sendGistsListPublic(ctx context.Context, params GistsListPublicParams) (res GistsListPublicRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-public"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/public"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListPublic",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gists/public"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListPublicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListStarred invokes gists/list-starred operation.
//
// List the authenticated user's starred gists:.
//
// GET /gists/starred
func (c *Client) GistsListStarred(ctx context.Context, params GistsListStarredParams) (GistsListStarredRes, error) {
	res, err := c.sendGistsListStarred(ctx, params)
	return res, err
}

func (c *Client) sendGistsListStarred(ctx context.Context, params GistsListStarredParams) (res GistsListStarredRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-starred"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/starred"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListStarred",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gists/starred"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsListStarredResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsStar invokes gists/star operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /gists/{gist_id}/star
func (c *Client) GistsStar(ctx context.Context, params GistsStarParams) (GistsStarRes, error) {
	res, err := c.sendGistsStar(ctx, params)
	return res, err
}

func (c *Client) sendGistsStar(ctx context.Context, params GistsStarParams) (res GistsStarRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/star"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/star"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsStar",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/star"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsStarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsUnstar invokes gists/unstar operation.
//
// Unstar a gist.
//
// DELETE /gists/{gist_id}/star
func (c *Client) GistsUnstar(ctx context.Context, params GistsUnstarParams) (GistsUnstarRes, error) {
	res, err := c.sendGistsUnstar(ctx, params)
	return res, err
}

func (c *Client) sendGistsUnstar(ctx context.Context, params GistsUnstarParams) (res GistsUnstarRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/unstar"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/star"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsUnstar",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/star"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsUnstarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsUpdateComment invokes gists/update-comment operation.
//
// Update a gist comment.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (c *Client) GistsUpdateComment(ctx context.Context, request *GistsUpdateCommentReq, params GistsUpdateCommentParams) (GistsUpdateCommentRes, error) {
	res, err := c.sendGistsUpdateComment(ctx, request, params)
	return res, err
}

func (c *Client) sendGistsUpdateComment(ctx context.Context, request *GistsUpdateCommentReq, params GistsUpdateCommentParams) (res GistsUpdateCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/update-comment"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments/{comment_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsUpdateComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGistsUpdateCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGistsUpdateCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateBlob invokes git/create-blob operation.
//
// Create a blob.
//
// POST /repos/{owner}/{repo}/git/blobs
func (c *Client) GitCreateBlob(ctx context.Context, request *GitCreateBlobReq, params GitCreateBlobParams) (GitCreateBlobRes, error) {
	res, err := c.sendGitCreateBlob(ctx, request, params)
	return res, err
}

func (c *Client) sendGitCreateBlob(ctx context.Context, request *GitCreateBlobReq, params GitCreateBlobParams) (res GitCreateBlobRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-blob"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/blobs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateBlob",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/blobs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGitCreateBlobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitCreateBlobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateCommit invokes git/create-commit operation.
//
// Creates a new Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/commits
func (c *Client) GitCreateCommit(ctx context.Context, request *GitCreateCommitReq, params GitCreateCommitParams) (GitCreateCommitRes, error) {
	res, err := c.sendGitCreateCommit(ctx, request, params)
	return res, err
}

func (c *Client) sendGitCreateCommit(ctx context.Context, request *GitCreateCommitReq, params GitCreateCommitParams) (res GitCreateCommitRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-commit"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/commits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateCommit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/commits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGitCreateCommitRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitCreateCommitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateRef invokes git/create-ref operation.
//
// Creates a reference for your repository. You are unable to create new references for empty
// repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
// without branches.
//
// POST /repos/{owner}/{repo}/git/refs
func (c *Client) GitCreateRef(ctx context.Context, request *GitCreateRefReq, params GitCreateRefParams) (GitCreateRefRes, error) {
	res, err := c.sendGitCreateRef(ctx, request, params)
	return res, err
}

func (c *Client) sendGitCreateRef(ctx context.Context, request *GitCreateRefReq, params GitCreateRefParams) (res GitCreateRefRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-ref"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/refs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/refs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGitCreateRefRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitCreateRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateTag invokes git/create-tag operation.
//
// Note that creating a tag object does not create the reference that makes a tag in Git. If you want
// to create an annotated tag in Git, you have to do this call to create the tag object, and then
// [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]`
// reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.
// com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/tags
func (c *Client) GitCreateTag(ctx context.Context, request *GitCreateTagReq, params GitCreateTagParams) (GitCreateTagRes, error) {
	res, err := c.sendGitCreateTag(ctx, request, params)
	return res, err
}

func (c *Client) sendGitCreateTag(ctx context.Context, request *GitCreateTagReq, params GitCreateTagParams) (res GitCreateTagRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tag"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/tags"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateTag",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGitCreateTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitCreateTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateTree invokes git/create-tree operation.
//
// The tree creation API accepts nested entries. If you specify both a tree and a nested path
// modifying that tree, this endpoint will overwrite the contents of the tree with the new path
// contents, and create a new tree structure.
// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to
// commit the tree and then update a branch to point to the commit. For more information see "[Create
// a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
// reference](https://docs.github.com/rest/reference/git#update-a-reference).".
//
// POST /repos/{owner}/{repo}/git/trees
func (c *Client) GitCreateTree(ctx context.Context, request *GitCreateTreeReq, params GitCreateTreeParams) (GitCreateTreeRes, error) {
	res, err := c.sendGitCreateTree(ctx, request, params)
	return res, err
}

func (c *Client) sendGitCreateTree(ctx context.Context, request *GitCreateTreeReq, params GitCreateTreeParams) (res GitCreateTreeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tree"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/trees"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateTree",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/trees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGitCreateTreeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitCreateTreeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitDeleteRef invokes git/delete-ref operation.
//
// Delete a reference.
//
// DELETE /repos/{owner}/{repo}/git/refs/{ref}
func (c *Client) GitDeleteRef(ctx context.Context, params GitDeleteRefParams) (GitDeleteRefRes, error) {
	res, err := c.sendGitDeleteRef(ctx, params)
	return res, err
}

func (c *Client) sendGitDeleteRef(ctx context.Context, params GitDeleteRefParams) (res GitDeleteRefRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/delete-ref"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/refs/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitDeleteRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/refs/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitDeleteRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetBlob invokes git/get-blob operation.
//
// The `content` in the response will always be Base64 encoded.
// _Note_: This API supports blobs up to 100 megabytes in size.
//
// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
func (c *Client) GitGetBlob(ctx context.Context, params GitGetBlobParams) (GitGetBlobRes, error) {
	res, err := c.sendGitGetBlob(ctx, params)
	return res, err
}

func (c *Client) sendGitGetBlob(ctx context.Context, params GitGetBlobParams) (res GitGetBlobRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-blob"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/blobs/{file_sha}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetBlob",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/blobs/"
	{
		// Encode "file_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "file_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FileSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitGetBlobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetCommit invokes git/get-commit operation.
//
// Gets a Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (c *Client) GitGetCommit(ctx context.Context, params GitGetCommitParams) (GitGetCommitRes, error) {
	res, err := c.sendGitGetCommit(ctx, params)
	return res, err
}

func (c *Client) sendGitGetCommit(ctx context.Context, params GitGetCommitParams) (res GitGetCommitRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-commit"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/commits/{commit_sha}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetCommit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitGetCommitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetRef invokes git/get-ref operation.
//
// Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
// `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an
// existing ref, a `404` is returned.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (c *Client) GitGetRef(ctx context.Context, params GitGetRefParams) (GitGetRefRes, error) {
	res, err := c.sendGitGetRef(ctx, params)
	return res, err
}

func (c *Client) sendGitGetRef(ctx context.Context, params GitGetRefParams) (res GitGetRefRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-ref"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/ref/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/ref/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitGetRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetTag invokes git/get-tag operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (c *Client) GitGetTag(ctx context.Context, params GitGetTagParams) (GitGetTagRes, error) {
	res, err := c.sendGitGetTag(ctx, params)
	return res, err
}

func (c *Client) sendGitGetTag(ctx context.Context, params GitGetTagParams) (res GitGetTagRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tag"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/tags/{tag_sha}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetTag",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/tags/"
	{
		// Encode "tag_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TagSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitGetTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetTree invokes git/get-tree operation.
//
// Returns a single tree using the SHA1 value for that tree.
// If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our
// maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees,
// and fetch one sub-tree at a time.
//
// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
func (c *Client) GitGetTree(ctx context.Context, params GitGetTreeParams) (GitGetTreeRes, error) {
	res, err := c.sendGitGetTree(ctx, params)
	return res, err
}

func (c *Client) sendGitGetTree(ctx context.Context, params GitGetTreeParams) (res GitGetTreeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tree"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/trees/{tree_sha}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetTree",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/trees/"
	{
		// Encode "tree_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tree_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TreeSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "recursive" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "recursive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Recursive.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitGetTreeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitListMatchingRefs invokes git/list-matching-refs operation.
//
// Returns an array of references from your Git database that match the supplied name. The `:ref` in
// the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If
// the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be
// returned as an array.
// When you use this endpoint without providing a `:ref`, it will return an array of all the
// references from your Git database, including notes and stashes if they exist on the server.
// Anything in the namespace is returned, not just `heads` and `tags`.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// If you request matching references for a branch named `feature` but the branch `feature` doesn't
// exist, the response can still include other matching head refs that start with the word `feature`,
// such as `featureA` and `featureB`.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (c *Client) GitListMatchingRefs(ctx context.Context, params GitListMatchingRefsParams) (*GitListMatchingRefsOKHeaders, error) {
	res, err := c.sendGitListMatchingRefs(ctx, params)
	return res, err
}

func (c *Client) sendGitListMatchingRefs(ctx context.Context, params GitListMatchingRefsParams) (res *GitListMatchingRefsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/list-matching-refs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/matching-refs/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitListMatchingRefs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/matching-refs/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitListMatchingRefsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitUpdateRef invokes git/update-ref operation.
//
// Update a reference.
//
// PATCH /repos/{owner}/{repo}/git/refs/{ref}
func (c *Client) GitUpdateRef(ctx context.Context, request *GitUpdateRefReq, params GitUpdateRefParams) (GitUpdateRefRes, error) {
	res, err := c.sendGitUpdateRef(ctx, request, params)
	return res, err
}

func (c *Client) sendGitUpdateRef(ctx context.Context, request *GitUpdateRefReq, params GitUpdateRefParams) (res GitUpdateRefRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/update-ref"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/refs/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitUpdateRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/git/refs/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGitUpdateRefRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitUpdateRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitignoreGetAllTemplates invokes gitignore/get-all-templates operation.
//
// List all templates available to pass as an option when [creating a repository](https://docs.github.
// com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
//
// GET /gitignore/templates
func (c *Client) GitignoreGetAllTemplates(ctx context.Context) (GitignoreGetAllTemplatesRes, error) {
	res, err := c.sendGitignoreGetAllTemplates(ctx)
	return res, err
}

func (c *Client) sendGitignoreGetAllTemplates(ctx context.Context) (res GitignoreGetAllTemplatesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-all-templates"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gitignore/templates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitignoreGetAllTemplates",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gitignore/templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitignoreGetAllTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitignoreGetTemplate invokes gitignore/get-template operation.
//
// The API also allows fetching the source of a single template.
// Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw
// contents.
//
// GET /gitignore/templates/{name}
func (c *Client) GitignoreGetTemplate(ctx context.Context, params GitignoreGetTemplateParams) (GitignoreGetTemplateRes, error) {
	res, err := c.sendGitignoreGetTemplate(ctx, params)
	return res, err
}

func (c *Client) sendGitignoreGetTemplate(ctx context.Context, params GitignoreGetTemplateParams) (res GitignoreGetTemplateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-template"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gitignore/templates/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GitignoreGetTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gitignore/templates/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGitignoreGetTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsRemoveRestrictionsForAuthenticatedUser invokes interactions/remove-restrictions-for-authenticated-user operation.
//
// Removes any interaction restrictions from your public repositories.
//
// DELETE /user/interaction-limits
func (c *Client) InteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context) error {
	_, err := c.sendInteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
	return err
}

func (c *Client) sendInteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context) (res *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/interaction-limits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsRemoveRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/interaction-limits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsRemoveRestrictionsForOrg invokes interactions/remove-restrictions-for-org operation.
//
// Removes all interaction restrictions from public repositories in the given organization. You must
// be an organization owner to remove restrictions.
//
// DELETE /orgs/{org}/interaction-limits
func (c *Client) InteractionsRemoveRestrictionsForOrg(ctx context.Context, params InteractionsRemoveRestrictionsForOrgParams) error {
	_, err := c.sendInteractionsRemoveRestrictionsForOrg(ctx, params)
	return err
}

func (c *Client) sendInteractionsRemoveRestrictionsForOrg(ctx context.Context, params InteractionsRemoveRestrictionsForOrgParams) (res *InteractionsRemoveRestrictionsForOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/interaction-limits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsRemoveRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/interaction-limits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInteractionsRemoveRestrictionsForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsRemoveRestrictionsForRepo invokes interactions/remove-restrictions-for-repo operation.
//
// Removes all interaction restrictions from the given repository. You must have owner or admin
// access to remove restrictions. If the interaction limit is set for the user or organization that
// owns this repository, you will receive a `409 Conflict` response and will not be able to use this
// endpoint to change the interaction limit for a single repository.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (c *Client) InteractionsRemoveRestrictionsForRepo(ctx context.Context, params InteractionsRemoveRestrictionsForRepoParams) (InteractionsRemoveRestrictionsForRepoRes, error) {
	res, err := c.sendInteractionsRemoveRestrictionsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendInteractionsRemoveRestrictionsForRepo(ctx context.Context, params InteractionsRemoveRestrictionsForRepoParams) (res InteractionsRemoveRestrictionsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-repo"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/interaction-limits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsRemoveRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/interaction-limits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInteractionsRemoveRestrictionsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsSetRestrictionsForAuthenticatedUser invokes interactions/set-restrictions-for-authenticated-user operation.
//
// Temporarily restricts which type of GitHub user can interact with your public repositories.
// Setting the interaction limit at the user level will overwrite any interaction limits that are set
// for individual repositories owned by the user.
//
// PUT /user/interaction-limits
func (c *Client) InteractionsSetRestrictionsForAuthenticatedUser(ctx context.Context, request *InteractionLimit) (InteractionsSetRestrictionsForAuthenticatedUserRes, error) {
	res, err := c.sendInteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
	return res, err
}

func (c *Client) sendInteractionsSetRestrictionsForAuthenticatedUser(ctx context.Context, request *InteractionLimit) (res InteractionsSetRestrictionsForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-authenticated-user"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/interaction-limits"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsSetRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/interaction-limits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInteractionsSetRestrictionsForAuthenticatedUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInteractionsSetRestrictionsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsSetRestrictionsForOrg invokes interactions/set-restrictions-for-org operation.
//
// Temporarily restricts interactions to a certain type of GitHub user in any public repository in
// the given organization. You must be an organization owner to set these restrictions. Setting the
// interaction limit at the organization level will overwrite any interaction limits that are set for
// individual repositories owned by the organization.
//
// PUT /orgs/{org}/interaction-limits
func (c *Client) InteractionsSetRestrictionsForOrg(ctx context.Context, request *InteractionLimit, params InteractionsSetRestrictionsForOrgParams) (InteractionsSetRestrictionsForOrgRes, error) {
	res, err := c.sendInteractionsSetRestrictionsForOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendInteractionsSetRestrictionsForOrg(ctx context.Context, request *InteractionLimit, params InteractionsSetRestrictionsForOrgParams) (res InteractionsSetRestrictionsForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/interaction-limits"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsSetRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/interaction-limits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInteractionsSetRestrictionsForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInteractionsSetRestrictionsForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsSetRestrictionsForRepo invokes interactions/set-restrictions-for-repo operation.
//
// Temporarily restricts interactions to a certain type of GitHub user within the given repository.
// You must have owner or admin access to set these restrictions. If an interaction limit is set for
// the user or organization that owns this repository, you will receive a `409 Conflict` response and
// will not be able to use this endpoint to change the interaction limit for a single repository.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (c *Client) InteractionsSetRestrictionsForRepo(ctx context.Context, request *InteractionLimit, params InteractionsSetRestrictionsForRepoParams) (InteractionsSetRestrictionsForRepoRes, error) {
	res, err := c.sendInteractionsSetRestrictionsForRepo(ctx, request, params)
	return res, err
}

func (c *Client) sendInteractionsSetRestrictionsForRepo(ctx context.Context, request *InteractionLimit, params InteractionsSetRestrictionsForRepoParams) (res InteractionsSetRestrictionsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-repo"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/interaction-limits"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsSetRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/interaction-limits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInteractionsSetRestrictionsForRepoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInteractionsSetRestrictionsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesAddAssignees invokes issues/add-assignees operation.
//
// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (c *Client) IssuesAddAssignees(ctx context.Context, request OptIssuesAddAssigneesReq, params IssuesAddAssigneesParams) (*IssueSimple, error) {
	res, err := c.sendIssuesAddAssignees(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesAddAssignees(ctx context.Context, request OptIssuesAddAssigneesReq, params IssuesAddAssigneesParams) (res *IssueSimple, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/add-assignees"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/assignees"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesAddAssignees",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/assignees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesAddAssigneesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesAddAssigneesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCheckUserCanBeAssigned invokes issues/check-user-can-be-assigned operation.
//
// Checks if a user has permission to be assigned to an issue in this repository.
// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is
// returned.
// Otherwise a `404` status code is returned.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (c *Client) IssuesCheckUserCanBeAssigned(ctx context.Context, params IssuesCheckUserCanBeAssignedParams) (IssuesCheckUserCanBeAssignedRes, error) {
	res, err := c.sendIssuesCheckUserCanBeAssigned(ctx, params)
	return res, err
}

func (c *Client) sendIssuesCheckUserCanBeAssigned(ctx context.Context, params IssuesCheckUserCanBeAssignedParams) (res IssuesCheckUserCanBeAssignedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/check-user-can-be-assigned"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/assignees/{assignee}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCheckUserCanBeAssigned",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/assignees/"
	{
		// Encode "assignee" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "assignee",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Assignee))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesCheckUserCanBeAssignedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreate invokes issues/create operation.
//
// Any user with pull access to a repository can create an issue. If [issues are disabled in the
// repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone`
// status.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues
func (c *Client) IssuesCreate(ctx context.Context, request *IssuesCreateReq, params IssuesCreateParams) (IssuesCreateRes, error) {
	res, err := c.sendIssuesCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesCreate(ctx context.Context, request *IssuesCreateReq, params IssuesCreateParams) (res IssuesCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreateComment invokes issues/create-comment operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
func (c *Client) IssuesCreateComment(ctx context.Context, request *IssuesCreateCommentReq, params IssuesCreateCommentParams) (IssuesCreateCommentRes, error) {
	res, err := c.sendIssuesCreateComment(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesCreateComment(ctx context.Context, request *IssuesCreateCommentReq, params IssuesCreateCommentParams) (res IssuesCreateCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreateComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesCreateCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesCreateCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreateLabel invokes issues/create-label operation.
//
// Create a label.
//
// POST /repos/{owner}/{repo}/labels
func (c *Client) IssuesCreateLabel(ctx context.Context, request *IssuesCreateLabelReq, params IssuesCreateLabelParams) (IssuesCreateLabelRes, error) {
	res, err := c.sendIssuesCreateLabel(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesCreateLabel(ctx context.Context, request *IssuesCreateLabelReq, params IssuesCreateLabelParams) (res IssuesCreateLabelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-label"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreateLabel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/labels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesCreateLabelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesCreateLabelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreateMilestone invokes issues/create-milestone operation.
//
// Create a milestone.
//
// POST /repos/{owner}/{repo}/milestones
func (c *Client) IssuesCreateMilestone(ctx context.Context, request *IssuesCreateMilestoneReq, params IssuesCreateMilestoneParams) (IssuesCreateMilestoneRes, error) {
	res, err := c.sendIssuesCreateMilestone(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesCreateMilestone(ctx context.Context, request *IssuesCreateMilestoneReq, params IssuesCreateMilestoneParams) (res IssuesCreateMilestoneRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-milestone"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreateMilestone",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/milestones"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesCreateMilestoneRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesCreateMilestoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesDeleteComment invokes issues/delete-comment operation.
//
// Delete an issue comment.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (c *Client) IssuesDeleteComment(ctx context.Context, params IssuesDeleteCommentParams) error {
	_, err := c.sendIssuesDeleteComment(ctx, params)
	return err
}

func (c *Client) sendIssuesDeleteComment(ctx context.Context, params IssuesDeleteCommentParams) (res *IssuesDeleteCommentNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesDeleteComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesDeleteCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesDeleteLabel invokes issues/delete-label operation.
//
// Delete a label.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (c *Client) IssuesDeleteLabel(ctx context.Context, params IssuesDeleteLabelParams) error {
	_, err := c.sendIssuesDeleteLabel(ctx, params)
	return err
}

func (c *Client) sendIssuesDeleteLabel(ctx context.Context, params IssuesDeleteLabelParams) (res *IssuesDeleteLabelNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-label"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesDeleteLabel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesDeleteLabelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesDeleteMilestone invokes issues/delete-milestone operation.
//
// Delete a milestone.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (c *Client) IssuesDeleteMilestone(ctx context.Context, params IssuesDeleteMilestoneParams) (IssuesDeleteMilestoneRes, error) {
	res, err := c.sendIssuesDeleteMilestone(ctx, params)
	return res, err
}

func (c *Client) sendIssuesDeleteMilestone(ctx context.Context, params IssuesDeleteMilestoneParams) (res IssuesDeleteMilestoneRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-milestone"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesDeleteMilestone",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesDeleteMilestoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGet invokes issues/get operation.
//
// The API returns a [`301 Moved Permanently` status](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
// [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to
// another repository. If
// the issue was transferred to or deleted from a repository where the authenticated user lacks read
// access, the API
// returns a `404 Not Found` status. If the issue was deleted from a repository where the
// authenticated user has read
// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted
// issues, subscribe
// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}
func (c *Client) IssuesGet(ctx context.Context, params IssuesGetParams) (IssuesGetRes, error) {
	res, err := c.sendIssuesGet(ctx, params)
	return res, err
}

func (c *Client) sendIssuesGet(ctx context.Context, params IssuesGetParams) (res IssuesGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetComment invokes issues/get-comment operation.
//
// Get an issue comment.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (c *Client) IssuesGetComment(ctx context.Context, params IssuesGetCommentParams) (IssuesGetCommentRes, error) {
	res, err := c.sendIssuesGetComment(ctx, params)
	return res, err
}

func (c *Client) sendIssuesGetComment(ctx context.Context, params IssuesGetCommentParams) (res IssuesGetCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesGetCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetEvent invokes issues/get-event operation.
//
// Get an issue event.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (c *Client) IssuesGetEvent(ctx context.Context, params IssuesGetEventParams) (IssuesGetEventRes, error) {
	res, err := c.sendIssuesGetEvent(ctx, params)
	return res, err
}

func (c *Client) sendIssuesGetEvent(ctx context.Context, params IssuesGetEventParams) (res IssuesGetEventRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-event"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/events/{event_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetEvent",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/events/"
	{
		// Encode "event_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "event_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.EventID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesGetEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetLabel invokes issues/get-label operation.
//
// Get a label.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (c *Client) IssuesGetLabel(ctx context.Context, params IssuesGetLabelParams) (IssuesGetLabelRes, error) {
	res, err := c.sendIssuesGetLabel(ctx, params)
	return res, err
}

func (c *Client) sendIssuesGetLabel(ctx context.Context, params IssuesGetLabelParams) (res IssuesGetLabelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-label"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetLabel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesGetLabelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetMilestone invokes issues/get-milestone operation.
//
// Get a milestone.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (c *Client) IssuesGetMilestone(ctx context.Context, params IssuesGetMilestoneParams) (IssuesGetMilestoneRes, error) {
	res, err := c.sendIssuesGetMilestone(ctx, params)
	return res, err
}

func (c *Client) sendIssuesGetMilestone(ctx context.Context, params IssuesGetMilestoneParams) (res IssuesGetMilestoneRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-milestone"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetMilestone",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesGetMilestoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesList invokes issues/list operation.
//
// List issues assigned to the authenticated user across all visible repositories including owned
// repositories, member
// repositories, and organization repositories. You can use the `filter` query parameter to fetch
// issues that are not
// necessarily assigned to you.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /issues
func (c *Client) IssuesList(ctx context.Context, params IssuesListParams) (IssuesListRes, error) {
	res, err := c.sendIssuesList(ctx, params)
	return res, err
}

func (c *Client) sendIssuesList(ctx context.Context, params IssuesListParams) (res IssuesListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/issues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/issues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "collab" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "collab",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Collab.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "orgs" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "orgs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Orgs.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "owned" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "owned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Owned.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pulls" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pulls",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Pulls.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListAssignees invokes issues/list-assignees operation.
//
// Lists the [available assignees](https://help.github.
// com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
//
// GET /repos/{owner}/{repo}/assignees
func (c *Client) IssuesListAssignees(ctx context.Context, params IssuesListAssigneesParams) (IssuesListAssigneesRes, error) {
	res, err := c.sendIssuesListAssignees(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListAssignees(ctx context.Context, params IssuesListAssigneesParams) (res IssuesListAssigneesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-assignees"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/assignees"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListAssignees",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/assignees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListAssigneesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListComments invokes issues/list-comments operation.
//
// Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (c *Client) IssuesListComments(ctx context.Context, params IssuesListCommentsParams) (IssuesListCommentsRes, error) {
	res, err := c.sendIssuesListComments(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListComments(ctx context.Context, params IssuesListCommentsParams) (res IssuesListCommentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListComments",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListCommentsForRepo invokes issues/list-comments-for-repo operation.
//
// By default, Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/comments
func (c *Client) IssuesListCommentsForRepo(ctx context.Context, params IssuesListCommentsForRepoParams) (IssuesListCommentsForRepoRes, error) {
	res, err := c.sendIssuesListCommentsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListCommentsForRepo(ctx context.Context, params IssuesListCommentsForRepoParams) (res IssuesListCommentsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListCommentsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListEventsForRepo invokes issues/list-events-for-repo operation.
//
// List issue events for a repository.
//
// GET /repos/{owner}/{repo}/issues/events
func (c *Client) IssuesListEventsForRepo(ctx context.Context, params IssuesListEventsForRepoParams) (IssuesListEventsForRepoRes, error) {
	res, err := c.sendIssuesListEventsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListEventsForRepo(ctx context.Context, params IssuesListEventsForRepoParams) (res IssuesListEventsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-events-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListEventsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListEventsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListForAuthenticatedUser invokes issues/list-for-authenticated-user operation.
//
// List issues across owned and member repositories assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /user/issues
func (c *Client) IssuesListForAuthenticatedUser(ctx context.Context, params IssuesListForAuthenticatedUserParams) (IssuesListForAuthenticatedUserRes, error) {
	res, err := c.sendIssuesListForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListForAuthenticatedUser(ctx context.Context, params IssuesListForAuthenticatedUserParams) (res IssuesListForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/issues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/issues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListForOrg invokes issues/list-for-org operation.
//
// List issues in an organization assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /orgs/{org}/issues
func (c *Client) IssuesListForOrg(ctx context.Context, params IssuesListForOrgParams) (IssuesListForOrgRes, error) {
	res, err := c.sendIssuesListForOrg(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListForOrg(ctx context.Context, params IssuesListForOrgParams) (res IssuesListForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/issues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/issues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListForRepo invokes issues/list-for-repo operation.
//
// List issues in a repository.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues
func (c *Client) IssuesListForRepo(ctx context.Context, params IssuesListForRepoParams) (IssuesListForRepoRes, error) {
	res, err := c.sendIssuesListForRepo(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListForRepo(ctx context.Context, params IssuesListForRepoParams) (res IssuesListForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "milestone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "milestone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Milestone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "assignee" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "assignee",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Assignee.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "creator" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "creator",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Creator.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "mentioned" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mentioned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Mentioned.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListLabelsForMilestone invokes issues/list-labels-for-milestone operation.
//
// List labels for issues in a milestone.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (c *Client) IssuesListLabelsForMilestone(ctx context.Context, params IssuesListLabelsForMilestoneParams) (*IssuesListLabelsForMilestoneOKHeaders, error) {
	res, err := c.sendIssuesListLabelsForMilestone(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListLabelsForMilestone(ctx context.Context, params IssuesListLabelsForMilestoneParams) (res *IssuesListLabelsForMilestoneOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-milestone"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}/labels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListLabelsForMilestone",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/labels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListLabelsForMilestoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListLabelsForRepo invokes issues/list-labels-for-repo operation.
//
// List labels for a repository.
//
// GET /repos/{owner}/{repo}/labels
func (c *Client) IssuesListLabelsForRepo(ctx context.Context, params IssuesListLabelsForRepoParams) (IssuesListLabelsForRepoRes, error) {
	res, err := c.sendIssuesListLabelsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListLabelsForRepo(ctx context.Context, params IssuesListLabelsForRepoParams) (res IssuesListLabelsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListLabelsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/labels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListLabelsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListLabelsOnIssue invokes issues/list-labels-on-issue operation.
//
// List labels for an issue.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (c *Client) IssuesListLabelsOnIssue(ctx context.Context, params IssuesListLabelsOnIssueParams) (IssuesListLabelsOnIssueRes, error) {
	res, err := c.sendIssuesListLabelsOnIssue(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListLabelsOnIssue(ctx context.Context, params IssuesListLabelsOnIssueParams) (res IssuesListLabelsOnIssueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-on-issue"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/labels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListLabelsOnIssue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/labels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListLabelsOnIssueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListMilestones invokes issues/list-milestones operation.
//
// List milestones.
//
// GET /repos/{owner}/{repo}/milestones
func (c *Client) IssuesListMilestones(ctx context.Context, params IssuesListMilestonesParams) (IssuesListMilestonesRes, error) {
	res, err := c.sendIssuesListMilestones(ctx, params)
	return res, err
}

func (c *Client) sendIssuesListMilestones(ctx context.Context, params IssuesListMilestonesParams) (res IssuesListMilestonesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-milestones"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListMilestones",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/milestones"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesListMilestonesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesLock invokes issues/lock operation.
//
// Users with push access can lock an issue or pull request's conversation.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
func (c *Client) IssuesLock(ctx context.Context, request OptNilIssuesLockReq, params IssuesLockParams) (IssuesLockRes, error) {
	res, err := c.sendIssuesLock(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesLock(ctx context.Context, request OptNilIssuesLockReq, params IssuesLockParams) (res IssuesLockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/lock"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/lock"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesLock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/lock"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesLockRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesLockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesRemoveAllLabels invokes issues/remove-all-labels operation.
//
// Remove all labels from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (c *Client) IssuesRemoveAllLabels(ctx context.Context, params IssuesRemoveAllLabelsParams) (IssuesRemoveAllLabelsRes, error) {
	res, err := c.sendIssuesRemoveAllLabels(ctx, params)
	return res, err
}

func (c *Client) sendIssuesRemoveAllLabels(ctx context.Context, params IssuesRemoveAllLabelsParams) (res IssuesRemoveAllLabelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-all-labels"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/labels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesRemoveAllLabels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/labels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesRemoveAllLabelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesRemoveAssignees invokes issues/remove-assignees operation.
//
// Removes one or more assignees from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (c *Client) IssuesRemoveAssignees(ctx context.Context, request OptIssuesRemoveAssigneesReq, params IssuesRemoveAssigneesParams) (*IssueSimple, error) {
	res, err := c.sendIssuesRemoveAssignees(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesRemoveAssignees(ctx context.Context, request OptIssuesRemoveAssigneesReq, params IssuesRemoveAssigneesParams) (res *IssueSimple, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-assignees"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/assignees"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesRemoveAssignees",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/assignees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesRemoveAssigneesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesRemoveAssigneesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesRemoveLabel invokes issues/remove-label operation.
//
// Removes the specified label from the issue, and returns the remaining labels on the issue. This
// endpoint returns a `404 Not Found` status if the label does not exist.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (c *Client) IssuesRemoveLabel(ctx context.Context, params IssuesRemoveLabelParams) (IssuesRemoveLabelRes, error) {
	res, err := c.sendIssuesRemoveLabel(ctx, params)
	return res, err
}

func (c *Client) sendIssuesRemoveLabel(ctx context.Context, params IssuesRemoveLabelParams) (res IssuesRemoveLabelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-label"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesRemoveLabel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesRemoveLabelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUnlock invokes issues/unlock operation.
//
// Users with push access can unlock an issue's conversation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (c *Client) IssuesUnlock(ctx context.Context, params IssuesUnlockParams) (IssuesUnlockRes, error) {
	res, err := c.sendIssuesUnlock(ctx, params)
	return res, err
}

func (c *Client) sendIssuesUnlock(ctx context.Context, params IssuesUnlockParams) (res IssuesUnlockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/unlock"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/lock"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUnlock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/lock"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesUnlockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdate invokes issues/update operation.
//
// Issue owners and users with push access can edit an issue.
//
// PATCH /repos/{owner}/{repo}/issues/{issue_number}
func (c *Client) IssuesUpdate(ctx context.Context, request OptIssuesUpdateReq, params IssuesUpdateParams) (IssuesUpdateRes, error) {
	res, err := c.sendIssuesUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesUpdate(ctx context.Context, request OptIssuesUpdateReq, params IssuesUpdateParams) (res IssuesUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdateComment invokes issues/update-comment operation.
//
// Update an issue comment.
//
// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
func (c *Client) IssuesUpdateComment(ctx context.Context, request *IssuesUpdateCommentReq, params IssuesUpdateCommentParams) (IssuesUpdateCommentRes, error) {
	res, err := c.sendIssuesUpdateComment(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesUpdateComment(ctx context.Context, request *IssuesUpdateCommentReq, params IssuesUpdateCommentParams) (res IssuesUpdateCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-comment"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdateComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesUpdateCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesUpdateCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdateLabel invokes issues/update-label operation.
//
// Update a label.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (c *Client) IssuesUpdateLabel(ctx context.Context, request OptIssuesUpdateLabelReq, params IssuesUpdateLabelParams) (*Label, error) {
	res, err := c.sendIssuesUpdateLabel(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesUpdateLabel(ctx context.Context, request OptIssuesUpdateLabelReq, params IssuesUpdateLabelParams) (res *Label, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-label"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdateLabel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesUpdateLabelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesUpdateLabelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdateMilestone invokes issues/update-milestone operation.
//
// Update a milestone.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (c *Client) IssuesUpdateMilestone(ctx context.Context, request OptIssuesUpdateMilestoneReq, params IssuesUpdateMilestoneParams) (*Milestone, error) {
	res, err := c.sendIssuesUpdateMilestone(ctx, request, params)
	return res, err
}

func (c *Client) sendIssuesUpdateMilestone(ctx context.Context, request OptIssuesUpdateMilestoneReq, params IssuesUpdateMilestoneParams) (res *Milestone, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-milestone"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdateMilestone",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIssuesUpdateMilestoneRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIssuesUpdateMilestoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicensesGet invokes licenses/get operation.
//
// Get a license.
//
// GET /licenses/{license}
func (c *Client) LicensesGet(ctx context.Context, params LicensesGetParams) (LicensesGetRes, error) {
	res, err := c.sendLicensesGet(ctx, params)
	return res, err
}

func (c *Client) sendLicensesGet(ctx context.Context, params LicensesGetParams) (res LicensesGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/licenses/{license}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "LicensesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/licenses/"
	{
		// Encode "license" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "license",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.License))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLicensesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicensesGetAllCommonlyUsed invokes licenses/get-all-commonly-used operation.
//
// Get all commonly used licenses.
//
// GET /licenses
func (c *Client) LicensesGetAllCommonlyUsed(ctx context.Context, params LicensesGetAllCommonlyUsedParams) (LicensesGetAllCommonlyUsedRes, error) {
	res, err := c.sendLicensesGetAllCommonlyUsed(ctx, params)
	return res, err
}

func (c *Client) sendLicensesGetAllCommonlyUsed(ctx context.Context, params LicensesGetAllCommonlyUsedParams) (res LicensesGetAllCommonlyUsedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-all-commonly-used"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/licenses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "LicensesGetAllCommonlyUsed",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/licenses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "featured" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Featured.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLicensesGetAllCommonlyUsedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicensesGetForRepo invokes licenses/get-for-repo operation.
//
// This method returns the contents of the repository's license file, if one is detected.
// Similar to [Get repository content](https://docs.github.
// com/rest/reference/repos#get-repository-content), this method also supports [custom media
// types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content
// or rendered license HTML.
//
// GET /repos/{owner}/{repo}/license
func (c *Client) LicensesGetForRepo(ctx context.Context, params LicensesGetForRepoParams) (*LicenseContent, error) {
	res, err := c.sendLicensesGetForRepo(ctx, params)
	return res, err
}

func (c *Client) sendLicensesGetForRepo(ctx context.Context, params LicensesGetForRepoParams) (res *LicenseContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/license"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "LicensesGetForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/license"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLicensesGetForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarkdownRender invokes markdown/render operation.
//
// Render a Markdown document.
//
// POST /markdown
func (c *Client) MarkdownRender(ctx context.Context, request *MarkdownRenderReq) (MarkdownRenderRes, error) {
	res, err := c.sendMarkdownRender(ctx, request)
	return res, err
}

func (c *Client) sendMarkdownRender(ctx context.Context, request *MarkdownRenderReq) (res MarkdownRenderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("markdown/render"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/markdown"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarkdownRender",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/markdown"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarkdownRenderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarkdownRenderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarkdownRenderRaw invokes markdown/render-raw operation.
//
// You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or
// `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored
// Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain
// format like a README.md file. Markdown content must be 400 KB or less.
//
// POST /markdown/raw
func (c *Client) MarkdownRenderRaw(ctx context.Context, request MarkdownRenderRawReq) (MarkdownRenderRawRes, error) {
	res, err := c.sendMarkdownRenderRaw(ctx, request)
	return res, err
}

func (c *Client) sendMarkdownRenderRaw(ctx context.Context, request MarkdownRenderRawReq) (res MarkdownRenderRawRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("markdown/render-raw"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/markdown/raw"),
	}
	// Validate request before sending.
	switch request := request.(type) {
	case *MarkdownRenderRawReqEmptyBody:
		// Validation is not needed for the empty body type.
	case *MarkdownRenderRawReqTextPlain:
		// Validation is not required for this type.
	case *MarkdownRenderRawReqTextXMarkdown:
		// Validation is not required for this type.
	default:
		return res, errors.Errorf("unexpected request type: %T", request)
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarkdownRenderRaw",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/markdown/raw"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarkdownRenderRawRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarkdownRenderRawResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetaGet invokes meta/get operation.
//
// Returns meta information about GitHub, including a list of GitHub's IP addresses. For more
// information, see "[About GitHub's IP addresses](https://help.github.
// com/articles/about-github-s-ip-addresses/)."
// **Note:** The IP addresses shown in the documentation's response are only example values. You must
// always query the API directly to get the latest list of IP addresses.
//
// GET /meta
func (c *Client) MetaGet(ctx context.Context) (MetaGetRes, error) {
	res, err := c.sendMetaGet(ctx)
	return res, err
}

func (c *Client) sendMetaGet(ctx context.Context) (res MetaGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/meta"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetaGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/meta"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetaGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetaGetOctocat invokes meta/get-octocat operation.
//
// Get the octocat as ASCII art.
//
// GET /octocat
func (c *Client) MetaGetOctocat(ctx context.Context, params MetaGetOctocatParams) (MetaGetOctocatOK, error) {
	res, err := c.sendMetaGetOctocat(ctx, params)
	return res, err
}

func (c *Client) sendMetaGetOctocat(ctx context.Context, params MetaGetOctocatParams) (res MetaGetOctocatOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-octocat"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/octocat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetaGetOctocat",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/octocat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "s" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "s",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.S.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetaGetOctocatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetaGetZen invokes meta/get-zen operation.
//
// Get a random sentence from the Zen of GitHub.
//
// GET /zen
func (c *Client) MetaGetZen(ctx context.Context) (MetaGetZenOK, error) {
	res, err := c.sendMetaGetZen(ctx)
	return res, err
}

func (c *Client) sendMetaGetZen(ctx context.Context) (res MetaGetZenOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-zen"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/zen"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetaGetZen",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/zen"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetaGetZenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetaRoot invokes meta/root operation.
//
// Get Hypermedia links to resources accessible in GitHub's REST API.
//
// GET /
func (c *Client) MetaRoot(ctx context.Context) (*MetaRootOK, error) {
	res, err := c.sendMetaRoot(ctx)
	return res, err
}

func (c *Client) sendMetaRoot(ctx context.Context) (res *MetaRootOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/root"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetaRoot",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetaRootResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsCancelImport invokes migrations/cancel-import operation.
//
// Stop an import for a repository.
//
// DELETE /repos/{owner}/{repo}/import
func (c *Client) MigrationsCancelImport(ctx context.Context, params MigrationsCancelImportParams) error {
	_, err := c.sendMigrationsCancelImport(ctx, params)
	return err
}

func (c *Client) sendMigrationsCancelImport(ctx context.Context, params MigrationsCancelImportParams) (res *MigrationsCancelImportNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/cancel-import"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsCancelImport",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsCancelImportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsDeleteArchiveForAuthenticatedUser invokes migrations/delete-archive-for-authenticated-user operation.
//
// Deletes a previous migration archive. Downloadable migration archives are automatically deleted
// after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.
// github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration
// status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints,
// will continue to be available even after an archive is deleted.
//
// DELETE /user/migrations/{migration_id}/archive
func (c *Client) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, params MigrationsDeleteArchiveForAuthenticatedUserParams) (MigrationsDeleteArchiveForAuthenticatedUserRes, error) {
	res, err := c.sendMigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, params MigrationsDeleteArchiveForAuthenticatedUserParams) (res MigrationsDeleteArchiveForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/archive"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsDeleteArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/archive"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsDeleteArchiveForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsDeleteArchiveForOrg invokes migrations/delete-archive-for-org operation.
//
// Deletes a previous migration archive. Migration archives are automatically deleted after seven
// days.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (c *Client) MigrationsDeleteArchiveForOrg(ctx context.Context, params MigrationsDeleteArchiveForOrgParams) (MigrationsDeleteArchiveForOrgRes, error) {
	res, err := c.sendMigrationsDeleteArchiveForOrg(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsDeleteArchiveForOrg(ctx context.Context, params MigrationsDeleteArchiveForOrgParams) (res MigrationsDeleteArchiveForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/archive"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsDeleteArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/archive"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsDeleteArchiveForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsDownloadArchiveForOrg invokes migrations/download-archive-for-org operation.
//
// Fetches the URL to a migration archive.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (c *Client) MigrationsDownloadArchiveForOrg(ctx context.Context, params MigrationsDownloadArchiveForOrgParams) (MigrationsDownloadArchiveForOrgRes, error) {
	res, err := c.sendMigrationsDownloadArchiveForOrg(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsDownloadArchiveForOrg(ctx context.Context, params MigrationsDownloadArchiveForOrgParams) (res MigrationsDownloadArchiveForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/download-archive-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/archive"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsDownloadArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/archive"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsDownloadArchiveForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetArchiveForAuthenticatedUser invokes migrations/get-archive-for-authenticated-user operation.
//
// Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources
// your repository uses, the migration archive can contain JSON files with data for these objects:
// *   attachments
// *   bases
// *   commit\_comments
// *   issue\_comments
// *   issue\_events
// *   issues
// *   milestones
// *   organizations
// *   projects
// *   protected\_branches
// *   pull\_request\_reviews
// *   pull\_requests
// *   releases
// *   repositories
// *   review\_comments
// *   schema
// *   users
// The archive will also contain an `attachments` directory that includes all attachment files
// uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
//
// GET /user/migrations/{migration_id}/archive
func (c *Client) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, params MigrationsGetArchiveForAuthenticatedUserParams) (MigrationsGetArchiveForAuthenticatedUserRes, error) {
	res, err := c.sendMigrationsGetArchiveForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsGetArchiveForAuthenticatedUser(ctx context.Context, params MigrationsGetArchiveForAuthenticatedUserParams) (res MigrationsGetArchiveForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-archive-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/archive"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/archive"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsGetArchiveForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetCommitAuthors invokes migrations/get-commit-authors operation.
//
// Each type of source control system represents authors in a different way. For example, a Git
// commit author has a display name and an email address, but a Subversion commit author just has a
// username. The GitHub Importer will make the author information valid, but the author might not be
// correct. For example, it will change the bare Subversion username `hubot` into something like
// `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
// This endpoint and the [Map a commit author](https://docs.github.
// com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git
// author information.
//
// GET /repos/{owner}/{repo}/import/authors
func (c *Client) MigrationsGetCommitAuthors(ctx context.Context, params MigrationsGetCommitAuthorsParams) (MigrationsGetCommitAuthorsRes, error) {
	res, err := c.sendMigrationsGetCommitAuthors(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsGetCommitAuthors(ctx context.Context, params MigrationsGetCommitAuthorsParams) (res MigrationsGetCommitAuthorsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-commit-authors"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/authors"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetCommitAuthors",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import/authors"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsGetCommitAuthorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetImportStatus invokes migrations/get-import-status operation.
//
// View the progress of an import.
// **Import status**
// This section includes details about the possible values of the `status` field of the Import
// Progress response.
// An import that does not have errors will progress through these steps:
// *   `detecting` - the "detection" step of the import is in progress because the request did not
// include a `vcs` parameter. The import is identifying the type of source control present at the URL.
// *   `importing` - the "raw" step of the import is in progress. This is where commit data is
// fetched from the original repository. The import progress response will include `commit_count`
// (the total number of raw commits that will be imported) and `percent` (0 - 100, the current
// progress through the import).
// *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are
// converted to Git branches, and where author updates are applied. The import progress response does
// not include progress information.
// *   `pushing` - the "push" step of the import is in progress. This is where the importer updates
// the repository on GitHub. The import progress response will include `push_percent`, which is the
// percent value reported by `git push` when it is "Writing objects".
// *   `complete` - the import is complete, and the repository is ready on GitHub.
// If there are problems, you will see one of these in the `status` field:
// *   `auth_failed` - the import requires authentication in order to connect to the original
// repository. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `error` - the import encountered an error. The import progress response will include the
// `failed_step` and an error message. Contact [GitHub Support](https://support.github.
// com/contact?tags=dotcom-rest-api) for more information.
// *   `detection_needs_auth` - the importer requires authentication for the originating repository
// to continue detection. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
// resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import)
// and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
// URL.
// *   `detection_found_multiple` - the importer found several projects or repositories at the
// provided URL. When this is the case, the Import Progress response will also include a
// `project_choices` field with the possible project choices as values. To update project choice,
// please see the [Update an import](https://docs.github.
// com/rest/reference/migrations#update-an-import) section.
// **The project_choices field**
// When multiple projects are found at the provided URL, the response hash will include a
// `project_choices` field, the value of which is an array of hashes each representing a project
// choice. The exact key/value pairs of the project hashes will differ depending on the version
// control type.
// **Git LFS related fields**
// This section includes details about Git LFS related fields that may be present in the Import
// Progress response.
// *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
// can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
// *   `has_large_files` - the boolean value describing whether files larger than 100MB were found
// during the `importing` step.
// *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the
// originating repository.
// *   `large_files_count` - the total number of files larger than 100MB found in the originating
// repository. To see a list of these files, make a "Get Large Files" request.
//
// GET /repos/{owner}/{repo}/import
func (c *Client) MigrationsGetImportStatus(ctx context.Context, params MigrationsGetImportStatusParams) (MigrationsGetImportStatusRes, error) {
	res, err := c.sendMigrationsGetImportStatus(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsGetImportStatus(ctx context.Context, params MigrationsGetImportStatusParams) (res MigrationsGetImportStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-import-status"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetImportStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsGetImportStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetLargeFiles invokes migrations/get-large-files operation.
//
// List files larger than 100MB found during the import.
//
// GET /repos/{owner}/{repo}/import/large_files
func (c *Client) MigrationsGetLargeFiles(ctx context.Context, params MigrationsGetLargeFilesParams) ([]PorterLargeFile, error) {
	res, err := c.sendMigrationsGetLargeFiles(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsGetLargeFiles(ctx context.Context, params MigrationsGetLargeFilesParams) (res []PorterLargeFile, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-large-files"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/large_files"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetLargeFiles",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import/large_files"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsGetLargeFilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetStatusForAuthenticatedUser invokes migrations/get-status-for-authenticated-user operation.
//
// Fetches a single user migration. The response includes the `state` of the migration, which can be
// one of the following values:
// *   `pending` - the migration hasn't started yet.
// *   `exporting` - the migration is in progress.
// *   `exported` - the migration finished successfully.
// *   `failed` - the migration failed.
// Once the migration has been `exported` you can [download the migration archive](https://docs.
// github.com/rest/reference/migrations#download-a-user-migration-archive).
//
// GET /user/migrations/{migration_id}
func (c *Client) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, params MigrationsGetStatusForAuthenticatedUserParams) (MigrationsGetStatusForAuthenticatedUserRes, error) {
	res, err := c.sendMigrationsGetStatusForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsGetStatusForAuthenticatedUser(ctx context.Context, params MigrationsGetStatusForAuthenticatedUserParams) (res MigrationsGetStatusForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetStatusForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "exclude" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Exclude {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsGetStatusForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetStatusForOrg invokes migrations/get-status-for-org operation.
//
// Fetches the status of a migration.
// The `state` of a migration can be one of the following values:
// *   `pending`, which means the migration hasn't started yet.
// *   `exporting`, which means the migration is in progress.
// *   `exported`, which means the migration finished successfully.
// *   `failed`, which means the migration failed.
//
// GET /orgs/{org}/migrations/{migration_id}
func (c *Client) MigrationsGetStatusForOrg(ctx context.Context, params MigrationsGetStatusForOrgParams) (MigrationsGetStatusForOrgRes, error) {
	res, err := c.sendMigrationsGetStatusForOrg(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsGetStatusForOrg(ctx context.Context, params MigrationsGetStatusForOrgParams) (res MigrationsGetStatusForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetStatusForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "exclude" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Exclude {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsGetStatusForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListForAuthenticatedUser invokes migrations/list-for-authenticated-user operation.
//
// Lists all migrations a user has started.
//
// GET /user/migrations
func (c *Client) MigrationsListForAuthenticatedUser(ctx context.Context, params MigrationsListForAuthenticatedUserParams) (MigrationsListForAuthenticatedUserRes, error) {
	res, err := c.sendMigrationsListForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsListForAuthenticatedUser(ctx context.Context, params MigrationsListForAuthenticatedUserParams) (res MigrationsListForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/migrations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListForOrg invokes migrations/list-for-org operation.
//
// Lists the most recent migrations.
//
// GET /orgs/{org}/migrations
func (c *Client) MigrationsListForOrg(ctx context.Context, params MigrationsListForOrgParams) (*MigrationsListForOrgOKHeaders, error) {
	res, err := c.sendMigrationsListForOrg(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsListForOrg(ctx context.Context, params MigrationsListForOrgParams) (res *MigrationsListForOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "exclude" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Exclude {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsListForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListReposForOrg invokes migrations/list-repos-for-org operation.
//
// List all the repositories for this organization migration.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (c *Client) MigrationsListReposForOrg(ctx context.Context, params MigrationsListReposForOrgParams) (MigrationsListReposForOrgRes, error) {
	res, err := c.sendMigrationsListReposForOrg(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsListReposForOrg(ctx context.Context, params MigrationsListReposForOrgParams) (res MigrationsListReposForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListReposForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsListReposForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListReposForUser invokes migrations/list-repos-for-user operation.
//
// Lists all the repositories for this user migration.
//
// GET /user/migrations/{migration_id}/repositories
func (c *Client) MigrationsListReposForUser(ctx context.Context, params MigrationsListReposForUserParams) (MigrationsListReposForUserRes, error) {
	res, err := c.sendMigrationsListReposForUser(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsListReposForUser(ctx context.Context, params MigrationsListReposForUserParams) (res MigrationsListReposForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListReposForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsListReposForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsMapCommitAuthor invokes migrations/map-commit-author operation.
//
// Update an author's identity for the import. Your application can continue updating authors any
// time before you push new commits to the repository.
//
// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
func (c *Client) MigrationsMapCommitAuthor(ctx context.Context, request OptMigrationsMapCommitAuthorReq, params MigrationsMapCommitAuthorParams) (MigrationsMapCommitAuthorRes, error) {
	res, err := c.sendMigrationsMapCommitAuthor(ctx, request, params)
	return res, err
}

func (c *Client) sendMigrationsMapCommitAuthor(ctx context.Context, request OptMigrationsMapCommitAuthorReq, params MigrationsMapCommitAuthorParams) (res MigrationsMapCommitAuthorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/map-commit-author"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/authors/{author_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsMapCommitAuthor",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import/authors/"
	{
		// Encode "author_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "author_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrationsMapCommitAuthorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsMapCommitAuthorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsSetLfsPreference invokes migrations/set-lfs-preference operation.
//
// You can import repositories from Subversion, Mercurial, and TFS that include files larger than
// 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about
// our LFS feature and working with large files [on our help site](https://help.github.
// com/articles/versioning-large-files/).
//
// PATCH /repos/{owner}/{repo}/import/lfs
func (c *Client) MigrationsSetLfsPreference(ctx context.Context, request *MigrationsSetLfsPreferenceReq, params MigrationsSetLfsPreferenceParams) (MigrationsSetLfsPreferenceRes, error) {
	res, err := c.sendMigrationsSetLfsPreference(ctx, request, params)
	return res, err
}

func (c *Client) sendMigrationsSetLfsPreference(ctx context.Context, request *MigrationsSetLfsPreferenceReq, params MigrationsSetLfsPreferenceParams) (res MigrationsSetLfsPreferenceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/set-lfs-preference"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/lfs"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsSetLfsPreference",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import/lfs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrationsSetLfsPreferenceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsSetLfsPreferenceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsStartForAuthenticatedUser invokes migrations/start-for-authenticated-user operation.
//
// Initiates the generation of a user migration archive.
//
// POST /user/migrations
func (c *Client) MigrationsStartForAuthenticatedUser(ctx context.Context, request *MigrationsStartForAuthenticatedUserReq) (MigrationsStartForAuthenticatedUserRes, error) {
	res, err := c.sendMigrationsStartForAuthenticatedUser(ctx, request)
	return res, err
}

func (c *Client) sendMigrationsStartForAuthenticatedUser(ctx context.Context, request *MigrationsStartForAuthenticatedUserReq) (res MigrationsStartForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-authenticated-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/migrations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsStartForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/migrations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrationsStartForAuthenticatedUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsStartForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsStartForOrg invokes migrations/start-for-org operation.
//
// Initiates the generation of a migration archive.
//
// POST /orgs/{org}/migrations
func (c *Client) MigrationsStartForOrg(ctx context.Context, request *MigrationsStartForOrgReq, params MigrationsStartForOrgParams) (MigrationsStartForOrgRes, error) {
	res, err := c.sendMigrationsStartForOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendMigrationsStartForOrg(ctx context.Context, request *MigrationsStartForOrgReq, params MigrationsStartForOrgParams) (res MigrationsStartForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsStartForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrationsStartForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsStartForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsStartImport invokes migrations/start-import operation.
//
// Start a source import to a GitHub repository using GitHub Importer.
//
// PUT /repos/{owner}/{repo}/import
func (c *Client) MigrationsStartImport(ctx context.Context, request *MigrationsStartImportReq, params MigrationsStartImportParams) (MigrationsStartImportRes, error) {
	res, err := c.sendMigrationsStartImport(ctx, request, params)
	return res, err
}

func (c *Client) sendMigrationsStartImport(ctx context.Context, request *MigrationsStartImportReq, params MigrationsStartImportParams) (res MigrationsStartImportRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-import"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsStartImport",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrationsStartImportRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsStartImportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsUnlockRepoForAuthenticatedUser invokes migrations/unlock-repo-for-authenticated-user operation.
//
// Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.
// github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you
// can unlock each repository to begin using it again or [delete the repository](https://docs.github.
// com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a
// status of `404 Not Found` if the repository is not locked.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (c *Client) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, params MigrationsUnlockRepoForAuthenticatedUserParams) (MigrationsUnlockRepoForAuthenticatedUserRes, error) {
	res, err := c.sendMigrationsUnlockRepoForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, params MigrationsUnlockRepoForAuthenticatedUserParams) (res MigrationsUnlockRepoForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/repos/{repo_name}/lock"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsUnlockRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos/"
	{
		// Encode "repo_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RepoName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/lock"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsUnlockRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsUnlockRepoForOrg invokes migrations/unlock-repo-for-org operation.
//
// Unlocks a repository that was locked for migration. You should unlock each migrated repository and
// [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration
// is complete and you no longer need the source data.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (c *Client) MigrationsUnlockRepoForOrg(ctx context.Context, params MigrationsUnlockRepoForOrgParams) (MigrationsUnlockRepoForOrgRes, error) {
	res, err := c.sendMigrationsUnlockRepoForOrg(ctx, params)
	return res, err
}

func (c *Client) sendMigrationsUnlockRepoForOrg(ctx context.Context, params MigrationsUnlockRepoForOrgParams) (res MigrationsUnlockRepoForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsUnlockRepoForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repos/"
	{
		// Encode "repo_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RepoName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/lock"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsUnlockRepoForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsUpdateImport invokes migrations/update-import operation.
//
// An import can be updated with credentials or a project choice by passing in the appropriate
// parameters in this API
// request. If no parameters are provided, the import will be restarted.
//
// PATCH /repos/{owner}/{repo}/import
func (c *Client) MigrationsUpdateImport(ctx context.Context, request OptNilMigrationsUpdateImportReq, params MigrationsUpdateImportParams) (*Import, error) {
	res, err := c.sendMigrationsUpdateImport(ctx, request, params)
	return res, err
}

func (c *Client) sendMigrationsUpdateImport(ctx context.Context, request OptNilMigrationsUpdateImportReq, params MigrationsUpdateImportParams) (res *Import, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/update-import"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsUpdateImport",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/import"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrationsUpdateImportRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrationsUpdateImportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsCreateAuthorization invokes oauth-authorizations/create-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates OAuth tokens using [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor
// authentication setup, Basic Authentication for this endpoint requires that you use a one-time
// password (OTP) and your username and password instead of tokens. For more information, see
// "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// To create tokens for a particular OAuth application using this endpoint, you must authenticate as
// the user you want to create an authorization for and provide the app's client ID and secret, found
// on your OAuth application's settings page. If your OAuth application intends to create multiple
// tokens for one user, use `fingerprint` to differentiate between them.
// You can also create tokens on GitHub from the [personal access tokens settings](https://github.
// com/settings/tokens) page. Read more about these tokens in [the GitHub Help
// documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
// Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about
// allowing tokens in [the GitHub Help documentation](https://help.github.
// com/articles/about-identity-and-access-management-with-saml-single-sign-on).
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /authorizations
func (c *Client) OAuthAuthorizationsCreateAuthorization(ctx context.Context, request OptOAuthAuthorizationsCreateAuthorizationReq) (OAuthAuthorizationsCreateAuthorizationRes, error) {
	res, err := c.sendOAuthAuthorizationsCreateAuthorization(ctx, request)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsCreateAuthorization(ctx context.Context, request OptOAuthAuthorizationsCreateAuthorizationReq) (res OAuthAuthorizationsCreateAuthorizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/create-authorization"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/authorizations"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsCreateAuthorization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/authorizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOAuthAuthorizationsCreateAuthorizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsCreateAuthorizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsDeleteAuthorization invokes oauth-authorizations/delete-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /authorizations/{authorization_id}
func (c *Client) OAuthAuthorizationsDeleteAuthorization(ctx context.Context, params OAuthAuthorizationsDeleteAuthorizationParams) (OAuthAuthorizationsDeleteAuthorizationRes, error) {
	res, err := c.sendOAuthAuthorizationsDeleteAuthorization(ctx, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsDeleteAuthorization(ctx context.Context, params OAuthAuthorizationsDeleteAuthorizationParams) (res OAuthAuthorizationsDeleteAuthorizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-authorization"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/authorizations/{authorization_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/authorizations/"
	{
		// Encode "authorization_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorizationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsDeleteAuthorizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsDeleteGrant invokes oauth-authorizations/delete-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for your user. Once deleted, the application has no access to your account and is no
// longer listed on [the application authorizations settings screen within GitHub](https://github.
// com/settings/applications#authorized).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /applications/grants/{grant_id}
func (c *Client) OAuthAuthorizationsDeleteGrant(ctx context.Context, params OAuthAuthorizationsDeleteGrantParams) (OAuthAuthorizationsDeleteGrantRes, error) {
	res, err := c.sendOAuthAuthorizationsDeleteGrant(ctx, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsDeleteGrant(ctx context.Context, params OAuthAuthorizationsDeleteGrantParams) (res OAuthAuthorizationsDeleteGrantRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-grant"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/applications/grants/{grant_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsDeleteGrant",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/applications/grants/"
	{
		// Encode "grant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "grant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GrantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsDeleteGrantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetAuthorization invokes oauth-authorizations/get-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /authorizations/{authorization_id}
func (c *Client) OAuthAuthorizationsGetAuthorization(ctx context.Context, params OAuthAuthorizationsGetAuthorizationParams) (OAuthAuthorizationsGetAuthorizationRes, error) {
	res, err := c.sendOAuthAuthorizationsGetAuthorization(ctx, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsGetAuthorization(ctx context.Context, params OAuthAuthorizationsGetAuthorizationParams) (res OAuthAuthorizationsGetAuthorizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-authorization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/authorizations/{authorization_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetAuthorization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/authorizations/"
	{
		// Encode "authorization_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorizationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsGetAuthorizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetGrant invokes oauth-authorizations/get-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /applications/grants/{grant_id}
func (c *Client) OAuthAuthorizationsGetGrant(ctx context.Context, params OAuthAuthorizationsGetGrantParams) (OAuthAuthorizationsGetGrantRes, error) {
	res, err := c.sendOAuthAuthorizationsGetGrant(ctx, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsGetGrant(ctx context.Context, params OAuthAuthorizationsGetGrantParams) (res OAuthAuthorizationsGetGrantRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-grant"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/applications/grants/{grant_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetGrant",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/applications/grants/"
	{
		// Encode "grant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "grant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GrantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsGetGrantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetOrCreateAuthorizationForApp invokes oauth-authorizations/get-or-create-authorization-for-app operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates a new authorization for the specified OAuth application, only if an authorization for that
// application doesn't already exist for the user. The URL includes the 20 character client ID for
// the OAuth app that is requesting the token. It returns the user's existing authorization for the
// application if one is present. Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /authorizations/clients/{client_id}
func (c *Client) OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, request *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams) (OAuthAuthorizationsGetOrCreateAuthorizationForAppRes, error) {
	res, err := c.sendOAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, request *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams) (res OAuthAuthorizationsGetOrCreateAuthorizationForAppRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/authorizations/clients/{client_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/authorizations/clients/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint invokes oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// This method will create a new authorization for the specified OAuth application, only if an
// authorization for that application and fingerprint do not already exist for the user. The URL
// includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint`
// is a unique string to distinguish an authorization from others created for the same client ID and
// user. It returns the user's existing authorization for the application if one is present.
// Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /authorizations/clients/{client_id}/{fingerprint}
func (c *Client) OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, request *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams) (OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes, error) {
	res, err := c.sendOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, request *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams) (res OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/authorizations/clients/{client_id}/{fingerprint}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/authorizations/clients/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "fingerprint" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fingerprint",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Fingerprint))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsListAuthorizations invokes oauth-authorizations/list-authorizations operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /authorizations
func (c *Client) OAuthAuthorizationsListAuthorizations(ctx context.Context, params OAuthAuthorizationsListAuthorizationsParams) (OAuthAuthorizationsListAuthorizationsRes, error) {
	res, err := c.sendOAuthAuthorizationsListAuthorizations(ctx, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsListAuthorizations(ctx context.Context, params OAuthAuthorizationsListAuthorizationsParams) (res OAuthAuthorizationsListAuthorizationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-authorizations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/authorizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsListAuthorizations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/authorizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "client_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClientID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsListAuthorizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsListGrants invokes oauth-authorizations/list-grants operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// You can use this API to list the set of OAuth applications that have been granted access to your
// account. Unlike the [list your authorizations](https://docs.github.
// com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage
// individual tokens. This API will return one entry for each OAuth application that has been granted
// access to your account, regardless of the number of tokens an application has generated for your
// user. The list of OAuth applications returned matches what is shown on [the application
// authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
//
//	The `scopes` returned are the union of scopes authorized for the application. For example, if an
//
// application has one token with `repo` scope and another token with `user` scope, the grant will
// return `["repo", "user"]`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /applications/grants
func (c *Client) OAuthAuthorizationsListGrants(ctx context.Context, params OAuthAuthorizationsListGrantsParams) (OAuthAuthorizationsListGrantsRes, error) {
	res, err := c.sendOAuthAuthorizationsListGrants(ctx, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsListGrants(ctx context.Context, params OAuthAuthorizationsListGrantsParams) (res OAuthAuthorizationsListGrantsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-grants"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/applications/grants"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsListGrants",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/applications/grants"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "client_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClientID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsListGrantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsUpdateAuthorization invokes oauth-authorizations/update-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// You can only send one of these scope keys at a time.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /authorizations/{authorization_id}
func (c *Client) OAuthAuthorizationsUpdateAuthorization(ctx context.Context, request OptOAuthAuthorizationsUpdateAuthorizationReq, params OAuthAuthorizationsUpdateAuthorizationParams) (OAuthAuthorizationsUpdateAuthorizationRes, error) {
	res, err := c.sendOAuthAuthorizationsUpdateAuthorization(ctx, request, params)
	return res, err
}

func (c *Client) sendOAuthAuthorizationsUpdateAuthorization(ctx context.Context, request OptOAuthAuthorizationsUpdateAuthorizationReq, params OAuthAuthorizationsUpdateAuthorizationParams) (res OAuthAuthorizationsUpdateAuthorizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/update-authorization"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/authorizations/{authorization_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsUpdateAuthorization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/authorizations/"
	{
		// Encode "authorization_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorizationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOAuthAuthorizationsUpdateAuthorizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthAuthorizationsUpdateAuthorizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsBlockUser invokes orgs/block-user operation.
//
// Block a user from an organization.
//
// PUT /orgs/{org}/blocks/{username}
func (c *Client) OrgsBlockUser(ctx context.Context, params OrgsBlockUserParams) (OrgsBlockUserRes, error) {
	res, err := c.sendOrgsBlockUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsBlockUser(ctx context.Context, params OrgsBlockUserParams) (res OrgsBlockUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/block-user"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsBlockUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsBlockUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCancelInvitation invokes orgs/cancel-invitation operation.
//
// Cancel an organization invitation. In order to cancel an organization invitation, the
// authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
//
// DELETE /orgs/{org}/invitations/{invitation_id}
func (c *Client) OrgsCancelInvitation(ctx context.Context, params OrgsCancelInvitationParams) (OrgsCancelInvitationRes, error) {
	res, err := c.sendOrgsCancelInvitation(ctx, params)
	return res, err
}

func (c *Client) sendOrgsCancelInvitation(ctx context.Context, params OrgsCancelInvitationParams) (res OrgsCancelInvitationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/cancel-invitation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations/{invitation_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCancelInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsCancelInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCheckBlockedUser invokes orgs/check-blocked-user operation.
//
// Check if a user is blocked by an organization.
//
// GET /orgs/{org}/blocks/{username}
func (c *Client) OrgsCheckBlockedUser(ctx context.Context, params OrgsCheckBlockedUserParams) (OrgsCheckBlockedUserRes, error) {
	res, err := c.sendOrgsCheckBlockedUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsCheckBlockedUser(ctx context.Context, params OrgsCheckBlockedUserParams) (res OrgsCheckBlockedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-blocked-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCheckBlockedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsCheckBlockedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCheckMembershipForUser invokes orgs/check-membership-for-user operation.
//
// Check if a user is, publicly or privately, a member of the organization.
//
// GET /orgs/{org}/members/{username}
func (c *Client) OrgsCheckMembershipForUser(ctx context.Context, params OrgsCheckMembershipForUserParams) (OrgsCheckMembershipForUserRes, error) {
	res, err := c.sendOrgsCheckMembershipForUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsCheckMembershipForUser(ctx context.Context, params OrgsCheckMembershipForUserParams) (res OrgsCheckMembershipForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-membership-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCheckMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsCheckMembershipForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCheckPublicMembershipForUser invokes orgs/check-public-membership-for-user operation.
//
// Check public organization membership for a user.
//
// GET /orgs/{org}/public_members/{username}
func (c *Client) OrgsCheckPublicMembershipForUser(ctx context.Context, params OrgsCheckPublicMembershipForUserParams) (OrgsCheckPublicMembershipForUserRes, error) {
	res, err := c.sendOrgsCheckPublicMembershipForUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsCheckPublicMembershipForUser(ctx context.Context, params OrgsCheckPublicMembershipForUserParams) (res OrgsCheckPublicMembershipForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-public-membership-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCheckPublicMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/public_members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsCheckPublicMembershipForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsConvertMemberToOutsideCollaborator invokes orgs/convert-member-to-outside-collaborator operation.
//
// When an organization member is converted to an outside collaborator, they'll only have access to
// the repositories that their current team membership allows. The user will no longer be a member of
// the organization. For more information, see "[Converting an organization member to an outside
// collaborator](https://help.github.
// com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (c *Client) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, params OrgsConvertMemberToOutsideCollaboratorParams) (OrgsConvertMemberToOutsideCollaboratorRes, error) {
	res, err := c.sendOrgsConvertMemberToOutsideCollaborator(ctx, params)
	return res, err
}

func (c *Client) sendOrgsConvertMemberToOutsideCollaborator(ctx context.Context, params OrgsConvertMemberToOutsideCollaboratorParams) (res OrgsConvertMemberToOutsideCollaboratorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/convert-member-to-outside-collaborator"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/outside_collaborators/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsConvertMemberToOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outside_collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsConvertMemberToOutsideCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCreateInvitation invokes orgs/create-invitation operation.
//
// Invite people to an organization by using their GitHub user ID or their email address. In order to
// create invitations in an organization, the authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /orgs/{org}/invitations
func (c *Client) OrgsCreateInvitation(ctx context.Context, request OptOrgsCreateInvitationReq, params OrgsCreateInvitationParams) (OrgsCreateInvitationRes, error) {
	res, err := c.sendOrgsCreateInvitation(ctx, request, params)
	return res, err
}

func (c *Client) sendOrgsCreateInvitation(ctx context.Context, request OptOrgsCreateInvitationReq, params OrgsCreateInvitationParams) (res OrgsCreateInvitationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-invitation"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCreateInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrgsCreateInvitationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsCreateInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCreateWebhook invokes orgs/create-webhook operation.
//
// Here's how you can create a hook that posts payloads in JSON format:.
//
// POST /orgs/{org}/hooks
func (c *Client) OrgsCreateWebhook(ctx context.Context, request *OrgsCreateWebhookReq, params OrgsCreateWebhookParams) (OrgsCreateWebhookRes, error) {
	res, err := c.sendOrgsCreateWebhook(ctx, request, params)
	return res, err
}

func (c *Client) sendOrgsCreateWebhook(ctx context.Context, request *OrgsCreateWebhookReq, params OrgsCreateWebhookParams) (res OrgsCreateWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-webhook"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrgsCreateWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsCreateWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsDeleteWebhook invokes orgs/delete-webhook operation.
//
// Delete an organization webhook.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (c *Client) OrgsDeleteWebhook(ctx context.Context, params OrgsDeleteWebhookParams) (OrgsDeleteWebhookRes, error) {
	res, err := c.sendOrgsDeleteWebhook(ctx, params)
	return res, err
}

func (c *Client) sendOrgsDeleteWebhook(ctx context.Context, params OrgsDeleteWebhookParams) (res OrgsDeleteWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/delete-webhook"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsDeleteWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGet invokes orgs/get operation.
//
// To see many of the organization response values, you need to be an authenticated organization
// owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`,
// the organization requires all members, billing managers, and outside collaborators to enable
// [two-factor authentication](https://help.github.
// com/articles/securing-your-account-with-two-factor-authentication-2fa/).
// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information
// about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example
// response, see 'Response with GitHub plan information' below.".
//
// GET /orgs/{org}
func (c *Client) OrgsGet(ctx context.Context, params OrgsGetParams) (OrgsGetRes, error) {
	res, err := c.sendOrgsGet(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGet(ctx context.Context, params OrgsGetParams) (res OrgsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetAuditLog invokes orgs/get-audit-log operation.
//
// Gets the audit log for an organization. For more information, see "[Reviewing the audit log for
// your organization](https://docs.github.
// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
// To use this endpoint, you must be an organization owner, and you must use an access token with the
// `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use
// this endpoint.
//
// GET /orgs/{org}/audit-log
func (c *Client) OrgsGetAuditLog(ctx context.Context, params OrgsGetAuditLogParams) ([]AuditLogEvent, error) {
	res, err := c.sendOrgsGetAuditLog(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGetAuditLog(ctx context.Context, params OrgsGetAuditLogParams) (res []AuditLogEvent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-audit-log"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/audit-log"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audit-log"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "phrase" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phrase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Phrase.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Include.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "before" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetAuditLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetMembershipForAuthenticatedUser invokes orgs/get-membership-for-authenticated-user operation.
//
// Get an organization membership for the authenticated user.
//
// GET /user/memberships/orgs/{org}
func (c *Client) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, params OrgsGetMembershipForAuthenticatedUserParams) (OrgsGetMembershipForAuthenticatedUserRes, error) {
	res, err := c.sendOrgsGetMembershipForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGetMembershipForAuthenticatedUser(ctx context.Context, params OrgsGetMembershipForAuthenticatedUserParams) (res OrgsGetMembershipForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/memberships/orgs/{org}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/memberships/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetMembershipForUser invokes orgs/get-membership-for-user operation.
//
// In order to get a user's membership with an organization, the authenticated user must be an
// organization member. The `state` parameter in the response can be used to identify the user's
// membership status.
//
// GET /orgs/{org}/memberships/{username}
func (c *Client) OrgsGetMembershipForUser(ctx context.Context, params OrgsGetMembershipForUserParams) (OrgsGetMembershipForUserRes, error) {
	res, err := c.sendOrgsGetMembershipForUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGetMembershipForUser(ctx context.Context, params OrgsGetMembershipForUserParams) (res OrgsGetMembershipForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/memberships/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetMembershipForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetWebhook invokes orgs/get-webhook operation.
//
// Returns a webhook configured in an organization. To get only the webhook `config` properties, see
// "[Get a webhook configuration for an
// organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization).".
//
// GET /orgs/{org}/hooks/{hook_id}
func (c *Client) OrgsGetWebhook(ctx context.Context, params OrgsGetWebhookParams) (OrgsGetWebhookRes, error) {
	res, err := c.sendOrgsGetWebhook(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGetWebhook(ctx context.Context, params OrgsGetWebhookParams) (res OrgsGetWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetWebhookConfigForOrg invokes orgs/get-webhook-config-for-org operation.
//
// Returns the webhook configuration for an organization. To get more information about the webhook,
// including the `active` state and `events`, use "[Get an organization webhook
// ](/rest/reference/orgs#get-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:read` permission.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (c *Client) OrgsGetWebhookConfigForOrg(ctx context.Context, params OrgsGetWebhookConfigForOrgParams) (*WebhookConfig, error) {
	res, err := c.sendOrgsGetWebhookConfigForOrg(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGetWebhookConfigForOrg(ctx context.Context, params OrgsGetWebhookConfigForOrgParams) (res *WebhookConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-config-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetWebhookConfigForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetWebhookDelivery invokes orgs/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
func (c *Client) OrgsGetWebhookDelivery(ctx context.Context, params OrgsGetWebhookDeliveryParams) (OrgsGetWebhookDeliveryRes, error) {
	res, err := c.sendOrgsGetWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendOrgsGetWebhookDelivery(ctx context.Context, params OrgsGetWebhookDeliveryParams) (res OrgsGetWebhookDeliveryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-delivery"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsGetWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsList invokes orgs/list operation.
//
// Lists all organizations, in the order that they were created on GitHub.
// **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of organizations.
//
// GET /organizations
func (c *Client) OrgsList(ctx context.Context, params OrgsListParams) (OrgsListRes, error) {
	res, err := c.sendOrgsList(ctx, params)
	return res, err
}

func (c *Client) sendOrgsList(ctx context.Context, params OrgsListParams) (res OrgsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListBlockedUsers invokes orgs/list-blocked-users operation.
//
// List the users blocked by an organization.
//
// GET /orgs/{org}/blocks
func (c *Client) OrgsListBlockedUsers(ctx context.Context, params OrgsListBlockedUsersParams) (OrgsListBlockedUsersRes, error) {
	res, err := c.sendOrgsListBlockedUsers(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListBlockedUsers(ctx context.Context, params OrgsListBlockedUsersParams) (res OrgsListBlockedUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-blocked-users"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListBlockedUsers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/blocks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListBlockedUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListFailedInvitations invokes orgs/list-failed-invitations operation.
//
// The return hash contains `failed_at` and `failed_reason` fields which represent the time at which
// the invitation failed and the reason for the failure.
//
// GET /orgs/{org}/failed_invitations
func (c *Client) OrgsListFailedInvitations(ctx context.Context, params OrgsListFailedInvitationsParams) (OrgsListFailedInvitationsRes, error) {
	res, err := c.sendOrgsListFailedInvitations(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListFailedInvitations(ctx context.Context, params OrgsListFailedInvitationsParams) (res OrgsListFailedInvitationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-failed-invitations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/failed_invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListFailedInvitations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/failed_invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListFailedInvitationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListForAuthenticatedUser invokes orgs/list-for-authenticated-user operation.
//
// List organizations for the authenticated user.
// **OAuth scope requirements**
// This only lists organizations that your authorization allows you to operate on in some way (e.g.,
// you can list teams with `read:org` scope, you can publicize your organization membership with
// `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth
// requests with insufficient scope receive a `403 Forbidden` response.
//
// GET /user/orgs
func (c *Client) OrgsListForAuthenticatedUser(ctx context.Context, params OrgsListForAuthenticatedUserParams) (OrgsListForAuthenticatedUserRes, error) {
	res, err := c.sendOrgsListForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListForAuthenticatedUser(ctx context.Context, params OrgsListForAuthenticatedUserParams) (res OrgsListForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/orgs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/orgs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListForUser invokes orgs/list-for-user operation.
//
// List [public organization memberships](https://help.github.
// com/articles/publicizing-or-concealing-organization-membership) for the specified user.
// This method only lists _public_ memberships, regardless of authentication. If you need to fetch
// all of the organization memberships (public and private) for the authenticated user, use the [List
// organizations for the authenticated user](https://docs.github.
// com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
//
// GET /users/{username}/orgs
func (c *Client) OrgsListForUser(ctx context.Context, params OrgsListForUserParams) (*OrgsListForUserOKHeaders, error) {
	res, err := c.sendOrgsListForUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListForUser(ctx context.Context, params OrgsListForUserParams) (res *OrgsListForUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/orgs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/orgs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListInvitationTeams invokes orgs/list-invitation-teams operation.
//
// List all teams associated with an invitation. In order to see invitations in an organization, the
// authenticated user must be an organization owner.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (c *Client) OrgsListInvitationTeams(ctx context.Context, params OrgsListInvitationTeamsParams) (OrgsListInvitationTeamsRes, error) {
	res, err := c.sendOrgsListInvitationTeams(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListInvitationTeams(ctx context.Context, params OrgsListInvitationTeamsParams) (res OrgsListInvitationTeamsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-invitation-teams"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations/{invitation_id}/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListInvitationTeams",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListInvitationTeamsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListMembers invokes orgs/list-members operation.
//
// List all users who are members of an organization. If the authenticated user is also a member of
// this organization then both concealed and public members will be returned.
//
// GET /orgs/{org}/members
func (c *Client) OrgsListMembers(ctx context.Context, params OrgsListMembersParams) (OrgsListMembersRes, error) {
	res, err := c.sendOrgsListMembers(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListMembers(ctx context.Context, params OrgsListMembersParams) (res OrgsListMembersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-members"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "role" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Role.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListMembershipsForAuthenticatedUser invokes orgs/list-memberships-for-authenticated-user operation.
//
// List organization memberships for the authenticated user.
//
// GET /user/memberships/orgs
func (c *Client) OrgsListMembershipsForAuthenticatedUser(ctx context.Context, params OrgsListMembershipsForAuthenticatedUserParams) (OrgsListMembershipsForAuthenticatedUserRes, error) {
	res, err := c.sendOrgsListMembershipsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListMembershipsForAuthenticatedUser(ctx context.Context, params OrgsListMembershipsForAuthenticatedUserParams) (res OrgsListMembershipsForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-memberships-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/memberships/orgs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListMembershipsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/memberships/orgs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListMembershipsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListOutsideCollaborators invokes orgs/list-outside-collaborators operation.
//
// List all users who are outside collaborators of an organization.
//
// GET /orgs/{org}/outside_collaborators
func (c *Client) OrgsListOutsideCollaborators(ctx context.Context, params OrgsListOutsideCollaboratorsParams) (*OrgsListOutsideCollaboratorsOKHeaders, error) {
	res, err := c.sendOrgsListOutsideCollaborators(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListOutsideCollaborators(ctx context.Context, params OrgsListOutsideCollaboratorsParams) (res *OrgsListOutsideCollaboratorsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-outside-collaborators"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/outside_collaborators"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListOutsideCollaborators",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outside_collaborators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListOutsideCollaboratorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListPendingInvitations invokes orgs/list-pending-invitations operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// GET /orgs/{org}/invitations
func (c *Client) OrgsListPendingInvitations(ctx context.Context, params OrgsListPendingInvitationsParams) (OrgsListPendingInvitationsRes, error) {
	res, err := c.sendOrgsListPendingInvitations(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListPendingInvitations(ctx context.Context, params OrgsListPendingInvitationsParams) (res OrgsListPendingInvitationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-pending-invitations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListPendingInvitations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListPendingInvitationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListPublicMembers invokes orgs/list-public-members operation.
//
// Members of an organization can choose to have their membership publicized or not.
//
// GET /orgs/{org}/public_members
func (c *Client) OrgsListPublicMembers(ctx context.Context, params OrgsListPublicMembersParams) (*OrgsListPublicMembersOKHeaders, error) {
	res, err := c.sendOrgsListPublicMembers(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListPublicMembers(ctx context.Context, params OrgsListPublicMembersParams) (res *OrgsListPublicMembersOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-public-members"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListPublicMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/public_members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListPublicMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListSamlSSOAuthorizations invokes orgs/list-saml-sso-authorizations operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `read:org` scope can list all credential
// authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either
// personal access tokens or SSH keys that organization members have authorized for the organization.
// For more information, see [About authentication with SAML single sign-on](https://help.github.
// com/en/articles/about-authentication-with-saml-single-sign-on).
//
// GET /orgs/{org}/credential-authorizations
func (c *Client) OrgsListSamlSSOAuthorizations(ctx context.Context, params OrgsListSamlSSOAuthorizationsParams) ([]CredentialAuthorization, error) {
	res, err := c.sendOrgsListSamlSSOAuthorizations(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListSamlSSOAuthorizations(ctx context.Context, params OrgsListSamlSSOAuthorizationsParams) (res []CredentialAuthorization, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-saml-sso-authorizations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/credential-authorizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListSamlSSOAuthorizations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/credential-authorizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListSamlSSOAuthorizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListWebhookDeliveries invokes orgs/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries
func (c *Client) OrgsListWebhookDeliveries(ctx context.Context, params OrgsListWebhookDeliveriesParams) (OrgsListWebhookDeliveriesRes, error) {
	res, err := c.sendOrgsListWebhookDeliveries(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListWebhookDeliveries(ctx context.Context, params OrgsListWebhookDeliveriesParams) (res OrgsListWebhookDeliveriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhook-deliveries"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/deliveries"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deliveries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListWebhookDeliveriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListWebhooks invokes orgs/list-webhooks operation.
//
// List organization webhooks.
//
// GET /orgs/{org}/hooks
func (c *Client) OrgsListWebhooks(ctx context.Context, params OrgsListWebhooksParams) (OrgsListWebhooksRes, error) {
	res, err := c.sendOrgsListWebhooks(ctx, params)
	return res, err
}

func (c *Client) sendOrgsListWebhooks(ctx context.Context, params OrgsListWebhooksParams) (res OrgsListWebhooksRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhooks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListWebhooks",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsListWebhooksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsPingWebhook invokes orgs/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (c *Client) OrgsPingWebhook(ctx context.Context, params OrgsPingWebhookParams) (OrgsPingWebhookRes, error) {
	res, err := c.sendOrgsPingWebhook(ctx, params)
	return res, err
}

func (c *Client) sendOrgsPingWebhook(ctx context.Context, params OrgsPingWebhookParams) (res OrgsPingWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/ping-webhook"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/pings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsPingWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsPingWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRedeliverWebhookDelivery invokes orgs/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for a webhook configured in an organization.
//
// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (c *Client) OrgsRedeliverWebhookDelivery(ctx context.Context, params OrgsRedeliverWebhookDeliveryParams) (OrgsRedeliverWebhookDeliveryRes, error) {
	res, err := c.sendOrgsRedeliverWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendOrgsRedeliverWebhookDelivery(ctx context.Context, params OrgsRedeliverWebhookDeliveryParams) (res OrgsRedeliverWebhookDeliveryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/redeliver-webhook-delivery"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/attempts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsRedeliverWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveMember invokes orgs/remove-member operation.
//
// Removing a user from this list will remove them from all teams and they will no longer have any
// access to the organization's repositories.
//
// DELETE /orgs/{org}/members/{username}
func (c *Client) OrgsRemoveMember(ctx context.Context, params OrgsRemoveMemberParams) (OrgsRemoveMemberRes, error) {
	res, err := c.sendOrgsRemoveMember(ctx, params)
	return res, err
}

func (c *Client) sendOrgsRemoveMember(ctx context.Context, params OrgsRemoveMemberParams) (res OrgsRemoveMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-member"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsRemoveMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveMembershipForUser invokes orgs/remove-membership-for-user operation.
//
// In order to remove a user's membership with an organization, the authenticated user must be an
// organization owner.
// If the specified user is an active member of the organization, this will remove them from the
// organization. If the specified user has been invited to the organization, this will cancel their
// invitation. The specified user will receive an email notification in both cases.
//
// DELETE /orgs/{org}/memberships/{username}
func (c *Client) OrgsRemoveMembershipForUser(ctx context.Context, params OrgsRemoveMembershipForUserParams) (OrgsRemoveMembershipForUserRes, error) {
	res, err := c.sendOrgsRemoveMembershipForUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsRemoveMembershipForUser(ctx context.Context, params OrgsRemoveMembershipForUserParams) (res OrgsRemoveMembershipForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-membership-for-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/memberships/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsRemoveMembershipForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveOutsideCollaborator invokes orgs/remove-outside-collaborator operation.
//
// Removing a user from this list will remove them from all the organization's repositories.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (c *Client) OrgsRemoveOutsideCollaborator(ctx context.Context, params OrgsRemoveOutsideCollaboratorParams) (OrgsRemoveOutsideCollaboratorRes, error) {
	res, err := c.sendOrgsRemoveOutsideCollaborator(ctx, params)
	return res, err
}

func (c *Client) sendOrgsRemoveOutsideCollaborator(ctx context.Context, params OrgsRemoveOutsideCollaboratorParams) (res OrgsRemoveOutsideCollaboratorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-outside-collaborator"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/outside_collaborators/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outside_collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsRemoveOutsideCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemovePublicMembershipForAuthenticatedUser invokes orgs/remove-public-membership-for-authenticated-user operation.
//
// Remove public organization membership for the authenticated user.
//
// DELETE /orgs/{org}/public_members/{username}
func (c *Client) OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsRemovePublicMembershipForAuthenticatedUserParams) error {
	_, err := c.sendOrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
	return err
}

func (c *Client) sendOrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsRemovePublicMembershipForAuthenticatedUserParams) (res *OrgsRemovePublicMembershipForAuthenticatedUserNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-public-membership-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemovePublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/public_members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveSamlSSOAuthorization invokes orgs/remove-saml-sso-authorization operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `admin:org` scope can remove a credential
// authorization for an organization that uses SAML SSO. Once you remove someone's credential
// authorization, they will need to create a new personal access token or SSH key and authorize it
// for the organization they want to access.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (c *Client) OrgsRemoveSamlSSOAuthorization(ctx context.Context, params OrgsRemoveSamlSSOAuthorizationParams) (OrgsRemoveSamlSSOAuthorizationRes, error) {
	res, err := c.sendOrgsRemoveSamlSSOAuthorization(ctx, params)
	return res, err
}

func (c *Client) sendOrgsRemoveSamlSSOAuthorization(ctx context.Context, params OrgsRemoveSamlSSOAuthorizationParams) (res OrgsRemoveSamlSSOAuthorizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-saml-sso-authorization"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/credential-authorizations/{credential_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveSamlSSOAuthorization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/credential-authorizations/"
	{
		// Encode "credential_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "credential_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CredentialID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsRemoveSamlSSOAuthorizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsSetMembershipForUser invokes orgs/set-membership-for-user operation.
//
// Only authenticated organization owners can add a member to the organization or update the member's
// role.
// *   If the authenticated user is _adding_ a member to the organization, the invited user will
// receive an email inviting them to the organization. The user's [membership status](https://docs.
// github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until
// they accept the invitation.
// *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the
// authenticated user changes a member's role to `admin`, the affected user will receive an email
// notifying them that they've been made an organization owner. If the authenticated user changes an
// owner's role to `member`, no email will be sent.
// **Rate limits**
// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour
// period. If the organization is more than one month old or on a paid plan, the limit is 500
// invitations per 24 hour period.
//
// PUT /orgs/{org}/memberships/{username}
func (c *Client) OrgsSetMembershipForUser(ctx context.Context, request OptOrgsSetMembershipForUserReq, params OrgsSetMembershipForUserParams) (OrgsSetMembershipForUserRes, error) {
	res, err := c.sendOrgsSetMembershipForUser(ctx, request, params)
	return res, err
}

func (c *Client) sendOrgsSetMembershipForUser(ctx context.Context, request OptOrgsSetMembershipForUserReq, params OrgsSetMembershipForUserParams) (res OrgsSetMembershipForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-membership-for-user"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/memberships/{username}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsSetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrgsSetMembershipForUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsSetMembershipForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsSetPublicMembershipForAuthenticatedUser invokes orgs/set-public-membership-for-authenticated-user operation.
//
// The user can publicize their own membership. (A user cannot publicize the membership for another
// user.)
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /orgs/{org}/public_members/{username}
func (c *Client) OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsSetPublicMembershipForAuthenticatedUserParams) (OrgsSetPublicMembershipForAuthenticatedUserRes, error) {
	res, err := c.sendOrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendOrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsSetPublicMembershipForAuthenticatedUserParams) (res OrgsSetPublicMembershipForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-public-membership-for-authenticated-user"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsSetPublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/public_members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsSetPublicMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUnblockUser invokes orgs/unblock-user operation.
//
// Unblock a user from an organization.
//
// DELETE /orgs/{org}/blocks/{username}
func (c *Client) OrgsUnblockUser(ctx context.Context, params OrgsUnblockUserParams) error {
	_, err := c.sendOrgsUnblockUser(ctx, params)
	return err
}

func (c *Client) sendOrgsUnblockUser(ctx context.Context, params OrgsUnblockUserParams) (res *OrgsUnblockUserNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/unblock-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUnblockUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsUnblockUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUpdateMembershipForAuthenticatedUser invokes orgs/update-membership-for-authenticated-user operation.
//
// Update an organization membership for the authenticated user.
//
// PATCH /user/memberships/orgs/{org}
func (c *Client) OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, request *OrgsUpdateMembershipForAuthenticatedUserReq, params OrgsUpdateMembershipForAuthenticatedUserParams) (OrgsUpdateMembershipForAuthenticatedUserRes, error) {
	res, err := c.sendOrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
	return res, err
}

func (c *Client) sendOrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, request *OrgsUpdateMembershipForAuthenticatedUserReq, params OrgsUpdateMembershipForAuthenticatedUserParams) (res OrgsUpdateMembershipForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-membership-for-authenticated-user"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user/memberships/orgs/{org}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUpdateMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/memberships/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrgsUpdateMembershipForAuthenticatedUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsUpdateMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUpdateWebhook invokes orgs/update-webhook operation.
//
// Updates a webhook configured in an organization. When you update a webhook, the `secret` will be
// overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new
// `secret` or the secret will be removed. If you are only updating individual webhook `config`
// properties, use "[Update a webhook configuration for an
// organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization).".
//
// PATCH /orgs/{org}/hooks/{hook_id}
func (c *Client) OrgsUpdateWebhook(ctx context.Context, request OptOrgsUpdateWebhookReq, params OrgsUpdateWebhookParams) (OrgsUpdateWebhookRes, error) {
	res, err := c.sendOrgsUpdateWebhook(ctx, request, params)
	return res, err
}

func (c *Client) sendOrgsUpdateWebhook(ctx context.Context, request OptOrgsUpdateWebhookReq, params OrgsUpdateWebhookParams) (res OrgsUpdateWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrgsUpdateWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsUpdateWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUpdateWebhookConfigForOrg invokes orgs/update-webhook-config-for-org operation.
//
// Updates the webhook configuration for an organization. To update more information about the
// webhook, including the `active` state and `events`, use "[Update an organization webhook
// ](/rest/reference/orgs#update-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:write` permission.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (c *Client) OrgsUpdateWebhookConfigForOrg(ctx context.Context, request OptOrgsUpdateWebhookConfigForOrgReq, params OrgsUpdateWebhookConfigForOrgParams) (*WebhookConfig, error) {
	res, err := c.sendOrgsUpdateWebhookConfigForOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendOrgsUpdateWebhookConfigForOrg(ctx context.Context, request OptOrgsUpdateWebhookConfigForOrgReq, params OrgsUpdateWebhookConfigForOrgParams) (res *WebhookConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook-config-for-org"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/config"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUpdateWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrgsUpdateWebhookConfigForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrgsUpdateWebhookConfigForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageForAuthenticatedUser invokes packages/delete-package-for-authenticated-user operation.
//
// Deletes a package owned by the authenticated user. You cannot delete a public package if any
// version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for
// further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}
func (c *Client) PackagesDeletePackageForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageForAuthenticatedUserParams) (PackagesDeletePackageForAuthenticatedUserRes, error) {
	res, err := c.sendPackagesDeletePackageForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesDeletePackageForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageForAuthenticatedUserParams) (res PackagesDeletePackageForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesDeletePackageForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageForOrg invokes packages/delete-package-for-org operation.
//
// Deletes an entire package in an organization. You cannot delete a public package if any version of
// the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (c *Client) PackagesDeletePackageForOrg(ctx context.Context, params PackagesDeletePackageForOrgParams) (PackagesDeletePackageForOrgRes, error) {
	res, err := c.sendPackagesDeletePackageForOrg(ctx, params)
	return res, err
}

func (c *Client) sendPackagesDeletePackageForOrg(ctx context.Context, params PackagesDeletePackageForOrgParams) (res PackagesDeletePackageForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesDeletePackageForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageForUser invokes packages/delete-package-for-user operation.
//
// Deletes an entire package for a user. You cannot delete a public package if any version of the
// package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (c *Client) PackagesDeletePackageForUser(ctx context.Context, params PackagesDeletePackageForUserParams) (PackagesDeletePackageForUserRes, error) {
	res, err := c.sendPackagesDeletePackageForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesDeletePackageForUser(ctx context.Context, params PackagesDeletePackageForUserParams) (res PackagesDeletePackageForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesDeletePackageForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageVersionForAuthenticatedUser invokes packages/delete-package-version-for-authenticated-user operation.
//
// Deletes a specific package version for a package owned by the authenticated user.  If the package
// is public and the package version has more than 5,000 downloads, you cannot delete the package
// version. In this scenario, contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageVersionForAuthenticatedUserParams) (PackagesDeletePackageVersionForAuthenticatedUserRes, error) {
	res, err := c.sendPackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageVersionForAuthenticatedUserParams) (res PackagesDeletePackageVersionForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-authenticated-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesDeletePackageVersionForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageVersionForOrg invokes packages/delete-package-version-for-org operation.
//
// Deletes a specific package version in an organization. If the package is public and the package
// version has more than 5,000 downloads, you cannot delete the package version. In this scenario,
// contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesDeletePackageVersionForOrg(ctx context.Context, params PackagesDeletePackageVersionForOrgParams) (PackagesDeletePackageVersionForOrgRes, error) {
	res, err := c.sendPackagesDeletePackageVersionForOrg(ctx, params)
	return res, err
}

func (c *Client) sendPackagesDeletePackageVersionForOrg(ctx context.Context, params PackagesDeletePackageVersionForOrgParams) (res PackagesDeletePackageVersionForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesDeletePackageVersionForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageVersionForUser invokes packages/delete-package-version-for-user operation.
//
// Deletes a specific package version for a user. If the package is public and the package version
// has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact
// GitHub support for further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesDeletePackageVersionForUser(ctx context.Context, params PackagesDeletePackageVersionForUserParams) (PackagesDeletePackageVersionForUserRes, error) {
	res, err := c.sendPackagesDeletePackageVersionForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesDeletePackageVersionForUser(ctx context.Context, params PackagesDeletePackageVersionForUserParams) (res PackagesDeletePackageVersionForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-user"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesDeletePackageVersionForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser invokes packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// Returns all package versions for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) (PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes, error) {
	res, err := c.sendPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) (res PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByOrg invokes packages/get-all-package-versions-for-package-owned-by-org operation.
//
// Returns all package versions for a package owned by an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams) (PackagesGetAllPackageVersionsForPackageOwnedByOrgRes, error) {
	res, err := c.sendPackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams) (res PackagesGetAllPackageVersionsForPackageOwnedByOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByUser invokes packages/get-all-package-versions-for-package-owned-by-user operation.
//
// Returns all package versions for a public package owned by a specified user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByUserParams) (PackagesGetAllPackageVersionsForPackageOwnedByUserRes, error) {
	res, err := c.sendPackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByUserParams) (res PackagesGetAllPackageVersionsForPackageOwnedByUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetAllPackageVersionsForPackageOwnedByUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageForAuthenticatedUser invokes packages/get-package-for-authenticated-user operation.
//
// Gets a specific package for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}
func (c *Client) PackagesGetPackageForAuthenticatedUser(ctx context.Context, params PackagesGetPackageForAuthenticatedUserParams) (*Package, error) {
	res, err := c.sendPackagesGetPackageForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetPackageForAuthenticatedUser(ctx context.Context, params PackagesGetPackageForAuthenticatedUserParams) (res *Package, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetPackageForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageForOrganization invokes packages/get-package-for-organization operation.
//
// Gets a specific package in an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (c *Client) PackagesGetPackageForOrganization(ctx context.Context, params PackagesGetPackageForOrganizationParams) (*Package, error) {
	res, err := c.sendPackagesGetPackageForOrganization(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetPackageForOrganization(ctx context.Context, params PackagesGetPackageForOrganizationParams) (res *Package, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-organization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageForOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetPackageForOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageForUser invokes packages/get-package-for-user operation.
//
// Gets a specific package metadata for a public package owned by a user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (c *Client) PackagesGetPackageForUser(ctx context.Context, params PackagesGetPackageForUserParams) (*Package, error) {
	res, err := c.sendPackagesGetPackageForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetPackageForUser(ctx context.Context, params PackagesGetPackageForUserParams) (res *Package, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetPackageForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageVersionForAuthenticatedUser invokes packages/get-package-version-for-authenticated-user operation.
//
// Gets a specific package version for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, params PackagesGetPackageVersionForAuthenticatedUserParams) (*PackageVersion, error) {
	res, err := c.sendPackagesGetPackageVersionForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, params PackagesGetPackageVersionForAuthenticatedUserParams) (res *PackageVersion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetPackageVersionForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageVersionForOrganization invokes packages/get-package-version-for-organization operation.
//
// Gets a specific package version in an organization.
// You must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesGetPackageVersionForOrganization(ctx context.Context, params PackagesGetPackageVersionForOrganizationParams) (*PackageVersion, error) {
	res, err := c.sendPackagesGetPackageVersionForOrganization(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetPackageVersionForOrganization(ctx context.Context, params PackagesGetPackageVersionForOrganizationParams) (res *PackageVersion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-organization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageVersionForOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetPackageVersionForOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageVersionForUser invokes packages/get-package-version-for-user operation.
//
// Gets a specific package version for a public package owned by a specified user.
// At this time, to use this endpoint, you must authenticate using an access token with the
// `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesGetPackageVersionForUser(ctx context.Context, params PackagesGetPackageVersionForUserParams) (*PackageVersion, error) {
	res, err := c.sendPackagesGetPackageVersionForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesGetPackageVersionForUser(ctx context.Context, params PackagesGetPackageVersionForUserParams) (res *PackageVersion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesGetPackageVersionForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesListPackagesForAuthenticatedUser invokes packages/list-packages-for-authenticated-user operation.
//
// Lists packages owned by the authenticated user within the user's namespace.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages
func (c *Client) PackagesListPackagesForAuthenticatedUser(ctx context.Context, params PackagesListPackagesForAuthenticatedUserParams) ([]Package, error) {
	res, err := c.sendPackagesListPackagesForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesListPackagesForAuthenticatedUser(ctx context.Context, params PackagesListPackagesForAuthenticatedUserParams) (res []Package, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesListPackagesForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/packages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "package_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "visibility" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesListPackagesForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesListPackagesForOrganization invokes packages/list-packages-for-organization operation.
//
// Lists all packages in an organization readable by the user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages
func (c *Client) PackagesListPackagesForOrganization(ctx context.Context, params PackagesListPackagesForOrganizationParams) (PackagesListPackagesForOrganizationRes, error) {
	res, err := c.sendPackagesListPackagesForOrganization(ctx, params)
	return res, err
}

func (c *Client) sendPackagesListPackagesForOrganization(ctx context.Context, params PackagesListPackagesForOrganizationParams) (res PackagesListPackagesForOrganizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-organization"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesListPackagesForOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "package_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "visibility" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesListPackagesForOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesListPackagesForUser invokes packages/list-packages-for-user operation.
//
// Lists all packages in a user's namespace for which the requesting user has access.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages
func (c *Client) PackagesListPackagesForUser(ctx context.Context, params PackagesListPackagesForUserParams) (PackagesListPackagesForUserRes, error) {
	res, err := c.sendPackagesListPackagesForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesListPackagesForUser(ctx context.Context, params PackagesListPackagesForUserParams) (res PackagesListPackagesForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesListPackagesForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "package_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "visibility" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesListPackagesForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageForAuthenticatedUser invokes packages/restore-package-for-authenticated-user operation.
//
// Restores a package owned by the authenticated user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (c *Client) PackagesRestorePackageForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageForAuthenticatedUserParams) (PackagesRestorePackageForAuthenticatedUserRes, error) {
	res, err := c.sendPackagesRestorePackageForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesRestorePackageForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageForAuthenticatedUserParams) (res PackagesRestorePackageForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-authenticated-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/restore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesRestorePackageForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageForOrg invokes packages/restore-package-for-org operation.
//
// Restores an entire package in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (c *Client) PackagesRestorePackageForOrg(ctx context.Context, params PackagesRestorePackageForOrgParams) (PackagesRestorePackageForOrgRes, error) {
	res, err := c.sendPackagesRestorePackageForOrg(ctx, params)
	return res, err
}

func (c *Client) sendPackagesRestorePackageForOrg(ctx context.Context, params PackagesRestorePackageForOrgParams) (res PackagesRestorePackageForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/restore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesRestorePackageForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageForUser invokes packages/restore-package-for-user operation.
//
// Restores an entire package for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (c *Client) PackagesRestorePackageForUser(ctx context.Context, params PackagesRestorePackageForUserParams) (PackagesRestorePackageForUserRes, error) {
	res, err := c.sendPackagesRestorePackageForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesRestorePackageForUser(ctx context.Context, params PackagesRestorePackageForUserParams) (res PackagesRestorePackageForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/restore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesRestorePackageForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageVersionForAuthenticatedUser invokes packages/restore-package-version-for-authenticated-user operation.
//
// Restores a package version owned by the authenticated user.
// You can restore a deleted package version under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (c *Client) PackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageVersionForAuthenticatedUserParams) (PackagesRestorePackageVersionForAuthenticatedUserRes, error) {
	res, err := c.sendPackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageVersionForAuthenticatedUserParams) (res PackagesRestorePackageVersionForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-authenticated-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesRestorePackageVersionForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageVersionForOrg invokes packages/restore-package-version-for-org operation.
//
// Restores a specific package version in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (c *Client) PackagesRestorePackageVersionForOrg(ctx context.Context, params PackagesRestorePackageVersionForOrgParams) (PackagesRestorePackageVersionForOrgRes, error) {
	res, err := c.sendPackagesRestorePackageVersionForOrg(ctx, params)
	return res, err
}

func (c *Client) sendPackagesRestorePackageVersionForOrg(ctx context.Context, params PackagesRestorePackageVersionForOrgParams) (res PackagesRestorePackageVersionForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesRestorePackageVersionForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageVersionForUser invokes packages/restore-package-version-for-user operation.
//
// Restores a specific package version for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (c *Client) PackagesRestorePackageVersionForUser(ctx context.Context, params PackagesRestorePackageVersionForUserParams) (PackagesRestorePackageVersionForUserRes, error) {
	res, err := c.sendPackagesRestorePackageVersionForUser(ctx, params)
	return res, err
}

func (c *Client) sendPackagesRestorePackageVersionForUser(ctx context.Context, params PackagesRestorePackageVersionForUserParams) (res PackagesRestorePackageVersionForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePackagesRestorePackageVersionForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsAddCollaborator invokes projects/add-collaborator operation.
//
// Adds a collaborator to an organization project and sets their permission level. You must be an
// organization owner or a project `admin` to add a collaborator.
//
// PUT /projects/{project_id}/collaborators/{username}
func (c *Client) ProjectsAddCollaborator(ctx context.Context, request OptNilProjectsAddCollaboratorReq, params ProjectsAddCollaboratorParams) (ProjectsAddCollaboratorRes, error) {
	res, err := c.sendProjectsAddCollaborator(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsAddCollaborator(ctx context.Context, request OptNilProjectsAddCollaboratorReq, params ProjectsAddCollaboratorParams) (res ProjectsAddCollaboratorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/add-collaborator"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators/{username}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsAddCollaboratorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsAddCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateColumn invokes projects/create-column operation.
//
// Create a project column.
//
// POST /projects/{project_id}/columns
func (c *Client) ProjectsCreateColumn(ctx context.Context, request *ProjectsCreateColumnReq, params ProjectsCreateColumnParams) (ProjectsCreateColumnRes, error) {
	res, err := c.sendProjectsCreateColumn(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsCreateColumn(ctx context.Context, request *ProjectsCreateColumnReq, params ProjectsCreateColumnParams) (res ProjectsCreateColumnRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-column"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/columns"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateColumn",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/columns"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsCreateColumnRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsCreateColumnResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateForAuthenticatedUser invokes projects/create-for-authenticated-user operation.
//
// Create a user project.
//
// POST /user/projects
func (c *Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, request *ProjectsCreateForAuthenticatedUserReq) (ProjectsCreateForAuthenticatedUserRes, error) {
	res, err := c.sendProjectsCreateForAuthenticatedUser(ctx, request)
	return res, err
}

func (c *Client) sendProjectsCreateForAuthenticatedUser(ctx context.Context, request *ProjectsCreateForAuthenticatedUserReq) (res ProjectsCreateForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-authenticated-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsCreateForAuthenticatedUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsCreateForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateForOrg invokes projects/create-for-org operation.
//
// Creates an organization project board. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /orgs/{org}/projects
func (c *Client) ProjectsCreateForOrg(ctx context.Context, request *ProjectsCreateForOrgReq, params ProjectsCreateForOrgParams) (ProjectsCreateForOrgRes, error) {
	res, err := c.sendProjectsCreateForOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsCreateForOrg(ctx context.Context, request *ProjectsCreateForOrgReq, params ProjectsCreateForOrgParams) (res ProjectsCreateForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsCreateForOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsCreateForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateForRepo invokes projects/create-for-repo operation.
//
// Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /repos/{owner}/{repo}/projects
func (c *Client) ProjectsCreateForRepo(ctx context.Context, request *ProjectsCreateForRepoReq, params ProjectsCreateForRepoParams) (ProjectsCreateForRepoRes, error) {
	res, err := c.sendProjectsCreateForRepo(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsCreateForRepo(ctx context.Context, request *ProjectsCreateForRepoReq, params ProjectsCreateForRepoParams) (res ProjectsCreateForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-repo"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsCreateForRepoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsCreateForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsDelete invokes projects/delete operation.
//
// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
//
// DELETE /projects/{project_id}
func (c *Client) ProjectsDelete(ctx context.Context, params ProjectsDeleteParams) (ProjectsDeleteRes, error) {
	res, err := c.sendProjectsDelete(ctx, params)
	return res, err
}

func (c *Client) sendProjectsDelete(ctx context.Context, params ProjectsDeleteParams) (res ProjectsDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/{project_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsDeleteCard invokes projects/delete-card operation.
//
// Delete a project card.
//
// DELETE /projects/columns/cards/{card_id}
func (c *Client) ProjectsDeleteCard(ctx context.Context, params ProjectsDeleteCardParams) (ProjectsDeleteCardRes, error) {
	res, err := c.sendProjectsDeleteCard(ctx, params)
	return res, err
}

func (c *Client) sendProjectsDeleteCard(ctx context.Context, params ProjectsDeleteCardParams) (res ProjectsDeleteCardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-card"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsDeleteCard",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsDeleteCardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsDeleteColumn invokes projects/delete-column operation.
//
// Delete a project column.
//
// DELETE /projects/columns/{column_id}
func (c *Client) ProjectsDeleteColumn(ctx context.Context, params ProjectsDeleteColumnParams) (ProjectsDeleteColumnRes, error) {
	res, err := c.sendProjectsDeleteColumn(ctx, params)
	return res, err
}

func (c *Client) sendProjectsDeleteColumn(ctx context.Context, params ProjectsDeleteColumnParams) (res ProjectsDeleteColumnRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-column"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsDeleteColumn",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsDeleteColumnResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGet invokes projects/get operation.
//
// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do
// not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status
// is returned.
//
// GET /projects/{project_id}
func (c *Client) ProjectsGet(ctx context.Context, params ProjectsGetParams) (ProjectsGetRes, error) {
	res, err := c.sendProjectsGet(ctx, params)
	return res, err
}

func (c *Client) sendProjectsGet(ctx context.Context, params ProjectsGetParams) (res ProjectsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGetCard invokes projects/get-card operation.
//
// Get a project card.
//
// GET /projects/columns/cards/{card_id}
func (c *Client) ProjectsGetCard(ctx context.Context, params ProjectsGetCardParams) (ProjectsGetCardRes, error) {
	res, err := c.sendProjectsGetCard(ctx, params)
	return res, err
}

func (c *Client) sendProjectsGetCard(ctx context.Context, params ProjectsGetCardParams) (res ProjectsGetCardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-card"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGetCard",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsGetCardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGetColumn invokes projects/get-column operation.
//
// Get a project column.
//
// GET /projects/columns/{column_id}
func (c *Client) ProjectsGetColumn(ctx context.Context, params ProjectsGetColumnParams) (ProjectsGetColumnRes, error) {
	res, err := c.sendProjectsGetColumn(ctx, params)
	return res, err
}

func (c *Client) sendProjectsGetColumn(ctx context.Context, params ProjectsGetColumnParams) (res ProjectsGetColumnRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-column"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGetColumn",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsGetColumnResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGetPermissionForUser invokes projects/get-permission-for-user operation.
//
// Returns the collaborator's permission level for an organization project. Possible values for the
// `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project
// `admin` to review a user's permission level.
//
// GET /projects/{project_id}/collaborators/{username}/permission
func (c *Client) ProjectsGetPermissionForUser(ctx context.Context, params ProjectsGetPermissionForUserParams) (ProjectsGetPermissionForUserRes, error) {
	res, err := c.sendProjectsGetPermissionForUser(ctx, params)
	return res, err
}

func (c *Client) sendProjectsGetPermissionForUser(ctx context.Context, params ProjectsGetPermissionForUserParams) (res ProjectsGetPermissionForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-permission-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators/{username}/permission"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGetPermissionForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/permission"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsGetPermissionForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListCards invokes projects/list-cards operation.
//
// List project cards.
//
// GET /projects/columns/{column_id}/cards
func (c *Client) ProjectsListCards(ctx context.Context, params ProjectsListCardsParams) (ProjectsListCardsRes, error) {
	res, err := c.sendProjectsListCards(ctx, params)
	return res, err
}

func (c *Client) sendProjectsListCards(ctx context.Context, params ProjectsListCardsParams) (res ProjectsListCardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-cards"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}/cards"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListCards",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "archived_state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "archived_state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ArchivedState.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsListCardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListCollaborators invokes projects/list-collaborators operation.
//
// Lists the collaborators for an organization project. For a project, the list of collaborators
// includes outside collaborators, organization members that are direct collaborators, organization
// members with access through team memberships, organization members with access through default
// organization permissions, and organization owners. You must be an organization owner or a project
// `admin` to list collaborators.
//
// GET /projects/{project_id}/collaborators
func (c *Client) ProjectsListCollaborators(ctx context.Context, params ProjectsListCollaboratorsParams) (ProjectsListCollaboratorsRes, error) {
	res, err := c.sendProjectsListCollaborators(ctx, params)
	return res, err
}

func (c *Client) sendProjectsListCollaborators(ctx context.Context, params ProjectsListCollaboratorsParams) (res ProjectsListCollaboratorsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-collaborators"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListCollaborators",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/collaborators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "affiliation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Affiliation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsListCollaboratorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListColumns invokes projects/list-columns operation.
//
// List project columns.
//
// GET /projects/{project_id}/columns
func (c *Client) ProjectsListColumns(ctx context.Context, params ProjectsListColumnsParams) (ProjectsListColumnsRes, error) {
	res, err := c.sendProjectsListColumns(ctx, params)
	return res, err
}

func (c *Client) sendProjectsListColumns(ctx context.Context, params ProjectsListColumnsParams) (res ProjectsListColumnsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-columns"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/columns"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListColumns",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/columns"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsListColumnsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListForOrg invokes projects/list-for-org operation.
//
// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /orgs/{org}/projects
func (c *Client) ProjectsListForOrg(ctx context.Context, params ProjectsListForOrgParams) (ProjectsListForOrgRes, error) {
	res, err := c.sendProjectsListForOrg(ctx, params)
	return res, err
}

func (c *Client) sendProjectsListForOrg(ctx context.Context, params ProjectsListForOrgParams) (res ProjectsListForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsListForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListForRepo invokes projects/list-for-repo operation.
//
// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /repos/{owner}/{repo}/projects
func (c *Client) ProjectsListForRepo(ctx context.Context, params ProjectsListForRepoParams) (ProjectsListForRepoRes, error) {
	res, err := c.sendProjectsListForRepo(ctx, params)
	return res, err
}

func (c *Client) sendProjectsListForRepo(ctx context.Context, params ProjectsListForRepoParams) (res ProjectsListForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsListForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListForUser invokes projects/list-for-user operation.
//
// List user projects.
//
// GET /users/{username}/projects
func (c *Client) ProjectsListForUser(ctx context.Context, params ProjectsListForUserParams) (ProjectsListForUserRes, error) {
	res, err := c.sendProjectsListForUser(ctx, params)
	return res, err
}

func (c *Client) sendProjectsListForUser(ctx context.Context, params ProjectsListForUserParams) (res ProjectsListForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsListForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsMoveCard invokes projects/move-card operation.
//
// Move a project card.
//
// POST /projects/columns/cards/{card_id}/moves
func (c *Client) ProjectsMoveCard(ctx context.Context, request *ProjectsMoveCardReq, params ProjectsMoveCardParams) (ProjectsMoveCardRes, error) {
	res, err := c.sendProjectsMoveCard(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsMoveCard(ctx context.Context, request *ProjectsMoveCardReq, params ProjectsMoveCardParams) (res ProjectsMoveCardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-card"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}/moves"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsMoveCard",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/moves"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsMoveCardRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsMoveCardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsMoveColumn invokes projects/move-column operation.
//
// Move a project column.
//
// POST /projects/columns/{column_id}/moves
func (c *Client) ProjectsMoveColumn(ctx context.Context, request *ProjectsMoveColumnReq, params ProjectsMoveColumnParams) (ProjectsMoveColumnRes, error) {
	res, err := c.sendProjectsMoveColumn(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsMoveColumn(ctx context.Context, request *ProjectsMoveColumnReq, params ProjectsMoveColumnParams) (res ProjectsMoveColumnRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-column"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}/moves"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsMoveColumn",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/moves"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsMoveColumnRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsMoveColumnResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsRemoveCollaborator invokes projects/remove-collaborator operation.
//
// Removes a collaborator from an organization project. You must be an organization owner or a
// project `admin` to remove a collaborator.
//
// DELETE /projects/{project_id}/collaborators/{username}
func (c *Client) ProjectsRemoveCollaborator(ctx context.Context, params ProjectsRemoveCollaboratorParams) (ProjectsRemoveCollaboratorRes, error) {
	res, err := c.sendProjectsRemoveCollaborator(ctx, params)
	return res, err
}

func (c *Client) sendProjectsRemoveCollaborator(ctx context.Context, params ProjectsRemoveCollaboratorParams) (res ProjectsRemoveCollaboratorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/remove-collaborator"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsRemoveCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsUpdate invokes projects/update operation.
//
// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled.
// If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410
// Gone` status is returned.
//
// PATCH /projects/{project_id}
func (c *Client) ProjectsUpdate(ctx context.Context, request OptProjectsUpdateReq, params ProjectsUpdateParams) (ProjectsUpdateRes, error) {
	res, err := c.sendProjectsUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsUpdate(ctx context.Context, request OptProjectsUpdateReq, params ProjectsUpdateParams) (res ProjectsUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/projects/{project_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsUpdateCard invokes projects/update-card operation.
//
// Update an existing project card.
//
// PATCH /projects/columns/cards/{card_id}
func (c *Client) ProjectsUpdateCard(ctx context.Context, request OptProjectsUpdateCardReq, params ProjectsUpdateCardParams) (ProjectsUpdateCardRes, error) {
	res, err := c.sendProjectsUpdateCard(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsUpdateCard(ctx context.Context, request OptProjectsUpdateCardReq, params ProjectsUpdateCardParams) (res ProjectsUpdateCardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-card"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsUpdateCard",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsUpdateCardRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsUpdateCardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsUpdateColumn invokes projects/update-column operation.
//
// Update an existing project column.
//
// PATCH /projects/columns/{column_id}
func (c *Client) ProjectsUpdateColumn(ctx context.Context, request *ProjectsUpdateColumnReq, params ProjectsUpdateColumnParams) (ProjectsUpdateColumnRes, error) {
	res, err := c.sendProjectsUpdateColumn(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsUpdateColumn(ctx context.Context, request *ProjectsUpdateColumnReq, params ProjectsUpdateColumnParams) (res ProjectsUpdateColumnRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-column"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsUpdateColumn",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsUpdateColumnRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProjectsUpdateColumnResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCheckIfMerged invokes pulls/check-if-merged operation.
//
// Check if a pull request has been merged.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (c *Client) PullsCheckIfMerged(ctx context.Context, params PullsCheckIfMergedParams) (PullsCheckIfMergedRes, error) {
	res, err := c.sendPullsCheckIfMerged(ctx, params)
	return res, err
}

func (c *Client) sendPullsCheckIfMerged(ctx context.Context, params PullsCheckIfMergedParams) (res PullsCheckIfMergedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/check-if-merged"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/merge"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCheckIfMerged",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/merge"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsCheckIfMergedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreate invokes pulls/create operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
// You can create a new pull request.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls
func (c *Client) PullsCreate(ctx context.Context, request *PullsCreateReq, params PullsCreateParams) (PullsCreateRes, error) {
	res, err := c.sendPullsCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsCreate(ctx context.Context, request *PullsCreateReq, params PullsCreateParams) (res PullsCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreateReplyForReviewComment invokes pulls/create-reply-for-review-comment operation.
//
// Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of
// the review comment you are replying to. This must be the ID of a _top-level review comment_, not a
// reply to that comment. Replies to replies are not supported.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (c *Client) PullsCreateReplyForReviewComment(ctx context.Context, request *PullsCreateReplyForReviewCommentReq, params PullsCreateReplyForReviewCommentParams) (PullsCreateReplyForReviewCommentRes, error) {
	res, err := c.sendPullsCreateReplyForReviewComment(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsCreateReplyForReviewComment(ctx context.Context, request *PullsCreateReplyForReviewCommentReq, params PullsCreateReplyForReviewCommentParams) (res PullsCreateReplyForReviewCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-reply-for-review-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreateReplyForReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/replies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsCreateReplyForReviewCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsCreateReplyForReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreateReview invokes pulls/create-review operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in
// the response.
// **Note:** To comment on a specific line in a file, you need to first determine the _position_ of
// that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media
// type](https://docs.github.
// com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request
// diff, add this media type to the `Accept` header of a call to the [single pull
// request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
// The `position` value equals the number of lines down from the first "@@" hunk header in the file
// you want to add a comment. The line just below the "@@" line is position 1, the next line is
// position 2, and so on. The position in the diff continues to increase through lines of whitespace
// and additional hunks until the beginning of a new file.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (c *Client) PullsCreateReview(ctx context.Context, request OptPullsCreateReviewReq, params PullsCreateReviewParams) (PullsCreateReviewRes, error) {
	res, err := c.sendPullsCreateReview(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsCreateReview(ctx context.Context, request OptPullsCreateReviewReq, params PullsCreateReviewParams) (res PullsCreateReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreateReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsCreateReviewRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsCreateReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreateReviewComment invokes pulls/create-review-comment operation.
//
// Creates a review comment in the pull request diff. To add a regular comment to a pull request
// timeline, see "[Create an issue comment](https://docs.github.
// com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using
// `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than
// one line in the pull request diff.
// You can still create a review comment using the `position` parameter. When you use `position`, the
// `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information,
// see the [`comfort-fade` preview notice](https://docs.github.
// com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
// **Note:** The position value equals the number of lines down from the first "@@" hunk header in
// the file you want to add a comment. The line just below the "@@" line is position 1, the next line
// is position 2, and so on. The position in the diff continues to increase through lines of
// whitespace and additional hunks until the beginning of a new file.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (c *Client) PullsCreateReviewComment(ctx context.Context, request *PullsCreateReviewCommentReq, params PullsCreateReviewCommentParams) (PullsCreateReviewCommentRes, error) {
	res, err := c.sendPullsCreateReviewComment(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsCreateReviewComment(ctx context.Context, request *PullsCreateReviewCommentReq, params PullsCreateReviewCommentParams) (res PullsCreateReviewCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/comments"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreateReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsCreateReviewCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsCreateReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsDeletePendingReview invokes pulls/delete-pending-review operation.
//
// Delete a pending review for a pull request.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (c *Client) PullsDeletePendingReview(ctx context.Context, params PullsDeletePendingReviewParams) (PullsDeletePendingReviewRes, error) {
	res, err := c.sendPullsDeletePendingReview(ctx, params)
	return res, err
}

func (c *Client) sendPullsDeletePendingReview(ctx context.Context, params PullsDeletePendingReviewParams) (res PullsDeletePendingReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-pending-review"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsDeletePendingReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsDeletePendingReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsDeleteReviewComment invokes pulls/delete-review-comment operation.
//
// Deletes a review comment.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (c *Client) PullsDeleteReviewComment(ctx context.Context, params PullsDeleteReviewCommentParams) (PullsDeleteReviewCommentRes, error) {
	res, err := c.sendPullsDeleteReviewComment(ctx, params)
	return res, err
}

func (c *Client) sendPullsDeleteReviewComment(ctx context.Context, params PullsDeleteReviewCommentParams) (res PullsDeleteReviewCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-review-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsDeleteReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsDeleteReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsDismissReview invokes pulls/dismiss-review operation.
//
// **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.
// com/rest/reference/repos#branches), you must be a repository administrator or be included in the
// list of people or teams who can dismiss pull request reviews.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (c *Client) PullsDismissReview(ctx context.Context, request *PullsDismissReviewReq, params PullsDismissReviewParams) (PullsDismissReviewRes, error) {
	res, err := c.sendPullsDismissReview(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsDismissReview(ctx context.Context, request *PullsDismissReviewReq, params PullsDismissReviewParams) (res PullsDismissReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/dismiss-review"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsDismissReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/dismissals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsDismissReviewRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsDismissReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsGet invokes pulls/get operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists details of a pull request by providing its number.
// When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or
// [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub
// creates a merge commit to test whether the pull request can be automatically merged into the base
// branch. This test commit is not added to the base branch or the head branch. You can review the
// status of the test commit using the `mergeable` key. For more information, see "[Checking
// mergeability of pull requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`,
// then GitHub has started a background job to compute the mergeability. After giving the job time to
// complete, resubmit the request. When the job finishes, you will see a non-`null` value for the
// `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be
// the SHA of the _test_ merge commit.
// The value of the `merge_commit_sha` attribute changes depending on the state of the pull request.
// Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge
// commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how
// you merged the pull request:
//   - If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/),
//     `merge_commit_sha` represents the SHA of the merge commit.
//   - If merged via a [squash](https://help.github.
//
// com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha`
// represents the SHA of the squashed commit on the base branch.
// *   If [rebased](https://help.github.
// com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha`
// represents the commit that the base branch was updated to.
// Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (c *Client) PullsGet(ctx context.Context, params PullsGetParams) (PullsGetRes, error) {
	res, err := c.sendPullsGet(ctx, params)
	return res, err
}

func (c *Client) sendPullsGet(ctx context.Context, params PullsGetParams) (res PullsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsGetReview invokes pulls/get-review operation.
//
// Get a review for a pull request.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (c *Client) PullsGetReview(ctx context.Context, params PullsGetReviewParams) (PullsGetReviewRes, error) {
	res, err := c.sendPullsGetReview(ctx, params)
	return res, err
}

func (c *Client) sendPullsGetReview(ctx context.Context, params PullsGetReviewParams) (res PullsGetReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsGetReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsGetReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsGetReviewComment invokes pulls/get-review-comment operation.
//
// Provides details for a review comment.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (c *Client) PullsGetReviewComment(ctx context.Context, params PullsGetReviewCommentParams) (PullsGetReviewCommentRes, error) {
	res, err := c.sendPullsGetReviewComment(ctx, params)
	return res, err
}

func (c *Client) sendPullsGetReviewComment(ctx context.Context, params PullsGetReviewCommentParams) (res PullsGetReviewCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsGetReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsGetReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsList invokes pulls/list operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/pulls
func (c *Client) PullsList(ctx context.Context, params PullsListParams) (PullsListRes, error) {
	res, err := c.sendPullsList(ctx, params)
	return res, err
}

func (c *Client) sendPullsList(ctx context.Context, params PullsListParams) (res PullsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "head" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "head",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Head.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "base" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "base",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Base.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListCommentsForReview invokes pulls/list-comments-for-review operation.
//
// List comments for a specific pull request review.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (c *Client) PullsListCommentsForReview(ctx context.Context, params PullsListCommentsForReviewParams) (PullsListCommentsForReviewRes, error) {
	res, err := c.sendPullsListCommentsForReview(ctx, params)
	return res, err
}

func (c *Client) sendPullsListCommentsForReview(ctx context.Context, params PullsListCommentsForReviewParams) (res PullsListCommentsForReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-comments-for-review"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListCommentsForReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListCommentsForReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListCommits invokes pulls/list-commits operation.
//
// Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull
// requests with more than 250 commits, use the [List commits](https://docs.github.
// com/rest/reference/repos#list-commits) endpoint.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (c *Client) PullsListCommits(ctx context.Context, params PullsListCommitsParams) (*PullsListCommitsOKHeaders, error) {
	res, err := c.sendPullsListCommits(ctx, params)
	return res, err
}

func (c *Client) sendPullsListCommits(ctx context.Context, params PullsListCommitsParams) (res *PullsListCommitsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-commits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/commits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListCommits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/commits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListCommitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListFiles invokes pulls/list-files operation.
//
// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per
// page by default.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
func (c *Client) PullsListFiles(ctx context.Context, params PullsListFilesParams) (PullsListFilesRes, error) {
	res, err := c.sendPullsListFiles(ctx, params)
	return res, err
}

func (c *Client) sendPullsListFiles(ctx context.Context, params PullsListFilesParams) (res PullsListFilesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-files"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/files"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListFiles",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListFilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListRequestedReviewers invokes pulls/list-requested-reviewers operation.
//
// List requested reviewers for a pull request.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (c *Client) PullsListRequestedReviewers(ctx context.Context, params PullsListRequestedReviewersParams) (*PullRequestReviewRequestHeaders, error) {
	res, err := c.sendPullsListRequestedReviewers(ctx, params)
	return res, err
}

func (c *Client) sendPullsListRequestedReviewers(ctx context.Context, params PullsListRequestedReviewersParams) (res *PullRequestReviewRequestHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-requested-reviewers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/requested_reviewers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListRequestedReviewersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListReviewComments invokes pulls/list-review-comments operation.
//
// Lists all review comments for a pull request. By default, review comments are in ascending order
// by ID.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (c *Client) PullsListReviewComments(ctx context.Context, params PullsListReviewCommentsParams) (*PullsListReviewCommentsOKHeaders, error) {
	res, err := c.sendPullsListReviewComments(ctx, params)
	return res, err
}

func (c *Client) sendPullsListReviewComments(ctx context.Context, params PullsListReviewCommentsParams) (res *PullsListReviewCommentsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListReviewComments",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListReviewCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListReviewCommentsForRepo invokes pulls/list-review-comments-for-repo operation.
//
// Lists review comments for all pull requests in a repository. By default, review comments are in
// ascending order by ID.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (c *Client) PullsListReviewCommentsForRepo(ctx context.Context, params PullsListReviewCommentsForRepoParams) (*PullsListReviewCommentsForRepoOKHeaders, error) {
	res, err := c.sendPullsListReviewCommentsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendPullsListReviewCommentsForRepo(ctx context.Context, params PullsListReviewCommentsForRepoParams) (res *PullsListReviewCommentsForRepoOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListReviewCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListReviewCommentsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListReviews invokes pulls/list-reviews operation.
//
// The list of reviews returns in chronological order.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (c *Client) PullsListReviews(ctx context.Context, params PullsListReviewsParams) (*PullsListReviewsOKHeaders, error) {
	res, err := c.sendPullsListReviews(ctx, params)
	return res, err
}

func (c *Client) sendPullsListReviews(ctx context.Context, params PullsListReviewsParams) (res *PullsListReviewsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-reviews"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListReviews",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsListReviewsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsMerge invokes pulls/merge operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (c *Client) PullsMerge(ctx context.Context, request OptNilPullsMergeReq, params PullsMergeParams) (PullsMergeRes, error) {
	res, err := c.sendPullsMerge(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsMerge(ctx context.Context, request OptNilPullsMergeReq, params PullsMergeParams) (res PullsMergeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/merge"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/merge"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsMerge",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/merge"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsMergeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsMergeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsRemoveRequestedReviewers invokes pulls/remove-requested-reviewers operation.
//
// Remove requested reviewers from a pull request.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (c *Client) PullsRemoveRequestedReviewers(ctx context.Context, request *PullsRemoveRequestedReviewersReq, params PullsRemoveRequestedReviewersParams) (PullsRemoveRequestedReviewersRes, error) {
	res, err := c.sendPullsRemoveRequestedReviewers(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsRemoveRequestedReviewers(ctx context.Context, request *PullsRemoveRequestedReviewersReq, params PullsRemoveRequestedReviewersParams) (res PullsRemoveRequestedReviewersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/remove-requested-reviewers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsRemoveRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/requested_reviewers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsRemoveRequestedReviewersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsRemoveRequestedReviewersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsSubmitReview invokes pulls/submit-review operation.
//
// Submit a review for a pull request.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (c *Client) PullsSubmitReview(ctx context.Context, request *PullsSubmitReviewReq, params PullsSubmitReviewParams) (PullsSubmitReviewRes, error) {
	res, err := c.sendPullsSubmitReview(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsSubmitReview(ctx context.Context, request *PullsSubmitReviewReq, params PullsSubmitReviewParams) (res PullsSubmitReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/submit-review"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsSubmitReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsSubmitReviewRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsSubmitReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdate invokes pulls/update operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
//
// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
func (c *Client) PullsUpdate(ctx context.Context, request OptPullsUpdateReq, params PullsUpdateParams) (PullsUpdateRes, error) {
	res, err := c.sendPullsUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsUpdate(ctx context.Context, request OptPullsUpdateReq, params PullsUpdateParams) (res PullsUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdateBranch invokes pulls/update-branch operation.
//
// Updates the pull request branch with the latest upstream changes by merging HEAD from the base
// branch into the pull request branch.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
func (c *Client) PullsUpdateBranch(ctx context.Context, request OptNilPullsUpdateBranchReq, params PullsUpdateBranchParams) (PullsUpdateBranchRes, error) {
	res, err := c.sendPullsUpdateBranch(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsUpdateBranch(ctx context.Context, request OptNilPullsUpdateBranchReq, params PullsUpdateBranchParams) (res PullsUpdateBranchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-branch"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdateBranch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/update-branch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsUpdateBranchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsUpdateBranchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdateReview invokes pulls/update-review operation.
//
// Update the review summary comment with new text.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (c *Client) PullsUpdateReview(ctx context.Context, request *PullsUpdateReviewReq, params PullsUpdateReviewParams) (PullsUpdateReviewRes, error) {
	res, err := c.sendPullsUpdateReview(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsUpdateReview(ctx context.Context, request *PullsUpdateReviewReq, params PullsUpdateReviewParams) (res PullsUpdateReviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdateReview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsUpdateReviewRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsUpdateReviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdateReviewComment invokes pulls/update-review-comment operation.
//
// Enables you to edit a review comment.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (c *Client) PullsUpdateReviewComment(ctx context.Context, request *PullsUpdateReviewCommentReq, params PullsUpdateReviewCommentParams) (*PullRequestReviewComment, error) {
	res, err := c.sendPullsUpdateReviewComment(ctx, request, params)
	return res, err
}

func (c *Client) sendPullsUpdateReviewComment(ctx context.Context, request *PullsUpdateReviewCommentReq, params PullsUpdateReviewCommentParams) (res *PullRequestReviewComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review-comment"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdateReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePullsUpdateReviewCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePullsUpdateReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RateLimitGet invokes rate-limit/get operation.
//
// **Note:** Accessing this endpoint does not count against your REST API rate limit.
// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating
// existing code, you should use the `core` object instead of the `rate` object. The `core` object
// contains the same information that is present in the `rate` object.
//
// GET /rate_limit
func (c *Client) RateLimitGet(ctx context.Context) (RateLimitGetRes, error) {
	res, err := c.sendRateLimitGet(ctx)
	return res, err
}

func (c *Client) sendRateLimitGet(ctx context.Context) (res RateLimitGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rate-limit/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/rate_limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RateLimitGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/rate_limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRateLimitGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForCommitComment invokes reactions/create-for-commit-comment operation.
//
// Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this commit
// comment.
//
// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (c *Client) ReactionsCreateForCommitComment(ctx context.Context, request *ReactionsCreateForCommitCommentReq, params ReactionsCreateForCommitCommentParams) (ReactionsCreateForCommitCommentRes, error) {
	res, err := c.sendReactionsCreateForCommitComment(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForCommitComment(ctx context.Context, request *ReactionsCreateForCommitCommentReq, params ReactionsCreateForCommitCommentParams) (res ReactionsCreateForCommitCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-commit-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForCommitCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForIssue invokes reactions/create-for-issue operation.
//
// Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with
// an HTTP `200` status means that you already added the reaction type to this issue.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (c *Client) ReactionsCreateForIssue(ctx context.Context, request *ReactionsCreateForIssueReq, params ReactionsCreateForIssueParams) (ReactionsCreateForIssueRes, error) {
	res, err := c.sendReactionsCreateForIssue(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForIssue(ctx context.Context, request *ReactionsCreateForIssueReq, params ReactionsCreateForIssueParams) (res ReactionsCreateForIssueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForIssue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForIssueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForIssueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForIssueComment invokes reactions/create-for-issue-comment operation.
//
// Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this issue
// comment.
//
// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (c *Client) ReactionsCreateForIssueComment(ctx context.Context, request *ReactionsCreateForIssueCommentReq, params ReactionsCreateForIssueCommentParams) (ReactionsCreateForIssueCommentRes, error) {
	res, err := c.sendReactionsCreateForIssueComment(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForIssueComment(ctx context.Context, request *ReactionsCreateForIssueCommentReq, params ReactionsCreateForIssueCommentParams) (res ReactionsCreateForIssueCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForIssueComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForIssueCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForIssueCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForPullRequestReviewComment invokes reactions/create-for-pull-request-review-comment operation.
//
// Create a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already
// added the reaction type to this pull request review comment.
//
// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (c *Client) ReactionsCreateForPullRequestReviewComment(ctx context.Context, request *ReactionsCreateForPullRequestReviewCommentReq, params ReactionsCreateForPullRequestReviewCommentParams) (ReactionsCreateForPullRequestReviewCommentRes, error) {
	res, err := c.sendReactionsCreateForPullRequestReviewComment(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForPullRequestReviewComment(ctx context.Context, request *ReactionsCreateForPullRequestReviewCommentReq, params ReactionsCreateForPullRequestReviewCommentParams) (res ReactionsCreateForPullRequestReviewCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-pull-request-review-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForPullRequestReviewCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForPullRequestReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForRelease invokes reactions/create-for-release operation.
//
// Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A
// response with a `Status: 200 OK` means that you already added the reaction type to this release.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
func (c *Client) ReactionsCreateForRelease(ctx context.Context, request *ReactionsCreateForReleaseReq, params ReactionsCreateForReleaseParams) (ReactionsCreateForReleaseRes, error) {
	res, err := c.sendReactionsCreateForRelease(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForRelease(ctx context.Context, request *ReactionsCreateForReleaseReq, params ReactionsCreateForReleaseParams) (res ReactionsCreateForReleaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-release"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForRelease",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForReleaseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionCommentInOrg invokes reactions/create-for-team-discussion-comment-in-org operation.
//
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, request *ReactionsCreateForTeamDiscussionCommentInOrgReq, params ReactionsCreateForTeamDiscussionCommentInOrgParams) (ReactionsCreateForTeamDiscussionCommentInOrgRes, error) {
	res, err := c.sendReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, request *ReactionsCreateForTeamDiscussionCommentInOrgReq, params ReactionsCreateForTeamDiscussionCommentInOrgParams) (res ReactionsCreateForTeamDiscussionCommentInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-in-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForTeamDiscussionCommentInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForTeamDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionCommentLegacy invokes reactions/create-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Create reaction for a team discussion
// comment](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, request *ReactionsCreateForTeamDiscussionCommentLegacyReq, params ReactionsCreateForTeamDiscussionCommentLegacyParams) (*Reaction, error) {
	res, err := c.sendReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, request *ReactionsCreateForTeamDiscussionCommentLegacyReq, params ReactionsCreateForTeamDiscussionCommentLegacyParams) (res *Reaction, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-legacy"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForTeamDiscussionCommentLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForTeamDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionInOrg invokes reactions/create-for-team-discussion-in-org operation.
//
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, request *ReactionsCreateForTeamDiscussionInOrgReq, params ReactionsCreateForTeamDiscussionInOrgParams) (ReactionsCreateForTeamDiscussionInOrgRes, error) {
	res, err := c.sendReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForTeamDiscussionInOrg(ctx context.Context, request *ReactionsCreateForTeamDiscussionInOrgReq, params ReactionsCreateForTeamDiscussionInOrgParams) (res ReactionsCreateForTeamDiscussionInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-in-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForTeamDiscussionInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForTeamDiscussionInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionLegacy invokes reactions/create-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create reaction for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, request *ReactionsCreateForTeamDiscussionLegacyReq, params ReactionsCreateForTeamDiscussionLegacyParams) (*Reaction, error) {
	res, err := c.sendReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendReactionsCreateForTeamDiscussionLegacy(ctx context.Context, request *ReactionsCreateForTeamDiscussionLegacyReq, params ReactionsCreateForTeamDiscussionLegacyParams) (res *Reaction, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-legacy"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/reactions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReactionsCreateForTeamDiscussionLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsCreateForTeamDiscussionLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForCommitComment invokes reactions/delete-for-commit-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForCommitComment(ctx context.Context, params ReactionsDeleteForCommitCommentParams) error {
	_, err := c.sendReactionsDeleteForCommitComment(ctx, params)
	return err
}

func (c *Client) sendReactionsDeleteForCommitComment(ctx context.Context, params ReactionsDeleteForCommitCommentParams) (res *ReactionsDeleteForCommitCommentNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-commit-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteForCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForIssue invokes reactions/delete-for-issue operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
// Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForIssue(ctx context.Context, params ReactionsDeleteForIssueParams) error {
	_, err := c.sendReactionsDeleteForIssue(ctx, params)
	return err
}

func (c *Client) sendReactionsDeleteForIssue(ctx context.Context, params ReactionsDeleteForIssueParams) (res *ReactionsDeleteForIssueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForIssue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteForIssueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForIssueComment invokes reactions/delete-for-issue-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete
// /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForIssueComment(ctx context.Context, params ReactionsDeleteForIssueCommentParams) error {
	_, err := c.sendReactionsDeleteForIssueComment(ctx, params)
	return err
}

func (c *Client) sendReactionsDeleteForIssueComment(ctx context.Context, params ReactionsDeleteForIssueCommentParams) (res *ReactionsDeleteForIssueCommentNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForIssueComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteForIssueCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForPullRequestComment invokes reactions/delete-for-pull-request-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
// Delete a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForPullRequestComment(ctx context.Context, params ReactionsDeleteForPullRequestCommentParams) error {
	_, err := c.sendReactionsDeleteForPullRequestComment(ctx, params)
	return err
}

func (c *Client) sendReactionsDeleteForPullRequestComment(ctx context.Context, params ReactionsDeleteForPullRequestCommentParams) (res *ReactionsDeleteForPullRequestCommentNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-pull-request-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForPullRequestComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteForPullRequestCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForTeamDiscussion invokes reactions/delete-for-team-discussion operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, params ReactionsDeleteForTeamDiscussionParams) error {
	_, err := c.sendReactionsDeleteForTeamDiscussion(ctx, params)
	return err
}

func (c *Client) sendReactionsDeleteForTeamDiscussion(ctx context.Context, params ReactionsDeleteForTeamDiscussionParams) (res *ReactionsDeleteForTeamDiscussionNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForTeamDiscussion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteForTeamDiscussionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForTeamDiscussionComment invokes reactions/delete-for-team-discussion-comment operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, params ReactionsDeleteForTeamDiscussionCommentParams) error {
	_, err := c.sendReactionsDeleteForTeamDiscussionComment(ctx, params)
	return err
}

func (c *Client) sendReactionsDeleteForTeamDiscussionComment(ctx context.Context, params ReactionsDeleteForTeamDiscussionCommentParams) (res *ReactionsDeleteForTeamDiscussionCommentNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForTeamDiscussionComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [10]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[9] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteForTeamDiscussionCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteLegacy invokes reactions/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions
// API. We recommend migrating your existing code to use the new delete reactions endpoints. For more
// information, see this [blog post](https://developer.github.
// com/changes/2020-02-26-new-delete-reactions-endpoints/).
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team
// discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion
// comment](https://docs.github.com/rest/reference/teams#discussion-comments).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /reactions/{reaction_id}
func (c *Client) ReactionsDeleteLegacy(ctx context.Context, params ReactionsDeleteLegacyParams) (ReactionsDeleteLegacyRes, error) {
	res, err := c.sendReactionsDeleteLegacy(ctx, params)
	return res, err
}

func (c *Client) sendReactionsDeleteLegacy(ctx context.Context, params ReactionsDeleteLegacyParams) (res ReactionsDeleteLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/reactions/{reaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsDeleteLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForCommitComment invokes reactions/list-for-commit-comment operation.
//
// List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (c *Client) ReactionsListForCommitComment(ctx context.Context, params ReactionsListForCommitCommentParams) (ReactionsListForCommitCommentRes, error) {
	res, err := c.sendReactionsListForCommitComment(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForCommitComment(ctx context.Context, params ReactionsListForCommitCommentParams) (res ReactionsListForCommitCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-commit-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForIssue invokes reactions/list-for-issue operation.
//
// List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (c *Client) ReactionsListForIssue(ctx context.Context, params ReactionsListForIssueParams) (ReactionsListForIssueRes, error) {
	res, err := c.sendReactionsListForIssue(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForIssue(ctx context.Context, params ReactionsListForIssueParams) (res ReactionsListForIssueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForIssue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForIssueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForIssueComment invokes reactions/list-for-issue-comment operation.
//
// List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (c *Client) ReactionsListForIssueComment(ctx context.Context, params ReactionsListForIssueCommentParams) (ReactionsListForIssueCommentRes, error) {
	res, err := c.sendReactionsListForIssueComment(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForIssueComment(ctx context.Context, params ReactionsListForIssueCommentParams) (res ReactionsListForIssueCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForIssueComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForIssueCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForPullRequestReviewComment invokes reactions/list-for-pull-request-review-comment operation.
//
// List the reactions to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (c *Client) ReactionsListForPullRequestReviewComment(ctx context.Context, params ReactionsListForPullRequestReviewCommentParams) (ReactionsListForPullRequestReviewCommentRes, error) {
	res, err := c.sendReactionsListForPullRequestReviewComment(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForPullRequestReviewComment(ctx context.Context, params ReactionsListForPullRequestReviewCommentParams) (res ReactionsListForPullRequestReviewCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-pull-request-review-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForPullRequestReviewCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionCommentInOrg invokes reactions/list-for-team-discussion-comment-in-org operation.
//
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, params ReactionsListForTeamDiscussionCommentInOrgParams) (*ReactionsListForTeamDiscussionCommentInOrgOKHeaders, error) {
	res, err := c.sendReactionsListForTeamDiscussionCommentInOrg(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, params ReactionsListForTeamDiscussionCommentInOrgParams) (res *ReactionsListForTeamDiscussionCommentInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForTeamDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionCommentLegacy invokes reactions/list-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team discussion
// comment`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, params ReactionsListForTeamDiscussionCommentLegacyParams) (*ReactionsListForTeamDiscussionCommentLegacyOKHeaders, error) {
	res, err := c.sendReactionsListForTeamDiscussionCommentLegacy(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, params ReactionsListForTeamDiscussionCommentLegacyParams) (res *ReactionsListForTeamDiscussionCommentLegacyOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForTeamDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionInOrg invokes reactions/list-for-team-discussion-in-org operation.
//
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionInOrg(ctx context.Context, params ReactionsListForTeamDiscussionInOrgParams) (*ReactionsListForTeamDiscussionInOrgOKHeaders, error) {
	res, err := c.sendReactionsListForTeamDiscussionInOrg(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForTeamDiscussionInOrg(ctx context.Context, params ReactionsListForTeamDiscussionInOrgParams) (res *ReactionsListForTeamDiscussionInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForTeamDiscussionInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionLegacy invokes reactions/list-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionLegacy(ctx context.Context, params ReactionsListForTeamDiscussionLegacyParams) (*ReactionsListForTeamDiscussionLegacyOKHeaders, error) {
	res, err := c.sendReactionsListForTeamDiscussionLegacy(ctx, params)
	return res, err
}

func (c *Client) sendReactionsListForTeamDiscussionLegacy(ctx context.Context, params ReactionsListForTeamDiscussionLegacyParams) (res *ReactionsListForTeamDiscussionLegacyOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/reactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/reactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReactionsListForTeamDiscussionLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAcceptInvitation invokes repos/accept-invitation operation.
//
// Accept a repository invitation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (c *Client) ReposAcceptInvitation(ctx context.Context, params ReposAcceptInvitationParams) (ReposAcceptInvitationRes, error) {
	res, err := c.sendReposAcceptInvitation(ctx, params)
	return res, err
}

func (c *Client) sendReposAcceptInvitation(ctx context.Context, params ReposAcceptInvitationParams) (res ReposAcceptInvitationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/accept-invitation"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user/repository_invitations/{invitation_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAcceptInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/repository_invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposAcceptInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddAppAccessRestrictions invokes repos/add-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified apps push access for this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposAddAppAccessRestrictions(ctx context.Context, request OptReposAddAppAccessRestrictionsReq, params ReposAddAppAccessRestrictionsParams) (ReposAddAppAccessRestrictionsRes, error) {
	res, err := c.sendReposAddAppAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposAddAppAccessRestrictions(ctx context.Context, request OptReposAddAppAccessRestrictionsReq, params ReposAddAppAccessRestrictionsParams) (res ReposAddAppAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-app-access-restrictions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/apps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposAddAppAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposAddAppAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddCollaborator invokes repos/add-collaborator operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// For more information the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// The invitee will receive a notification that they have been invited to the repository, which they
// must accept or decline. They may do this via the notifications page, the email they receive, or by
// using the [repository invitations API endpoints](https://docs.github.
// com/rest/reference/repos#invitations).
// **Rate limits**
// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no
// limit if you are inviting organization members to an organization repository.
//
// PUT /repos/{owner}/{repo}/collaborators/{username}
func (c *Client) ReposAddCollaborator(ctx context.Context, request OptReposAddCollaboratorReq, params ReposAddCollaboratorParams) (ReposAddCollaboratorRes, error) {
	res, err := c.sendReposAddCollaborator(ctx, request, params)
	return res, err
}

func (c *Client) sendReposAddCollaborator(ctx context.Context, request OptReposAddCollaboratorReq, params ReposAddCollaboratorParams) (res ReposAddCollaboratorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-collaborator"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposAddCollaboratorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposAddCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddStatusCheckContexts invokes repos/add-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposAddStatusCheckContexts(ctx context.Context, request OptReposAddStatusCheckContextsReq, params ReposAddStatusCheckContextsParams) (ReposAddStatusCheckContextsRes, error) {
	res, err := c.sendReposAddStatusCheckContexts(ctx, request, params)
	return res, err
}

func (c *Client) sendReposAddStatusCheckContexts(ctx context.Context, request OptReposAddStatusCheckContextsReq, params ReposAddStatusCheckContextsParams) (res ReposAddStatusCheckContextsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-status-check-contexts"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks/contexts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposAddStatusCheckContextsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposAddStatusCheckContextsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddTeamAccessRestrictions invokes repos/add-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified teams push access for this branch. You can also give push access to child
// teams.
// | Type    | Description
//
//	|
//
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposAddTeamAccessRestrictions(ctx context.Context, request OptReposAddTeamAccessRestrictionsReq, params ReposAddTeamAccessRestrictionsParams) (ReposAddTeamAccessRestrictionsRes, error) {
	res, err := c.sendReposAddTeamAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposAddTeamAccessRestrictions(ctx context.Context, request OptReposAddTeamAccessRestrictionsReq, params ReposAddTeamAccessRestrictionsParams) (res ReposAddTeamAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-team-access-restrictions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposAddTeamAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposAddTeamAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddUserAccessRestrictions invokes repos/add-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified people push access for this branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposAddUserAccessRestrictions(ctx context.Context, request OptReposAddUserAccessRestrictionsReq, params ReposAddUserAccessRestrictionsParams) (ReposAddUserAccessRestrictionsRes, error) {
	res, err := c.sendReposAddUserAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposAddUserAccessRestrictions(ctx context.Context, request OptReposAddUserAccessRestrictionsReq, params ReposAddUserAccessRestrictionsParams) (res ReposAddUserAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-user-access-restrictions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposAddUserAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposAddUserAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCheckCollaborator invokes repos/check-collaborator operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (c *Client) ReposCheckCollaborator(ctx context.Context, params ReposCheckCollaboratorParams) (ReposCheckCollaboratorRes, error) {
	res, err := c.sendReposCheckCollaborator(ctx, params)
	return res, err
}

func (c *Client) sendReposCheckCollaborator(ctx context.Context, params ReposCheckCollaboratorParams) (res ReposCheckCollaboratorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-collaborator"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCheckCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCheckCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCheckVulnerabilityAlerts invokes repos/check-vulnerability-alerts operation.
//
// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user
// must have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (c *Client) ReposCheckVulnerabilityAlerts(ctx context.Context, params ReposCheckVulnerabilityAlertsParams) (ReposCheckVulnerabilityAlertsRes, error) {
	res, err := c.sendReposCheckVulnerabilityAlerts(ctx, params)
	return res, err
}

func (c *Client) sendReposCheckVulnerabilityAlerts(ctx context.Context, params ReposCheckVulnerabilityAlertsParams) (res ReposCheckVulnerabilityAlertsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-vulnerability-alerts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/vulnerability-alerts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCheckVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/vulnerability-alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCheckVulnerabilityAlertsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCompareCommits invokes repos/compare-commits operation.
//
// The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in
// `repo`. To compare branches across other repositories in the same network as `repo`, use the
// format `<USERNAME>:branch`.
// The response from the API is equivalent to running the `git log base..head` command; however,
// commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
// The response also includes details on the files that were changed between the two commits. This
// includes the status of the change (for example, if a file was added, removed, modified, or
// renamed), and details of the change itself. For example, files with a `renamed` status have a
// `previous_filename` field showing the previous filename of the file, and files with a `modified`
// status have a `patch` field showing the changes made to the file.
// **Working with large comparisons**
// To process a response with a large number of commits, you can use (`per_page` or `page`) to
// paginate the results. When using paging, the list of changed files is only returned with page 1,
// but includes all changed files for the entire comparison. For more information on working with
// pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
// When calling this API without any paging parameters (`per_page` or `page`), the returned list is
// limited to 250 commits and the last commit in the list is the most recent of the entire comparison.
//
//	When a paging parameter is specified, the first commit in the returned list of each page is the
//
// earliest.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (c *Client) ReposCompareCommits(ctx context.Context, params ReposCompareCommitsParams) (ReposCompareCommitsRes, error) {
	res, err := c.sendReposCompareCommits(ctx, params)
	return res, err
}

func (c *Client) sendReposCompareCommits(ctx context.Context, params ReposCompareCommitsParams) (res ReposCompareCommitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/compare-commits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/compare/{basehead}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCompareCommits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/compare/"
	{
		// Encode "basehead" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "basehead",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Basehead))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCompareCommitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateAutolink invokes repos/create-autolink operation.
//
// Users with admin access to the repository can create an autolink.
//
// POST /repos/{owner}/{repo}/autolinks
func (c *Client) ReposCreateAutolink(ctx context.Context, request *ReposCreateAutolinkReq, params ReposCreateAutolinkParams) (ReposCreateAutolinkRes, error) {
	res, err := c.sendReposCreateAutolink(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateAutolink(ctx context.Context, request *ReposCreateAutolinkReq, params ReposCreateAutolinkParams) (res ReposCreateAutolinkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-autolink"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateAutolink",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/autolinks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateAutolinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateAutolinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateCommitComment invokes repos/create-commit-comment operation.
//
// Create a comment for a commit using its `:commit_sha`.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (c *Client) ReposCreateCommitComment(ctx context.Context, request *ReposCreateCommitCommentReq, params ReposCreateCommitCommentParams) (ReposCreateCommitCommentRes, error) {
	res, err := c.sendReposCreateCommitComment(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateCommitComment(ctx context.Context, request *ReposCreateCommitCommentReq, params ReposCreateCommitCommentParams) (res ReposCreateCommitCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-comment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateCommitCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateCommitSignatureProtection invokes repos/create-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// require signed commits on a branch. You must enable branch protection to require signed commits.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (c *Client) ReposCreateCommitSignatureProtection(ctx context.Context, params ReposCreateCommitSignatureProtectionParams) (ReposCreateCommitSignatureProtectionRes, error) {
	res, err := c.sendReposCreateCommitSignatureProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposCreateCommitSignatureProtection(ctx context.Context, params ReposCreateCommitSignatureProtectionParams) (res ReposCreateCommitSignatureProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-signature-protection"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_signatures"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateCommitSignatureProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateCommitStatus invokes repos/create-commit-status operation.
//
// Users with push access in a repository can create commit statuses for a given SHA.
// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
// create more than 1000 statuses will result in a validation error.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (c *Client) ReposCreateCommitStatus(ctx context.Context, request *ReposCreateCommitStatusReq, params ReposCreateCommitStatusParams) (*StatusHeaders, error) {
	res, err := c.sendReposCreateCommitStatus(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateCommitStatus(ctx context.Context, request *ReposCreateCommitStatusReq, params ReposCreateCommitStatusParams) (res *StatusHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-status"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/statuses/{sha}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateCommitStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/statuses/"
	{
		// Encode "sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Sha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateCommitStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateCommitStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDeployKey invokes repos/create-deploy-key operation.
//
// You can create a read-only deploy key.
//
// POST /repos/{owner}/{repo}/keys
func (c *Client) ReposCreateDeployKey(ctx context.Context, request *ReposCreateDeployKeyReq, params ReposCreateDeployKeyParams) (ReposCreateDeployKeyRes, error) {
	res, err := c.sendReposCreateDeployKey(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateDeployKey(ctx context.Context, request *ReposCreateDeployKeyReq, params ReposCreateDeployKeyParams) (res ReposCreateDeployKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deploy-key"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDeployKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateDeployKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateDeployKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDeployment invokes repos/create-deployment operation.
//
// Deployments offer a few configurable parameters with certain defaults.
// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and
// verify them
// before we merge a pull request.
// The `environment` parameter allows deployments to be issued to different runtime environments.
// Teams often have
// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`.
// This parameter
// makes it easier to track which environments have requested deployments. The default environment is
// `production`.
// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's
// default branch. If
// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If
// the merge succeeds,
// the API will return a successful merge commit. If merge conflicts prevent the merge from
// succeeding, the API will
// return a failure response.
// By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every
// submitted context must be in a `success`
// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be
// `success`, or to
// specify contexts that have not yet been submitted. You are not required to use commit statuses to
// deploy. If you do
// not require any contexts or create any commit statuses, the deployment will always succeed.
// The `payload` parameter is available for any extra information that a deployment system might need.
//
//	It is a JSON text
//
// field that will be passed on when a deployment event is dispatched.
// The `task` parameter is used by the deployment system to allow different execution paths. In the
// web world this might
// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a
// flag to compile an
// application with debugging enabled.
// Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
// #### Merged branch response
// You will see this response when GitHub automatically merges the base branch into the topic branch
// instead of creating
// a deployment. This auto-merge happens when:
// *   Auto-merge option is enabled in the repository
// *   Topic branch does not include the latest changes on the base branch, which is `master` in the
// response example
// *   There are no merge conflicts
// If there are no new commits in the base branch, a new request to create a deployment should give a
// successful
// response.
// #### Merge conflict response
// This error happens when the `auto_merge` option is enabled and when the default branch (in this
// case `master`), can't
// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge
// conflicts.
// #### Failed commit status checks
// This error happens when the `required_contexts` parameter indicates that one or more contexts need
// to have a `success`
// status for the commit to be deployed, but one or more of the required contexts do not have a state
// of `success`.
//
// POST /repos/{owner}/{repo}/deployments
func (c *Client) ReposCreateDeployment(ctx context.Context, request *ReposCreateDeploymentReq, params ReposCreateDeploymentParams) (ReposCreateDeploymentRes, error) {
	res, err := c.sendReposCreateDeployment(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateDeployment(ctx context.Context, request *ReposCreateDeploymentReq, params ReposCreateDeploymentParams) (res ReposCreateDeploymentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDeployment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateDeploymentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateDeploymentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDeploymentStatus invokes repos/create-deployment-status operation.
//
// Users with `push` access can create deployment statuses for a given deployment.
// GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo
// contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
//
// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (c *Client) ReposCreateDeploymentStatus(ctx context.Context, request *ReposCreateDeploymentStatusReq, params ReposCreateDeploymentStatusParams) (ReposCreateDeploymentStatusRes, error) {
	res, err := c.sendReposCreateDeploymentStatus(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateDeploymentStatus(ctx context.Context, request *ReposCreateDeploymentStatusReq, params ReposCreateDeploymentStatusParams) (res ReposCreateDeploymentStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment-status"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/statuses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateDeploymentStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateDeploymentStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDispatchEvent invokes repos/create-dispatch-event operation.
//
// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want
// activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook.
//
//	You must configure your GitHub Actions workflow or GitHub App to run when the
//
// `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
// "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
// The `client_payload` parameter is available for any extra information that your workflow might
// need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched.
//
//	For example, the `client_payload` can include a message that a user would like to send using a
//
// GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
// This endpoint requires write access to the repository by providing either:
// - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access
// token for the command line](https://help.github.
// com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help
// documentation.
// - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
// This input example shows how you can use the `client_payload` as a test to debug your workflow.
//
// POST /repos/{owner}/{repo}/dispatches
func (c *Client) ReposCreateDispatchEvent(ctx context.Context, request *ReposCreateDispatchEventReq, params ReposCreateDispatchEventParams) (ReposCreateDispatchEventRes, error) {
	res, err := c.sendReposCreateDispatchEvent(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateDispatchEvent(ctx context.Context, request *ReposCreateDispatchEventReq, params ReposCreateDispatchEventParams) (res ReposCreateDispatchEventRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-dispatch-event"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/dispatches"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDispatchEvent",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/dispatches"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateDispatchEventRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateDispatchEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateForAuthenticatedUser invokes repos/create-for-authenticated-user operation.
//
// Creates a new repository for the authenticated user.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /user/repos
func (c *Client) ReposCreateForAuthenticatedUser(ctx context.Context, request *ReposCreateForAuthenticatedUserReq) (ReposCreateForAuthenticatedUserRes, error) {
	res, err := c.sendReposCreateForAuthenticatedUser(ctx, request)
	return res, err
}

func (c *Client) sendReposCreateForAuthenticatedUser(ctx context.Context, request *ReposCreateForAuthenticatedUserReq) (res ReposCreateForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-for-authenticated-user"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/repos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateForAuthenticatedUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateFork invokes repos/create-fork operation.
//
// Create a fork for the authenticated user.
// **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time
// before you can access the git objects. If this takes longer than 5 minutes, be sure to contact
// [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
//
// POST /repos/{owner}/{repo}/forks
func (c *Client) ReposCreateFork(ctx context.Context, request OptNilReposCreateForkReq, params ReposCreateForkParams) (ReposCreateForkRes, error) {
	res, err := c.sendReposCreateFork(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateFork(ctx context.Context, request OptNilReposCreateForkReq, params ReposCreateForkParams) (res ReposCreateForkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-fork"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/forks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateFork",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/forks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateForkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateInOrg invokes repos/create-in-org operation.
//
// Creates a new repository in the specified organization. The authenticated user must be a member of
// the organization.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /orgs/{org}/repos
func (c *Client) ReposCreateInOrg(ctx context.Context, request *ReposCreateInOrgReq, params ReposCreateInOrgParams) (ReposCreateInOrgRes, error) {
	res, err := c.sendReposCreateInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateInOrg(ctx context.Context, request *ReposCreateInOrgReq, params ReposCreateInOrgParams) (res ReposCreateInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-in-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/repos"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateOrUpdateFileContents invokes repos/create-or-update-file-contents operation.
//
// Creates a new file or replaces an existing file in a repository.
//
// PUT /repos/{owner}/{repo}/contents/{path}
func (c *Client) ReposCreateOrUpdateFileContents(ctx context.Context, request *ReposCreateOrUpdateFileContentsReq, params ReposCreateOrUpdateFileContentsParams) (ReposCreateOrUpdateFileContentsRes, error) {
	res, err := c.sendReposCreateOrUpdateFileContents(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateOrUpdateFileContents(ctx context.Context, request *ReposCreateOrUpdateFileContentsReq, params ReposCreateOrUpdateFileContentsParams) (res ReposCreateOrUpdateFileContentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-or-update-file-contents"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/contents/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateOrUpdateFileContents",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/contents/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateOrUpdateFileContentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateOrUpdateFileContentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreatePagesSite invokes repos/create-pages-site operation.
//
// Configures a GitHub Pages site. For more information, see "[About GitHub
// Pages](/github/working-with-github-pages/about-github-pages).".
//
// POST /repos/{owner}/{repo}/pages
func (c *Client) ReposCreatePagesSite(ctx context.Context, request NilReposCreatePagesSiteReq, params ReposCreatePagesSiteParams) (ReposCreatePagesSiteRes, error) {
	res, err := c.sendReposCreatePagesSite(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreatePagesSite(ctx context.Context, request NilReposCreatePagesSiteReq, params ReposCreatePagesSiteParams) (res ReposCreatePagesSiteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-pages-site"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreatePagesSite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreatePagesSiteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreatePagesSiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateRelease invokes repos/create-release operation.
//
// Users with push access to the repository can create a release.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/releases
func (c *Client) ReposCreateRelease(ctx context.Context, request *ReposCreateReleaseReq, params ReposCreateReleaseParams) (ReposCreateReleaseRes, error) {
	res, err := c.sendReposCreateRelease(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateRelease(ctx context.Context, request *ReposCreateReleaseReq, params ReposCreateReleaseParams) (res ReposCreateReleaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-release"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateRelease",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateReleaseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateUsingTemplate invokes repos/create-using-template operation.
//
// Creates a new repository using a repository template. Use the `template_owner` and `template_repo`
// route parameters to specify the repository to use as the template. The authenticated user must own
// or be a member of an organization that owns the repository. To check if a repository is available
// to use as a template, get the repository's information using the [Get a repository](https://docs.
// github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is
// `true`.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (c *Client) ReposCreateUsingTemplate(ctx context.Context, request *ReposCreateUsingTemplateReq, params ReposCreateUsingTemplateParams) (*RepositoryHeaders, error) {
	res, err := c.sendReposCreateUsingTemplate(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateUsingTemplate(ctx context.Context, request *ReposCreateUsingTemplateReq, params ReposCreateUsingTemplateParams) (res *RepositoryHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-using-template"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{template_owner}/{template_repo}/generate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateUsingTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "template_owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "template_owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateOwner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "template_repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "template_repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateRepo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/generate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateUsingTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateUsingTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateWebhook invokes repos/create-webhook operation.
//
// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`.
// Multiple webhooks can
// share the same `config` as long as those webhooks do not have any `events` that overlap.
//
// POST /repos/{owner}/{repo}/hooks
func (c *Client) ReposCreateWebhook(ctx context.Context, request OptNilReposCreateWebhookReq, params ReposCreateWebhookParams) (ReposCreateWebhookRes, error) {
	res, err := c.sendReposCreateWebhook(ctx, request, params)
	return res, err
}

func (c *Client) sendReposCreateWebhook(ctx context.Context, request OptNilReposCreateWebhookReq, params ReposCreateWebhookParams) (res ReposCreateWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-webhook"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposCreateWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposCreateWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeclineInvitation invokes repos/decline-invitation operation.
//
// Decline a repository invitation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (c *Client) ReposDeclineInvitation(ctx context.Context, params ReposDeclineInvitationParams) (ReposDeclineInvitationRes, error) {
	res, err := c.sendReposDeclineInvitation(ctx, params)
	return res, err
}

func (c *Client) sendReposDeclineInvitation(ctx context.Context, params ReposDeclineInvitationParams) (res ReposDeclineInvitationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/decline-invitation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/repository_invitations/{invitation_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeclineInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/repository_invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeclineInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDelete invokes repos/delete operation.
//
// Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
// If an organization owner has configured the organization to prevent members from deleting
// organization-owned
// repositories, you will get a `403 Forbidden` response.
//
// DELETE /repos/{owner}/{repo}
func (c *Client) ReposDelete(ctx context.Context, params ReposDeleteParams) (ReposDeleteRes, error) {
	res, err := c.sendReposDelete(ctx, params)
	return res, err
}

func (c *Client) sendReposDelete(ctx context.Context, params ReposDeleteParams) (res ReposDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAccessRestrictions invokes repos/delete-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Disables the ability to restrict who can push to this branch.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (c *Client) ReposDeleteAccessRestrictions(ctx context.Context, params ReposDeleteAccessRestrictionsParams) error {
	_, err := c.sendReposDeleteAccessRestrictions(ctx, params)
	return err
}

func (c *Client) sendReposDeleteAccessRestrictions(ctx context.Context, params ReposDeleteAccessRestrictionsParams) (res *ReposDeleteAccessRestrictionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-access-restrictions"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAdminBranchProtection invokes repos/delete-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removing admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (c *Client) ReposDeleteAdminBranchProtection(ctx context.Context, params ReposDeleteAdminBranchProtectionParams) (ReposDeleteAdminBranchProtectionRes, error) {
	res, err := c.sendReposDeleteAdminBranchProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteAdminBranchProtection(ctx context.Context, params ReposDeleteAdminBranchProtectionParams) (res ReposDeleteAdminBranchProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-admin-branch-protection"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/enforce_admins"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteAdminBranchProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAnEnvironment invokes repos/delete-an-environment operation.
//
// You must authenticate using an access token with the repo scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (c *Client) ReposDeleteAnEnvironment(ctx context.Context, params ReposDeleteAnEnvironmentParams) error {
	_, err := c.sendReposDeleteAnEnvironment(ctx, params)
	return err
}

func (c *Client) sendReposDeleteAnEnvironment(ctx context.Context, params ReposDeleteAnEnvironmentParams) (res *ReposDeleteAnEnvironmentNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-an-environment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/environments/{environment_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAnEnvironment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteAnEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAutolink invokes repos/delete-autolink operation.
//
// This deletes a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (c *Client) ReposDeleteAutolink(ctx context.Context, params ReposDeleteAutolinkParams) (ReposDeleteAutolinkRes, error) {
	res, err := c.sendReposDeleteAutolink(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteAutolink(ctx context.Context, params ReposDeleteAutolinkParams) (res ReposDeleteAutolinkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-autolink"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks/{autolink_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAutolink",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/autolinks/"
	{
		// Encode "autolink_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autolink_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AutolinkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteAutolinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteBranchProtection invokes repos/delete-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (c *Client) ReposDeleteBranchProtection(ctx context.Context, params ReposDeleteBranchProtectionParams) (ReposDeleteBranchProtectionRes, error) {
	res, err := c.sendReposDeleteBranchProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteBranchProtection(ctx context.Context, params ReposDeleteBranchProtectionParams) (res ReposDeleteBranchProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-branch-protection"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteBranchProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteBranchProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteCommitComment invokes repos/delete-commit-comment operation.
//
// Delete a commit comment.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (c *Client) ReposDeleteCommitComment(ctx context.Context, params ReposDeleteCommitCommentParams) (ReposDeleteCommitCommentRes, error) {
	res, err := c.sendReposDeleteCommitComment(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteCommitComment(ctx context.Context, params ReposDeleteCommitCommentParams) (res ReposDeleteCommitCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-comment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteCommitSignatureProtection invokes repos/delete-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// disable required signed commits on a branch. You must enable branch protection to require signed
// commits.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (c *Client) ReposDeleteCommitSignatureProtection(ctx context.Context, params ReposDeleteCommitSignatureProtectionParams) (ReposDeleteCommitSignatureProtectionRes, error) {
	res, err := c.sendReposDeleteCommitSignatureProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteCommitSignatureProtection(ctx context.Context, params ReposDeleteCommitSignatureProtectionParams) (res ReposDeleteCommitSignatureProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-signature-protection"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_signatures"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteCommitSignatureProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteDeployKey invokes repos/delete-deploy-key operation.
//
// Deploy keys are immutable. If you need to update a key, remove the key and create a new one
// instead.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (c *Client) ReposDeleteDeployKey(ctx context.Context, params ReposDeleteDeployKeyParams) error {
	_, err := c.sendReposDeleteDeployKey(ctx, params)
	return err
}

func (c *Client) sendReposDeleteDeployKey(ctx context.Context, params ReposDeleteDeployKeyParams) (res *ReposDeleteDeployKeyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deploy-key"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys/{key_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteDeployKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteDeployKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteDeployment invokes repos/delete-deployment operation.
//
// To ensure there can always be an active deployment, you can only delete an _inactive_ deployment.
// Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
// To set a deployment as inactive, you must:
// *   Create a new deployment that is active so that the system has a record of the current state,
// then delete the previously active deployment.
// *   Mark the active deployment as inactive by adding any non-successful deployment status.
// For more information, see "[Create a deployment](https://docs.github.
// com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.
// github.com/rest/reference/repos#create-a-deployment-status).".
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (c *Client) ReposDeleteDeployment(ctx context.Context, params ReposDeleteDeploymentParams) (ReposDeleteDeploymentRes, error) {
	res, err := c.sendReposDeleteDeployment(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteDeployment(ctx context.Context, params ReposDeleteDeploymentParams) (res ReposDeleteDeploymentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deployment"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteDeployment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteDeploymentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteFile invokes repos/delete-file operation.
//
// Deletes a file in a repository.
// You can provide an additional `committer` parameter, which is an object containing information
// about the committer. Or, you can provide an `author` parameter, which is an object containing
// information about the author.
// The `author` section is optional and is filled in with the `committer` information if omitted. If
// the `committer` information is omitted, the authenticated user's information is used.
// You must provide values for both `name` and `email`, whether you choose to use `author` or
// `committer`. Otherwise, you'll receive a `422` status code.
//
// DELETE /repos/{owner}/{repo}/contents/{path}
func (c *Client) ReposDeleteFile(ctx context.Context, request *ReposDeleteFileReq, params ReposDeleteFileParams) (ReposDeleteFileRes, error) {
	res, err := c.sendReposDeleteFile(ctx, request, params)
	return res, err
}

func (c *Client) sendReposDeleteFile(ctx context.Context, request *ReposDeleteFileReq, params ReposDeleteFileParams) (res ReposDeleteFileRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-file"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/contents/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteFile",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/contents/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposDeleteFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteInvitation invokes repos/delete-invitation operation.
//
// Delete a repository invitation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (c *Client) ReposDeleteInvitation(ctx context.Context, params ReposDeleteInvitationParams) error {
	_, err := c.sendReposDeleteInvitation(ctx, params)
	return err
}

func (c *Client) sendReposDeleteInvitation(ctx context.Context, params ReposDeleteInvitationParams) (res *ReposDeleteInvitationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-invitation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/invitations/{invitation_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeletePagesSite invokes repos/delete-pages-site operation.
//
// Delete a GitHub Pages site.
//
// DELETE /repos/{owner}/{repo}/pages
func (c *Client) ReposDeletePagesSite(ctx context.Context, params ReposDeletePagesSiteParams) (ReposDeletePagesSiteRes, error) {
	res, err := c.sendReposDeletePagesSite(ctx, params)
	return res, err
}

func (c *Client) sendReposDeletePagesSite(ctx context.Context, params ReposDeletePagesSiteParams) (res ReposDeletePagesSiteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pages-site"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeletePagesSite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeletePagesSiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeletePullRequestReviewProtection invokes repos/delete-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (c *Client) ReposDeletePullRequestReviewProtection(ctx context.Context, params ReposDeletePullRequestReviewProtectionParams) (ReposDeletePullRequestReviewProtectionRes, error) {
	res, err := c.sendReposDeletePullRequestReviewProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposDeletePullRequestReviewProtection(ctx context.Context, params ReposDeletePullRequestReviewProtectionParams) (res ReposDeletePullRequestReviewProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pull-request-review-protection"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeletePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_pull_request_reviews"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeletePullRequestReviewProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteRelease invokes repos/delete-release operation.
//
// Users with push access to the repository can delete a release.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (c *Client) ReposDeleteRelease(ctx context.Context, params ReposDeleteReleaseParams) error {
	_, err := c.sendReposDeleteRelease(ctx, params)
	return err
}

func (c *Client) sendReposDeleteRelease(ctx context.Context, params ReposDeleteReleaseParams) (res *ReposDeleteReleaseNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteRelease",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteReleaseAsset invokes repos/delete-release-asset operation.
//
// Delete a release asset.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (c *Client) ReposDeleteReleaseAsset(ctx context.Context, params ReposDeleteReleaseAssetParams) error {
	_, err := c.sendReposDeleteReleaseAsset(ctx, params)
	return err
}

func (c *Client) sendReposDeleteReleaseAsset(ctx context.Context, params ReposDeleteReleaseAssetParams) (res *ReposDeleteReleaseAssetNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release-asset"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/assets/{asset_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/assets/"
	{
		// Encode "asset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AssetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteReleaseAssetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteWebhook invokes repos/delete-webhook operation.
//
// Delete a repository webhook.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (c *Client) ReposDeleteWebhook(ctx context.Context, params ReposDeleteWebhookParams) (ReposDeleteWebhookRes, error) {
	res, err := c.sendReposDeleteWebhook(ctx, params)
	return res, err
}

func (c *Client) sendReposDeleteWebhook(ctx context.Context, params ReposDeleteWebhookParams) (res ReposDeleteWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-webhook"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDeleteWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDisableAutomatedSecurityFixes invokes repos/disable-automated-security-fixes operation.
//
// Disables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (c *Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, params ReposDisableAutomatedSecurityFixesParams) error {
	_, err := c.sendReposDisableAutomatedSecurityFixes(ctx, params)
	return err
}

func (c *Client) sendReposDisableAutomatedSecurityFixes(ctx context.Context, params ReposDisableAutomatedSecurityFixesParams) (res *ReposDisableAutomatedSecurityFixesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-automated-security-fixes"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/automated-security-fixes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDisableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/automated-security-fixes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDisableAutomatedSecurityFixesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDisableLfsForRepo invokes repos/disable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// DELETE /repos/{owner}/{repo}/lfs
func (c *Client) ReposDisableLfsForRepo(ctx context.Context, params ReposDisableLfsForRepoParams) error {
	_, err := c.sendReposDisableLfsForRepo(ctx, params)
	return err
}

func (c *Client) sendReposDisableLfsForRepo(ctx context.Context, params ReposDisableLfsForRepoParams) (res *ReposDisableLfsForRepoNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-lfs-for-repo"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/lfs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDisableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/lfs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDisableLfsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDisableVulnerabilityAlerts invokes repos/disable-vulnerability-alerts operation.
//
// Disables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (c *Client) ReposDisableVulnerabilityAlerts(ctx context.Context, params ReposDisableVulnerabilityAlertsParams) error {
	_, err := c.sendReposDisableVulnerabilityAlerts(ctx, params)
	return err
}

func (c *Client) sendReposDisableVulnerabilityAlerts(ctx context.Context, params ReposDisableVulnerabilityAlertsParams) (res *ReposDisableVulnerabilityAlertsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-vulnerability-alerts"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/vulnerability-alerts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDisableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/vulnerability-alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDisableVulnerabilityAlertsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDownloadTarballArchive invokes repos/download-tarball-archive operation.
//
// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
// repository’s default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (c *Client) ReposDownloadTarballArchive(ctx context.Context, params ReposDownloadTarballArchiveParams) (*ReposDownloadTarballArchiveFound, error) {
	res, err := c.sendReposDownloadTarballArchive(ctx, params)
	return res, err
}

func (c *Client) sendReposDownloadTarballArchive(ctx context.Context, params ReposDownloadTarballArchiveParams) (res *ReposDownloadTarballArchiveFound, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-tarball-archive"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/tarball/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDownloadTarballArchive",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tarball/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDownloadTarballArchiveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDownloadZipballArchive invokes repos/download-zipball-archive operation.
//
// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
// repository’s default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (c *Client) ReposDownloadZipballArchive(ctx context.Context, params ReposDownloadZipballArchiveParams) (*ReposDownloadZipballArchiveFound, error) {
	res, err := c.sendReposDownloadZipballArchive(ctx, params)
	return res, err
}

func (c *Client) sendReposDownloadZipballArchive(ctx context.Context, params ReposDownloadZipballArchiveParams) (res *ReposDownloadZipballArchiveFound, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-zipball-archive"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/zipball/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDownloadZipballArchive",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/zipball/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposDownloadZipballArchiveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposEnableAutomatedSecurityFixes invokes repos/enable-automated-security-fixes operation.
//
// Enables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (c *Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, params ReposEnableAutomatedSecurityFixesParams) error {
	_, err := c.sendReposEnableAutomatedSecurityFixes(ctx, params)
	return err
}

func (c *Client) sendReposEnableAutomatedSecurityFixes(ctx context.Context, params ReposEnableAutomatedSecurityFixesParams) (res *ReposEnableAutomatedSecurityFixesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-automated-security-fixes"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/automated-security-fixes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposEnableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/automated-security-fixes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposEnableAutomatedSecurityFixesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposEnableLfsForRepo invokes repos/enable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// PUT /repos/{owner}/{repo}/lfs
func (c *Client) ReposEnableLfsForRepo(ctx context.Context, params ReposEnableLfsForRepoParams) (ReposEnableLfsForRepoRes, error) {
	res, err := c.sendReposEnableLfsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendReposEnableLfsForRepo(ctx context.Context, params ReposEnableLfsForRepoParams) (res ReposEnableLfsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-lfs-for-repo"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/lfs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposEnableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/lfs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposEnableLfsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposEnableVulnerabilityAlerts invokes repos/enable-vulnerability-alerts operation.
//
// Enables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (c *Client) ReposEnableVulnerabilityAlerts(ctx context.Context, params ReposEnableVulnerabilityAlertsParams) error {
	_, err := c.sendReposEnableVulnerabilityAlerts(ctx, params)
	return err
}

func (c *Client) sendReposEnableVulnerabilityAlerts(ctx context.Context, params ReposEnableVulnerabilityAlertsParams) (res *ReposEnableVulnerabilityAlertsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-vulnerability-alerts"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/vulnerability-alerts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposEnableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/vulnerability-alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposEnableVulnerabilityAlertsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGet invokes repos/get operation.
//
// The `parent` and `source` objects are present when the repository is a fork. `parent` is the
// repository this repository was forked from, `source` is the ultimate source for the network.
//
// GET /repos/{owner}/{repo}
func (c *Client) ReposGet(ctx context.Context, params ReposGetParams) (ReposGetRes, error) {
	res, err := c.sendReposGet(ctx, params)
	return res, err
}

func (c *Client) sendReposGet(ctx context.Context, params ReposGetParams) (res ReposGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAccessRestrictions invokes repos/get-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists who has access to this protected branch.
// **Note**: Users, apps, and teams `restrictions` are only available for organization-owned
// repositories.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (c *Client) ReposGetAccessRestrictions(ctx context.Context, params ReposGetAccessRestrictionsParams) (ReposGetAccessRestrictionsRes, error) {
	res, err := c.sendReposGetAccessRestrictions(ctx, params)
	return res, err
}

func (c *Client) sendReposGetAccessRestrictions(ctx context.Context, params ReposGetAccessRestrictionsParams) (res ReposGetAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-access-restrictions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAdminBranchProtection invokes repos/get-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (c *Client) ReposGetAdminBranchProtection(ctx context.Context, params ReposGetAdminBranchProtectionParams) (*ProtectedBranchAdminEnforced, error) {
	res, err := c.sendReposGetAdminBranchProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposGetAdminBranchProtection(ctx context.Context, params ReposGetAdminBranchProtectionParams) (res *ProtectedBranchAdminEnforced, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-admin-branch-protection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/enforce_admins"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetAdminBranchProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAllStatusCheckContexts invokes repos/get-all-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposGetAllStatusCheckContexts(ctx context.Context, params ReposGetAllStatusCheckContextsParams) (ReposGetAllStatusCheckContextsRes, error) {
	res, err := c.sendReposGetAllStatusCheckContexts(ctx, params)
	return res, err
}

func (c *Client) sendReposGetAllStatusCheckContexts(ctx context.Context, params ReposGetAllStatusCheckContextsParams) (res ReposGetAllStatusCheckContextsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-status-check-contexts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAllStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks/contexts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetAllStatusCheckContextsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAllTopics invokes repos/get-all-topics operation.
//
// Get all repository topics.
//
// GET /repos/{owner}/{repo}/topics
func (c *Client) ReposGetAllTopics(ctx context.Context, params ReposGetAllTopicsParams) (ReposGetAllTopicsRes, error) {
	res, err := c.sendReposGetAllTopics(ctx, params)
	return res, err
}

func (c *Client) sendReposGetAllTopics(ctx context.Context, params ReposGetAllTopicsParams) (res ReposGetAllTopicsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-topics"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/topics"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAllTopics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/topics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetAllTopicsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAppsWithAccessToProtectedBranch invokes repos/get-apps-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with
// `write` access to the `contents` permission can be added as authorized actors on a protected
// branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, params ReposGetAppsWithAccessToProtectedBranchParams) (ReposGetAppsWithAccessToProtectedBranchRes, error) {
	res, err := c.sendReposGetAppsWithAccessToProtectedBranch(ctx, params)
	return res, err
}

func (c *Client) sendReposGetAppsWithAccessToProtectedBranch(ctx context.Context, params ReposGetAppsWithAccessToProtectedBranchParams) (res ReposGetAppsWithAccessToProtectedBranchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-apps-with-access-to-protected-branch"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAppsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/apps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetAppsWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAutolink invokes repos/get-autolink operation.
//
// This returns a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (c *Client) ReposGetAutolink(ctx context.Context, params ReposGetAutolinkParams) (ReposGetAutolinkRes, error) {
	res, err := c.sendReposGetAutolink(ctx, params)
	return res, err
}

func (c *Client) sendReposGetAutolink(ctx context.Context, params ReposGetAutolinkParams) (res ReposGetAutolinkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-autolink"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks/{autolink_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAutolink",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/autolinks/"
	{
		// Encode "autolink_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autolink_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AutolinkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetAutolinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetBranch invokes repos/get-branch operation.
//
// Get a branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (c *Client) ReposGetBranch(ctx context.Context, params ReposGetBranchParams) (ReposGetBranchRes, error) {
	res, err := c.sendReposGetBranch(ctx, params)
	return res, err
}

func (c *Client) sendReposGetBranch(ctx context.Context, params ReposGetBranchParams) (res ReposGetBranchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetBranch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetBranchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetBranchProtection invokes repos/get-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (c *Client) ReposGetBranchProtection(ctx context.Context, params ReposGetBranchProtectionParams) (ReposGetBranchProtectionRes, error) {
	res, err := c.sendReposGetBranchProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposGetBranchProtection(ctx context.Context, params ReposGetBranchProtectionParams) (res ReposGetBranchProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch-protection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetBranchProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetBranchProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetClones invokes repos/get-clones operation.
//
// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (c *Client) ReposGetClones(ctx context.Context, params ReposGetClonesParams) (ReposGetClonesRes, error) {
	res, err := c.sendReposGetClones(ctx, params)
	return res, err
}

func (c *Client) sendReposGetClones(ctx context.Context, params ReposGetClonesParams) (res ReposGetClonesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-clones"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/clones"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetClones",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/traffic/clones"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Per.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetClonesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCodeFrequencyStats invokes repos/get-code-frequency-stats operation.
//
// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (c *Client) ReposGetCodeFrequencyStats(ctx context.Context, params ReposGetCodeFrequencyStatsParams) (ReposGetCodeFrequencyStatsRes, error) {
	res, err := c.sendReposGetCodeFrequencyStats(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCodeFrequencyStats(ctx context.Context, params ReposGetCodeFrequencyStatsParams) (res ReposGetCodeFrequencyStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-code-frequency-stats"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/code_frequency"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCodeFrequencyStats",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats/code_frequency"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCodeFrequencyStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCollaboratorPermissionLevel invokes repos/get-collaborator-permission-level operation.
//
// Checks the repository permission of a collaborator. The possible repository permissions are
// `admin`, `write`, `read`, and `none`.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (c *Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, params ReposGetCollaboratorPermissionLevelParams) (ReposGetCollaboratorPermissionLevelRes, error) {
	res, err := c.sendReposGetCollaboratorPermissionLevel(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCollaboratorPermissionLevel(ctx context.Context, params ReposGetCollaboratorPermissionLevelParams) (res ReposGetCollaboratorPermissionLevelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-collaborator-permission-level"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}/permission"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCollaboratorPermissionLevel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/permission"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCollaboratorPermissionLevelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCombinedStatusForRef invokes repos/get-combined-status-for-ref operation.
//
// Users with pull access in a repository can access a combined view of commit statuses for a given
// ref. The ref can be a SHA, a branch name, or a tag name.
// The most recent status for each context is returned, up to 100. This field
// [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there
// are over 100 contexts.
// Additionally, a combined `state` is returned. The `state` is one of:
// *   **failure** if any of the contexts report as `error` or `failure`
// *   **pending** if there are no statuses or a context is `pending`
// *   **success** if the latest status for all contexts is `success`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (c *Client) ReposGetCombinedStatusForRef(ctx context.Context, params ReposGetCombinedStatusForRefParams) (ReposGetCombinedStatusForRefRes, error) {
	res, err := c.sendReposGetCombinedStatusForRef(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCombinedStatusForRef(ctx context.Context, params ReposGetCombinedStatusForRefParams) (res ReposGetCombinedStatusForRefRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-combined-status-for-ref"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCombinedStatusForRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCombinedStatusForRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommit invokes repos/get-commit operation.
//
// Returns the contents of a single commit reference. You must have `read` access for the repository
// to use this endpoint.
// **Note:** If there are more than 300 files in the commit diff, the response will include
// pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains
// the static commit information, and the only changes are to the file listing.
// You can pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and
// `patch` formats. Diffs with binary data will have no `patch` property.
// To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
// type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header.
//
//	You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local
//
// reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits/{ref}
func (c *Client) ReposGetCommit(ctx context.Context, params ReposGetCommitParams) (ReposGetCommitRes, error) {
	res, err := c.sendReposGetCommit(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCommit(ctx context.Context, params ReposGetCommitParams) (res ReposGetCommitRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCommitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommitActivityStats invokes repos/get-commit-activity-stats operation.
//
// Returns the last year of commit activity grouped by week. The `days` array is a group of commits
// per day, starting on `Sunday`.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (c *Client) ReposGetCommitActivityStats(ctx context.Context, params ReposGetCommitActivityStatsParams) (ReposGetCommitActivityStatsRes, error) {
	res, err := c.sendReposGetCommitActivityStats(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCommitActivityStats(ctx context.Context, params ReposGetCommitActivityStatsParams) (res ReposGetCommitActivityStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-activity-stats"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/commit_activity"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommitActivityStats",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats/commit_activity"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCommitActivityStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommitComment invokes repos/get-commit-comment operation.
//
// Get a commit comment.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (c *Client) ReposGetCommitComment(ctx context.Context, params ReposGetCommitCommentParams) (ReposGetCommitCommentRes, error) {
	res, err := c.sendReposGetCommitComment(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCommitComment(ctx context.Context, params ReposGetCommitCommentParams) (res ReposGetCommitCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-comment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommitSignatureProtection invokes repos/get-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// check whether a branch requires signed commits. An enabled status of `true` indicates you must
// sign commits on this branch. For more information, see [Signing commits with GPG](https://help.
// github.com/articles/signing-commits-with-gpg) in GitHub Help.
// **Note**: You must enable branch protection to require signed commits.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (c *Client) ReposGetCommitSignatureProtection(ctx context.Context, params ReposGetCommitSignatureProtectionParams) (ReposGetCommitSignatureProtectionRes, error) {
	res, err := c.sendReposGetCommitSignatureProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCommitSignatureProtection(ctx context.Context, params ReposGetCommitSignatureProtectionParams) (res ReposGetCommitSignatureProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-signature-protection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_signatures"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCommitSignatureProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommunityProfileMetrics invokes repos/get-community-profile-metrics operation.
//
// This endpoint will return all community profile metrics, including an
// overall health score, repository description, the presence of documentation, detected
// code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
// README, and CONTRIBUTING files.
// The `health_percentage` score is defined as a percentage of how many of
// these four documents are present: README, CONTRIBUTING, LICENSE, and
// CODE_OF_CONDUCT. For example, if all four documents are present, then
// the `health_percentage` is `100`. If only one is present, then the
// `health_percentage` is `25`.
// `content_reports_enabled` is only returned for organization-owned repositories.
//
// GET /repos/{owner}/{repo}/community/profile
func (c *Client) ReposGetCommunityProfileMetrics(ctx context.Context, params ReposGetCommunityProfileMetricsParams) (*CommunityProfile, error) {
	res, err := c.sendReposGetCommunityProfileMetrics(ctx, params)
	return res, err
}

func (c *Client) sendReposGetCommunityProfileMetrics(ctx context.Context, params ReposGetCommunityProfileMetricsParams) (res *CommunityProfile, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-community-profile-metrics"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/community/profile"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommunityProfileMetrics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/community/profile"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetCommunityProfileMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetContributorsStats invokes repos/get-contributors-stats operation.
//
// Returns the `total` number of commits authored by the contributor. In addition, the response
// includes a Weekly Hash (`weeks` array) with the following information:
// *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
// *   `a` - Number of additions
// *   `d` - Number of deletions
// *   `c` - Number of commits.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (c *Client) ReposGetContributorsStats(ctx context.Context, params ReposGetContributorsStatsParams) (ReposGetContributorsStatsRes, error) {
	res, err := c.sendReposGetContributorsStats(ctx, params)
	return res, err
}

func (c *Client) sendReposGetContributorsStats(ctx context.Context, params ReposGetContributorsStatsParams) (res ReposGetContributorsStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-contributors-stats"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/contributors"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetContributorsStats",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats/contributors"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetContributorsStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetDeployKey invokes repos/get-deploy-key operation.
//
// Get a deploy key.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (c *Client) ReposGetDeployKey(ctx context.Context, params ReposGetDeployKeyParams) (ReposGetDeployKeyRes, error) {
	res, err := c.sendReposGetDeployKey(ctx, params)
	return res, err
}

func (c *Client) sendReposGetDeployKey(ctx context.Context, params ReposGetDeployKeyParams) (res ReposGetDeployKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deploy-key"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys/{key_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetDeployKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetDeployKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetDeployment invokes repos/get-deployment operation.
//
// Get a deployment.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}
func (c *Client) ReposGetDeployment(ctx context.Context, params ReposGetDeploymentParams) (ReposGetDeploymentRes, error) {
	res, err := c.sendReposGetDeployment(ctx, params)
	return res, err
}

func (c *Client) sendReposGetDeployment(ctx context.Context, params ReposGetDeploymentParams) (res ReposGetDeploymentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetDeployment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetDeploymentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetDeploymentStatus invokes repos/get-deployment-status operation.
//
// Users with pull access can view a deployment status for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (c *Client) ReposGetDeploymentStatus(ctx context.Context, params ReposGetDeploymentStatusParams) (ReposGetDeploymentStatusRes, error) {
	res, err := c.sendReposGetDeploymentStatus(ctx, params)
	return res, err
}

func (c *Client) sendReposGetDeploymentStatus(ctx context.Context, params ReposGetDeploymentStatusParams) (res ReposGetDeploymentStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment-status"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/statuses/"
	{
		// Encode "status_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "status_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.StatusID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetDeploymentStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetLatestPagesBuild invokes repos/get-latest-pages-build operation.
//
// Get latest Pages build.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (c *Client) ReposGetLatestPagesBuild(ctx context.Context, params ReposGetLatestPagesBuildParams) (*PageBuild, error) {
	res, err := c.sendReposGetLatestPagesBuild(ctx, params)
	return res, err
}

func (c *Client) sendReposGetLatestPagesBuild(ctx context.Context, params ReposGetLatestPagesBuildParams) (res *PageBuild, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-pages-build"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds/latest"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetLatestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages/builds/latest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetLatestPagesBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetLatestRelease invokes repos/get-latest-release operation.
//
// View the latest published full release for the repository.
// The latest release is the most recent non-prerelease, non-draft release, sorted by the
// `created_at` attribute. The `created_at` attribute is the date of the commit used for the release,
// and not the date when the release was drafted or published.
//
// GET /repos/{owner}/{repo}/releases/latest
func (c *Client) ReposGetLatestRelease(ctx context.Context, params ReposGetLatestReleaseParams) (*Release, error) {
	res, err := c.sendReposGetLatestRelease(ctx, params)
	return res, err
}

func (c *Client) sendReposGetLatestRelease(ctx context.Context, params ReposGetLatestReleaseParams) (res *Release, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-release"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/latest"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetLatestRelease",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/latest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetLatestReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPages invokes repos/get-pages operation.
//
// Get a GitHub Pages site.
//
// GET /repos/{owner}/{repo}/pages
func (c *Client) ReposGetPages(ctx context.Context, params ReposGetPagesParams) (ReposGetPagesRes, error) {
	res, err := c.sendReposGetPages(ctx, params)
	return res, err
}

func (c *Client) sendReposGetPages(ctx context.Context, params ReposGetPagesParams) (res ReposGetPagesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPages",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetPagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPagesBuild invokes repos/get-pages-build operation.
//
// Get GitHub Pages build.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (c *Client) ReposGetPagesBuild(ctx context.Context, params ReposGetPagesBuildParams) (*PageBuild, error) {
	res, err := c.sendReposGetPagesBuild(ctx, params)
	return res, err
}

func (c *Client) sendReposGetPagesBuild(ctx context.Context, params ReposGetPagesBuildParams) (res *PageBuild, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-build"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds/{build_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPagesBuild",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages/builds/"
	{
		// Encode "build_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "build_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.BuildID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetPagesBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPagesHealthCheck invokes repos/get-pages-health-check operation.
//
// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
// GitHub Pages.
// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous
// background task to get the results for the domain. After the background task completes, subsequent
// requests to this endpoint return a `200 OK` status with the health check results in the response.
// Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and
// `administration:write` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/pages/health
func (c *Client) ReposGetPagesHealthCheck(ctx context.Context, params ReposGetPagesHealthCheckParams) (ReposGetPagesHealthCheckRes, error) {
	res, err := c.sendReposGetPagesHealthCheck(ctx, params)
	return res, err
}

func (c *Client) sendReposGetPagesHealthCheck(ctx context.Context, params ReposGetPagesHealthCheckParams) (res ReposGetPagesHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-health-check"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/health"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPagesHealthCheck",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetPagesHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetParticipationStats invokes repos/get-participation-stats operation.
//
// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
// everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit
// counts for non-owners, you can subtract `owner` from `all`.
// The array order is oldest week (index 0) to most recent week.
//
// GET /repos/{owner}/{repo}/stats/participation
func (c *Client) ReposGetParticipationStats(ctx context.Context, params ReposGetParticipationStatsParams) (ReposGetParticipationStatsRes, error) {
	res, err := c.sendReposGetParticipationStats(ctx, params)
	return res, err
}

func (c *Client) sendReposGetParticipationStats(ctx context.Context, params ReposGetParticipationStatsParams) (res ReposGetParticipationStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-participation-stats"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/participation"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetParticipationStats",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats/participation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetParticipationStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPullRequestReviewProtection invokes repos/get-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (c *Client) ReposGetPullRequestReviewProtection(ctx context.Context, params ReposGetPullRequestReviewProtectionParams) (*ProtectedBranchPullRequestReview, error) {
	res, err := c.sendReposGetPullRequestReviewProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposGetPullRequestReviewProtection(ctx context.Context, params ReposGetPullRequestReviewProtectionParams) (res *ProtectedBranchPullRequestReview, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pull-request-review-protection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_pull_request_reviews"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetPullRequestReviewProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPunchCardStats invokes repos/get-punch-card-stats operation.
//
// Each array contains the day number, hour number, and number of commits:
// *   `0-6`: Sunday - Saturday
// *   `0-23`: Hour of day
// *   Number of commits
// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on
// Tuesdays. All times are based on the time zone of individual commits.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (c *Client) ReposGetPunchCardStats(ctx context.Context, params ReposGetPunchCardStatsParams) (ReposGetPunchCardStatsRes, error) {
	res, err := c.sendReposGetPunchCardStats(ctx, params)
	return res, err
}

func (c *Client) sendReposGetPunchCardStats(ctx context.Context, params ReposGetPunchCardStatsParams) (res ReposGetPunchCardStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-punch-card-stats"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/punch_card"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPunchCardStats",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats/punch_card"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetPunchCardStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReadme invokes repos/get-readme operation.
//
// Gets the preferred README for a repository.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme
func (c *Client) ReposGetReadme(ctx context.Context, params ReposGetReadmeParams) (ReposGetReadmeRes, error) {
	res, err := c.sendReposGetReadme(ctx, params)
	return res, err
}

func (c *Client) sendReposGetReadme(ctx context.Context, params ReposGetReadmeParams) (res ReposGetReadmeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/readme"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReadme",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/readme"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "ref" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ref.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetReadmeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReadmeInDirectory invokes repos/get-readme-in-directory operation.
//
// Gets the README from a repository directory.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme/{dir}
func (c *Client) ReposGetReadmeInDirectory(ctx context.Context, params ReposGetReadmeInDirectoryParams) (ReposGetReadmeInDirectoryRes, error) {
	res, err := c.sendReposGetReadmeInDirectory(ctx, params)
	return res, err
}

func (c *Client) sendReposGetReadmeInDirectory(ctx context.Context, params ReposGetReadmeInDirectoryParams) (res ReposGetReadmeInDirectoryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme-in-directory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/readme/{dir}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReadmeInDirectory",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/readme/"
	{
		// Encode "dir" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dir",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Dir))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "ref" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ref.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetReadmeInDirectoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetRelease invokes repos/get-release operation.
//
// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release
// assets. This key is a [hypermedia resource](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia).
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (c *Client) ReposGetRelease(ctx context.Context, params ReposGetReleaseParams) (ReposGetReleaseRes, error) {
	res, err := c.sendReposGetRelease(ctx, params)
	return res, err
}

func (c *Client) sendReposGetRelease(ctx context.Context, params ReposGetReleaseParams) (res ReposGetReleaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetRelease",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReleaseAsset invokes repos/get-release-asset operation.
//
// To download the asset's binary content, set the `Accept` header of the request to
// [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
// either redirect the client to the location, or stream it directly if possible. API clients should
// handle both a `200` or `302` response.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (c *Client) ReposGetReleaseAsset(ctx context.Context, params ReposGetReleaseAssetParams) (ReposGetReleaseAssetRes, error) {
	res, err := c.sendReposGetReleaseAsset(ctx, params)
	return res, err
}

func (c *Client) sendReposGetReleaseAsset(ctx context.Context, params ReposGetReleaseAssetParams) (res ReposGetReleaseAssetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-asset"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/assets/{asset_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/assets/"
	{
		// Encode "asset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AssetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetReleaseAssetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReleaseByTag invokes repos/get-release-by-tag operation.
//
// Get a published release with the specified tag.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (c *Client) ReposGetReleaseByTag(ctx context.Context, params ReposGetReleaseByTagParams) (ReposGetReleaseByTagRes, error) {
	res, err := c.sendReposGetReleaseByTag(ctx, params)
	return res, err
}

func (c *Client) sendReposGetReleaseByTag(ctx context.Context, params ReposGetReleaseByTagParams) (res ReposGetReleaseByTagRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-by-tag"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/tags/{tag}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReleaseByTag",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/tags/"
	{
		// Encode "tag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Tag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetReleaseByTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetStatusChecksProtection invokes repos/get-status-checks-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (c *Client) ReposGetStatusChecksProtection(ctx context.Context, params ReposGetStatusChecksProtectionParams) (ReposGetStatusChecksProtectionRes, error) {
	res, err := c.sendReposGetStatusChecksProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposGetStatusChecksProtection(ctx context.Context, params ReposGetStatusChecksProtectionParams) (res ReposGetStatusChecksProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-status-checks-protection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetStatusChecksProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetStatusChecksProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetTeamsWithAccessToProtectedBranch invokes repos/get-teams-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the teams who have push access to this branch. The list includes child teams.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, params ReposGetTeamsWithAccessToProtectedBranchParams) (ReposGetTeamsWithAccessToProtectedBranchRes, error) {
	res, err := c.sendReposGetTeamsWithAccessToProtectedBranch(ctx, params)
	return res, err
}

func (c *Client) sendReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, params ReposGetTeamsWithAccessToProtectedBranchParams) (res ReposGetTeamsWithAccessToProtectedBranchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-teams-with-access-to-protected-branch"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetTeamsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetTeamsWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetTopPaths invokes repos/get-top-paths operation.
//
// Get the top 10 popular contents over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (c *Client) ReposGetTopPaths(ctx context.Context, params ReposGetTopPathsParams) (ReposGetTopPathsRes, error) {
	res, err := c.sendReposGetTopPaths(ctx, params)
	return res, err
}

func (c *Client) sendReposGetTopPaths(ctx context.Context, params ReposGetTopPathsParams) (res ReposGetTopPathsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-paths"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/popular/paths"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetTopPaths",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/traffic/popular/paths"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetTopPathsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetTopReferrers invokes repos/get-top-referrers operation.
//
// Get the top 10 referrers over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (c *Client) ReposGetTopReferrers(ctx context.Context, params ReposGetTopReferrersParams) (ReposGetTopReferrersRes, error) {
	res, err := c.sendReposGetTopReferrers(ctx, params)
	return res, err
}

func (c *Client) sendReposGetTopReferrers(ctx context.Context, params ReposGetTopReferrersParams) (res ReposGetTopReferrersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-referrers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/popular/referrers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetTopReferrers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/traffic/popular/referrers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetTopReferrersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetUsersWithAccessToProtectedBranch invokes repos/get-users-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the people who have push access to this branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, params ReposGetUsersWithAccessToProtectedBranchParams) (ReposGetUsersWithAccessToProtectedBranchRes, error) {
	res, err := c.sendReposGetUsersWithAccessToProtectedBranch(ctx, params)
	return res, err
}

func (c *Client) sendReposGetUsersWithAccessToProtectedBranch(ctx context.Context, params ReposGetUsersWithAccessToProtectedBranchParams) (res ReposGetUsersWithAccessToProtectedBranchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-users-with-access-to-protected-branch"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetUsersWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetUsersWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetViews invokes repos/get-views operation.
//
// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/views
func (c *Client) ReposGetViews(ctx context.Context, params ReposGetViewsParams) (ReposGetViewsRes, error) {
	res, err := c.sendReposGetViews(ctx, params)
	return res, err
}

func (c *Client) sendReposGetViews(ctx context.Context, params ReposGetViewsParams) (res ReposGetViewsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-views"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/views"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetViews",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/traffic/views"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Per.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetViewsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetWebhook invokes repos/get-webhook operation.
//
// Returns a webhook configured in a repository. To get only the webhook `config` properties, see
// "[Get a webhook configuration for a
// repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (c *Client) ReposGetWebhook(ctx context.Context, params ReposGetWebhookParams) (ReposGetWebhookRes, error) {
	res, err := c.sendReposGetWebhook(ctx, params)
	return res, err
}

func (c *Client) sendReposGetWebhook(ctx context.Context, params ReposGetWebhookParams) (res ReposGetWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetWebhookConfigForRepo invokes repos/get-webhook-config-for-repo operation.
//
// Returns the webhook configuration for a repository. To get more information about the webhook,
// including the `active` state and `events`, use "[Get a repository
// webhook](/rest/reference/orgs#get-a-repository-webhook)."
// Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:read` permission.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (c *Client) ReposGetWebhookConfigForRepo(ctx context.Context, params ReposGetWebhookConfigForRepoParams) (*WebhookConfig, error) {
	res, err := c.sendReposGetWebhookConfigForRepo(ctx, params)
	return res, err
}

func (c *Client) sendReposGetWebhookConfigForRepo(ctx context.Context, params ReposGetWebhookConfigForRepoParams) (res *WebhookConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-config-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetWebhookConfigForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetWebhookDelivery invokes repos/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
func (c *Client) ReposGetWebhookDelivery(ctx context.Context, params ReposGetWebhookDeliveryParams) (ReposGetWebhookDeliveryRes, error) {
	res, err := c.sendReposGetWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendReposGetWebhookDelivery(ctx context.Context, params ReposGetWebhookDeliveryParams) (res ReposGetWebhookDeliveryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-delivery"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposGetWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListAutolinks invokes repos/list-autolinks operation.
//
// This returns a list of autolinks configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks
func (c *Client) ReposListAutolinks(ctx context.Context, params ReposListAutolinksParams) ([]Autolink, error) {
	res, err := c.sendReposListAutolinks(ctx, params)
	return res, err
}

func (c *Client) sendReposListAutolinks(ctx context.Context, params ReposListAutolinksParams) (res []Autolink, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-autolinks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListAutolinks",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/autolinks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListAutolinksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListBranches invokes repos/list-branches operation.
//
// List branches.
//
// GET /repos/{owner}/{repo}/branches
func (c *Client) ReposListBranches(ctx context.Context, params ReposListBranchesParams) (ReposListBranchesRes, error) {
	res, err := c.sendReposListBranches(ctx, params)
	return res, err
}

func (c *Client) sendReposListBranches(ctx context.Context, params ReposListBranchesParams) (res ReposListBranchesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListBranches",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "protected" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "protected",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Protected.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListBranchesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListBranchesForHeadCommit invokes repos/list-branches-for-head-commit operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
func (c *Client) ReposListBranchesForHeadCommit(ctx context.Context, params ReposListBranchesForHeadCommitParams) (ReposListBranchesForHeadCommitRes, error) {
	res, err := c.sendReposListBranchesForHeadCommit(ctx, params)
	return res, err
}

func (c *Client) sendReposListBranchesForHeadCommit(ctx context.Context, params ReposListBranchesForHeadCommitParams) (res ReposListBranchesForHeadCommitRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches-for-head-commit"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListBranchesForHeadCommit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/branches-where-head"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListBranchesForHeadCommitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCollaborators invokes repos/list-collaborators operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators
func (c *Client) ReposListCollaborators(ctx context.Context, params ReposListCollaboratorsParams) (ReposListCollaboratorsRes, error) {
	res, err := c.sendReposListCollaborators(ctx, params)
	return res, err
}

func (c *Client) sendReposListCollaborators(ctx context.Context, params ReposListCollaboratorsParams) (res ReposListCollaboratorsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-collaborators"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCollaborators",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/collaborators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "affiliation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Affiliation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListCollaboratorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommentsForCommit invokes repos/list-comments-for-commit operation.
//
// Use the `:commit_sha` to specify the commit that will have its comments listed.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (c *Client) ReposListCommentsForCommit(ctx context.Context, params ReposListCommentsForCommitParams) (*ReposListCommentsForCommitOKHeaders, error) {
	res, err := c.sendReposListCommentsForCommit(ctx, params)
	return res, err
}

func (c *Client) sendReposListCommentsForCommit(ctx context.Context, params ReposListCommentsForCommitParams) (res *ReposListCommentsForCommitOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-comments-for-commit"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommentsForCommit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListCommentsForCommitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommitCommentsForRepo invokes repos/list-commit-comments-for-repo operation.
//
// Commit Comments use [these custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types). You can read more about the use of media types in
// the API [here](https://docs.github.com/rest/overview/media-types/).
// Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/comments
func (c *Client) ReposListCommitCommentsForRepo(ctx context.Context, params ReposListCommitCommentsForRepoParams) (*ReposListCommitCommentsForRepoOKHeaders, error) {
	res, err := c.sendReposListCommitCommentsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendReposListCommitCommentsForRepo(ctx context.Context, params ReposListCommitCommentsForRepoParams) (res *ReposListCommitCommentsForRepoOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-comments-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommitCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListCommitCommentsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommitStatusesForRef invokes repos/list-commit-statuses-for-ref operation.
//
// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a
// SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first
// status in the list will be the latest one.
// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (c *Client) ReposListCommitStatusesForRef(ctx context.Context, params ReposListCommitStatusesForRefParams) (ReposListCommitStatusesForRefRes, error) {
	res, err := c.sendReposListCommitStatusesForRef(ctx, params)
	return res, err
}

func (c *Client) sendReposListCommitStatusesForRef(ctx context.Context, params ReposListCommitStatusesForRefParams) (res ReposListCommitStatusesForRefRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-statuses-for-ref"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/statuses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommitStatusesForRef",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/statuses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListCommitStatusesForRefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommits invokes repos/list-commits operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits
func (c *Client) ReposListCommits(ctx context.Context, params ReposListCommitsParams) (ReposListCommitsRes, error) {
	res, err := c.sendReposListCommits(ctx, params)
	return res, err
}

func (c *Client) sendReposListCommits(ctx context.Context, params ReposListCommitsParams) (res ReposListCommitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sha" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sha",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sha.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Path.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "author" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "author",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Author.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListCommitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListContributors invokes repos/list-contributors operation.
//
// Lists contributors to the specified repository and sorts them by the number of commits per
// contributor in descending order. This endpoint may return information that is a few hours old
// because the GitHub REST API v3 caches contributor data to improve performance.
// GitHub identifies contributors by author email address. This endpoint groups contribution counts
// by GitHub user, which includes all associated email addresses. To improve performance, only the
// first 500 author email addresses in the repository link to GitHub users. The rest will appear as
// anonymous contributors without associated GitHub user information.
//
// GET /repos/{owner}/{repo}/contributors
func (c *Client) ReposListContributors(ctx context.Context, params ReposListContributorsParams) (ReposListContributorsRes, error) {
	res, err := c.sendReposListContributors(ctx, params)
	return res, err
}

func (c *Client) sendReposListContributors(ctx context.Context, params ReposListContributorsParams) (res ReposListContributorsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-contributors"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/contributors"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListContributors",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/contributors"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "anon" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "anon",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Anon.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListContributorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListDeployKeys invokes repos/list-deploy-keys operation.
//
// List deploy keys.
//
// GET /repos/{owner}/{repo}/keys
func (c *Client) ReposListDeployKeys(ctx context.Context, params ReposListDeployKeysParams) (*ReposListDeployKeysOKHeaders, error) {
	res, err := c.sendReposListDeployKeys(ctx, params)
	return res, err
}

func (c *Client) sendReposListDeployKeys(ctx context.Context, params ReposListDeployKeysParams) (res *ReposListDeployKeysOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deploy-keys"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListDeployKeys",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListDeployKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListDeploymentStatuses invokes repos/list-deployment-statuses operation.
//
// Users with pull access can view deployment statuses for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (c *Client) ReposListDeploymentStatuses(ctx context.Context, params ReposListDeploymentStatusesParams) (ReposListDeploymentStatusesRes, error) {
	res, err := c.sendReposListDeploymentStatuses(ctx, params)
	return res, err
}

func (c *Client) sendReposListDeploymentStatuses(ctx context.Context, params ReposListDeploymentStatusesParams) (res ReposListDeploymentStatusesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployment-statuses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListDeploymentStatuses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/statuses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListDeploymentStatusesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListDeployments invokes repos/list-deployments operation.
//
// Simple filtering of deployments is available via query parameters:.
//
// GET /repos/{owner}/{repo}/deployments
func (c *Client) ReposListDeployments(ctx context.Context, params ReposListDeploymentsParams) (*ReposListDeploymentsOKHeaders, error) {
	res, err := c.sendReposListDeployments(ctx, params)
	return res, err
}

func (c *Client) sendReposListDeployments(ctx context.Context, params ReposListDeploymentsParams) (res *ReposListDeploymentsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployments"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListDeployments",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/deployments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sha" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sha",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sha.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ref" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ref.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "task" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "task",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Task.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Environment.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListDeploymentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForAuthenticatedUser invokes repos/list-for-authenticated-user operation.
//
// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
//
// GET /user/repos
func (c *Client) ReposListForAuthenticatedUser(ctx context.Context, params ReposListForAuthenticatedUserParams) (ReposListForAuthenticatedUserRes, error) {
	res, err := c.sendReposListForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendReposListForAuthenticatedUser(ctx context.Context, params ReposListForAuthenticatedUserParams) (res ReposListForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/repos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "visibility" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "affiliation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Affiliation.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "before" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForOrg invokes repos/list-for-org operation.
//
// Lists repositories for the specified organization.
//
// GET /orgs/{org}/repos
func (c *Client) ReposListForOrg(ctx context.Context, params ReposListForOrgParams) (*ReposListForOrgOKHeaders, error) {
	res, err := c.sendReposListForOrg(ctx, params)
	return res, err
}

func (c *Client) sendReposListForOrg(ctx context.Context, params ReposListForOrgParams) (res *ReposListForOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/repos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForUser invokes repos/list-for-user operation.
//
// Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list
// internal repositories for the specified user.
//
// GET /users/{username}/repos
func (c *Client) ReposListForUser(ctx context.Context, params ReposListForUserParams) (*ReposListForUserOKHeaders, error) {
	res, err := c.sendReposListForUser(ctx, params)
	return res, err
}

func (c *Client) sendReposListForUser(ctx context.Context, params ReposListForUserParams) (res *ReposListForUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/repos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForks invokes repos/list-forks operation.
//
// List forks.
//
// GET /repos/{owner}/{repo}/forks
func (c *Client) ReposListForks(ctx context.Context, params ReposListForksParams) (ReposListForksRes, error) {
	res, err := c.sendReposListForks(ctx, params)
	return res, err
}

func (c *Client) sendReposListForks(ctx context.Context, params ReposListForksParams) (res ReposListForksRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-forks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/forks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForks",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/forks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListForksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListInvitations invokes repos/list-invitations operation.
//
// When authenticating as a user with admin rights to a repository, this endpoint will list all
// currently open repository invitations.
//
// GET /repos/{owner}/{repo}/invitations
func (c *Client) ReposListInvitations(ctx context.Context, params ReposListInvitationsParams) (*ReposListInvitationsOKHeaders, error) {
	res, err := c.sendReposListInvitations(ctx, params)
	return res, err
}

func (c *Client) sendReposListInvitations(ctx context.Context, params ReposListInvitationsParams) (res *ReposListInvitationsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListInvitations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListInvitationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListInvitationsForAuthenticatedUser invokes repos/list-invitations-for-authenticated-user operation.
//
// When authenticating as a user, this endpoint will list all currently open repository invitations
// for that user.
//
// GET /user/repository_invitations
func (c *Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, params ReposListInvitationsForAuthenticatedUserParams) (ReposListInvitationsForAuthenticatedUserRes, error) {
	res, err := c.sendReposListInvitationsForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendReposListInvitationsForAuthenticatedUser(ctx context.Context, params ReposListInvitationsForAuthenticatedUserParams) (res ReposListInvitationsForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/repository_invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListInvitationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/repository_invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListInvitationsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListLanguages invokes repos/list-languages operation.
//
// Lists languages for the specified repository. The value shown for each language is the number of
// bytes of code written in that language.
//
// GET /repos/{owner}/{repo}/languages
func (c *Client) ReposListLanguages(ctx context.Context, params ReposListLanguagesParams) (Language, error) {
	res, err := c.sendReposListLanguages(ctx, params)
	return res, err
}

func (c *Client) sendReposListLanguages(ctx context.Context, params ReposListLanguagesParams) (res Language, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-languages"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/languages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListLanguages",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/languages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListLanguagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListPagesBuilds invokes repos/list-pages-builds operation.
//
// List GitHub Pages builds.
//
// GET /repos/{owner}/{repo}/pages/builds
func (c *Client) ReposListPagesBuilds(ctx context.Context, params ReposListPagesBuildsParams) (*ReposListPagesBuildsOKHeaders, error) {
	res, err := c.sendReposListPagesBuilds(ctx, params)
	return res, err
}

func (c *Client) sendReposListPagesBuilds(ctx context.Context, params ReposListPagesBuildsParams) (res *ReposListPagesBuildsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pages-builds"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListPagesBuilds",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages/builds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListPagesBuildsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListPublic invokes repos/list-public operation.
//
// Lists all public repositories in the order that they were created.
// Note:
// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users
// on the enterprise.
// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page
// of repositories.
//
// GET /repositories
func (c *Client) ReposListPublic(ctx context.Context, params ReposListPublicParams) (ReposListPublicRes, error) {
	res, err := c.sendReposListPublic(ctx, params)
	return res, err
}

func (c *Client) sendReposListPublic(ctx context.Context, params ReposListPublicParams) (res ReposListPublicRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-public"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListPublic",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListPublicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListPullRequestsAssociatedWithCommit invokes repos/list-pull-requests-associated-with-commit operation.
//
// Lists the merged pull request that introduced the commit to the repository. If the commit is not
// present in the default branch, additionally returns open pull requests associated with the commit.
// The results may include open and closed pull requests. Additional preview headers may be required
// to see certain details for associated pull requests, such as whether a pull request is in a draft
// state. For more information about previews that might affect this endpoint, see the [List pull
// requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (c *Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, params ReposListPullRequestsAssociatedWithCommitParams) (*ReposListPullRequestsAssociatedWithCommitOKHeaders, error) {
	res, err := c.sendReposListPullRequestsAssociatedWithCommit(ctx, params)
	return res, err
}

func (c *Client) sendReposListPullRequestsAssociatedWithCommit(ctx context.Context, params ReposListPullRequestsAssociatedWithCommitParams) (res *ReposListPullRequestsAssociatedWithCommitOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pull-requests-associated-with-commit"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/pulls"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListPullRequestsAssociatedWithCommit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/pulls"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListPullRequestsAssociatedWithCommitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListReleaseAssets invokes repos/list-release-assets operation.
//
// List release assets.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (c *Client) ReposListReleaseAssets(ctx context.Context, params ReposListReleaseAssetsParams) (*ReposListReleaseAssetsOKHeaders, error) {
	res, err := c.sendReposListReleaseAssets(ctx, params)
	return res, err
}

func (c *Client) sendReposListReleaseAssets(ctx context.Context, params ReposListReleaseAssetsParams) (res *ReposListReleaseAssetsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-release-assets"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}/assets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListReleaseAssets",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/assets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListReleaseAssetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListReleases invokes repos/list-releases operation.
//
// This returns a list of releases, which does not include regular Git tags that have not been
// associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.
// github.com/rest/reference/repos#list-repository-tags).
// Information about published releases are available to everyone. Only users with push access will
// receive listings for draft releases.
//
// GET /repos/{owner}/{repo}/releases
func (c *Client) ReposListReleases(ctx context.Context, params ReposListReleasesParams) (ReposListReleasesRes, error) {
	res, err := c.sendReposListReleases(ctx, params)
	return res, err
}

func (c *Client) sendReposListReleases(ctx context.Context, params ReposListReleasesParams) (res ReposListReleasesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-releases"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListReleases",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListReleasesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListTags invokes repos/list-tags operation.
//
// List repository tags.
//
// GET /repos/{owner}/{repo}/tags
func (c *Client) ReposListTags(ctx context.Context, params ReposListTagsParams) (*ReposListTagsOKHeaders, error) {
	res, err := c.sendReposListTags(ctx, params)
	return res, err
}

func (c *Client) sendReposListTags(ctx context.Context, params ReposListTagsParams) (res *ReposListTagsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-tags"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/tags"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListTags",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListTeams invokes repos/list-teams operation.
//
// List repository teams.
//
// GET /repos/{owner}/{repo}/teams
func (c *Client) ReposListTeams(ctx context.Context, params ReposListTeamsParams) (*ReposListTeamsOKHeaders, error) {
	res, err := c.sendReposListTeams(ctx, params)
	return res, err
}

func (c *Client) sendReposListTeams(ctx context.Context, params ReposListTeamsParams) (res *ReposListTeamsOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-teams"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListTeams",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListTeamsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListWebhookDeliveries invokes repos/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
func (c *Client) ReposListWebhookDeliveries(ctx context.Context, params ReposListWebhookDeliveriesParams) (ReposListWebhookDeliveriesRes, error) {
	res, err := c.sendReposListWebhookDeliveries(ctx, params)
	return res, err
}

func (c *Client) sendReposListWebhookDeliveries(ctx context.Context, params ReposListWebhookDeliveriesParams) (res ReposListWebhookDeliveriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhook-deliveries"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/deliveries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListWebhookDeliveriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListWebhooks invokes repos/list-webhooks operation.
//
// List repository webhooks.
//
// GET /repos/{owner}/{repo}/hooks
func (c *Client) ReposListWebhooks(ctx context.Context, params ReposListWebhooksParams) (ReposListWebhooksRes, error) {
	res, err := c.sendReposListWebhooks(ctx, params)
	return res, err
}

func (c *Client) sendReposListWebhooks(ctx context.Context, params ReposListWebhooksParams) (res ReposListWebhooksRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhooks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListWebhooks",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposListWebhooksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposMerge invokes repos/merge operation.
//
// Merge a branch.
//
// POST /repos/{owner}/{repo}/merges
func (c *Client) ReposMerge(ctx context.Context, request *ReposMergeReq, params ReposMergeParams) (ReposMergeRes, error) {
	res, err := c.sendReposMerge(ctx, request, params)
	return res, err
}

func (c *Client) sendReposMerge(ctx context.Context, request *ReposMergeReq, params ReposMergeParams) (res ReposMergeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/merges"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposMerge",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/merges"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposMergeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposMergeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposMergeUpstream invokes repos/merge-upstream operation.
//
// **Note:** This endpoint is currently in beta and subject to change.
// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (c *Client) ReposMergeUpstream(ctx context.Context, request *ReposMergeUpstreamReq, params ReposMergeUpstreamParams) (ReposMergeUpstreamRes, error) {
	res, err := c.sendReposMergeUpstream(ctx, request, params)
	return res, err
}

func (c *Client) sendReposMergeUpstream(ctx context.Context, request *ReposMergeUpstreamReq, params ReposMergeUpstreamParams) (res ReposMergeUpstreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge-upstream"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/merge-upstream"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposMergeUpstream",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/merge-upstream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposMergeUpstreamRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposMergeUpstreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposPingWebhook invokes repos/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (c *Client) ReposPingWebhook(ctx context.Context, params ReposPingWebhookParams) (ReposPingWebhookRes, error) {
	res, err := c.sendReposPingWebhook(ctx, params)
	return res, err
}

func (c *Client) sendReposPingWebhook(ctx context.Context, params ReposPingWebhookParams) (res ReposPingWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/ping-webhook"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/pings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposPingWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/pings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposPingWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRedeliverWebhookDelivery invokes repos/redeliver-webhook-delivery operation.
//
// Redeliver a webhook delivery for a webhook configured in a repository.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (c *Client) ReposRedeliverWebhookDelivery(ctx context.Context, params ReposRedeliverWebhookDeliveryParams) (ReposRedeliverWebhookDeliveryRes, error) {
	res, err := c.sendReposRedeliverWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendReposRedeliverWebhookDelivery(ctx context.Context, params ReposRedeliverWebhookDeliveryParams) (res ReposRedeliverWebhookDeliveryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/redeliver-webhook-delivery"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [9]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/attempts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRedeliverWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveAppAccessRestrictions invokes repos/remove-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposRemoveAppAccessRestrictions(ctx context.Context, request OptReposRemoveAppAccessRestrictionsReq, params ReposRemoveAppAccessRestrictionsParams) (ReposRemoveAppAccessRestrictionsRes, error) {
	res, err := c.sendReposRemoveAppAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposRemoveAppAccessRestrictions(ctx context.Context, request OptReposRemoveAppAccessRestrictionsReq, params ReposRemoveAppAccessRestrictionsParams) (res ReposRemoveAppAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-app-access-restrictions"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/apps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposRemoveAppAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRemoveAppAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveCollaborator invokes repos/remove-collaborator operation.
//
// Remove a repository collaborator.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (c *Client) ReposRemoveCollaborator(ctx context.Context, params ReposRemoveCollaboratorParams) error {
	_, err := c.sendReposRemoveCollaborator(ctx, params)
	return err
}

func (c *Client) sendReposRemoveCollaborator(ctx context.Context, params ReposRemoveCollaboratorParams) (res *ReposRemoveCollaboratorNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-collaborator"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRemoveCollaboratorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveStatusCheckContexts invokes repos/remove-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposRemoveStatusCheckContexts(ctx context.Context, request OptReposRemoveStatusCheckContextsReq, params ReposRemoveStatusCheckContextsParams) (ReposRemoveStatusCheckContextsRes, error) {
	res, err := c.sendReposRemoveStatusCheckContexts(ctx, request, params)
	return res, err
}

func (c *Client) sendReposRemoveStatusCheckContexts(ctx context.Context, request OptReposRemoveStatusCheckContextsReq, params ReposRemoveStatusCheckContextsParams) (res ReposRemoveStatusCheckContextsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-contexts"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks/contexts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposRemoveStatusCheckContextsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRemoveStatusCheckContextsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveStatusCheckProtection invokes repos/remove-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (c *Client) ReposRemoveStatusCheckProtection(ctx context.Context, params ReposRemoveStatusCheckProtectionParams) error {
	_, err := c.sendReposRemoveStatusCheckProtection(ctx, params)
	return err
}

func (c *Client) sendReposRemoveStatusCheckProtection(ctx context.Context, params ReposRemoveStatusCheckProtectionParams) (res *ReposRemoveStatusCheckProtectionNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-protection"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRemoveStatusCheckProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveTeamAccessRestrictions invokes repos/remove-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a team to push to this branch. You can also remove push access for child
// teams.
// | Type    | Description
//
//	|
//
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The
// list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposRemoveTeamAccessRestrictions(ctx context.Context, request OptReposRemoveTeamAccessRestrictionsReq, params ReposRemoveTeamAccessRestrictionsParams) (ReposRemoveTeamAccessRestrictionsRes, error) {
	res, err := c.sendReposRemoveTeamAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposRemoveTeamAccessRestrictions(ctx context.Context, request OptReposRemoveTeamAccessRestrictionsReq, params ReposRemoveTeamAccessRestrictionsParams) (res ReposRemoveTeamAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-team-access-restrictions"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposRemoveTeamAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRemoveTeamAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveUserAccessRestrictions invokes repos/remove-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a user to push to this branch.
// | Type    | Description
//
//	|
//
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposRemoveUserAccessRestrictions(ctx context.Context, request OptReposRemoveUserAccessRestrictionsReq, params ReposRemoveUserAccessRestrictionsParams) (ReposRemoveUserAccessRestrictionsRes, error) {
	res, err := c.sendReposRemoveUserAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposRemoveUserAccessRestrictions(ctx context.Context, request OptReposRemoveUserAccessRestrictionsReq, params ReposRemoveUserAccessRestrictionsParams) (res ReposRemoveUserAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-user-access-restrictions"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposRemoveUserAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRemoveUserAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRenameBranch invokes repos/rename-branch operation.
//
// Renames a branch in a repository.
// **Note:** Although the API responds immediately, the branch rename process might take some extra
// time to complete in the background. You won't be able to push to the old branch name while the
// rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.
// com/github/administering-a-repository/renaming-a-branch)".
// The permissions required to use this endpoint depends on whether you are renaming the default
// branch.
// To rename a non-default branch:
// * Users must have push access.
// * GitHub Apps must have the `contents:write` repository permission.
// To rename the default branch:
// * Users must have admin or owner permissions.
// * GitHub Apps must have the `administration:write` repository permission.
//
// POST /repos/{owner}/{repo}/branches/{branch}/rename
func (c *Client) ReposRenameBranch(ctx context.Context, request OptReposRenameBranchReq, params ReposRenameBranchParams) (ReposRenameBranchRes, error) {
	res, err := c.sendReposRenameBranch(ctx, request, params)
	return res, err
}

func (c *Client) sendReposRenameBranch(ctx context.Context, request OptReposRenameBranchReq, params ReposRenameBranchParams) (res ReposRenameBranchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/rename-branch"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/rename"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRenameBranch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/rename"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposRenameBranchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRenameBranchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposReplaceAllTopics invokes repos/replace-all-topics operation.
//
// Replace all repository topics.
//
// PUT /repos/{owner}/{repo}/topics
func (c *Client) ReposReplaceAllTopics(ctx context.Context, request *ReposReplaceAllTopicsReq, params ReposReplaceAllTopicsParams) (ReposReplaceAllTopicsRes, error) {
	res, err := c.sendReposReplaceAllTopics(ctx, request, params)
	return res, err
}

func (c *Client) sendReposReplaceAllTopics(ctx context.Context, request *ReposReplaceAllTopicsReq, params ReposReplaceAllTopicsParams) (res ReposReplaceAllTopicsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/replace-all-topics"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/topics"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposReplaceAllTopics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/topics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposReplaceAllTopicsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposReplaceAllTopicsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRequestPagesBuild invokes repos/request-pages-build operation.
//
// You can request that your site be built from the latest revision on the default branch. This has
// the same effect as pushing a commit to your default branch, but does not require an additional
// commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
// Build requests are limited to one concurrent build per repository and one concurrent build per
// requester. If you request a build while another is still in progress, the second request will be
// queued until the first completes.
//
// POST /repos/{owner}/{repo}/pages/builds
func (c *Client) ReposRequestPagesBuild(ctx context.Context, params ReposRequestPagesBuildParams) (*PageBuildStatus, error) {
	res, err := c.sendReposRequestPagesBuild(ctx, params)
	return res, err
}

func (c *Client) sendReposRequestPagesBuild(ctx context.Context, params ReposRequestPagesBuildParams) (res *PageBuildStatus, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/request-pages-build"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRequestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pages/builds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposRequestPagesBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetAdminBranchProtection invokes repos/set-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Adding admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (c *Client) ReposSetAdminBranchProtection(ctx context.Context, params ReposSetAdminBranchProtectionParams) (*ProtectedBranchAdminEnforced, error) {
	res, err := c.sendReposSetAdminBranchProtection(ctx, params)
	return res, err
}

func (c *Client) sendReposSetAdminBranchProtection(ctx context.Context, params ReposSetAdminBranchProtectionParams) (res *ProtectedBranchAdminEnforced, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-admin-branch-protection"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/enforce_admins"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposSetAdminBranchProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetAppAccessRestrictions invokes repos/set-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of apps that have push access to this branch. This removes all apps that
// previously had push access and grants push access to the new list of apps. Only installed GitHub
// Apps with `write` access to the `contents` permission can be added as authorized actors on a
// protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposSetAppAccessRestrictions(ctx context.Context, request OptReposSetAppAccessRestrictionsReq, params ReposSetAppAccessRestrictionsParams) (ReposSetAppAccessRestrictionsRes, error) {
	res, err := c.sendReposSetAppAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposSetAppAccessRestrictions(ctx context.Context, request OptReposSetAppAccessRestrictionsReq, params ReposSetAppAccessRestrictionsParams) (res ReposSetAppAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-app-access-restrictions"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/apps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposSetAppAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposSetAppAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetStatusCheckContexts invokes repos/set-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposSetStatusCheckContexts(ctx context.Context, request OptReposSetStatusCheckContextsReq, params ReposSetStatusCheckContextsParams) (ReposSetStatusCheckContextsRes, error) {
	res, err := c.sendReposSetStatusCheckContexts(ctx, request, params)
	return res, err
}

func (c *Client) sendReposSetStatusCheckContexts(ctx context.Context, request OptReposSetStatusCheckContextsReq, params ReposSetStatusCheckContextsParams) (res ReposSetStatusCheckContextsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-status-check-contexts"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks/contexts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposSetStatusCheckContextsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposSetStatusCheckContextsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetTeamAccessRestrictions invokes repos/set-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of teams that have push access to this branch. This removes all teams that
// previously had push access and grants push access to the new list of teams. Team restrictions
// include child teams.
// | Type    | Description
//
//	|
//
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposSetTeamAccessRestrictions(ctx context.Context, request OptReposSetTeamAccessRestrictionsReq, params ReposSetTeamAccessRestrictionsParams) (ReposSetTeamAccessRestrictionsRes, error) {
	res, err := c.sendReposSetTeamAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposSetTeamAccessRestrictions(ctx context.Context, request OptReposSetTeamAccessRestrictionsReq, params ReposSetTeamAccessRestrictionsParams) (res ReposSetTeamAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-team-access-restrictions"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposSetTeamAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposSetTeamAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetUserAccessRestrictions invokes repos/set-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of people that have push access to this branch. This removes all people that
// previously had push access and grants push access to the new list of people.
// | Type    | Description
//
//	|
//
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposSetUserAccessRestrictions(ctx context.Context, request OptReposSetUserAccessRestrictionsReq, params ReposSetUserAccessRestrictionsParams) (ReposSetUserAccessRestrictionsRes, error) {
	res, err := c.sendReposSetUserAccessRestrictions(ctx, request, params)
	return res, err
}

func (c *Client) sendReposSetUserAccessRestrictions(ctx context.Context, request OptReposSetUserAccessRestrictionsReq, params ReposSetUserAccessRestrictionsParams) (res ReposSetUserAccessRestrictionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-user-access-restrictions"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/restrictions/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposSetUserAccessRestrictionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposSetUserAccessRestrictionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposTestPushWebhook invokes repos/test-push-webhook operation.
//
// This will trigger the hook with the latest push to the current repository if the hook is
// subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
// respond with 204 but no test POST will be generated.
// **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (c *Client) ReposTestPushWebhook(ctx context.Context, params ReposTestPushWebhookParams) (ReposTestPushWebhookRes, error) {
	res, err := c.sendReposTestPushWebhook(ctx, params)
	return res, err
}

func (c *Client) sendReposTestPushWebhook(ctx context.Context, params ReposTestPushWebhookParams) (res ReposTestPushWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/test-push-webhook"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/tests"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposTestPushWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/tests"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposTestPushWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposTransfer invokes repos/transfer operation.
//
// A transfer request will need to be accepted by the new owner when transferring a personal
// repository to another user. The response will contain the original `owner`, and the transfer will
// continue asynchronously. For more details on the requirements to transfer personal and
// organization-owned repositories, see [about repository transfers](https://help.github.
// com/articles/about-repository-transfers/).
//
// POST /repos/{owner}/{repo}/transfer
func (c *Client) ReposTransfer(ctx context.Context, request *ReposTransferReq, params ReposTransferParams) (*MinimalRepository, error) {
	res, err := c.sendReposTransfer(ctx, request, params)
	return res, err
}

func (c *Client) sendReposTransfer(ctx context.Context, request *ReposTransferReq, params ReposTransferParams) (res *MinimalRepository, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/transfer"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/transfer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposTransfer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposTransferRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposTransferResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdate invokes repos/update operation.
//
// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.
// github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
//
// PATCH /repos/{owner}/{repo}
func (c *Client) ReposUpdate(ctx context.Context, request OptReposUpdateReq, params ReposUpdateParams) (ReposUpdateRes, error) {
	res, err := c.sendReposUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdate(ctx context.Context, request OptReposUpdateReq, params ReposUpdateParams) (res ReposUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateBranchProtection invokes repos/update-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Protecting a branch requires admin or owner permissions to the repository.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
// **Note**: The list of users, apps, and teams in total is limited to 100 items.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (c *Client) ReposUpdateBranchProtection(ctx context.Context, request *ReposUpdateBranchProtectionReq, params ReposUpdateBranchProtectionParams) (ReposUpdateBranchProtectionRes, error) {
	res, err := c.sendReposUpdateBranchProtection(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateBranchProtection(ctx context.Context, request *ReposUpdateBranchProtectionReq, params ReposUpdateBranchProtectionParams) (res ReposUpdateBranchProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-branch-protection"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateBranchProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateBranchProtectionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateBranchProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateCommitComment invokes repos/update-commit-comment operation.
//
// Update a commit comment.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (c *Client) ReposUpdateCommitComment(ctx context.Context, request *ReposUpdateCommitCommentReq, params ReposUpdateCommitCommentParams) (ReposUpdateCommitCommentRes, error) {
	res, err := c.sendReposUpdateCommitComment(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateCommitComment(ctx context.Context, request *ReposUpdateCommitCommentReq, params ReposUpdateCommitCommentParams) (res ReposUpdateCommitCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-commit-comment"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateCommitComment",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateCommitCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateCommitCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateInvitation invokes repos/update-invitation operation.
//
// Update a repository invitation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (c *Client) ReposUpdateInvitation(ctx context.Context, request OptReposUpdateInvitationReq, params ReposUpdateInvitationParams) (*RepositoryInvitation, error) {
	res, err := c.sendReposUpdateInvitation(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateInvitation(ctx context.Context, request OptReposUpdateInvitationReq, params ReposUpdateInvitationParams) (res *RepositoryInvitation, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-invitation"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/invitations/{invitation_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateInvitationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdatePullRequestReviewProtection invokes repos/update-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating pull request review enforcement requires admin or owner permissions to the repository and
// branch protection to be enabled.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (c *Client) ReposUpdatePullRequestReviewProtection(ctx context.Context, request OptReposUpdatePullRequestReviewProtectionReq, params ReposUpdatePullRequestReviewProtectionParams) (ReposUpdatePullRequestReviewProtectionRes, error) {
	res, err := c.sendReposUpdatePullRequestReviewProtection(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdatePullRequestReviewProtection(ctx context.Context, request OptReposUpdatePullRequestReviewProtectionReq, params ReposUpdatePullRequestReviewProtectionParams) (res ReposUpdatePullRequestReviewProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-pull-request-review-protection"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdatePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_pull_request_reviews"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdatePullRequestReviewProtectionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdatePullRequestReviewProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateRelease invokes repos/update-release operation.
//
// Users with push access to the repository can edit a release.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (c *Client) ReposUpdateRelease(ctx context.Context, request OptReposUpdateReleaseReq, params ReposUpdateReleaseParams) (ReposUpdateReleaseRes, error) {
	res, err := c.sendReposUpdateRelease(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateRelease(ctx context.Context, request OptReposUpdateReleaseReq, params ReposUpdateReleaseParams) (res ReposUpdateReleaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateRelease",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateReleaseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateReleaseAsset invokes repos/update-release-asset operation.
//
// Users with push access to the repository can edit a release asset.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (c *Client) ReposUpdateReleaseAsset(ctx context.Context, request OptReposUpdateReleaseAssetReq, params ReposUpdateReleaseAssetParams) (*ReleaseAsset, error) {
	res, err := c.sendReposUpdateReleaseAsset(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateReleaseAsset(ctx context.Context, request OptReposUpdateReleaseAssetReq, params ReposUpdateReleaseAssetParams) (res *ReleaseAsset, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release-asset"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/assets/{asset_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/assets/"
	{
		// Encode "asset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AssetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateReleaseAssetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateReleaseAssetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateStatusCheckProtection invokes repos/update-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating required status checks requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (c *Client) ReposUpdateStatusCheckProtection(ctx context.Context, request OptReposUpdateStatusCheckProtectionReq, params ReposUpdateStatusCheckProtectionParams) (ReposUpdateStatusCheckProtectionRes, error) {
	res, err := c.sendReposUpdateStatusCheckProtection(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateStatusCheckProtection(ctx context.Context, request OptReposUpdateStatusCheckProtectionReq, params ReposUpdateStatusCheckProtectionParams) (res ReposUpdateStatusCheckProtectionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-status-check-protection"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/protection/required_status_checks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateStatusCheckProtectionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateStatusCheckProtectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateWebhook invokes repos/update-webhook operation.
//
// Updates a webhook configured in a repository. If you previously had a `secret` set, you must
// provide the same `secret` or set a new `secret` or the secret will be removed. If you are only
// updating individual webhook `config` properties, use "[Update a webhook configuration for a
// repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
func (c *Client) ReposUpdateWebhook(ctx context.Context, request OptReposUpdateWebhookReq, params ReposUpdateWebhookParams) (ReposUpdateWebhookRes, error) {
	res, err := c.sendReposUpdateWebhook(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateWebhook(ctx context.Context, request OptReposUpdateWebhookReq, params ReposUpdateWebhookParams) (res ReposUpdateWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateWebhookConfigForRepo invokes repos/update-webhook-config-for-repo operation.
//
// Updates the webhook configuration for a repository. To update more information about the webhook,
// including the `active` state and `events`, use "[Update a repository
// webhook](/rest/reference/orgs#update-a-repository-webhook)."
// Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:write` permission.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (c *Client) ReposUpdateWebhookConfigForRepo(ctx context.Context, request OptReposUpdateWebhookConfigForRepoReq, params ReposUpdateWebhookConfigForRepoParams) (*WebhookConfig, error) {
	res, err := c.sendReposUpdateWebhookConfigForRepo(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUpdateWebhookConfigForRepo(ctx context.Context, request OptReposUpdateWebhookConfigForRepoReq, params ReposUpdateWebhookConfigForRepoParams) (res *WebhookConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook-config-for-repo"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/config"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUpdateWebhookConfigForRepoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUpdateWebhookConfigForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUploadReleaseAsset invokes repos/upload-release-asset operation.
//
// This endpoint makes use of [a Hypermedia relation](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The
// endpoint you call to upload release assets is specific to your release. Use the `upload_url`
// returned in
// the response of the [Create a release endpoint](https://docs.github.
// com/rest/reference/repos#create-a-release) to upload a release asset.
// You need to use an HTTP client which supports [SNI](http://en.wikipedia.
// org/wiki/Server_Name_Indication) to make calls to this endpoint.
// Most libraries will set the required `Content-Length` header automatically. Use the required
// `Content-Type` header to provide the media type of the asset. For a list of media types, see
// [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
// `application/zip`
// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw
// binary content of the asset as the request body. Everything else about the endpoint is the same as
// the rest of the API. For example,
// you'll still need to pass your authentication to be able to upload an asset.
// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an
// empty asset with a state of `starter`. It can be safely deleted.
// **Notes:**
// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and
// leading or trailing periods. The "[List assets for a release](https://docs.github.
// com/rest/reference/repos#list-assets-for-a-release)"
// endpoint lists the renamed filenames. For more information and help, contact [GitHub
// Support](https://support.github.com/contact?tags=dotcom-rest-api).
// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an
// error and must delete the old file before you can re-upload the new asset.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/assets
func (c *Client) ReposUploadReleaseAsset(ctx context.Context, request *ReposUploadReleaseAssetReqWithContentType, params ReposUploadReleaseAssetParams) (*ReleaseAsset, error) {
	res, err := c.sendReposUploadReleaseAsset(ctx, request, params)
	return res, err
}

func (c *Client) sendReposUploadReleaseAsset(ctx context.Context, request *ReposUploadReleaseAssetReqWithContentType, params ReposUploadReleaseAssetParams) (res *ReleaseAsset, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/upload-release-asset"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}/assets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUploadReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/assets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "label" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "label",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Label.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReposUploadReleaseAssetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReposUploadReleaseAssetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScimDeleteUserFromOrg invokes scim/delete-user-from-org operation.
//
// Delete a SCIM user from an organization.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (c *Client) ScimDeleteUserFromOrg(ctx context.Context, params ScimDeleteUserFromOrgParams) (ScimDeleteUserFromOrgRes, error) {
	res, err := c.sendScimDeleteUserFromOrg(ctx, params)
	return res, err
}

func (c *Client) sendScimDeleteUserFromOrg(ctx context.Context, params ScimDeleteUserFromOrgParams) (res ScimDeleteUserFromOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scim/delete-user-from-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/scim/v2/organizations/{org}/Users/{scim_user_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ScimDeleteUserFromOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/scim/v2/organizations/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeScimDeleteUserFromOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCode invokes search/code operation.
//
// Searches for query terms inside of a file. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for code, you can get text match metadata for the file **content** and file
// **path** fields when you pass the `text-match` media type. For more details about how to receive
// highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the definition of the `addClass` function inside
// [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
// `q=addClass+in:file+language:js+repo:jquery/jquery`
// This query searches for the keyword `addClass` within a file's contents. The query limits the
// search to files where the language is JavaScript in the `jquery/jquery` repository.
// #### Considerations for code search
// Due to the complexity of searching code, there are a few restrictions on how searches are
// performed:
// *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
// *   Only files smaller than 384 KB are searchable.
// *   You must always include at least one search term when searching source code. For example,
// searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code)
// is not valid, while [`amazing
// language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
//
// GET /search/code
func (c *Client) SearchCode(ctx context.Context, params SearchCodeParams) (SearchCodeRes, error) {
	res, err := c.sendSearchCode(ctx, params)
	return res, err
}

func (c *Client) sendSearchCode(ctx context.Context, params SearchCodeParams) (res SearchCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/code"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/code"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchCode",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/code"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCommits invokes search/commits operation.
//
// Find commits via various criteria on the default branch (usually `master`). This method returns up
// to 100 results [per page](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for commits, you can get text match metadata for the **message** field when you
// provide the `text-match` media type. For more details about how to receive highlighted search
// results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to find commits related to CSS in the
// [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look
// something like this:
// `q=repo:octocat/Spoon-Knife+css`.
//
// GET /search/commits
func (c *Client) SearchCommits(ctx context.Context, params SearchCommitsParams) (SearchCommitsRes, error) {
	res, err := c.sendSearchCommits(ctx, params)
	return res, err
}

func (c *Client) sendSearchCommits(ctx context.Context, params SearchCommitsParams) (res SearchCommitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/commits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/commits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchCommits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/commits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchCommitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchIssuesAndPullRequests invokes search/issues-and-pull-requests operation.
//
// Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for issues, you can get text match metadata for the issue **title**, issue **body**,
//
//	and issue **comment body** fields when you pass the `text-match` media type. For more details
//
// about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might
// look something like this.
// `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
// This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The
// search runs across repositories whose primary language is Python. The results are sorted by
// creation date in ascending order, which means the oldest issues appear first in the search results.
// **Note:** For [user-to-server](https://docs.github.
// com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests)
// GitHub App requests, you can't retrieve a combination of issues and pull requests in a single
// query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an
// HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you
// must send separate queries for issues and pull requests. For more information about the `is`
// qualifier, see "[Searching only issues or pull requests](https://docs.github.
// com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests).".
//
// GET /search/issues
func (c *Client) SearchIssuesAndPullRequests(ctx context.Context, params SearchIssuesAndPullRequestsParams) (SearchIssuesAndPullRequestsRes, error) {
	res, err := c.sendSearchIssuesAndPullRequests(ctx, params)
	return res, err
}

func (c *Client) sendSearchIssuesAndPullRequests(ctx context.Context, params SearchIssuesAndPullRequestsParams) (res SearchIssuesAndPullRequestsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/issues-and-pull-requests"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/issues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchIssuesAndPullRequests",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/issues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchIssuesAndPullRequestsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchLabels invokes search/labels operation.
//
// Find labels in a repository with names or descriptions that match search keywords. Returns up to
// 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for labels, you can get text match metadata for the label **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`,
// or `enhancement`. Your query might look like this:
// `q=bug+defect+enhancement&repository_id=64778136`
// The labels that best match the query appear first in the search results.
//
// GET /search/labels
func (c *Client) SearchLabels(ctx context.Context, params SearchLabelsParams) (SearchLabelsRes, error) {
	res, err := c.sendSearchLabels(ctx, params)
	return res, err
}

func (c *Client) sendSearchLabels(ctx context.Context, params SearchLabelsParams) (res SearchLabelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/labels"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/labels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchLabels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/labels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "repository_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "repository_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchLabelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchRepos invokes search/repos operation.
//
// Find repositories via various criteria. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for repositories, you can get text match metadata for the **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to search for popular Tetris repositories written in assembly code, your
// query might look like this:
// `q=tetris+language:assembly&sort=stars&order=desc`
// This query searches for repositories with the word `tetris` in the name, the description, or the
// README. The results are limited to repositories where the primary language is assembly. The
// results are sorted by stars in descending order, so that the most popular repositories appear
// first in the search results.
// When you include the `mercy` preview header, you can also search for multiple topics by adding
// more `topic:` instances. For example, your query might look like this:
// `q=topic:ruby+topic:rails`.
//
// GET /search/repositories
func (c *Client) SearchRepos(ctx context.Context, params SearchReposParams) (SearchReposRes, error) {
	res, err := c.sendSearchRepos(ctx, params)
	return res, err
}

func (c *Client) sendSearchRepos(ctx context.Context, params SearchReposParams) (res SearchReposRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/repos"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/repositories"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchRepos",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/repositories"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchReposResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchTopics invokes search/topics operation.
//
// Find topics via various criteria. Results are sorted by best match. This method returns up to 100
// results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list
// of qualifiers.
// When searching for topics, you can get text match metadata for the topic's **short\_description**,
// **description**, **name**, or **display\_name** field when you pass the `text-match` media type.
// For more details about how to receive highlighted search results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to search for topics related to Ruby that are featured on https://github.
// com/topics. Your query might look like this:
// `q=ruby+is:featured`
// This query searches for topics with the keyword `ruby` and limits the results to find only topics
// that are featured. The topics that are the best match for the query appear first in the search
// results.
//
// GET /search/topics
func (c *Client) SearchTopics(ctx context.Context, params SearchTopicsParams) (SearchTopicsRes, error) {
	res, err := c.sendSearchTopics(ctx, params)
	return res, err
}

func (c *Client) sendSearchTopics(ctx context.Context, params SearchTopicsParams) (res SearchTopicsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/topics"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/topics"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchTopics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/topics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchTopicsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchUsers invokes search/users operation.
//
// Find users via various criteria. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for users, you can get text match metadata for the issue **login**, **email**, and
// **name** fields when you pass the `text-match` media type. For more details about highlighting
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you're looking for a list of popular users, you might try this query:
// `q=tom+repos:%3E42+followers:%3E1000`
// This query searches for users with the name `tom`. The results are restricted to users with more
// than 42 repositories and over 1,000 followers.
//
// GET /search/users
func (c *Client) SearchUsers(ctx context.Context, params SearchUsersParams) (SearchUsersRes, error) {
	res, err := c.sendSearchUsers(ctx, params)
	return res, err
}

func (c *Client) sendSearchUsers(ctx context.Context, params SearchUsersParams) (res SearchUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/users"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchUsers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningGetAlert invokes secret-scanning/get-alert operation.
//
// Gets a single secret scanning alert detected in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (c *Client) SecretScanningGetAlert(ctx context.Context, params SecretScanningGetAlertParams) (SecretScanningGetAlertRes, error) {
	res, err := c.sendSecretScanningGetAlert(ctx, params)
	return res, err
}

func (c *Client) sendSecretScanningGetAlert(ctx context.Context, params SecretScanningGetAlertParams) (res SecretScanningGetAlertRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/get-alert"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSecretScanningGetAlertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningListAlertsForOrg invokes secret-scanning/list-alerts-for-org operation.
//
// Lists all secret scanning alerts for all eligible repositories in an organization, from newest to
// oldest.
// To use this endpoint, you must be an administrator for the repository or organization, and you
// must use an access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /orgs/{org}/secret-scanning/alerts
func (c *Client) SecretScanningListAlertsForOrg(ctx context.Context, params SecretScanningListAlertsForOrgParams) (SecretScanningListAlertsForOrgRes, error) {
	res, err := c.sendSecretScanningListAlertsForOrg(ctx, params)
	return res, err
}

func (c *Client) sendSecretScanningListAlertsForOrg(ctx context.Context, params SecretScanningListAlertsForOrgParams) (res SecretScanningListAlertsForOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/secret-scanning/alerts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningListAlertsForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/secret-scanning/alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "secret_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "secret_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SecretType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSecretScanningListAlertsForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningListAlertsForRepo invokes secret-scanning/list-alerts-for-repo operation.
//
// Lists all secret scanning alerts for a private repository, from newest to oldest. To use this
// endpoint, you must be an administrator for the repository or organization, and you must use an
// access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (c *Client) SecretScanningListAlertsForRepo(ctx context.Context, params SecretScanningListAlertsForRepoParams) (SecretScanningListAlertsForRepoRes, error) {
	res, err := c.sendSecretScanningListAlertsForRepo(ctx, params)
	return res, err
}

func (c *Client) sendSecretScanningListAlertsForRepo(ctx context.Context, params SecretScanningListAlertsForRepoParams) (res SecretScanningListAlertsForRepoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-repo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/secret-scanning/alerts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-scanning/alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "secret_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "secret_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SecretType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSecretScanningListAlertsForRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningUpdateAlert invokes secret-scanning/update-alert operation.
//
// Updates the status of a secret scanning alert in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (c *Client) SecretScanningUpdateAlert(ctx context.Context, request *SecretScanningUpdateAlertReq, params SecretScanningUpdateAlertParams) (SecretScanningUpdateAlertRes, error) {
	res, err := c.sendSecretScanningUpdateAlert(ctx, request, params)
	return res, err
}

func (c *Client) sendSecretScanningUpdateAlert(ctx context.Context, request *SecretScanningUpdateAlertReq, params SecretScanningUpdateAlertParams) (res SecretScanningUpdateAlertRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/update-alert"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSecretScanningUpdateAlertRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSecretScanningUpdateAlertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddMemberLegacy invokes teams/add-member-legacy operation.
//
// The "Add team member" endpoint (described below) is deprecated.
// We recommend using the [Add or update team membership for a user](https://docs.github.
// com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you
// to invite new organization members to your teams.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To add someone to a team, the authenticated user must be an organization owner or a team
// maintainer in the team they're changing. The person being added to the team must be a member of
// the team's organization.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/members/{username}
func (c *Client) TeamsAddMemberLegacy(ctx context.Context, params TeamsAddMemberLegacyParams) (TeamsAddMemberLegacyRes, error) {
	res, err := c.sendTeamsAddMemberLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsAddMemberLegacy(ctx context.Context, params TeamsAddMemberLegacyParams) (res TeamsAddMemberLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-member-legacy"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddMemberLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateMembershipForUserInOrg invokes teams/add-or-update-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Adds an organization member to a team. An authenticated organization owner or team maintainer can
// add organization members to a team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// An organization owner can add someone who is not part of the team's organization to a team. When
// an organization owner adds someone to a team who is not an organization member, this endpoint will
// send an invitation to the person via email. This newly-created membership will be in the "pending"
// state until the person accepts the invitation, at which point the membership will transition to
// the "active" state and the user will be added as a member of the team.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (c *Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserInOrgReq, params TeamsAddOrUpdateMembershipForUserInOrgParams) (TeamsAddOrUpdateMembershipForUserInOrgRes, error) {
	res, err := c.sendTeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserInOrgReq, params TeamsAddOrUpdateMembershipForUserInOrgParams) (res TeamsAddOrUpdateMembershipForUserInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-in-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/memberships/{username}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsAddOrUpdateMembershipForUserInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddOrUpdateMembershipForUserInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateMembershipForUserLegacy invokes teams/add-or-update-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team membership for a
// user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// If the user is already a member of the team's organization, this endpoint will add the user to the
// team. To add a membership between an organization member and a team, the authenticated user must
// be an organization owner or a team maintainer.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to
// the user via email. This newly-created membership will be in the "pending" state until the user
// accepts the invitation, at which point the membership will transition to the "active" state and
// the user will be added as a member of the team. To add a membership between an unaffiliated user
// and a team, the authenticated user must be an organization owner.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/memberships/{username}
func (c *Client) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserLegacyReq, params TeamsAddOrUpdateMembershipForUserLegacyParams) (TeamsAddOrUpdateMembershipForUserLegacyRes, error) {
	res, err := c.sendTeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserLegacyReq, params TeamsAddOrUpdateMembershipForUserLegacyParams) (res TeamsAddOrUpdateMembershipForUserLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-legacy"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/memberships/{username}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsAddOrUpdateMembershipForUserLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddOrUpdateMembershipForUserLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateProjectPermissionsInOrg invokes teams/add-or-update-project-permissions-in-org operation.
//
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (c *Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, request OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq, params TeamsAddOrUpdateProjectPermissionsInOrgParams) (TeamsAddOrUpdateProjectPermissionsInOrgRes, error) {
	res, err := c.sendTeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, request OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq, params TeamsAddOrUpdateProjectPermissionsInOrgParams) (res TeamsAddOrUpdateProjectPermissionsInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-in-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects/{project_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateProjectPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateProjectPermissionsLegacy invokes teams/add-or-update-project-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team project
// permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions)
// endpoint.
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/projects/{project_id}
func (c *Client) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateProjectPermissionsLegacyReq, params TeamsAddOrUpdateProjectPermissionsLegacyParams) (TeamsAddOrUpdateProjectPermissionsLegacyRes, error) {
	res, err := c.sendTeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateProjectPermissionsLegacyReq, params TeamsAddOrUpdateProjectPermissionsLegacyParams) (res TeamsAddOrUpdateProjectPermissionsLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-legacy"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects/{project_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateProjectPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsAddOrUpdateProjectPermissionsLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateRepoPermissionsInOrg invokes teams/add-or-update-repo-permissions-in-org operation.
//
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to
// set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP
// verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
// For more information about the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (c *Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsInOrgReq, params TeamsAddOrUpdateRepoPermissionsInOrgParams) error {
	_, err := c.sendTeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
	return err
}

func (c *Client) sendTeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsInOrgReq, params TeamsAddOrUpdateRepoPermissionsInOrgParams) (res *TeamsAddOrUpdateRepoPermissionsInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-in-org"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateRepoPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateRepoPermissionsLegacy invokes teams/add-or-update-repo-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Add or update team repository
// permissions](https://docs.github.
// com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/repos/{owner}/{repo}
func (c *Client) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsLegacyReq, params TeamsAddOrUpdateRepoPermissionsLegacyParams) (TeamsAddOrUpdateRepoPermissionsLegacyRes, error) {
	res, err := c.sendTeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsLegacyReq, params TeamsAddOrUpdateRepoPermissionsLegacyParams) (res TeamsAddOrUpdateRepoPermissionsLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-legacy"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos/{owner}/{repo}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateRepoPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsAddOrUpdateRepoPermissionsLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForProjectInOrg invokes teams/check-permissions-for-project-in-org operation.
//
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (c *Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, params TeamsCheckPermissionsForProjectInOrgParams) (TeamsCheckPermissionsForProjectInOrgRes, error) {
	res, err := c.sendTeamsCheckPermissionsForProjectInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsCheckPermissionsForProjectInOrg(ctx context.Context, params TeamsCheckPermissionsForProjectInOrgParams) (res TeamsCheckPermissionsForProjectInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects/{project_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCheckPermissionsForProjectInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForProjectLegacy invokes teams/check-permissions-for-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project)
// endpoint.
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/projects/{project_id}
func (c *Client) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, params TeamsCheckPermissionsForProjectLegacyParams) (TeamsCheckPermissionsForProjectLegacyRes, error) {
	res, err := c.sendTeamsCheckPermissionsForProjectLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsCheckPermissionsForProjectLegacy(ctx context.Context, params TeamsCheckPermissionsForProjectLegacyParams) (res TeamsCheckPermissionsForProjectLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects/{project_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCheckPermissionsForProjectLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForRepoInOrg invokes teams/check-permissions-for-repo-in-org operation.
//
// Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a
// repository. Repositories inherited through a parent team will also be checked.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
// If a team doesn't have permission for the repository, you will receive a `404 Not Found` response
// status.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (c *Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, params TeamsCheckPermissionsForRepoInOrgParams) (TeamsCheckPermissionsForRepoInOrgRes, error) {
	res, err := c.sendTeamsCheckPermissionsForRepoInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsCheckPermissionsForRepoInOrg(ctx context.Context, params TeamsCheckPermissionsForRepoInOrgParams) (res TeamsCheckPermissionsForRepoInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCheckPermissionsForRepoInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForRepoLegacy invokes teams/check-permissions-for-repo-legacy operation.
//
// **Note**: Repositories inherited through a parent team will also be checked.
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository)
// endpoint.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `Accept` header:.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (c *Client) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, params TeamsCheckPermissionsForRepoLegacyParams) (TeamsCheckPermissionsForRepoLegacyRes, error) {
	res, err := c.sendTeamsCheckPermissionsForRepoLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsCheckPermissionsForRepoLegacy(ctx context.Context, params TeamsCheckPermissionsForRepoLegacyParams) (res TeamsCheckPermissionsForRepoLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCheckPermissionsForRepoLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreate invokes teams/create operation.
//
// To create a team, the authenticated user must be a member or owner of `{org}`. By default,
// organization members can create teams. Organization owners can limit team creation to organization
// owners. For more information, see "[Setting team creation permissions](https://help.github.
// com/en/articles/setting-team-creation-permissions-in-your-organization)."
// When you create a new team, you automatically become a team maintainer without explicitly adding
// yourself to the optional array of `maintainers`. For more information, see "[About
// teams](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
//
// POST /orgs/{org}/teams
func (c *Client) TeamsCreate(ctx context.Context, request *TeamsCreateReq, params TeamsCreateParams) (TeamsCreateRes, error) {
	res, err := c.sendTeamsCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreate(ctx context.Context, request *TeamsCreateReq, params TeamsCreateParams) (res TeamsCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionCommentInOrg invokes teams/create-discussion-comment-in-org operation.
//
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (c *Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, request *TeamsCreateDiscussionCommentInOrgReq, params TeamsCreateDiscussionCommentInOrgParams) (*TeamDiscussionComment, error) {
	res, err := c.sendTeamsCreateDiscussionCommentInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreateDiscussionCommentInOrg(ctx context.Context, request *TeamsCreateDiscussionCommentInOrgReq, params TeamsCreateDiscussionCommentInOrgParams) (res *TeamDiscussionComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-in-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateDiscussionCommentInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionCommentLegacy invokes teams/create-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Create a discussion
// comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (c *Client) TeamsCreateDiscussionCommentLegacy(ctx context.Context, request *TeamsCreateDiscussionCommentLegacyReq, params TeamsCreateDiscussionCommentLegacyParams) (*TeamDiscussionComment, error) {
	res, err := c.sendTeamsCreateDiscussionCommentLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreateDiscussionCommentLegacy(ctx context.Context, request *TeamsCreateDiscussionCommentLegacyReq, params TeamsCreateDiscussionCommentLegacyParams) (res *TeamDiscussionComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-legacy"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateDiscussionCommentLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionInOrg invokes teams/create-discussion-in-org operation.
//
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (c *Client) TeamsCreateDiscussionInOrg(ctx context.Context, request *TeamsCreateDiscussionInOrgReq, params TeamsCreateDiscussionInOrgParams) (*TeamDiscussion, error) {
	res, err := c.sendTeamsCreateDiscussionInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreateDiscussionInOrg(ctx context.Context, request *TeamsCreateDiscussionInOrgReq, params TeamsCreateDiscussionInOrgParams) (res *TeamDiscussion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-in-org"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateDiscussionInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateDiscussionInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionLegacy invokes teams/create-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.
// github.com/rest/reference/teams#create-a-discussion) endpoint.
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions
func (c *Client) TeamsCreateDiscussionLegacy(ctx context.Context, request *TeamsCreateDiscussionLegacyReq, params TeamsCreateDiscussionLegacyParams) (*TeamDiscussion, error) {
	res, err := c.sendTeamsCreateDiscussionLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreateDiscussionLegacy(ctx context.Context, request *TeamsCreateDiscussionLegacyReq, params TeamsCreateDiscussionLegacyParams) (res *TeamDiscussion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-legacy"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateDiscussionLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateDiscussionLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateOrUpdateIdpGroupConnectionsInOrg invokes teams/create-or-update-idp-group-connections-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, request *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq, params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) (*GroupMapping, error) {
	res, err := c.sendTeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, request *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq, params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) (res *GroupMapping, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-in-org"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/team-sync/group-mappings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateOrUpdateIdpGroupConnectionsLegacy invokes teams/create-or-update-idp-group-connections-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create or update IdP group
// connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/team-sync/group-mappings
func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, request *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq, params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams) (TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes, error) {
	res, err := c.sendTeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, request *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq, params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams) (res TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-legacy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/team-sync/group-mappings"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/team-sync/group-mappings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionCommentInOrg invokes teams/delete-discussion-comment-in-org operation.
//
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, params TeamsDeleteDiscussionCommentInOrgParams) error {
	_, err := c.sendTeamsDeleteDiscussionCommentInOrg(ctx, params)
	return err
}

func (c *Client) sendTeamsDeleteDiscussionCommentInOrg(ctx context.Context, params TeamsDeleteDiscussionCommentInOrgParams) (res *TeamsDeleteDiscussionCommentInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsDeleteDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionCommentLegacy invokes teams/delete-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a discussion
// comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, params TeamsDeleteDiscussionCommentLegacyParams) error {
	_, err := c.sendTeamsDeleteDiscussionCommentLegacy(ctx, params)
	return err
}

func (c *Client) sendTeamsDeleteDiscussionCommentLegacy(ctx context.Context, params TeamsDeleteDiscussionCommentLegacyParams) (res *TeamsDeleteDiscussionCommentLegacyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsDeleteDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionInOrg invokes teams/delete-discussion-in-org operation.
//
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (c *Client) TeamsDeleteDiscussionInOrg(ctx context.Context, params TeamsDeleteDiscussionInOrgParams) error {
	_, err := c.sendTeamsDeleteDiscussionInOrg(ctx, params)
	return err
}

func (c *Client) sendTeamsDeleteDiscussionInOrg(ctx context.Context, params TeamsDeleteDiscussionInOrgParams) (res *TeamsDeleteDiscussionInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsDeleteDiscussionInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionLegacy invokes teams/delete-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.
// github.com/rest/reference/teams#delete-a-discussion) endpoint.
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (c *Client) TeamsDeleteDiscussionLegacy(ctx context.Context, params TeamsDeleteDiscussionLegacyParams) error {
	_, err := c.sendTeamsDeleteDiscussionLegacy(ctx, params)
	return err
}

func (c *Client) sendTeamsDeleteDiscussionLegacy(ctx context.Context, params TeamsDeleteDiscussionLegacyParams) (res *TeamsDeleteDiscussionLegacyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsDeleteDiscussionLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteInOrg invokes teams/delete-in-org operation.
//
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (c *Client) TeamsDeleteInOrg(ctx context.Context, params TeamsDeleteInOrgParams) error {
	_, err := c.sendTeamsDeleteInOrg(ctx, params)
	return err
}

func (c *Client) sendTeamsDeleteInOrg(ctx context.Context, params TeamsDeleteInOrgParams) (res *TeamsDeleteInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsDeleteInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteLegacy invokes teams/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a team](https://docs.github.
// com/rest/reference/teams#delete-a-team) endpoint.
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}
func (c *Client) TeamsDeleteLegacy(ctx context.Context, params TeamsDeleteLegacyParams) (TeamsDeleteLegacyRes, error) {
	res, err := c.sendTeamsDeleteLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsDeleteLegacy(ctx context.Context, params TeamsDeleteLegacyParams) (res TeamsDeleteLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsDeleteLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetByName invokes teams/get-by-name operation.
//
// Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}`.
//
// GET /orgs/{org}/teams/{team_slug}
func (c *Client) TeamsGetByName(ctx context.Context, params TeamsGetByNameParams) (TeamsGetByNameRes, error) {
	res, err := c.sendTeamsGetByName(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetByName(ctx context.Context, params TeamsGetByNameParams) (res TeamsGetByNameRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-by-name"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetByName",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetByNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionCommentInOrg invokes teams/get-discussion-comment-in-org operation.
//
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, params TeamsGetDiscussionCommentInOrgParams) (*TeamDiscussionComment, error) {
	res, err := c.sendTeamsGetDiscussionCommentInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetDiscussionCommentInOrg(ctx context.Context, params TeamsGetDiscussionCommentInOrgParams) (res *TeamDiscussionComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionCommentLegacy invokes teams/get-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.
// github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsGetDiscussionCommentLegacy(ctx context.Context, params TeamsGetDiscussionCommentLegacyParams) (*TeamDiscussionComment, error) {
	res, err := c.sendTeamsGetDiscussionCommentLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetDiscussionCommentLegacy(ctx context.Context, params TeamsGetDiscussionCommentLegacyParams) (res *TeamDiscussionComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionInOrg invokes teams/get-discussion-in-org operation.
//
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (c *Client) TeamsGetDiscussionInOrg(ctx context.Context, params TeamsGetDiscussionInOrgParams) (*TeamDiscussion, error) {
	res, err := c.sendTeamsGetDiscussionInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetDiscussionInOrg(ctx context.Context, params TeamsGetDiscussionInOrgParams) (res *TeamDiscussion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetDiscussionInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionLegacy invokes teams/get-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.
// com/rest/reference/teams#get-a-discussion) endpoint.
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (c *Client) TeamsGetDiscussionLegacy(ctx context.Context, params TeamsGetDiscussionLegacyParams) (*TeamDiscussion, error) {
	res, err := c.sendTeamsGetDiscussionLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetDiscussionLegacy(ctx context.Context, params TeamsGetDiscussionLegacyParams) (res *TeamDiscussion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetDiscussionLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetLegacy invokes teams/get-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the [Get a team by name](https://docs.github.
// com/rest/reference/teams#get-a-team-by-name) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}
func (c *Client) TeamsGetLegacy(ctx context.Context, params TeamsGetLegacyParams) (TeamsGetLegacyRes, error) {
	res, err := c.sendTeamsGetLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetLegacy(ctx context.Context, params TeamsGetLegacyParams) (res TeamsGetLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetMemberLegacy invokes teams/get-member-legacy operation.
//
// The "Get team member" endpoint (described below) is deprecated.
// We recommend using the [Get team membership for a user](https://docs.github.
// com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get
// both active and pending memberships.
// To list members in a team, the team must be visible to the authenticated user.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/members/{username}
func (c *Client) TeamsGetMemberLegacy(ctx context.Context, params TeamsGetMemberLegacyParams) (TeamsGetMemberLegacyRes, error) {
	res, err := c.sendTeamsGetMemberLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetMemberLegacy(ctx context.Context, params TeamsGetMemberLegacyParams) (res TeamsGetMemberLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-member-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetMemberLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetMembershipForUserInOrg invokes teams/get-membership-for-user-in-org operation.
//
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (c *Client) TeamsGetMembershipForUserInOrg(ctx context.Context, params TeamsGetMembershipForUserInOrgParams) (TeamsGetMembershipForUserInOrgRes, error) {
	res, err := c.sendTeamsGetMembershipForUserInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetMembershipForUserInOrg(ctx context.Context, params TeamsGetMembershipForUserInOrgParams) (res TeamsGetMembershipForUserInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/memberships/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetMembershipForUserInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetMembershipForUserLegacy invokes teams/get-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get team membership for a
// user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/memberships/{username}
func (c *Client) TeamsGetMembershipForUserLegacy(ctx context.Context, params TeamsGetMembershipForUserLegacyParams) (TeamsGetMembershipForUserLegacyRes, error) {
	res, err := c.sendTeamsGetMembershipForUserLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsGetMembershipForUserLegacy(ctx context.Context, params TeamsGetMembershipForUserLegacyParams) (res TeamsGetMembershipForUserLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/memberships/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsGetMembershipForUserLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsList invokes teams/list operation.
//
// Lists all teams in an organization that are visible to the authenticated user.
//
// GET /orgs/{org}/teams
func (c *Client) TeamsList(ctx context.Context, params TeamsListParams) (TeamsListRes, error) {
	res, err := c.sendTeamsList(ctx, params)
	return res, err
}

func (c *Client) sendTeamsList(ctx context.Context, params TeamsListParams) (res TeamsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListChildInOrg invokes teams/list-child-in-org operation.
//
// Lists the child teams of the team specified by `{team_slug}`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/teams`.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (c *Client) TeamsListChildInOrg(ctx context.Context, params TeamsListChildInOrgParams) (*TeamsListChildInOrgOKHeaders, error) {
	res, err := c.sendTeamsListChildInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListChildInOrg(ctx context.Context, params TeamsListChildInOrgParams) (res *TeamsListChildInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListChildInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListChildInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListChildLegacy invokes teams/list-child-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.
// com/rest/reference/teams#list-child-teams) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/teams
func (c *Client) TeamsListChildLegacy(ctx context.Context, params TeamsListChildLegacyParams) (TeamsListChildLegacyRes, error) {
	res, err := c.sendTeamsListChildLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListChildLegacy(ctx context.Context, params TeamsListChildLegacyParams) (res TeamsListChildLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListChildLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListChildLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionCommentsInOrg invokes teams/list-discussion-comments-in-org operation.
//
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (c *Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, params TeamsListDiscussionCommentsInOrgParams) (*TeamsListDiscussionCommentsInOrgOKHeaders, error) {
	res, err := c.sendTeamsListDiscussionCommentsInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListDiscussionCommentsInOrg(ctx context.Context, params TeamsListDiscussionCommentsInOrgParams) (res *TeamsListDiscussionCommentsInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionCommentsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListDiscussionCommentsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionCommentsLegacy invokes teams/list-discussion-comments-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List discussion comments](https://docs.
// github.com/rest/reference/teams#list-discussion-comments) endpoint.
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (c *Client) TeamsListDiscussionCommentsLegacy(ctx context.Context, params TeamsListDiscussionCommentsLegacyParams) (*TeamsListDiscussionCommentsLegacyOKHeaders, error) {
	res, err := c.sendTeamsListDiscussionCommentsLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListDiscussionCommentsLegacy(ctx context.Context, params TeamsListDiscussionCommentsLegacyParams) (res *TeamsListDiscussionCommentsLegacyOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionCommentsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListDiscussionCommentsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionsInOrg invokes teams/list-discussions-in-org operation.
//
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (c *Client) TeamsListDiscussionsInOrg(ctx context.Context, params TeamsListDiscussionsInOrgParams) (*TeamsListDiscussionsInOrgOKHeaders, error) {
	res, err := c.sendTeamsListDiscussionsInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListDiscussionsInOrg(ctx context.Context, params TeamsListDiscussionsInOrgParams) (res *TeamsListDiscussionsInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pinned" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pinned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Pinned.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListDiscussionsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionsLegacy invokes teams/list-discussions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.
// com/rest/reference/teams#list-discussions) endpoint.
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions
func (c *Client) TeamsListDiscussionsLegacy(ctx context.Context, params TeamsListDiscussionsLegacyParams) (*TeamsListDiscussionsLegacyOKHeaders, error) {
	res, err := c.sendTeamsListDiscussionsLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListDiscussionsLegacy(ctx context.Context, params TeamsListDiscussionsLegacyParams) (res *TeamsListDiscussionsLegacyOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListDiscussionsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListForAuthenticatedUser invokes teams/list-for-authenticated-user operation.
//
// List all of the teams across all of the organizations to which the authenticated user belongs.
// This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via
// [OAuth](https://docs.github.com/apps/building-oauth-apps/).
//
// GET /user/teams
func (c *Client) TeamsListForAuthenticatedUser(ctx context.Context, params TeamsListForAuthenticatedUserParams) (TeamsListForAuthenticatedUserRes, error) {
	res, err := c.sendTeamsListForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListForAuthenticatedUser(ctx context.Context, params TeamsListForAuthenticatedUserParams) (res TeamsListForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/teams"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/teams"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListIdpGroupsForLegacy invokes teams/list-idp-groups-for-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List IdP groups for a
// team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (c *Client) TeamsListIdpGroupsForLegacy(ctx context.Context, params TeamsListIdpGroupsForLegacyParams) (TeamsListIdpGroupsForLegacyRes, error) {
	res, err := c.sendTeamsListIdpGroupsForLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListIdpGroupsForLegacy(ctx context.Context, params TeamsListIdpGroupsForLegacyParams) (res TeamsListIdpGroupsForLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/team-sync/group-mappings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListIdpGroupsForLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/team-sync/group-mappings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListIdpGroupsForLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListIdpGroupsForOrg invokes teams/list-idp-groups-for-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups available in an organization. You can limit your page results using the `per_page`
// parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next
// page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination
// explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89).".
//
// GET /orgs/{org}/team-sync/groups
func (c *Client) TeamsListIdpGroupsForOrg(ctx context.Context, params TeamsListIdpGroupsForOrgParams) (*GroupMappingHeaders, error) {
	res, err := c.sendTeamsListIdpGroupsForOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListIdpGroupsForOrg(ctx context.Context, params TeamsListIdpGroupsForOrgParams) (res *GroupMappingHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/team-sync/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListIdpGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/team-sync/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListIdpGroupsForOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListIdpGroupsInOrg invokes teams/list-idp-groups-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (c *Client) TeamsListIdpGroupsInOrg(ctx context.Context, params TeamsListIdpGroupsInOrgParams) (*GroupMapping, error) {
	res, err := c.sendTeamsListIdpGroupsInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListIdpGroupsInOrg(ctx context.Context, params TeamsListIdpGroupsInOrgParams) (res *GroupMapping, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListIdpGroupsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/team-sync/group-mappings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListIdpGroupsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListMembersInOrg invokes teams/list-members-in-org operation.
//
// Team members will include the members of child teams.
// To list members in a team, the team must be visible to the authenticated user.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (c *Client) TeamsListMembersInOrg(ctx context.Context, params TeamsListMembersInOrgParams) (*TeamsListMembersInOrgOKHeaders, error) {
	res, err := c.sendTeamsListMembersInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListMembersInOrg(ctx context.Context, params TeamsListMembersInOrgParams) (res *TeamsListMembersInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListMembersInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "role" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Role.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListMembersInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListMembersLegacy invokes teams/list-members-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team members`](https://docs.github.
// com/rest/reference/teams#list-team-members) endpoint.
// Team members will include the members of child teams.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/members
func (c *Client) TeamsListMembersLegacy(ctx context.Context, params TeamsListMembersLegacyParams) (TeamsListMembersLegacyRes, error) {
	res, err := c.sendTeamsListMembersLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListMembersLegacy(ctx context.Context, params TeamsListMembersLegacyParams) (res TeamsListMembersLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListMembersLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "role" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Role.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListMembersLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListPendingInvitationsInOrg invokes teams/list-pending-invitations-in-org operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/invitations`.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (c *Client) TeamsListPendingInvitationsInOrg(ctx context.Context, params TeamsListPendingInvitationsInOrgParams) (*TeamsListPendingInvitationsInOrgOKHeaders, error) {
	res, err := c.sendTeamsListPendingInvitationsInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListPendingInvitationsInOrg(ctx context.Context, params TeamsListPendingInvitationsInOrgParams) (res *TeamsListPendingInvitationsInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListPendingInvitationsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListPendingInvitationsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListPendingInvitationsLegacy invokes teams/list-pending-invitations-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List pending team
// invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/invitations
func (c *Client) TeamsListPendingInvitationsLegacy(ctx context.Context, params TeamsListPendingInvitationsLegacyParams) (*TeamsListPendingInvitationsLegacyOKHeaders, error) {
	res, err := c.sendTeamsListPendingInvitationsLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListPendingInvitationsLegacy(ctx context.Context, params TeamsListPendingInvitationsLegacyParams) (res *TeamsListPendingInvitationsLegacyOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListPendingInvitationsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListPendingInvitationsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListProjectsInOrg invokes teams/list-projects-in-org operation.
//
// Lists the organization projects for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects`.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (c *Client) TeamsListProjectsInOrg(ctx context.Context, params TeamsListProjectsInOrgParams) (*TeamsListProjectsInOrgOKHeaders, error) {
	res, err := c.sendTeamsListProjectsInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListProjectsInOrg(ctx context.Context, params TeamsListProjectsInOrgParams) (res *TeamsListProjectsInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListProjectsInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListProjectsInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListProjectsLegacy invokes teams/list-projects-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team projects`](https://docs.
// github.com/rest/reference/teams#list-team-projects) endpoint.
// Lists the organization projects for a team.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/projects
func (c *Client) TeamsListProjectsLegacy(ctx context.Context, params TeamsListProjectsLegacyParams) (TeamsListProjectsLegacyRes, error) {
	res, err := c.sendTeamsListProjectsLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListProjectsLegacy(ctx context.Context, params TeamsListProjectsLegacyParams) (res TeamsListProjectsLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListProjectsLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListProjectsLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListReposInOrg invokes teams/list-repos-in-org operation.
//
// Lists a team's repositories visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos`.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (c *Client) TeamsListReposInOrg(ctx context.Context, params TeamsListReposInOrgParams) (*TeamsListReposInOrgOKHeaders, error) {
	res, err := c.sendTeamsListReposInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListReposInOrg(ctx context.Context, params TeamsListReposInOrgParams) (res *TeamsListReposInOrgOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-in-org"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListReposInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListReposInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListReposLegacy invokes teams/list-repos-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List team repositories](https://docs.
// github.com/rest/reference/teams#list-team-repositories) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/repos
func (c *Client) TeamsListReposLegacy(ctx context.Context, params TeamsListReposLegacyParams) (TeamsListReposLegacyRes, error) {
	res, err := c.sendTeamsListReposLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsListReposLegacy(ctx context.Context, params TeamsListReposLegacyParams) (res TeamsListReposLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-legacy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListReposLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsListReposLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveMemberLegacy invokes teams/remove-member-legacy operation.
//
// The "Remove team member" endpoint (described below) is deprecated.
// We recommend using the [Remove team membership for a user](https://docs.github.
// com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to
// remove both active and pending memberships.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an
// owner of the org that the team is associated with. Removing a team member does not delete the user,
//
//	it just removes them from the team.
//
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/members/{username}
func (c *Client) TeamsRemoveMemberLegacy(ctx context.Context, params TeamsRemoveMemberLegacyParams) (TeamsRemoveMemberLegacyRes, error) {
	res, err := c.sendTeamsRemoveMemberLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsRemoveMemberLegacy(ctx context.Context, params TeamsRemoveMemberLegacyParams) (res TeamsRemoveMemberLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-member-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveMemberLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveMembershipForUserInOrg invokes teams/remove-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (c *Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, params TeamsRemoveMembershipForUserInOrgParams) (TeamsRemoveMembershipForUserInOrgRes, error) {
	res, err := c.sendTeamsRemoveMembershipForUserInOrg(ctx, params)
	return res, err
}

func (c *Client) sendTeamsRemoveMembershipForUserInOrg(ctx context.Context, params TeamsRemoveMembershipForUserInOrgParams) (res TeamsRemoveMembershipForUserInOrgRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/memberships/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveMembershipForUserInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveMembershipForUserLegacy invokes teams/remove-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove team membership for a
// user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/memberships/{username}
func (c *Client) TeamsRemoveMembershipForUserLegacy(ctx context.Context, params TeamsRemoveMembershipForUserLegacyParams) (TeamsRemoveMembershipForUserLegacyRes, error) {
	res, err := c.sendTeamsRemoveMembershipForUserLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsRemoveMembershipForUserLegacy(ctx context.Context, params TeamsRemoveMembershipForUserLegacyParams) (res TeamsRemoveMembershipForUserLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/memberships/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveMembershipForUserLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveProjectInOrg invokes teams/remove-project-in-org operation.
//
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. This endpoint removes the project from the team, but does not delete the project.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (c *Client) TeamsRemoveProjectInOrg(ctx context.Context, params TeamsRemoveProjectInOrgParams) error {
	_, err := c.sendTeamsRemoveProjectInOrg(ctx, params)
	return err
}

func (c *Client) sendTeamsRemoveProjectInOrg(ctx context.Context, params TeamsRemoveProjectInOrgParams) (res *TeamsRemoveProjectInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects/{project_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveProjectInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveProjectLegacy invokes teams/remove-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a project from a
// team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/projects/{project_id}
func (c *Client) TeamsRemoveProjectLegacy(ctx context.Context, params TeamsRemoveProjectLegacyParams) (TeamsRemoveProjectLegacyRes, error) {
	res, err := c.sendTeamsRemoveProjectLegacy(ctx, params)
	return res, err
}

func (c *Client) sendTeamsRemoveProjectLegacy(ctx context.Context, params TeamsRemoveProjectLegacyParams) (res TeamsRemoveProjectLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects/{project_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveProjectLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveRepoInOrg invokes teams/remove-repo-in-org operation.
//
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team. This
// does not delete the repository, it just removes it from the team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (c *Client) TeamsRemoveRepoInOrg(ctx context.Context, params TeamsRemoveRepoInOrgParams) error {
	_, err := c.sendTeamsRemoveRepoInOrg(ctx, params)
	return err
}

func (c *Client) sendTeamsRemoveRepoInOrg(ctx context.Context, params TeamsRemoveRepoInOrgParams) (res *TeamsRemoveRepoInOrgNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-in-org"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveRepoInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveRepoLegacy invokes teams/remove-repo-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a repository from a
// team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team.
// NOTE: This does not delete the repository, it just removes it from the team.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (c *Client) TeamsRemoveRepoLegacy(ctx context.Context, params TeamsRemoveRepoLegacyParams) error {
	_, err := c.sendTeamsRemoveRepoLegacy(ctx, params)
	return err
}

func (c *Client) sendTeamsRemoveRepoLegacy(ctx context.Context, params TeamsRemoveRepoLegacyParams) (res *TeamsRemoveRepoLegacyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-legacy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos/{owner}/{repo}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsRemoveRepoLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionCommentInOrg invokes teams/update-discussion-comment-in-org operation.
//
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, request *TeamsUpdateDiscussionCommentInOrgReq, params TeamsUpdateDiscussionCommentInOrgParams) (*TeamDiscussionComment, error) {
	res, err := c.sendTeamsUpdateDiscussionCommentInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsUpdateDiscussionCommentInOrg(ctx context.Context, request *TeamsUpdateDiscussionCommentInOrgReq, params TeamsUpdateDiscussionCommentInOrgParams) (res *TeamDiscussionComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-in-org"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsUpdateDiscussionCommentInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsUpdateDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionCommentLegacy invokes teams/update-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion
// comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, request *TeamsUpdateDiscussionCommentLegacyReq, params TeamsUpdateDiscussionCommentLegacyParams) (*TeamDiscussionComment, error) {
	res, err := c.sendTeamsUpdateDiscussionCommentLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsUpdateDiscussionCommentLegacy(ctx context.Context, request *TeamsUpdateDiscussionCommentLegacyReq, params TeamsUpdateDiscussionCommentLegacyParams) (res *TeamDiscussionComment, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-legacy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsUpdateDiscussionCommentLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsUpdateDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionInOrg invokes teams/update-discussion-in-org operation.
//
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (c *Client) TeamsUpdateDiscussionInOrg(ctx context.Context, request OptTeamsUpdateDiscussionInOrgReq, params TeamsUpdateDiscussionInOrgParams) (*TeamDiscussion, error) {
	res, err := c.sendTeamsUpdateDiscussionInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsUpdateDiscussionInOrg(ctx context.Context, request OptTeamsUpdateDiscussionInOrgReq, params TeamsUpdateDiscussionInOrgParams) (res *TeamDiscussion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-in-org"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsUpdateDiscussionInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsUpdateDiscussionInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionLegacy invokes teams/update-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.
// com/rest/reference/teams#update-a-discussion) endpoint.
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (c *Client) TeamsUpdateDiscussionLegacy(ctx context.Context, request OptTeamsUpdateDiscussionLegacyReq, params TeamsUpdateDiscussionLegacyParams) (*TeamDiscussion, error) {
	res, err := c.sendTeamsUpdateDiscussionLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsUpdateDiscussionLegacy(ctx context.Context, request OptTeamsUpdateDiscussionLegacyReq, params TeamsUpdateDiscussionLegacyParams) (res *TeamDiscussion, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-legacy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsUpdateDiscussionLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsUpdateDiscussionLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateInOrg invokes teams/update-in-org operation.
//
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}`.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (c *Client) TeamsUpdateInOrg(ctx context.Context, request OptTeamsUpdateInOrgReq, params TeamsUpdateInOrgParams) (*TeamFull, error) {
	res, err := c.sendTeamsUpdateInOrg(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsUpdateInOrg(ctx context.Context, request OptTeamsUpdateInOrgReq, params TeamsUpdateInOrgParams) (res *TeamFull, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-in-org"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateInOrg",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsUpdateInOrgRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsUpdateInOrgResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateLegacy invokes teams/update-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a team](https://docs.github.
// com/rest/reference/teams#update-a-team) endpoint.
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}
func (c *Client) TeamsUpdateLegacy(ctx context.Context, request *TeamsUpdateLegacyReq, params TeamsUpdateLegacyParams) (TeamsUpdateLegacyRes, error) {
	res, err := c.sendTeamsUpdateLegacy(ctx, request, params)
	return res, err
}

func (c *Client) sendTeamsUpdateLegacy(ctx context.Context, request *TeamsUpdateLegacyReq, params TeamsUpdateLegacyParams) (res TeamsUpdateLegacyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-legacy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateLegacy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsUpdateLegacyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTeamsUpdateLegacyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersAddEmailForAuthenticated invokes users/add-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// POST /user/emails
func (c *Client) UsersAddEmailForAuthenticated(ctx context.Context, request OptUsersAddEmailForAuthenticatedReq) (UsersAddEmailForAuthenticatedRes, error) {
	res, err := c.sendUsersAddEmailForAuthenticated(ctx, request)
	return res, err
}

func (c *Client) sendUsersAddEmailForAuthenticated(ctx context.Context, request OptUsersAddEmailForAuthenticatedReq) (res UsersAddEmailForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/add-email-for-authenticated"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/emails"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersAddEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/emails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersAddEmailForAuthenticatedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersAddEmailForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBlock invokes users/block operation.
//
// Block a user.
//
// PUT /user/blocks/{username}
func (c *Client) UsersBlock(ctx context.Context, params UsersBlockParams) (UsersBlockRes, error) {
	res, err := c.sendUsersBlock(ctx, params)
	return res, err
}

func (c *Client) sendUsersBlock(ctx context.Context, params UsersBlockParams) (res UsersBlockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/block"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/blocks/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersBlock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersBlockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCheckBlocked invokes users/check-blocked operation.
//
// Check if a user is blocked by the authenticated user.
//
// GET /user/blocks/{username}
func (c *Client) UsersCheckBlocked(ctx context.Context, params UsersCheckBlockedParams) (UsersCheckBlockedRes, error) {
	res, err := c.sendUsersCheckBlocked(ctx, params)
	return res, err
}

func (c *Client) sendUsersCheckBlocked(ctx context.Context, params UsersCheckBlockedParams) (res UsersCheckBlockedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-blocked"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/blocks/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCheckBlocked",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersCheckBlockedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCheckFollowingForUser invokes users/check-following-for-user operation.
//
// Check if a user follows another user.
//
// GET /users/{username}/following/{target_user}
func (c *Client) UsersCheckFollowingForUser(ctx context.Context, params UsersCheckFollowingForUserParams) (UsersCheckFollowingForUserRes, error) {
	res, err := c.sendUsersCheckFollowingForUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersCheckFollowingForUser(ctx context.Context, params UsersCheckFollowingForUserParams) (res UsersCheckFollowingForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-following-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/following/{target_user}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCheckFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/following/"
	{
		// Encode "target_user" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "target_user",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TargetUser))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersCheckFollowingForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCheckPersonIsFollowedByAuthenticated invokes users/check-person-is-followed-by-authenticated operation.
//
// Check if a person is followed by the authenticated user.
//
// GET /user/following/{username}
func (c *Client) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, params UsersCheckPersonIsFollowedByAuthenticatedParams) (UsersCheckPersonIsFollowedByAuthenticatedRes, error) {
	res, err := c.sendUsersCheckPersonIsFollowedByAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, params UsersCheckPersonIsFollowedByAuthenticatedParams) (res UsersCheckPersonIsFollowedByAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-person-is-followed-by-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/following/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCheckPersonIsFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/following/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersCheckPersonIsFollowedByAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCreateGpgKeyForAuthenticated invokes users/create-gpg-key-for-authenticated operation.
//
// Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via
// Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/gpg_keys
func (c *Client) UsersCreateGpgKeyForAuthenticated(ctx context.Context, request *UsersCreateGpgKeyForAuthenticatedReq) (UsersCreateGpgKeyForAuthenticatedRes, error) {
	res, err := c.sendUsersCreateGpgKeyForAuthenticated(ctx, request)
	return res, err
}

func (c *Client) sendUsersCreateGpgKeyForAuthenticated(ctx context.Context, request *UsersCreateGpgKeyForAuthenticatedReq) (res UsersCreateGpgKeyForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-gpg-key-for-authenticated"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/gpg_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCreateGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/gpg_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersCreateGpgKeyForAuthenticatedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersCreateGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCreatePublicSSHKeyForAuthenticated invokes users/create-public-ssh-key-for-authenticated operation.
//
// Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/keys
func (c *Client) UsersCreatePublicSSHKeyForAuthenticated(ctx context.Context, request *UsersCreatePublicSSHKeyForAuthenticatedReq) (UsersCreatePublicSSHKeyForAuthenticatedRes, error) {
	res, err := c.sendUsersCreatePublicSSHKeyForAuthenticated(ctx, request)
	return res, err
}

func (c *Client) sendUsersCreatePublicSSHKeyForAuthenticated(ctx context.Context, request *UsersCreatePublicSSHKeyForAuthenticatedReq) (res UsersCreatePublicSSHKeyForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-public-ssh-key-for-authenticated"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/keys"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCreatePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersCreatePublicSSHKeyForAuthenticatedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersCreatePublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeleteEmailForAuthenticated invokes users/delete-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// DELETE /user/emails
func (c *Client) UsersDeleteEmailForAuthenticated(ctx context.Context, request OptUsersDeleteEmailForAuthenticatedReq) (UsersDeleteEmailForAuthenticatedRes, error) {
	res, err := c.sendUsersDeleteEmailForAuthenticated(ctx, request)
	return res, err
}

func (c *Client) sendUsersDeleteEmailForAuthenticated(ctx context.Context, request OptUsersDeleteEmailForAuthenticatedReq) (res UsersDeleteEmailForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-email-for-authenticated"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/emails"),
	}
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersDeleteEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/emails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersDeleteEmailForAuthenticatedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersDeleteEmailForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeleteGpgKeyForAuthenticated invokes users/delete-gpg-key-for-authenticated operation.
//
// Removes a GPG key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/gpg_keys/{gpg_key_id}
func (c *Client) UsersDeleteGpgKeyForAuthenticated(ctx context.Context, params UsersDeleteGpgKeyForAuthenticatedParams) (UsersDeleteGpgKeyForAuthenticatedRes, error) {
	res, err := c.sendUsersDeleteGpgKeyForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersDeleteGpgKeyForAuthenticated(ctx context.Context, params UsersDeleteGpgKeyForAuthenticatedParams) (res UsersDeleteGpgKeyForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-gpg-key-for-authenticated"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/gpg_keys/{gpg_key_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersDeleteGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/gpg_keys/"
	{
		// Encode "gpg_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gpg_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GpgKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersDeleteGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeletePublicSSHKeyForAuthenticated invokes users/delete-public-ssh-key-for-authenticated operation.
//
// Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/keys/{key_id}
func (c *Client) UsersDeletePublicSSHKeyForAuthenticated(ctx context.Context, params UsersDeletePublicSSHKeyForAuthenticatedParams) (UsersDeletePublicSSHKeyForAuthenticatedRes, error) {
	res, err := c.sendUsersDeletePublicSSHKeyForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersDeletePublicSSHKeyForAuthenticated(ctx context.Context, params UsersDeletePublicSSHKeyForAuthenticatedParams) (res UsersDeletePublicSSHKeyForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-public-ssh-key-for-authenticated"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/keys/{key_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersDeletePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersDeletePublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersFollow invokes users/follow operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with
// the `user:follow` scope.
//
// PUT /user/following/{username}
func (c *Client) UsersFollow(ctx context.Context, params UsersFollowParams) (UsersFollowRes, error) {
	res, err := c.sendUsersFollow(ctx, params)
	return res, err
}

func (c *Client) sendUsersFollow(ctx context.Context, params UsersFollowParams) (res UsersFollowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/follow"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/following/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersFollow",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/following/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersFollowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetAuthenticated invokes users/get-authenticated operation.
//
// If the authenticated user is authenticated through basic authentication or OAuth with the `user`
// scope, then the response lists public and private profile information.
// If the authenticated user is authenticated through OAuth without the `user` scope, then the
// response lists only public profile information.
//
// GET /user
func (c *Client) UsersGetAuthenticated(ctx context.Context) (UsersGetAuthenticatedRes, error) {
	res, err := c.sendUsersGetAuthenticated(ctx)
	return res, err
}

func (c *Client) sendUsersGetAuthenticated(ctx context.Context) (res UsersGetAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersGetAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetByUsername invokes users/get-by-username operation.
//
// Provides publicly available information about someone with a GitHub account.
// GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a
// user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
// authorizing users for GitHub Apps](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details
// about authentication. For an example response, see 'Response with GitHub plan information' below"
// The `email` key in the following response is the publicly visible email address from your GitHub
// [profile page](https://github.com/settings/profile). When setting up your profile, you can select
// a primary email address to be “public” which provides an email entry for this endpoint. If you
// do not set a public email address for `email`, then it will have a value of `null`. You only see
// publicly visible email addresses when authenticated with GitHub. For more information, see
// [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
// The Emails API enables you to list all of your email addresses, and toggle a primary email to be
// visible publicly. For more information, see "[Emails API](https://docs.github.
// com/rest/reference/users#emails)".
//
// GET /users/{username}
func (c *Client) UsersGetByUsername(ctx context.Context, params UsersGetByUsernameParams) (UsersGetByUsernameRes, error) {
	res, err := c.sendUsersGetByUsername(ctx, params)
	return res, err
}

func (c *Client) sendUsersGetByUsername(ctx context.Context, params UsersGetByUsernameParams) (res UsersGetByUsernameRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-by-username"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetByUsername",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersGetByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetContextForUser invokes users/get-context-for-user operation.
//
// Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
// scope. You can find out more about someone in relation to their pull requests, issues,
// repositories, and organizations.
// The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which
// returns more information than without the parameters. For example, if you wanted to find out more
// about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
// ```shell
// curl -u username:token
// https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
// ```.
//
// GET /users/{username}/hovercard
func (c *Client) UsersGetContextForUser(ctx context.Context, params UsersGetContextForUserParams) (UsersGetContextForUserRes, error) {
	res, err := c.sendUsersGetContextForUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersGetContextForUser(ctx context.Context, params UsersGetContextForUserParams) (res UsersGetContextForUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-context-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/hovercard"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetContextForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hovercard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "subject_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "subject_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SubjectType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "subject_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "subject_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SubjectID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersGetContextForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetGpgKeyForAuthenticated invokes users/get-gpg-key-for-authenticated operation.
//
// View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or
// via OAuth with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys/{gpg_key_id}
func (c *Client) UsersGetGpgKeyForAuthenticated(ctx context.Context, params UsersGetGpgKeyForAuthenticatedParams) (UsersGetGpgKeyForAuthenticatedRes, error) {
	res, err := c.sendUsersGetGpgKeyForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersGetGpgKeyForAuthenticated(ctx context.Context, params UsersGetGpgKeyForAuthenticatedParams) (res UsersGetGpgKeyForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-gpg-key-for-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/gpg_keys/{gpg_key_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/gpg_keys/"
	{
		// Encode "gpg_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gpg_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GpgKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersGetGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetPublicSSHKeyForAuthenticated invokes users/get-public-ssh-key-for-authenticated operation.
//
// View extended details for a single public SSH key. Requires that you are authenticated via Basic
// Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys/{key_id}
func (c *Client) UsersGetPublicSSHKeyForAuthenticated(ctx context.Context, params UsersGetPublicSSHKeyForAuthenticatedParams) (UsersGetPublicSSHKeyForAuthenticatedRes, error) {
	res, err := c.sendUsersGetPublicSSHKeyForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersGetPublicSSHKeyForAuthenticated(ctx context.Context, params UsersGetPublicSSHKeyForAuthenticatedParams) (res UsersGetPublicSSHKeyForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-public-ssh-key-for-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/keys/{key_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetPublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersGetPublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersList invokes users/list operation.
//
// Lists all users, in the order that they signed up on GitHub. This list includes personal user
// accounts and organization accounts.
// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of users.
//
// GET /users
func (c *Client) UsersList(ctx context.Context, params UsersListParams) (UsersListRes, error) {
	res, err := c.sendUsersList(ctx, params)
	return res, err
}

func (c *Client) sendUsersList(ctx context.Context, params UsersListParams) (res UsersListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListBlockedByAuthenticated invokes users/list-blocked-by-authenticated operation.
//
// List the users you've blocked on your personal account.
//
// GET /user/blocks
func (c *Client) UsersListBlockedByAuthenticated(ctx context.Context) (UsersListBlockedByAuthenticatedRes, error) {
	res, err := c.sendUsersListBlockedByAuthenticated(ctx)
	return res, err
}

func (c *Client) sendUsersListBlockedByAuthenticated(ctx context.Context) (res UsersListBlockedByAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-blocked-by-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/blocks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListBlockedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/blocks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListBlockedByAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListEmailsForAuthenticated invokes users/list-emails-for-authenticated operation.
//
// Lists all of your email addresses, and specifies which one is visible to the public. This endpoint
// is accessible with the `user:email` scope.
//
// GET /user/emails
func (c *Client) UsersListEmailsForAuthenticated(ctx context.Context, params UsersListEmailsForAuthenticatedParams) (UsersListEmailsForAuthenticatedRes, error) {
	res, err := c.sendUsersListEmailsForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersListEmailsForAuthenticated(ctx context.Context, params UsersListEmailsForAuthenticatedParams) (res UsersListEmailsForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-emails-for-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/emails"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/emails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListEmailsForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowedByAuthenticated invokes users/list-followed-by-authenticated operation.
//
// Lists the people who the authenticated user follows.
//
// GET /user/following
func (c *Client) UsersListFollowedByAuthenticated(ctx context.Context, params UsersListFollowedByAuthenticatedParams) (UsersListFollowedByAuthenticatedRes, error) {
	res, err := c.sendUsersListFollowedByAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersListFollowedByAuthenticated(ctx context.Context, params UsersListFollowedByAuthenticatedParams) (res UsersListFollowedByAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followed-by-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/following"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/following"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListFollowedByAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowersForAuthenticatedUser invokes users/list-followers-for-authenticated-user operation.
//
// Lists the people following the authenticated user.
//
// GET /user/followers
func (c *Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, params UsersListFollowersForAuthenticatedUserParams) (UsersListFollowersForAuthenticatedUserRes, error) {
	res, err := c.sendUsersListFollowersForAuthenticatedUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersListFollowersForAuthenticatedUser(ctx context.Context, params UsersListFollowersForAuthenticatedUserParams) (res UsersListFollowersForAuthenticatedUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-authenticated-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/followers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowersForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/followers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListFollowersForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowersForUser invokes users/list-followers-for-user operation.
//
// Lists the people following the specified user.
//
// GET /users/{username}/followers
func (c *Client) UsersListFollowersForUser(ctx context.Context, params UsersListFollowersForUserParams) (*UsersListFollowersForUserOKHeaders, error) {
	res, err := c.sendUsersListFollowersForUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersListFollowersForUser(ctx context.Context, params UsersListFollowersForUserParams) (res *UsersListFollowersForUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/followers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowersForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/followers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListFollowersForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowingForUser invokes users/list-following-for-user operation.
//
// Lists the people who the specified user follows.
//
// GET /users/{username}/following
func (c *Client) UsersListFollowingForUser(ctx context.Context, params UsersListFollowingForUserParams) (*UsersListFollowingForUserOKHeaders, error) {
	res, err := c.sendUsersListFollowingForUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersListFollowingForUser(ctx context.Context, params UsersListFollowingForUserParams) (res *UsersListFollowingForUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-following-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/following"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/following"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListFollowingForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListGpgKeysForAuthenticated invokes users/list-gpg-keys-for-authenticated operation.
//
// Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth
// with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys
func (c *Client) UsersListGpgKeysForAuthenticated(ctx context.Context, params UsersListGpgKeysForAuthenticatedParams) (UsersListGpgKeysForAuthenticatedRes, error) {
	res, err := c.sendUsersListGpgKeysForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersListGpgKeysForAuthenticated(ctx context.Context, params UsersListGpgKeysForAuthenticatedParams) (res UsersListGpgKeysForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/gpg_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListGpgKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/gpg_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListGpgKeysForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListGpgKeysForUser invokes users/list-gpg-keys-for-user operation.
//
// Lists the GPG keys for a user. This information is accessible by anyone.
//
// GET /users/{username}/gpg_keys
func (c *Client) UsersListGpgKeysForUser(ctx context.Context, params UsersListGpgKeysForUserParams) (*UsersListGpgKeysForUserOKHeaders, error) {
	res, err := c.sendUsersListGpgKeysForUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersListGpgKeysForUser(ctx context.Context, params UsersListGpgKeysForUserParams) (res *UsersListGpgKeysForUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/gpg_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListGpgKeysForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/gpg_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListGpgKeysForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListPublicEmailsForAuthenticated invokes users/list-public-emails-for-authenticated operation.
//
// Lists your publicly visible email address, which you can set with the [Set primary email
// visibility for the authenticated user](https://docs.github.
// com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This
// endpoint is accessible with the `user:email` scope.
//
// GET /user/public_emails
func (c *Client) UsersListPublicEmailsForAuthenticated(ctx context.Context, params UsersListPublicEmailsForAuthenticatedParams) (UsersListPublicEmailsForAuthenticatedRes, error) {
	res, err := c.sendUsersListPublicEmailsForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersListPublicEmailsForAuthenticated(ctx context.Context, params UsersListPublicEmailsForAuthenticatedParams) (res UsersListPublicEmailsForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-emails-for-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/public_emails"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListPublicEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/public_emails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListPublicEmailsForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListPublicKeysForUser invokes users/list-public-keys-for-user operation.
//
// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
//
// GET /users/{username}/keys
func (c *Client) UsersListPublicKeysForUser(ctx context.Context, params UsersListPublicKeysForUserParams) (*UsersListPublicKeysForUserOKHeaders, error) {
	res, err := c.sendUsersListPublicKeysForUser(ctx, params)
	return res, err
}

func (c *Client) sendUsersListPublicKeysForUser(ctx context.Context, params UsersListPublicKeysForUserParams) (res *UsersListPublicKeysForUserOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-keys-for-user"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListPublicKeysForUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListPublicKeysForUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListPublicSSHKeysForAuthenticated invokes users/list-public-ssh-keys-for-authenticated operation.
//
// Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys
func (c *Client) UsersListPublicSSHKeysForAuthenticated(ctx context.Context, params UsersListPublicSSHKeysForAuthenticatedParams) (UsersListPublicSSHKeysForAuthenticatedRes, error) {
	res, err := c.sendUsersListPublicSSHKeysForAuthenticated(ctx, params)
	return res, err
}

func (c *Client) sendUsersListPublicSSHKeysForAuthenticated(ctx context.Context, params UsersListPublicSSHKeysForAuthenticatedParams) (res UsersListPublicSSHKeysForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-ssh-keys-for-authenticated"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListPublicSSHKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersListPublicSSHKeysForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersSetPrimaryEmailVisibilityForAuthenticated invokes users/set-primary-email-visibility-for-authenticated operation.
//
// Sets the visibility for your primary email addresses.
//
// PATCH /user/email/visibility
func (c *Client) UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, request *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) (UsersSetPrimaryEmailVisibilityForAuthenticatedRes, error) {
	res, err := c.sendUsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
	return res, err
}

func (c *Client) sendUsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, request *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) (res UsersSetPrimaryEmailVisibilityForAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/set-primary-email-visibility-for-authenticated"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user/email/visibility"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersSetPrimaryEmailVisibilityForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user/email/visibility"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUnblock invokes users/unblock operation.
//
// Unblock a user.
//
// DELETE /user/blocks/{username}
func (c *Client) UsersUnblock(ctx context.Context, params UsersUnblockParams) (UsersUnblockRes, error) {
	res, err := c.sendUsersUnblock(ctx, params)
	return res, err
}

func (c *Client) sendUsersUnblock(ctx context.Context, params UsersUnblockParams) (res UsersUnblockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unblock"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/blocks/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersUnblock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersUnblockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUnfollow invokes users/unfollow operation.
//
// Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth
// with the `user:follow` scope.
//
// DELETE /user/following/{username}
func (c *Client) UsersUnfollow(ctx context.Context, params UsersUnfollowParams) (UsersUnfollowRes, error) {
	res, err := c.sendUsersUnfollow(ctx, params)
	return res, err
}

func (c *Client) sendUsersUnfollow(ctx context.Context, params UsersUnfollowParams) (res UsersUnfollowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unfollow"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/following/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersUnfollow",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/following/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersUnfollowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUpdateAuthenticated invokes users/update-authenticated operation.
//
// **Note:** If your email is set to private and you send an `email` parameter as part of this
// request to update your profile, your privacy settings are still enforced: the email address will
// not be displayed on your public profile or via the API.
//
// PATCH /user
func (c *Client) UsersUpdateAuthenticated(ctx context.Context, request OptUsersUpdateAuthenticatedReq) (UsersUpdateAuthenticatedRes, error) {
	res, err := c.sendUsersUpdateAuthenticated(ctx, request)
	return res, err
}

func (c *Client) sendUsersUpdateAuthenticated(ctx context.Context, request OptUsersUpdateAuthenticatedReq) (res UsersUpdateAuthenticatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/update-authenticated"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersUpdateAuthenticated",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersUpdateAuthenticatedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersUpdateAuthenticatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
