// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	cfg       config
	requests  syncint64.Counter
	errors    syncint64.Counter
	duration  syncint64.Histogram
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...Option) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	c := &Client{
		cfg:       newConfig(opts...),
		serverURL: u,
	}
	if c.requests, err = c.cfg.Meter.SyncInt64().Counter(otelogen.ClientRequestCount); err != nil {
		return nil, err
	}
	if c.errors, err = c.cfg.Meter.SyncInt64().Counter(otelogen.ClientErrorsCount); err != nil {
		return nil, err
	}
	if c.duration, err = c.cfg.Meter.SyncInt64().Histogram(otelogen.ClientDuration); err != nil {
		return nil, err
	}
	return c, nil
}

// ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a repository to the list of selected repositories that can access a self-hosted runner group.
// The runner group must have `visibility` set to `selected`. For more information, see "[Create a
// self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (c *Client) ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsAddSelectedRepoToOrgSecret invokes actions/add-selected-repo-to-org-secret operation.
//
// Adds a repository to an organization secret when the `visibility` for repository access is set to
// `selected`. The visibility is set when you [Create or update an organization secret](https://docs.
// github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (c *Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, params ActionsAddSelectedRepoToOrgSecretParams) (res ActionsAddSelectedRepoToOrgSecretRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-selected-repo-to-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsAddSelectedRepoToOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddSelectedRepoToOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsAddSelfHostedRunnerToGroupForOrg invokes actions/add-self-hosted-runner-to-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a self-hosted runner to a runner group configured in an organization.
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) ActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, params ActionsAddSelfHostedRunnerToGroupForOrgParams) (res ActionsAddSelfHostedRunnerToGroupForOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-self-hosted-runner-to-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsAddSelfHostedRunnerToGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddSelfHostedRunnerToGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsApproveWorkflowRun invokes actions/approve-workflow-run operation.
//
// Approves a workflow run for a pull request from a public fork of a first time contributor. For
// more information, see ["Approving workflow runs from public forks](https://docs.github.
// com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `actions:write` permission to use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (c *Client) ActionsApproveWorkflowRun(ctx context.Context, params ActionsApproveWorkflowRunParams) (res ActionsApproveWorkflowRunRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/approve-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsApproveWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/approve"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsApproveWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCancelWorkflowRun invokes actions/cancel-workflow-run operation.
//
// Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (c *Client) ActionsCancelWorkflowRun(ctx context.Context, params ActionsCancelWorkflowRunParams) (res ActionsCancelWorkflowRunAccepted, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/cancel-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCancelWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/cancel"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCancelWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateOrUpdateEnvironmentSecret invokes actions/create-or-update-environment-secret operation.
//
// Creates or updates an environment secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (c *Client) ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, request ActionsCreateOrUpdateEnvironmentSecretReq, params ActionsCreateOrUpdateEnvironmentSecretParams) (res ActionsCreateOrUpdateEnvironmentSecretRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-environment-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateOrUpdateEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsCreateOrUpdateEnvironmentSecretRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateEnvironmentSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateOrUpdateOrgSecret invokes actions/create-or-update-org-secret operation.
//
// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to
// use this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (c *Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, request ActionsCreateOrUpdateOrgSecretReq, params ActionsCreateOrUpdateOrgSecretParams) (res ActionsCreateOrUpdateOrgSecretRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateOrUpdateOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsCreateOrUpdateOrgSecretRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateOrUpdateRepoSecret invokes actions/create-or-update-repo-secret operation.
//
// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (c *Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, request ActionsCreateOrUpdateRepoSecretReq, params ActionsCreateOrUpdateRepoSecretParams) (res ActionsCreateOrUpdateRepoSecretRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-repo-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateOrUpdateRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsCreateOrUpdateRepoSecretRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateRepoSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRegistrationTokenForOrg invokes actions/create-registration-token-for-org operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/registration-token
func (c *Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, params ActionsCreateRegistrationTokenForOrgParams) (res AuthenticationToken, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRegistrationTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/registration-token"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRegistrationTokenForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRegistrationTokenForRepo invokes actions/create-registration-token-for-repo operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour. You
// must authenticate
// using an access token with the `repo` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (c *Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, params ActionsCreateRegistrationTokenForRepoParams) (res AuthenticationToken, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRegistrationTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/registration-token"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRegistrationTokenForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRemoveTokenForOrg invokes actions/create-remove-token-for-org operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// organization. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/remove-token
func (c *Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, params ActionsCreateRemoveTokenForOrgParams) (res AuthenticationToken, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRemoveTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/remove-token"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRemoveTokenForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateRemoveTokenForRepo invokes actions/create-remove-token-for-repo operation.
//
// Returns a token that you can pass to remove a self-hosted runner from a repository. The token
// expires after one hour.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided
// by this endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (c *Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, params ActionsCreateRemoveTokenForRepoParams) (res AuthenticationToken, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateRemoveTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/remove-token"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRemoveTokenForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsCreateSelfHostedRunnerGroupForOrg invokes actions/create-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Creates a new self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// POST /orgs/{org}/actions/runner-groups
func (c *Client) ActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, request ActionsCreateSelfHostedRunnerGroupForOrgReq, params ActionsCreateSelfHostedRunnerGroupForOrgParams) (res RunnerGroupsOrg, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-self-hosted-runner-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsCreateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsCreateSelfHostedRunnerGroupForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateSelfHostedRunnerGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteArtifact invokes actions/delete-artifact operation.
//
// Deletes an artifact for a workflow run. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (c *Client) ActionsDeleteArtifact(ctx context.Context, params ActionsDeleteArtifactParams) (res ActionsDeleteArtifactNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-artifact"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/artifacts/"
	{
		// Encode "artifact_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ArtifactID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteArtifactResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteEnvironmentSecret invokes actions/delete-environment-secret operation.
//
// Deletes a secret in an environment using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (c *Client) ActionsDeleteEnvironmentSecret(ctx context.Context, params ActionsDeleteEnvironmentSecretParams) (res ActionsDeleteEnvironmentSecretNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-environment-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteEnvironmentSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteOrgSecret invokes actions/delete-org-secret operation.
//
// Deletes a secret in an organization using the secret name. You must authenticate using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (c *Client) ActionsDeleteOrgSecret(ctx context.Context, params ActionsDeleteOrgSecretParams) (res ActionsDeleteOrgSecretNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteRepoSecret invokes actions/delete-repo-secret operation.
//
// Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (c *Client) ActionsDeleteRepoSecret(ctx context.Context, params ActionsDeleteRepoSecretParams) (res ActionsDeleteRepoSecretNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-repo-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteRepoSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteSelfHostedRunnerFromOrg invokes actions/delete-self-hosted-runner-from-org operation.
//
// Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (c *Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromOrgParams) (res ActionsDeleteSelfHostedRunnerFromOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteSelfHostedRunnerFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerFromOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteSelfHostedRunnerFromRepo invokes actions/delete-self-hosted-runner-from-repo operation.
//
// Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `repo`
// scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (c *Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromRepoParams) (res ActionsDeleteSelfHostedRunnerFromRepoNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteSelfHostedRunnerFromRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerFromRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteSelfHostedRunnerGroupFromOrg invokes actions/delete-self-hosted-runner-group-from-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Deletes a self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (c *Client) ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) (res ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-group-from-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteSelfHostedRunnerGroupFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteWorkflowRun invokes actions/delete-workflow-run operation.
//
// Delete a specific workflow run. Anyone with write access to the repository can use this endpoint.
// If the repository is
// private you must use an access token with the `repo` scope. GitHub Apps must have the
// `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (c *Client) ActionsDeleteWorkflowRun(ctx context.Context, params ActionsDeleteWorkflowRunParams) (res ActionsDeleteWorkflowRunNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDeleteWorkflowRunLogs invokes actions/delete-workflow-run-logs operation.
//
// Deletes all logs for a workflow run. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (c *Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, params ActionsDeleteWorkflowRunLogsParams) (res ActionsDeleteWorkflowRunLogsNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run-logs"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDeleteWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/logs"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteWorkflowRunLogsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDisableSelectedRepositoryGithubActionsOrganization invokes actions/disable-selected-repository-github-actions-organization operation.
//
// Removes a repository from the list of selected repositories that are enabled for GitHub Actions in
// an organization. To use this endpoint, the organization permission policy for
// `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (c *Client) ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) (res ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/disable-selected-repository-github-actions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDisableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDownloadArtifact invokes actions/download-artifact operation.
//
// Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look
// for `Location:` in
// the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone
// with read access to
// the repository can use this endpoint. If the repository is private you must use an access token
// with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (c *Client) ActionsDownloadArtifact(ctx context.Context, params ActionsDownloadArtifactParams) (res ActionsDownloadArtifactFound, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-artifact"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDownloadArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/artifacts/"
	{
		// Encode "artifact_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ArtifactID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "archive_format" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "archive_format",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ArchiveFormat))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadArtifactResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDownloadJobLogsForWorkflowRun invokes actions/download-job-logs-for-workflow-run operation.
//
// Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires
// after 1 minute. Look
// for `Location:` in the response header to find the URL for the download. Anyone with read access
// to the repository can
// use this endpoint. If the repository is private you must use an access token with the `repo` scope.
//  GitHub Apps must
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (c *Client) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, params ActionsDownloadJobLogsForWorkflowRunParams) (res ActionsDownloadJobLogsForWorkflowRunFound, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-job-logs-for-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDownloadJobLogsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/jobs/"
	{
		// Encode "job_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "job_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.JobID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/logs"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadJobLogsForWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsDownloadWorkflowRunLogs invokes actions/download-workflow-run-logs operation.
//
// Gets a redirect URL to download an archive of log files for a workflow run. This link expires
// after 1 minute. Look for
// `Location:` in the response header to find the URL for the download. Anyone with read access to
// the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have
// the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (c *Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, params ActionsDownloadWorkflowRunLogsParams) (res ActionsDownloadWorkflowRunLogsFound, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-workflow-run-logs"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsDownloadWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/logs"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadWorkflowRunLogsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsEnableSelectedRepositoryGithubActionsOrganization invokes actions/enable-selected-repository-github-actions-organization operation.
//
// Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an
// organization. To use this endpoint, the organization permission policy for `enabled_repositories`
// must be must be configured to `selected`. For more information, see "[Set GitHub Actions
// permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (c *Client) ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) (res ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/enable-selected-repository-github-actions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsEnableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetAllowedActionsOrganization invokes actions/get-allowed-actions-organization operation.
//
// Gets the selected actions that are allowed in an organization. To use this endpoint, the
// organization permission policy for `allowed_actions` must be configured to `selected`. For more
// information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization).""
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (c *Client) ActionsGetAllowedActionsOrganization(ctx context.Context, params ActionsGetAllowedActionsOrganizationParams) (res SelectedActions, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/selected-actions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetAllowedActionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetAllowedActionsRepository invokes actions/get-allowed-actions-repository operation.
//
// Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the
// repository policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for a
// repository](#set-github-actions-permissions-for-a-repository)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (c *Client) ActionsGetAllowedActionsRepository(ctx context.Context, params ActionsGetAllowedActionsRepositoryParams) (res SelectedActions, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-repository"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/selected-actions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetAllowedActionsRepositoryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetArtifact invokes actions/get-artifact operation.
//
// Gets a specific artifact for a workflow run. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (c *Client) ActionsGetArtifact(ctx context.Context, params ActionsGetArtifactParams) (res Artifact, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-artifact"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/artifacts/"
	{
		// Encode "artifact_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ArtifactID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetArtifactResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetEnvironmentPublicKey invokes actions/get-environment-public-key operation.
//
// Get the public key for an environment, which you need to encrypt environment secrets. You need to
// encrypt a secret before you can create or update secrets. Anyone with read access to the
// repository can use this endpoint. If the repository is private you must use an access token with
// the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (c *Client) ActionsGetEnvironmentPublicKey(ctx context.Context, params ActionsGetEnvironmentPublicKeyParams) (res ActionsPublicKey, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-public-key"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetEnvironmentPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secrets/public-key"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetEnvironmentPublicKeyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetEnvironmentSecret invokes actions/get-environment-secret operation.
//
// Gets a single environment secret without revealing its encrypted value. You must authenticate
// using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
// `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (c *Client) ActionsGetEnvironmentSecret(ctx context.Context, params ActionsGetEnvironmentSecretParams) (res ActionsSecret, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetEnvironmentSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetGithubActionsPermissionsOrganization invokes actions/get-github-actions-permissions-organization operation.
//
// Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions
func (c *Client) ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, params ActionsGetGithubActionsPermissionsOrganizationParams) (res ActionsOrganizationPermissions, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetGithubActionsPermissionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetGithubActionsPermissionsRepository invokes actions/get-github-actions-permissions-repository operation.
//
// Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is
// enabled and the actions allowed to run in the repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint. GitHub Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (c *Client) ActionsGetGithubActionsPermissionsRepository(ctx context.Context, params ActionsGetGithubActionsPermissionsRepositoryParams) (res ActionsRepositoryPermissions, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-repository"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetGithubActionsPermissionsRepositoryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetJobForWorkflowRun invokes actions/get-job-for-workflow-run operation.
//
// Gets a specific job in a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (c *Client) ActionsGetJobForWorkflowRun(ctx context.Context, params ActionsGetJobForWorkflowRunParams) (res Job, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-job-for-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetJobForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/jobs/"
	{
		// Encode "job_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "job_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.JobID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetJobForWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetOrgPublicKey invokes actions/get-org-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/public-key
func (c *Client) ActionsGetOrgPublicKey(ctx context.Context, params ActionsGetOrgPublicKeyParams) (res ActionsPublicKey, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-public-key"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetOrgPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/public-key"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetOrgPublicKeyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetOrgSecret invokes actions/get-org-secret operation.
//
// Gets a single organization secret without revealing its encrypted value. You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (c *Client) ActionsGetOrgSecret(ctx context.Context, params ActionsGetOrgSecretParams) (res OrganizationActionsSecret, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetRepoPublicKey invokes actions/get-repo-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (c *Client) ActionsGetRepoPublicKey(ctx context.Context, params ActionsGetRepoPublicKeyParams) (res ActionsPublicKey, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-public-key"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetRepoPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/public-key"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetRepoPublicKeyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetRepoSecret invokes actions/get-repo-secret operation.
//
// Gets a single repository secret without revealing its encrypted value. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
// repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (c *Client) ActionsGetRepoSecret(ctx context.Context, params ActionsGetRepoSecretParams) (res ActionsSecret, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetRepoSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetReviewsForRun invokes actions/get-reviews-for-run operation.
//
// Anyone with read access to the repository can use this endpoint. If the repository is private, you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (c *Client) ActionsGetReviewsForRun(ctx context.Context, params ActionsGetReviewsForRunParams) (res []EnvironmentApprovals, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-reviews-for-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetReviewsForRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/approvals"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetReviewsForRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetSelfHostedRunnerForOrg invokes actions/get-self-hosted-runner-for-org operation.
//
// Gets a specific self-hosted runner configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (c *Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerForOrgParams) (res Runner, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetSelfHostedRunnerForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetSelfHostedRunnerForRepo invokes actions/get-self-hosted-runner-for-repo operation.
//
// Gets a specific self-hosted runner configured in a repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (c *Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, params ActionsGetSelfHostedRunnerForRepoParams) (res Runner, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetSelfHostedRunnerForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetSelfHostedRunnerGroupForOrg invokes actions/get-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Gets a specific self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (c *Client) ActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerGroupForOrgParams) (res RunnerGroupsOrg, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetWorkflowRun invokes actions/get-workflow-run operation.
//
// Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (c *Client) ActionsGetWorkflowRun(ctx context.Context, params ActionsGetWorkflowRunParams) (res WorkflowRun, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsGetWorkflowRunUsage invokes actions/get-workflow-run-usage operation.
//
// Gets the number of billable minutes and total run time for a specific workflow run. Billable
// minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is
// listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (c *Client) ActionsGetWorkflowRunUsage(ctx context.Context, params ActionsGetWorkflowRunUsageParams) (res WorkflowRunUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run-usage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsGetWorkflowRunUsage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/timing"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetWorkflowRunUsageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListArtifactsForRepo invokes actions/list-artifacts-for-repo operation.
//
// Lists all artifacts for a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (c *Client) ActionsListArtifactsForRepo(ctx context.Context, params ActionsListArtifactsForRepoParams) (res ActionsListArtifactsForRepoOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-artifacts-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListArtifactsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/artifacts"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListArtifactsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListEnvironmentSecrets invokes actions/list-environment-secrets operation.
//
// Lists all secrets available in an environment without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (c *Client) ActionsListEnvironmentSecrets(ctx context.Context, params ActionsListEnvironmentSecretsParams) (res ActionsListEnvironmentSecretsOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-environment-secrets"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListEnvironmentSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secrets"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListEnvironmentSecretsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListJobsForWorkflowRun invokes actions/list-jobs-for-workflow-run operation.
//
// Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list
// of results. For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (c *Client) ActionsListJobsForWorkflowRun(ctx context.Context, params ActionsListJobsForWorkflowRunParams) (res ActionsListJobsForWorkflowRunOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-jobs-for-workflow-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListJobsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/jobs"

	q := u.Query()
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListJobsForWorkflowRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListOrgSecrets invokes actions/list-org-secrets operation.
//
// Lists all secrets available in an organization without revealing their encrypted values. You must
// authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps
// must have the `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets
func (c *Client) ActionsListOrgSecrets(ctx context.Context, params ActionsListOrgSecretsParams) (res ActionsListOrgSecretsOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-org-secrets"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListOrgSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListOrgSecretsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists the repositories with access to a self-hosted runner group configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (c *Client) ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRepoSecrets invokes actions/list-repo-secrets operation.
//
// Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (c *Client) ActionsListRepoSecrets(ctx context.Context, params ActionsListRepoSecretsParams) (res ActionsListRepoSecretsOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-secrets"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRepoSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoSecretsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRepoWorkflows invokes actions/list-repo-workflows operation.
//
// Lists the workflows in a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (c *Client) ActionsListRepoWorkflows(ctx context.Context, params ActionsListRepoWorkflowsParams) (res ActionsListRepoWorkflowsOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-workflows"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRepoWorkflows",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/workflows"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoWorkflowsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRunnerApplicationsForOrg invokes actions/list-runner-applications-for-org operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/downloads
func (c *Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, params ActionsListRunnerApplicationsForOrgParams) (res []RunnerApplication, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRunnerApplicationsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/downloads"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRunnerApplicationsForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListRunnerApplicationsForRepo invokes actions/list-runner-applications-for-repo operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (c *Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, params ActionsListRunnerApplicationsForRepoParams) (res []RunnerApplication, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListRunnerApplicationsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/downloads"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRunnerApplicationsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelectedReposForOrgSecret invokes actions/list-selected-repos-for-org-secret operation.
//
// Lists all repositories that have been selected when the `visibility` for repository access to a
// secret is set to `selected`. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (c *Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, params ActionsListSelectedReposForOrgSecretParams) (res ActionsListSelectedReposForOrgSecretOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repos-for-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelectedReposForOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelectedRepositoriesEnabledGithubActionsOrganization invokes actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// Lists the selected repositories that are enabled for GitHub Actions in an organization. To use
// this endpoint, the organization permission policy for `enabled_repositories` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/repositories
func (c *Client) ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) (res ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repositories-enabled-github-actions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/repositories"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnerGroupsForOrg invokes actions/list-self-hosted-runner-groups-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups
func (c *Client) ActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, params ActionsListSelfHostedRunnerGroupsForOrgParams) (res ActionsListSelfHostedRunnerGroupsForOrgOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runner-groups-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnerGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnerGroupsForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnersForOrg invokes actions/list-self-hosted-runners-for-org operation.
//
// Lists all self-hosted runners configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners
func (c *Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, params ActionsListSelfHostedRunnersForOrgParams) (res ActionsListSelfHostedRunnersForOrgOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnersForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnersForRepo invokes actions/list-self-hosted-runners-for-repo operation.
//
// Lists all self-hosted runners configured in a repository. You must authenticate using an access
// token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners
func (c *Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, params ActionsListSelfHostedRunnersForRepoParams) (res ActionsListSelfHostedRunnersForRepoOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnersForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListSelfHostedRunnersInGroupForOrg invokes actions/list-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists self-hosted runners that are in a specific organization group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) ActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, params ActionsListSelfHostedRunnersInGroupForOrgParams) (res ActionsListSelfHostedRunnersInGroupForOrgOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-in-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersInGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListWorkflowRunArtifacts invokes actions/list-workflow-run-artifacts operation.
//
// Lists artifacts for a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (c *Client) ActionsListWorkflowRunArtifacts(ctx context.Context, params ActionsListWorkflowRunArtifactsParams) (res ActionsListWorkflowRunArtifactsOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-run-artifacts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListWorkflowRunArtifacts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/artifacts"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListWorkflowRunArtifactsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsListWorkflowRunsForRepo invokes actions/list-workflow-runs-for-repo operation.
//
// Lists all workflow runs for a repository. You can use parameters to narrow the list of results.
// For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs
func (c *Client) ActionsListWorkflowRunsForRepo(ctx context.Context, params ActionsListWorkflowRunsForRepoParams) (res ActionsListWorkflowRunsForRepoOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-runs-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsListWorkflowRunsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs"

	q := u.Query()
	{
		// Encode "actor" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Actor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["actor"] = e.Result()
	}
	{
		// Encode "branch" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Branch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["branch"] = e.Result()
	}
	{
		// Encode "event" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Event.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["event"] = e.Result()
	}
	{
		// Encode "status" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["status"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "created" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Created.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["created"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsListWorkflowRunsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsReRunWorkflow invokes actions/re-run-workflow operation.
//
// **Deprecation Notice:** This endpoint is deprecated.
// We recommend migrating your existing code to use the new [retry workflow](https://docs.github.
// com/rest/reference/actions#retry-a-workflow) endpoint.
// Re-runs your workflow run using its `id`. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have
// the `actions:write` permission to use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (c *Client) ActionsReRunWorkflow(ctx context.Context, params ActionsReRunWorkflowParams) (res ActionsReRunWorkflowCreated, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/re-run-workflow"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsReRunWorkflow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/rerun"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsReRunWorkflowResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a repository from the list of selected repositories that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (c *Client) ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRemoveSelectedRepoFromOrgSecret invokes actions/remove-selected-repo-from-org-secret operation.
//
// Removes a repository from an organization secret when the `visibility` for repository access is
// set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (c *Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, params ActionsRemoveSelectedRepoFromOrgSecretParams) (res ActionsRemoveSelectedRepoFromOrgSecretRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-selected-repo-from-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRemoveSelectedRepoFromOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveSelectedRepoFromOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRemoveSelfHostedRunnerFromGroupForOrg invokes actions/remove-self-hosted-runner-from-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a self-hosted runner from a group configured in an organization. The runner is then
// returned to the default group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) (res ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-self-hosted-runner-from-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsRetryWorkflow invokes actions/retry-workflow operation.
//
// Retry your workflow run using its `id`. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (c *Client) ActionsRetryWorkflow(ctx context.Context, params ActionsRetryWorkflowParams) (res ActionsRetryWorkflowCreated, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/retry-workflow"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsRetryWorkflow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/retry"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsRetryWorkflowResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsReviewPendingDeploymentsForRun invokes actions/review-pending-deployments-for-run operation.
//
// Approve or reject pending deployments that are waiting on approval by a required reviewer.
// Anyone with read access to the repository contents and deployments can use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
func (c *Client) ActionsReviewPendingDeploymentsForRun(ctx context.Context, request ActionsReviewPendingDeploymentsForRunReq, params ActionsReviewPendingDeploymentsForRunParams) (res []Deployment, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/review-pending-deployments-for-run"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsReviewPendingDeploymentsForRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsReviewPendingDeploymentsForRunRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pending_deployments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsReviewPendingDeploymentsForRunResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetAllowedActionsOrganization invokes actions/set-allowed-actions-organization operation.
//
// Sets the actions that are allowed in an organization. To use this endpoint, the organization
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// If the organization belongs to an enterprise that has `selected` actions set at the enterprise
// level, then you cannot override any of the enterprise's allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the organization must belong to an
// enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories in the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (c *Client) ActionsSetAllowedActionsOrganization(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsOrganizationParams) (res ActionsSetAllowedActionsOrganizationNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetAllowedActionsOrganizationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/selected-actions"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetAllowedActionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetAllowedActionsRepository invokes actions/set-allowed-actions-repository operation.
//
// Sets the actions that are allowed in a repository. To use this endpoint, the repository permission
// policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set
// GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
// If the repository belongs to an organization or enterprise that has `selected` actions set at the
// organization or enterprise levels, then you cannot override any of the allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the repository must belong to an
// enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (c *Client) ActionsSetAllowedActionsRepository(ctx context.Context, request OptSelectedActions, params ActionsSetAllowedActionsRepositoryParams) (res ActionsSetAllowedActionsRepositoryNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-repository"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetAllowedActionsRepositoryRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/selected-actions"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetAllowedActionsRepositoryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetGithubActionsPermissionsOrganization invokes actions/set-github-actions-permissions-organization operation.
//
// Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// If the organization belongs to an enterprise that has set restrictive permissions at the
// enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them
// for the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions
func (c *Client) ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, request ActionsSetGithubActionsPermissionsOrganizationReq, params ActionsSetGithubActionsPermissionsOrganizationParams) (res ActionsSetGithubActionsPermissionsOrganizationNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetGithubActionsPermissionsOrganizationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetGithubActionsPermissionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetGithubActionsPermissionsRepository invokes actions/set-github-actions-permissions-repository operation.
//
// Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the
// repository.
// If the repository belongs to an organization or enterprise that has set restrictive permissions at
// the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you
// cannot override them for the repository.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (c *Client) ActionsSetGithubActionsPermissionsRepository(ctx context.Context, request ActionsSetGithubActionsPermissionsRepositoryReq, params ActionsSetGithubActionsPermissionsRepositoryParams) (res ActionsSetGithubActionsPermissionsRepositoryNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-repository"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetGithubActionsPermissionsRepositoryRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetGithubActionsPermissionsRepositoryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg invokes actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of repositories that have access to a self-hosted runner group configured in an
// organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (c *Client) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, request ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq, params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetSelectedReposForOrgSecret invokes actions/set-selected-repos-for-org-secret operation.
//
// Replaces all repositories for an organization secret when the `visibility` for repository access
// is set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (c *Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, request ActionsSetSelectedReposForOrgSecretReq, params ActionsSetSelectedReposForOrgSecretParams) (res ActionsSetSelectedReposForOrgSecretNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repos-for-org-secret"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetSelectedReposForOrgSecretRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/secrets/"
	{
		// Encode "secret_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelectedReposForOrgSecretResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization invokes actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// Replaces the list of selected repositories that are enabled for GitHub Actions in an organization.
// To use this endpoint, the organization permission policy for `enabled_repositories` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (c *Client) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, request ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq, params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) (res ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repositories-enabled-github-actions-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/repositories"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsSetSelfHostedRunnersInGroupForOrg invokes actions/set-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of self-hosted runners that are part of an organization runner group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) ActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, request ActionsSetSelfHostedRunnersInGroupForOrgReq, params ActionsSetSelfHostedRunnersInGroupForOrgParams) (res ActionsSetSelfHostedRunnersInGroupForOrgNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-self-hosted-runners-in-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsSetSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsSetSelfHostedRunnersInGroupForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelfHostedRunnersInGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionsUpdateSelfHostedRunnerGroupForOrg invokes actions/update-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Updates the `name` and `visibility` of a self-hosted runner group in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (c *Client) ActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, request ActionsUpdateSelfHostedRunnerGroupForOrgReq, params ActionsUpdateSelfHostedRunnerGroupForOrgParams) (res RunnerGroupsOrg, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/update-self-hosted-runner-group-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionsUpdateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActionsUpdateSelfHostedRunnerGroupForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityCheckRepoIsStarredByAuthenticatedUser invokes activity/check-repo-is-starred-by-authenticated-user operation.
//
// GET /user/starred/{owner}/{repo}
func (c *Client) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, params ActivityCheckRepoIsStarredByAuthenticatedUserParams) (res ActivityCheckRepoIsStarredByAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/check-repo-is-starred-by-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityCheckRepoIsStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/starred/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityDeleteRepoSubscription invokes activity/delete-repo-subscription operation.
//
// This endpoint should only be used to stop watching a repository. To control whether or not you
// wish to receive notifications from a repository, [set the repository's subscription
// manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
//
// DELETE /repos/{owner}/{repo}/subscription
func (c *Client) ActivityDeleteRepoSubscription(ctx context.Context, params ActivityDeleteRepoSubscriptionParams) (res ActivityDeleteRepoSubscriptionNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-repo-subscription"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityDeleteRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscription"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityDeleteRepoSubscriptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityDeleteThreadSubscription invokes activity/delete-thread-subscription operation.
//
// Mutes all future notifications for a conversation until you comment on the thread or get an
// **@mention**. If you are watching the repository of the thread, you will still receive
// notifications. To ignore future notifications for a repository you are watching, use the [Set a
// thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
// endpoint and set `ignore` to `true`.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (c *Client) ActivityDeleteThreadSubscription(ctx context.Context, params ActivityDeleteThreadSubscriptionParams) (res ActivityDeleteThreadSubscriptionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-thread-subscription"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityDeleteThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscription"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityDeleteThreadSubscriptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetFeeds invokes activity/get-feeds operation.
//
// GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard))
// format. The Feeds API lists all the feeds available to the authenticated user:
// *   **Timeline**: The GitHub global public timeline
// *   **User**: The public timeline for any user, using [URI template](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia)
// *   **Current user public**: The public timeline for the authenticated user
// *   **Current user**: The private timeline for the authenticated user
// *   **Current user actor**: The private timeline for activity created by the authenticated user
// *   **Current user organizations**: The private timeline for the organizations the authenticated
// user is a member of.
// *   **Security advisories**: A collection of public announcements that provide information about
// security-related vulnerabilities in software on GitHub.
// **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use
// the older, non revocable auth tokens.
//
// GET /feeds
func (c *Client) ActivityGetFeeds(ctx context.Context) (res Feed, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-feeds"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetFeeds",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/feeds"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetFeedsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetRepoSubscription invokes activity/get-repo-subscription operation.
//
// GET /repos/{owner}/{repo}/subscription
func (c *Client) ActivityGetRepoSubscription(ctx context.Context, params ActivityGetRepoSubscriptionParams) (res ActivityGetRepoSubscriptionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-repo-subscription"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscription"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetRepoSubscriptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetThread invokes activity/get-thread operation.
//
// GET /notifications/threads/{thread_id}
func (c *Client) ActivityGetThread(ctx context.Context, params ActivityGetThreadParams) (res ActivityGetThreadRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetThread",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetThreadResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityGetThreadSubscriptionForAuthenticatedUser invokes activity/get-thread-subscription-for-authenticated-user operation.
//
// This checks to see if the current user is subscribed to a thread. You can also [get a repository
// subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
// Note that subscriptions are only generated if a user is participating in a conversation--for
// example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
//
// GET /notifications/threads/{thread_id}/subscription
func (c *Client) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, params ActivityGetThreadSubscriptionForAuthenticatedUserParams) (res ActivityGetThreadSubscriptionForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread-subscription-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityGetThreadSubscriptionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscription"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListEventsForAuthenticatedUser invokes activity/list-events-for-authenticated-user operation.
//
// If you are authenticated as the given user, you will see your private events. Otherwise, you'll
// only see public events.
//
// GET /users/{username}/events
func (c *Client) ActivityListEventsForAuthenticatedUser(ctx context.Context, params ActivityListEventsForAuthenticatedUserParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-events-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListEventsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListNotificationsForAuthenticatedUser invokes activity/list-notifications-for-authenticated-user operation.
//
// List all notifications for the current user, sorted by most recently updated.
//
// GET /notifications
func (c *Client) ActivityListNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListNotificationsForAuthenticatedUserParams) (res ActivityListNotificationsForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-notifications-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/notifications"

	q := u.Query()
	{
		// Encode "all" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["all"] = e.Result()
	}
	{
		// Encode "participating" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Participating.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["participating"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "before" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["before"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListNotificationsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListOrgEventsForAuthenticatedUser invokes activity/list-org-events-for-authenticated-user operation.
//
// This is the user's organization dashboard. You must be authenticated as the user to view this.
//
// GET /users/{username}/events/orgs/{org}
func (c *Client) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, params ActivityListOrgEventsForAuthenticatedUserParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-org-events-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListOrgEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListOrgEventsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicEvents invokes activity/list-public-events operation.
//
// We delay the public events feed by five minutes, which means the most recent event returned by the
// public events API actually occurred at least five minutes ago.
//
// GET /events
func (c *Client) ActivityListPublicEvents(ctx context.Context, params ActivityListPublicEventsParams) (res ActivityListPublicEventsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicEventsForRepoNetwork invokes activity/list-public-events-for-repo-network operation.
//
// GET /networks/{owner}/{repo}/events
func (c *Client) ActivityListPublicEventsForRepoNetwork(ctx context.Context, params ActivityListPublicEventsForRepoNetworkParams) (res ActivityListPublicEventsForRepoNetworkRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-repo-network"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicEventsForRepoNetwork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/networks/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsForRepoNetworkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicEventsForUser invokes activity/list-public-events-for-user operation.
//
// GET /users/{username}/events/public
func (c *Client) ActivityListPublicEventsForUser(ctx context.Context, params ActivityListPublicEventsForUserParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events/public"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListPublicOrgEvents invokes activity/list-public-org-events operation.
//
// GET /orgs/{org}/events
func (c *Client) ActivityListPublicOrgEvents(ctx context.Context, params ActivityListPublicOrgEventsParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-org-events"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListPublicOrgEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicOrgEventsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReceivedEventsForUser invokes activity/list-received-events-for-user operation.
//
// These are events that you've received by watching repos and following users. If you are
// authenticated as the given user, you will see private events. Otherwise, you'll only see public
// events.
//
// GET /users/{username}/received_events
func (c *Client) ActivityListReceivedEventsForUser(ctx context.Context, params ActivityListReceivedEventsForUserParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-events-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReceivedEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/received_events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReceivedEventsForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReceivedPublicEventsForUser invokes activity/list-received-public-events-for-user operation.
//
// GET /users/{username}/received_events/public
func (c *Client) ActivityListReceivedPublicEventsForUser(ctx context.Context, params ActivityListReceivedPublicEventsForUserParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-public-events-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReceivedPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/received_events/public"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReceivedPublicEventsForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListRepoEvents invokes activity/list-repo-events operation.
//
// GET /repos/{owner}/{repo}/events
func (c *Client) ActivityListRepoEvents(ctx context.Context, params ActivityListRepoEventsParams) (res []Event, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-events"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListRepoEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListRepoEventsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListRepoNotificationsForAuthenticatedUser invokes activity/list-repo-notifications-for-authenticated-user operation.
//
// List all notifications for the current user.
//
// GET /repos/{owner}/{repo}/notifications
func (c *Client) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListRepoNotificationsForAuthenticatedUserParams) (res []Thread, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-notifications-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListRepoNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/notifications"

	q := u.Query()
	{
		// Encode "all" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["all"] = e.Result()
	}
	{
		// Encode "participating" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Participating.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["participating"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "before" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["before"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListRepoNotificationsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReposStarredByAuthenticatedUser invokes activity/list-repos-starred-by-authenticated-user operation.
//
// Lists repositories the authenticated user has starred.
// You can also find out _when_ stars were created by passing the following custom [media
// type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:.
//
// GET /user/starred
func (c *Client) ActivityListReposStarredByAuthenticatedUser(ctx context.Context, params ActivityListReposStarredByAuthenticatedUserParams) (res ActivityListReposStarredByAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-starred-by-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReposStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/starred"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReposStarredByAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListReposWatchedByUser invokes activity/list-repos-watched-by-user operation.
//
// Lists repositories a user is watching.
//
// GET /users/{username}/subscriptions
func (c *Client) ActivityListReposWatchedByUser(ctx context.Context, params ActivityListReposWatchedByUserParams) (res []MinimalRepository, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-watched-by-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListReposWatchedByUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscriptions"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReposWatchedByUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListWatchedReposForAuthenticatedUser invokes activity/list-watched-repos-for-authenticated-user operation.
//
// Lists repositories the authenticated user is watching.
//
// GET /user/subscriptions
func (c *Client) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, params ActivityListWatchedReposForAuthenticatedUserParams) (res ActivityListWatchedReposForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watched-repos-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListWatchedReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/subscriptions"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListWatchedReposForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityListWatchersForRepo invokes activity/list-watchers-for-repo operation.
//
// Lists the people watching the specified repository.
//
// GET /repos/{owner}/{repo}/subscribers
func (c *Client) ActivityListWatchersForRepo(ctx context.Context, params ActivityListWatchersForRepoParams) (res []SimpleUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watchers-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityListWatchersForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscribers"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityListWatchersForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityMarkNotificationsAsRead invokes activity/mark-notifications-as-read operation.
//
// Marks all notifications as "read" removes it from the [default view on GitHub](https://github.
// com/notifications). If the number of notifications is too large to complete in one request, you
// will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark
// notifications as "read." To check whether any "unread" notifications remain, you can use the [List
// notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the
// query parameter `all=false`.
//
// PUT /notifications
func (c *Client) ActivityMarkNotificationsAsRead(ctx context.Context, request OptActivityMarkNotificationsAsReadReq) (res ActivityMarkNotificationsAsReadRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-notifications-as-read"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityMarkNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActivityMarkNotificationsAsReadRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/notifications"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkNotificationsAsReadResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityMarkRepoNotificationsAsRead invokes activity/mark-repo-notifications-as-read operation.
//
// Marks all notifications in a repository as "read" removes them from the [default view on
// GitHub](https://github.com/notifications). If the number of notifications is too large to complete
// in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous
// process to mark notifications as "read." To check whether any "unread" notifications remain, you
// can use the [List repository notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and
// pass the query parameter `all=false`.
//
// PUT /repos/{owner}/{repo}/notifications
func (c *Client) ActivityMarkRepoNotificationsAsRead(ctx context.Context, request OptActivityMarkRepoNotificationsAsReadReq, params ActivityMarkRepoNotificationsAsReadParams) (res ActivityMarkRepoNotificationsAsReadRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-repo-notifications-as-read"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityMarkRepoNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActivityMarkRepoNotificationsAsReadRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/notifications"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkRepoNotificationsAsReadResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityMarkThreadAsRead invokes activity/mark-thread-as-read operation.
//
// PATCH /notifications/threads/{thread_id}
func (c *Client) ActivityMarkThreadAsRead(ctx context.Context, params ActivityMarkThreadAsReadParams) (res ActivityMarkThreadAsReadRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-thread-as-read"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityMarkThreadAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkThreadAsReadResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivitySetRepoSubscription invokes activity/set-repo-subscription operation.
//
// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore
// notifications made within a repository, set `ignored` to `true`. If you would like to stop
// watching a repository, [delete the repository's subscription](https://docs.github.
// com/rest/reference/activity#delete-a-repository-subscription) completely.
//
// PUT /repos/{owner}/{repo}/subscription
func (c *Client) ActivitySetRepoSubscription(ctx context.Context, request OptActivitySetRepoSubscriptionReq, params ActivitySetRepoSubscriptionParams) (res RepositorySubscription, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-repo-subscription"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivitySetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActivitySetRepoSubscriptionRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscription"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivitySetRepoSubscriptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivitySetThreadSubscription invokes activity/set-thread-subscription operation.
//
// If you are watching a repository, you receive notifications for all threads by default. Use this
// endpoint to ignore future notifications for threads until you comment on the thread or get an
// **@mention**.
// You can also use this endpoint to subscribe to threads that you are currently not receiving
// notifications for or to subscribed to threads that you have previously ignored.
// Unsubscribing from a conversation in a repository that you are not watching is functionally
// equivalent to the [Delete a thread subscription](https://docs.github.
// com/rest/reference/activity#delete-a-thread-subscription) endpoint.
//
// PUT /notifications/threads/{thread_id}/subscription
func (c *Client) ActivitySetThreadSubscription(ctx context.Context, request OptActivitySetThreadSubscriptionReq, params ActivitySetThreadSubscriptionParams) (res ActivitySetThreadSubscriptionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-thread-subscription"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivitySetThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeActivitySetThreadSubscriptionRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/notifications/threads/"
	{
		// Encode "thread_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ThreadID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/subscription"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivitySetThreadSubscriptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityStarRepoForAuthenticatedUser invokes activity/star-repo-for-authenticated-user operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /user/starred/{owner}/{repo}
func (c *Client) ActivityStarRepoForAuthenticatedUser(ctx context.Context, params ActivityStarRepoForAuthenticatedUserParams) (res ActivityStarRepoForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/star-repo-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityStarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/starred/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityStarRepoForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActivityUnstarRepoForAuthenticatedUser invokes activity/unstar-repo-for-authenticated-user operation.
//
// DELETE /user/starred/{owner}/{repo}
func (c *Client) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, params ActivityUnstarRepoForAuthenticatedUserParams) (res ActivityUnstarRepoForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/unstar-repo-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ActivityUnstarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/starred/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivityUnstarRepoForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsAddRepoToInstallation invokes apps/add-repo-to-installation operation.
//
// Add a single repository to an installation. The authenticated user must have admin access to the
// repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (c *Client) AppsAddRepoToInstallation(ctx context.Context, params AppsAddRepoToInstallationParams) (res AppsAddRepoToInstallationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/add-repo-to-installation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsAddRepoToInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsAddRepoToInstallationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCheckToken invokes apps/check-token operation.
//
// OAuth applications can use a special API method for checking OAuth token validity without
// exceeding the normal rate limits for failed login attempts. Authentication works differently with
// this particular endpoint. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where
// the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid
// tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token
func (c *Client) AppsCheckToken(ctx context.Context, request AppsCheckTokenReq, params AppsCheckTokenParams) (res AppsCheckTokenRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/check-token"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCheckToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsCheckTokenRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/token"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsCheckTokenResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCreateContentAttachment invokes apps/create-content-attachment operation.
//
// Creates an attachment under a content reference URL in the body or comment of an issue or pull
// request. Use the `id` and `repository` `full_name` of the content reference from the
// [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to
// create an attachment.
// The app must create a content attachment within six hours of the content reference URL being
// posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)"
// for details about content attachments.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
func (c *Client) AppsCreateContentAttachment(ctx context.Context, request AppsCreateContentAttachmentReq, params AppsCreateContentAttachmentParams) (res AppsCreateContentAttachmentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-content-attachment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCreateContentAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsCreateContentAttachmentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/content_references/"
	{
		// Encode "content_reference_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "content_reference_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ContentReferenceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/attachments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsCreateContentAttachmentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsCreateInstallationAccessToken invokes apps/create-installation-access-token operation.
//
// Creates an installation access token that enables a GitHub App to make authenticated API requests
// for the app's installation on an organization or individual account. Installation tokens expire
// one hour from the time you create them. Using an expired token produces a status code of `401 -
// Unauthorized`, and requires creating a new installation token. By default the installation token
// has access to all repositories that the installation can access. To restrict the access to
// specific repositories, you can provide the `repository_ids` when creating the token. When you omit
// `repository_ids`, the response does not contain the `repositories` key.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/installations/{installation_id}/access_tokens
func (c *Client) AppsCreateInstallationAccessToken(ctx context.Context, request OptAppsCreateInstallationAccessTokenReq, params AppsCreateInstallationAccessTokenParams) (res AppsCreateInstallationAccessTokenRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-installation-access-token"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsCreateInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsCreateInstallationAccessTokenRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/access_tokens"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsCreateInstallationAccessTokenResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsDeleteAuthorization invokes apps/delete-authorization operation.
//
// OAuth application owners can revoke a grant for their OAuth application and a specific user. You
// must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password. You
// must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's
// owner will be deleted.
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for the user. Once deleted, the application will have no access to the user's account
// and will no longer be listed on [the application authorizations settings screen within
// GitHub](https://github.com/settings/applications#authorized).
//
// DELETE /applications/{client_id}/grant
func (c *Client) AppsDeleteAuthorization(ctx context.Context, request AppsDeleteAuthorizationReq, params AppsDeleteAuthorizationParams) (res AppsDeleteAuthorizationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-authorization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsDeleteAuthorizationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/grant"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteAuthorizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsDeleteInstallation invokes apps/delete-installation operation.
//
// Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily
// suspend an app's access to your account's resources, then we recommend the "[Suspend an app
// installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}
func (c *Client) AppsDeleteInstallation(ctx context.Context, params AppsDeleteInstallationParams) (res AppsDeleteInstallationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-installation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsDeleteInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteInstallationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsDeleteToken invokes apps/delete-token operation.
//
// OAuth application owners can revoke a single token for an OAuth application. You must use [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
//
// DELETE /applications/{client_id}/token
func (c *Client) AppsDeleteToken(ctx context.Context, request AppsDeleteTokenReq, params AppsDeleteTokenParams) (res AppsDeleteTokenRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-token"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsDeleteToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsDeleteTokenRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/token"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteTokenResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetAuthenticated invokes apps/get-authenticated operation.
//
// Returns the GitHub App associated with the authentication credentials used. To see how many app
// installations are associated with this GitHub App, see the `installations_count` in the response.
// For more details about your app's installations, see the "[List installations for the
// authenticated app](https://docs.github.
// com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app
func (c *Client) AppsGetAuthenticated(ctx context.Context) (res Integration, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetBySlug invokes apps/get-by-slug operation.
//
// **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on
// the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
// If the GitHub App you specify is public, you can access this endpoint without authenticating. If
// the GitHub App you specify is private, you must authenticate with a [personal access
// token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or
// an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /apps/{app_slug}
func (c *Client) AppsGetBySlug(ctx context.Context, params AppsGetBySlugParams) (res AppsGetBySlugRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-by-slug"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetBySlug",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/apps/"
	{
		// Encode "app_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "app_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AppSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetBySlugResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetSubscriptionPlanForAccount invokes apps/get-subscription-plan-for-account operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/accounts/{account_id}
func (c *Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, params AppsGetSubscriptionPlanForAccountParams) (res AppsGetSubscriptionPlanForAccountRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetSubscriptionPlanForAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/marketplace_listing/accounts/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AccountID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetSubscriptionPlanForAccountResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetSubscriptionPlanForAccountStubbed invokes apps/get-subscription-plan-for-account-stubbed operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (c *Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, params AppsGetSubscriptionPlanForAccountStubbedParams) (res AppsGetSubscriptionPlanForAccountStubbedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account-stubbed"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetSubscriptionPlanForAccountStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/marketplace_listing/stubbed/accounts/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AccountID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetSubscriptionPlanForAccountStubbedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetWebhookConfigForApp invokes apps/get-webhook-config-for-app operation.
//
// Returns the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/config
func (c *Client) AppsGetWebhookConfigForApp(ctx context.Context) (res WebhookConfig, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-config-for-app"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/hook/config"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetWebhookConfigForAppResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsGetWebhookDelivery invokes apps/get-webhook-delivery operation.
//
// Returns a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries/{delivery_id}
func (c *Client) AppsGetWebhookDelivery(ctx context.Context, params AppsGetWebhookDeliveryParams) (res AppsGetWebhookDeliveryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-delivery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/hook/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetWebhookDeliveryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListAccountsForPlan invokes apps/list-accounts-for-plan operation.
//
// Returns user and organization accounts associated with the specified plan, including free plans.
// For per-seat pricing, you see the list of accounts that have purchased the plan, including the
// number of seats purchased. When someone submits a plan change that won't be processed until the
// end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans/{plan_id}/accounts
func (c *Client) AppsListAccountsForPlan(ctx context.Context, params AppsListAccountsForPlanParams) (res AppsListAccountsForPlanRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListAccountsForPlan",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/marketplace_listing/plans/"
	{
		// Encode "plan_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "plan_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PlanID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/accounts"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListAccountsForPlanResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListAccountsForPlanStubbed invokes apps/list-accounts-for-plan-stubbed operation.
//
// Returns repository and organization accounts associated with the specified plan, including free
// plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including
// the number of seats purchased. When someone submits a plan change that won't be processed until
// the end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (c *Client) AppsListAccountsForPlanStubbed(ctx context.Context, params AppsListAccountsForPlanStubbedParams) (res AppsListAccountsForPlanStubbedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan-stubbed"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListAccountsForPlanStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/marketplace_listing/stubbed/plans/"
	{
		// Encode "plan_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "plan_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PlanID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/accounts"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListAccountsForPlanStubbedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListInstallationReposForAuthenticatedUser invokes apps/list-installation-repos-for-authenticated-user operation.
//
// List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access for an installation.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
// You must use a [user-to-server OAuth access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
// The access the user has to each repository is included in the hash under the `permissions` key.
//
// GET /user/installations/{installation_id}/repositories
func (c *Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, params AppsListInstallationReposForAuthenticatedUserParams) (res AppsListInstallationReposForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-installation-repos-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListInstallationReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListInstallationReposForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListPlans invokes apps/list-plans operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans
func (c *Client) AppsListPlans(ctx context.Context, params AppsListPlansParams) (res AppsListPlansRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListPlans",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/marketplace_listing/plans"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListPlansResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListPlansStubbed invokes apps/list-plans-stubbed operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans
func (c *Client) AppsListPlansStubbed(ctx context.Context, params AppsListPlansStubbedParams) (res AppsListPlansStubbedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans-stubbed"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListPlansStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/marketplace_listing/stubbed/plans"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListPlansStubbedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListReposAccessibleToInstallation invokes apps/list-repos-accessible-to-installation operation.
//
// List repositories that an app installation can access.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /installation/repositories
func (c *Client) AppsListReposAccessibleToInstallation(ctx context.Context, params AppsListReposAccessibleToInstallationParams) (res AppsListReposAccessibleToInstallationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-repos-accessible-to-installation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListReposAccessibleToInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/installation/repositories"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListReposAccessibleToInstallationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListSubscriptionsForAuthenticatedUser invokes apps/list-subscriptions-for-authenticated-user operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases
func (c *Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserParams) (res AppsListSubscriptionsForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListSubscriptionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/marketplace_purchases"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListSubscriptionsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListSubscriptionsForAuthenticatedUserStubbed invokes apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases/stubbed
func (c *Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserStubbedParams) (res AppsListSubscriptionsForAuthenticatedUserStubbedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user-stubbed"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListSubscriptionsForAuthenticatedUserStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/marketplace_purchases/stubbed"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsListWebhookDeliveries invokes apps/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries
func (c *Client) AppsListWebhookDeliveries(ctx context.Context, params AppsListWebhookDeliveriesParams) (res AppsListWebhookDeliveriesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-webhook-deliveries"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/hook/deliveries"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "cursor" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["cursor"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsListWebhookDeliveriesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsRedeliverWebhookDelivery invokes apps/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/hook/deliveries/{delivery_id}/attempts
func (c *Client) AppsRedeliverWebhookDelivery(ctx context.Context, params AppsRedeliverWebhookDeliveryParams) (res AppsRedeliverWebhookDeliveryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/redeliver-webhook-delivery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/hook/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/attempts"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsRedeliverWebhookDeliveryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsRemoveRepoFromInstallation invokes apps/remove-repo-from-installation operation.
//
// Remove a single repository from an installation. The authenticated user must have admin access to
// the repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (c *Client) AppsRemoveRepoFromInstallation(ctx context.Context, params AppsRemoveRepoFromInstallationParams) (res AppsRemoveRepoFromInstallationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/remove-repo-from-installation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsRemoveRepoFromInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories/"
	{
		// Encode "repository_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsRemoveRepoFromInstallationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsResetToken invokes apps/reset-token operation.
//
// OAuth applications can use this API method to reset a valid OAuth token without end-user
// involvement. Applications must save the "token" property in the response because changes take
// effect immediately. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
// Invalid tokens will return `404 NOT FOUND`.
//
// PATCH /applications/{client_id}/token
func (c *Client) AppsResetToken(ctx context.Context, request AppsResetTokenReq, params AppsResetTokenParams) (res AppsResetTokenRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/reset-token"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsResetToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsResetTokenRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/token"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsResetTokenResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsRevokeInstallationAccessToken invokes apps/revoke-installation-access-token operation.
//
// Revokes the installation token you're using to authenticate as an installation and access this
// endpoint.
// Once an installation token is revoked, the token is invalidated and cannot be used. Other
// endpoints that require the revoked installation token must have a new installation token to work.
// You can create a new token using the "[Create an installation access token for an
// app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
// endpoint.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// DELETE /installation/token
func (c *Client) AppsRevokeInstallationAccessToken(ctx context.Context) (res AppsRevokeInstallationAccessTokenNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/revoke-installation-access-token"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsRevokeInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/installation/token"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsRevokeInstallationAccessTokenResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsScopeToken invokes apps/scope-token operation.
//
// Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission
// scoped user-to-server OAuth access token. You can specify which repositories the token can access
// and which permissions are granted to the token. You must use [Basic Authentication](https://docs.
// github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this
// endpoint, using the OAuth application's `client_id` and `client_secret` as the username and
// password. Invalid tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token/scoped
func (c *Client) AppsScopeToken(ctx context.Context, request AppsScopeTokenReq, params AppsScopeTokenParams) (res AppsScopeTokenRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/scope-token"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsScopeToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsScopeTokenRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/applications/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/token/scoped"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsScopeTokenResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsSuspendInstallation invokes apps/suspend-installation operation.
//
// Suspends a GitHub App on a user, organization, or business account, which blocks the app from
// accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub
// API or webhook events is blocked for that account.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PUT /app/installations/{installation_id}/suspended
func (c *Client) AppsSuspendInstallation(ctx context.Context, params AppsSuspendInstallationParams) (res AppsSuspendInstallationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/suspend-installation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsSuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/suspended"

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsSuspendInstallationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsUnsuspendInstallation invokes apps/unsuspend-installation operation.
//
// Removes a GitHub App installation suspension.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}/suspended
func (c *Client) AppsUnsuspendInstallation(ctx context.Context, params AppsUnsuspendInstallationParams) (res AppsUnsuspendInstallationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/unsuspend-installation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsUnsuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/app/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/suspended"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsUnsuspendInstallationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppsUpdateWebhookConfigForApp invokes apps/update-webhook-config-for-app operation.
//
// Updates the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PATCH /app/hook/config
func (c *Client) AppsUpdateWebhookConfigForApp(ctx context.Context, request OptAppsUpdateWebhookConfigForAppReq) (res WebhookConfig, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/update-webhook-config-for-app"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AppsUpdateWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeAppsUpdateWebhookConfigForAppRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/app/hook/config"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppsUpdateWebhookConfigForAppResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubActionsBillingGhe invokes billing/get-github-actions-billing-ghe operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (c *Client) BillingGetGithubActionsBillingGhe(ctx context.Context, params BillingGetGithubActionsBillingGheParams) (res ActionsBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-ghe"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubActionsBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/actions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingGheResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubActionsBillingOrg invokes billing/get-github-actions-billing-org operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/actions
func (c *Client) BillingGetGithubActionsBillingOrg(ctx context.Context, params BillingGetGithubActionsBillingOrgParams) (res ActionsBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubActionsBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/actions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubActionsBillingUser invokes billing/get-github-actions-billing-user operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/actions
func (c *Client) BillingGetGithubActionsBillingUser(ctx context.Context, params BillingGetGithubActionsBillingUserParams) (res ActionsBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubActionsBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/actions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubPackagesBillingGhe invokes billing/get-github-packages-billing-ghe operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (c *Client) BillingGetGithubPackagesBillingGhe(ctx context.Context, params BillingGetGithubPackagesBillingGheParams) (res PackagesBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-ghe"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubPackagesBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/packages"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingGheResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubPackagesBillingOrg invokes billing/get-github-packages-billing-org operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/packages
func (c *Client) BillingGetGithubPackagesBillingOrg(ctx context.Context, params BillingGetGithubPackagesBillingOrgParams) (res PackagesBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubPackagesBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/packages"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetGithubPackagesBillingUser invokes billing/get-github-packages-billing-user operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/packages
func (c *Client) BillingGetGithubPackagesBillingUser(ctx context.Context, params BillingGetGithubPackagesBillingUserParams) (res PackagesBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetGithubPackagesBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/packages"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetSharedStorageBillingGhe invokes billing/get-shared-storage-billing-ghe operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (c *Client) BillingGetSharedStorageBillingGhe(ctx context.Context, params BillingGetSharedStorageBillingGheParams) (res CombinedBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-ghe"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetSharedStorageBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/shared-storage"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingGheResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetSharedStorageBillingOrg invokes billing/get-shared-storage-billing-org operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (c *Client) BillingGetSharedStorageBillingOrg(ctx context.Context, params BillingGetSharedStorageBillingOrgParams) (res CombinedBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetSharedStorageBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/shared-storage"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BillingGetSharedStorageBillingUser invokes billing/get-shared-storage-billing-user operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/shared-storage
func (c *Client) BillingGetSharedStorageBillingUser(ctx context.Context, params BillingGetSharedStorageBillingUserParams) (res CombinedBillingUsage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BillingGetSharedStorageBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/settings/billing/shared-storage"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksCreateSuite invokes checks/create-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// By default, check suites are automatically created when you create a [check run](https://docs.
// github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually
// creating check suites when you've disabled automatic creation using "[Update repository
// preferences for check suites](https://docs.github.
// com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must
// have the `checks:write` permission to create check suites.
//
// POST /repos/{owner}/{repo}/check-suites
func (c *Client) ChecksCreateSuite(ctx context.Context, request ChecksCreateSuiteReq, params ChecksCreateSuiteParams) (res ChecksCreateSuiteRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/create-suite"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksCreateSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeChecksCreateSuiteRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-suites"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksCreateSuiteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksGet invokes checks/get operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check runs. OAuth Apps and
// authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (c *Client) ChecksGet(ctx context.Context, params ChecksGetParams) (res CheckRun, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-runs/"
	{
		// Encode "check_run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckRunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksGetSuite invokes checks/get-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check suites. OAuth Apps and
// authenticated users must have the `repo` scope to get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (c *Client) ChecksGetSuite(ctx context.Context, params ChecksGetSuiteParams) (res CheckSuite, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get-suite"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksGetSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-suites/"
	{
		// Encode "check_suite_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckSuiteID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksGetSuiteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListAnnotations invokes checks/list-annotations operation.
//
// Lists annotations for a check run using the annotation `id`. GitHub Apps must have the
// `checks:read` permission on a private repository or pull access to a public repository to get
// annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get
// annotations for a check run in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (c *Client) ChecksListAnnotations(ctx context.Context, params ChecksListAnnotationsParams) (res []CheckAnnotation, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-annotations"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListAnnotations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-runs/"
	{
		// Encode "check_run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckRunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/annotations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksListAnnotationsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListForRef invokes checks/list-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps
// must have the `checks:read` permission on a private repository or pull access to a public
// repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get
// check runs in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (c *Client) ChecksListForRef(ctx context.Context, params ChecksListForRefParams) (res ChecksListForRefOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-runs"

	q := u.Query()
	{
		// Encode "check_name" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.CheckName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["check_name"] = e.Result()
	}
	{
		// Encode "status" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["status"] = e.Result()
	}
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "app_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.AppID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["app_id"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksListForRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListForSuite invokes checks/list-for-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read`
// permission on a private repository or pull access to a public repository to get check runs. OAuth
// Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (c *Client) ChecksListForSuite(ctx context.Context, params ChecksListForSuiteParams) (res ChecksListForSuiteOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-suite"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListForSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-suites/"
	{
		// Encode "check_suite_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckSuiteID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-runs"

	q := u.Query()
	{
		// Encode "check_name" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.CheckName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["check_name"] = e.Result()
	}
	{
		// Encode "status" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["status"] = e.Result()
	}
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksListForSuiteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksListSuitesForRef invokes checks/list-suites-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub
// Apps must have the `checks:read` permission on a private repository or pull access to a public
// repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to
// get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (c *Client) ChecksListSuitesForRef(ctx context.Context, params ChecksListSuitesForRefParams) (res ChecksListSuitesForRefOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-suites-for-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksListSuitesForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-suites"

	q := u.Query()
	{
		// Encode "app_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.AppID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["app_id"] = e.Result()
	}
	{
		// Encode "check_name" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.CheckName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["check_name"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksListSuitesForRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksRerequestSuite invokes checks/rerequest-suite operation.
//
// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository.
// This endpoint will trigger the [`check_suite` webhook](https://docs.github.
// com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite
// is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
// To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private
// repository or pull access to a public repository.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (c *Client) ChecksRerequestSuite(ctx context.Context, params ChecksRerequestSuiteParams) (res ChecksRerequestSuiteCreated, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/rerequest-suite"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksRerequestSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-suites/"
	{
		// Encode "check_suite_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CheckSuiteID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/rerequest"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksRerequestSuiteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChecksSetSuitesPreferences invokes checks/set-suites-preferences operation.
//
// Changes the default automatic flow when creating check suites. By default, a check suite is
// automatically created each time code is pushed to a repository. When you disable the automatic
// creation of check suites, you can manually [Create a check suite](https://docs.github.
// com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository
// to set preferences for check suites.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (c *Client) ChecksSetSuitesPreferences(ctx context.Context, request ChecksSetSuitesPreferencesReq, params ChecksSetSuitesPreferencesParams) (res CheckSuitePreference, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/set-suites-preferences"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ChecksSetSuitesPreferences",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeChecksSetSuitesPreferencesRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/check-suites/preferences"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChecksSetSuitesPreferencesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningDeleteAnalysis invokes code-scanning/delete-analysis operation.
//
// Deletes a specified code scanning analysis from a repository. For
// private repositories, you must use an access token with the `repo` scope. For public repositories,
// you must use an access token with `public_repo` and `repo:security_events` scopes.
// GitHub Apps must have the `security_events` write permission to use this endpoint.
// You can delete one analysis at a time.
// To delete a series of analyses, start with the most recent analysis and work backwards.
// Conceptually, the process is similar to the undo function in a text editor.
// When you list the analyses for a repository,
// one or more will be identified as deletable in the response:
// ```
// "deletable": true
// ```
// An analysis is deletable when it's the most recent in a set of analyses.
// Typically, a repository will have multiple sets of analyses
// for each enabled code scanning tool,
// where a set is determined by a unique combination of analysis values:
// * `ref`
// * `tool`
// * `analysis_key`
// * `environment`
// If you attempt to delete an analysis that is not the most recent in a set,
// you'll get a 400 response with the message:
// ```
// Analysis specified is not deletable.
// ```
// The response from a successful `DELETE` operation provides you with
// two alternative URLs for deleting the next analysis in the set
// (see the example default response below).
// Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
// in the set. This is a useful option if you want to preserve at least one analysis
// for the specified tool in your repository.
// Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
// When you delete the last analysis in a set the value of `next_analysis_url` and
// `confirm_delete_url`
// in the 200 response is `null`.
// As an example of the deletion process,
// let's imagine that you added a workflow that configured a particular code scanning tool
// to analyze the code in a repository. This tool has added 15 analyses:
// 10 on the default branch, and another 5 on a topic branch.
// You therefore have two separate sets of analyses for this tool.
// You've now decided that you want to remove all of the analyses for the tool.
// To do this you must make 15 separate deletion requests.
// To start, you must find the deletable analysis for one of the sets,
// step through deleting the analyses in that set,
// and then repeat the process for the second set.
// The procedure therefore consists of a nested loop:
// **Outer loop**:
// * List the analyses for the repository, filtered by tool.
// * Parse this list to find a deletable analysis. If found:
// **Inner loop**:
// * Delete the identified analysis.
// * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next
// iteration.
// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub
// user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value.
//  Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis
// in each set undeleted to avoid removing a tool's analysis entirely.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (c *Client) CodeScanningDeleteAnalysis(ctx context.Context, params CodeScanningDeleteAnalysisParams) (res CodeScanningDeleteAnalysisRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/delete-analysis"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningDeleteAnalysis",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/analyses/"
	{
		// Encode "analysis_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "analysis_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AnalysisID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "confirm_delete" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ConfirmDelete.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["confirm_delete"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningDeleteAnalysisResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningGetAlert invokes code-scanning/get-alert operation.
//
// Gets a single code scanning alert. You must use an access token with the `security_events` scope
// to use this endpoint. GitHub Apps must have the `security_events` read permission to use this
// endpoint.
// **Deprecation notice**:
// The instances field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The same information can now be retrieved via
// a GET request to the URL specified by `instances_url`.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (c *Client) CodeScanningGetAlert(ctx context.Context, params CodeScanningGetAlertParams) (res CodeScanningGetAlertRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-alert"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetAlertResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningGetAnalysis invokes code-scanning/get-analysis operation.
//
// Gets a specified code scanning analysis for a repository.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// The default JSON response contains fields that describe the analysis.
// This includes the Git reference and commit SHA to which the analysis relates,
// the datetime of the analysis, the name of the code scanning tool,
// and the number of alerts.
// The `rules_count` field in the default response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// If you use the Accept header `application/sarif+json`,
// the response contains the analysis data that was uploaded.
// This is formatted as
// [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (c *Client) CodeScanningGetAnalysis(ctx context.Context, params CodeScanningGetAnalysisParams) (res CodeScanningGetAnalysisRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-analysis"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningGetAnalysis",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/analyses/"
	{
		// Encode "analysis_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "analysis_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AnalysisID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetAnalysisResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningGetSarif invokes code-scanning/get-sarif operation.
//
// Gets information about a SARIF upload, including the status and the URL of the analysis that was
// uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code
// scanning analysis for a
// repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You
// must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must
// have the `security_events` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (c *Client) CodeScanningGetSarif(ctx context.Context, params CodeScanningGetSarifParams) (res CodeScanningGetSarifRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-sarif"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningGetSarif",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/sarifs/"
	{
		// Encode "sarif_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sarif_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SarifID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetSarifResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningListAlertInstances invokes code-scanning/list-alert-instances operation.
//
// Lists all instances of the specified code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (c *Client) CodeScanningListAlertInstances(ctx context.Context, params CodeScanningListAlertInstancesParams) (res CodeScanningListAlertInstancesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alert-instances"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningListAlertInstances",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/instances"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "ref" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Ref.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["ref"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListAlertInstancesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningListAlertsForRepo invokes code-scanning/list-alerts-for-repo operation.
//
// Lists all open code scanning alerts for the default branch (usually `main`
// or `master`). You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` read permission to use
// this endpoint.
// The response includes a `most_recent_instance` object.
// This provides details of the most recent instance of this alert
// for the default branch or for the specified Git reference
// (if you used `ref` in the request).
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (c *Client) CodeScanningListAlertsForRepo(ctx context.Context, params CodeScanningListAlertsForRepoParams) (res CodeScanningListAlertsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alerts-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/alerts"

	q := u.Query()
	{
		// Encode "tool_name" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ToolName.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["tool_name"] = e.Result()
	}
	{
		// Encode "tool_guid" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ToolGUID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["tool_guid"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "ref" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Ref.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["ref"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListAlertsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningListRecentAnalyses invokes code-scanning/list-recent-analyses operation.
//
// Lists the details of all code scanning analyses for a repository,
// starting with the most recent.
// The response is paginated and you can use the `page` and `per_page` parameters
// to list the analyses you're interested in.
// By default 30 analyses are listed per page.
// The `rules_count` field in the response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (c *Client) CodeScanningListRecentAnalyses(ctx context.Context, params CodeScanningListRecentAnalysesParams) (res CodeScanningListRecentAnalysesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-recent-analyses"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningListRecentAnalyses",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/analyses"

	q := u.Query()
	{
		// Encode "tool_name" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ToolName.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["tool_name"] = e.Result()
	}
	{
		// Encode "tool_guid" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ToolGUID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["tool_guid"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "ref" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Ref.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["ref"] = e.Result()
	}
	{
		// Encode "sarif_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.SarifID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sarif_id"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListRecentAnalysesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningUpdateAlert invokes code-scanning/update-alert operation.
//
// Updates the status of a single code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write
// permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (c *Client) CodeScanningUpdateAlert(ctx context.Context, request CodeScanningUpdateAlertReq, params CodeScanningUpdateAlertParams) (res CodeScanningUpdateAlertRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/update-alert"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeCodeScanningUpdateAlertRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningUpdateAlertResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodeScanningUploadSarif invokes code-scanning/upload-sarif operation.
//
// Uploads SARIF data containing the results of a code scanning analysis to make the results
// available in a repository. You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
// There are two places where you can upload code scanning results.
// - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref
// refs/pull/42/head`, then the results appear as alerts in a pull request check. For more
// information, see "[Triaging code scanning alerts in pull
// requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
// - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in
// the **Security** tab for your repository. For more information, see "[Managing code scanning
// alerts for your
// repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
// You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and
// then encode it as a Base64 format string. For example:
// ```
// gzip -c analysis-data.sarif | base64 -w0
// ```
// SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are
// ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not
// necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool
// generates too many results, you should update the analysis configuration to run only the most
// important rules or queries.
// The `202 Accepted`, response includes an `id` value.
// You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}`
// endpoint.
// For more information, see "[Get information about a SARIF
// upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload).".
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (c *Client) CodeScanningUploadSarif(ctx context.Context, request CodeScanningUploadSarifReq, params CodeScanningUploadSarifParams) (res CodeScanningUploadSarifRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/upload-sarif"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodeScanningUploadSarif",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeCodeScanningUploadSarifRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/code-scanning/sarifs"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningUploadSarifResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodesOfConductGetAllCodesOfConduct invokes codes-of-conduct/get-all-codes-of-conduct operation.
//
// GET /codes_of_conduct
func (c *Client) CodesOfConductGetAllCodesOfConduct(ctx context.Context) (res CodesOfConductGetAllCodesOfConductRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-all-codes-of-conduct"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodesOfConductGetAllCodesOfConduct",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/codes_of_conduct"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodesOfConductGetAllCodesOfConductResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CodesOfConductGetConductCode invokes codes-of-conduct/get-conduct-code operation.
//
// GET /codes_of_conduct/{key}
func (c *Client) CodesOfConductGetConductCode(ctx context.Context, params CodesOfConductGetConductCodeParams) (res CodesOfConductGetConductCodeRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-conduct-code"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CodesOfConductGetConductCode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/codes_of_conduct/"
	{
		// Encode "key" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Key))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCodesOfConductGetConductCodeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EmojisGet invokes emojis/get operation.
//
// Lists all the emojis available to use on GitHub.
//
// GET /emojis
func (c *Client) EmojisGet(ctx context.Context) (res EmojisGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emojis/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EmojisGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/emojis"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEmojisGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Adds an organization to the list of selected organizations that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (c *Client) EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise invokes enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// Adds a self-hosted runner to a runner group configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise`
// scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) (res EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminCreateRegistrationTokenForEnterprise invokes enterprise-admin/create-registration-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (c *Client) EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) (res AuthenticationToken, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-registration-token-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminCreateRegistrationTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/registration-token"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminCreateRemoveTokenForEnterprise invokes enterprise-admin/create-remove-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// enterprise. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (c *Client) EnterpriseAdminCreateRemoveTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) (res AuthenticationToken, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-remove-token-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminCreateRemoveTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/remove-token"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// Creates a new self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (c *Client) EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) (res RunnerGroupsEnterprise, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-self-hosted-runner-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteScimGroupFromEnterprise invokes enterprise-admin/delete-scim-group-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminDeleteScimGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) (res EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-scim-group-from-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteScimGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise invokes enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) (res EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-from-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise invokes enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// Deletes a self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) (res EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-group-from-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDeleteUserFromEnterprise invokes enterprise-admin/delete-user-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminDeleteUserFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteUserFromEnterpriseParams) (res EnterpriseAdminDeleteUserFromEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-user-from-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDeleteUserFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteUserFromEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise invokes enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// Removes an organization from the list of selected organizations that are enabled for GitHub
// Actions in an enterprise. To use this endpoint, the enterprise permission policy for
// `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (c *Client) EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) (res EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/disable-selected-organization-github-actions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise invokes enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// Adds an organization to the list of selected organizations that are enabled for GitHub Actions in
// an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations`
// must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for
// an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (c *Client) EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) (res EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/enable-selected-organization-github-actions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetAllowedActionsEnterprise invokes enterprise-admin/get-allowed-actions-enterprise operation.
//
// Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (c *Client) EnterpriseAdminGetAllowedActionsEnterprise(ctx context.Context, params EnterpriseAdminGetAllowedActionsEnterpriseParams) (res SelectedActions, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-allowed-actions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/selected-actions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetAuditLog invokes enterprise-admin/get-audit-log operation.
//
// Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and
// you must use an access token with the `admin:enterprise` scope.
//
// GET /enterprises/{enterprise}/audit-log
func (c *Client) EnterpriseAdminGetAuditLog(ctx context.Context, params EnterpriseAdminGetAuditLogParams) (res []AuditLogEvent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-audit-log"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/audit-log"

	q := u.Query()
	{
		// Encode "phrase" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Phrase.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["phrase"] = e.Result()
	}
	{
		// Encode "include" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Include.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["include"] = e.Result()
	}
	{
		// Encode "after" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["after"] = e.Result()
	}
	{
		// Encode "before" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["before"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetAuditLogResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetGithubActionsPermissionsEnterprise invokes enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions
func (c *Client) EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx context.Context, params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) (res ActionsEnterprisePermissions, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-github-actions-permissions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetProvisioningInformationForEnterpriseGroup invokes enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-group"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "excludedAttributes" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ExcludedAttributes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["excludedAttributes"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetProvisioningInformationForEnterpriseUser invokes enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetSelfHostedRunnerForEnterprise invokes enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// Gets a specific self-hosted runner configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (c *Client) EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) (res Runner, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// Gets a specific self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (c *Client) EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) (res RunnerGroupsEnterprise, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Lists the organizations with access to a self-hosted runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (c *Client) EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/organizations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListProvisionedGroupsEnterprise invokes enterprise-admin/list-provisioned-groups-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (c *Client) EnterpriseAdminListProvisionedGroupsEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedGroupsEnterpriseParams) (res ScimGroupListEnterprise, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-groups-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListProvisionedGroupsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Groups"

	q := u.Query()
	{
		// Encode "startIndex" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.StartIndex.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["startIndex"] = e.Result()
	}
	{
		// Encode "count" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["count"] = e.Result()
	}
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "excludedAttributes" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ExcludedAttributes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["excludedAttributes"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListProvisionedIdentitiesEnterprise invokes enterprise-admin/list-provisioned-identities-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
// When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise,
// the account's metadata is immediately removed. However, the returned list of user accounts might
// not always match the organization or enterprise member list you see on GitHub. This can happen in
// certain cases where an external identity associated with an organization will not match an
// organization member:
// - When a user with a SCIM-provisioned external identity is removed from an enterprise, the
// account's metadata is preserved to allow the user to re-join the organization in the future.
// - When inviting a user to join an organization, you can expect to see their external identity in
// the results before they accept the invitation, or if the invitation is cancelled (or never
// accepted).
// - When a user is invited over SCIM, an external identity is created that matches with the
// invitee's email address. However, this identity is only linked to a user account when the user
// accepts the invitation by going through SAML SSO.
// The returned list of external identities can include an entry for a `null` user. These are
// unlinked SAML identities that are created when a user goes through the following Single Sign-On
// (SSO) process but does not sign in to their GitHub account after completing SSO:
// 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
// 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is
// not currently signed in to their GitHub account.
// 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is
// created and the user is prompted to sign in to their GitHub account:
// - If the user signs in, their GitHub account is linked to this entry.
// - If the user does not sign in (or does not create a new account when prompted), they are not
// added to the GitHub enterprise, and the external identity `null` entry remains in place.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (c *Client) EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) (res ScimUserListEnterprise, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-identities-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListProvisionedIdentitiesEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users"

	q := u.Query()
	{
		// Encode "startIndex" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.StartIndex.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["startIndex"] = e.Result()
	}
	{
		// Encode "count" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["count"] = e.Result()
	}
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListRunnerApplicationsForEnterprise invokes enterprise-admin/list-runner-applications-for-enterprise operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (c *Client) EnterpriseAdminListRunnerApplicationsForEnterprise(ctx context.Context, params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) (res []RunnerApplication, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-runner-applications-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListRunnerApplicationsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners/downloads"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise invokes enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use
// this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (c *Client) EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (res EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/organizations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise invokes enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// Lists all self-hosted runner groups for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (c *Client) EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) (res EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runner-groups-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelfHostedRunnersForEnterprise invokes enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// Lists all self-hosted runners configured for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners
func (c *Client) EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) (res EnterpriseAdminListSelfHostedRunnersForEnterpriseOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelfHostedRunnersForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runners"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise invokes enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// Lists the self-hosted runners that are in a specific enterprise group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) (res EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminProvisionAndInviteEnterpriseGroup invokes enterprise-admin/provision-and-invite-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision an enterprise group, and invite users to the group. This sends invitation emails to the
// email address of the invited users to join the GitHub organization that the SCIM group corresponds
// to.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx context.Context, request EnterpriseAdminProvisionAndInviteEnterpriseGroupReq, params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-group"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Groups"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminProvisionAndInviteEnterpriseUser invokes enterprise-admin/provision-and-invite-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision enterprise membership for a user, and send organization invitation emails to the email
// address.
// You can optionally include the groups a user will be invited to join. If you do not provide a list
// of `groups`, the user is provisioned for the enterprise, but no organization invitation emails
// will be sent.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx context.Context, request EnterpriseAdminProvisionAndInviteEnterpriseUserReq, params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminProvisionAndInviteEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Removes an organization from the list of selected organizations that can access a self-hosted
// runner group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (c *Client) EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/organizations/"
	{
		// Encode "org_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.OrgID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise invokes enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned
// to the default group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (c *Client) EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) (res EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners/"
	{
		// Encode "runner_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetAllowedActionsEnterprise invokes enterprise-admin/set-allowed-actions-enterprise operation.
//
// Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (c *Client) EnterpriseAdminSetAllowedActionsEnterprise(ctx context.Context, request SelectedActions, params EnterpriseAdminSetAllowedActionsEnterpriseParams) (res EnterpriseAdminSetAllowedActionsEnterpriseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-allowed-actions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetAllowedActionsEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/selected-actions"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetGithubActionsPermissionsEnterprise invokes enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (c *Client) EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx context.Context, request EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq, params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) (res EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-github-actions-permissions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetInformationForProvisionedEnterpriseGroup invokes enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned groups information. You must provide all the information
// required for the group as if you were provisioning it for the first time. Any existing group
// information that you don't provide will be removed, including group membership. If you want to
// only update a specific attribute, use the [Update an attribute for a SCIM enterprise
// group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx context.Context, request EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-group"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetInformationForProvisionedEnterpriseUser invokes enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned user's information. You must provide all the information required
// for the user as if you were provisioning them for the first time. Any existing user information
// that you don't provide will be removed. If you want to only update a specific attribute, use the
// [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint
// instead.
// You must at least provide the required values for the user: `userName`, `name`, and `emails`.
// **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external
// identity, and deletes the associated `{scim_user_id}`.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx context.Context, request EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq, params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise invokes enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Replaces the list of organizations that have access to a self-hosted runner configured in an
// enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (c *Client) EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, request EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq, params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/organizations"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise invokes enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise.
// To use this endpoint, the enterprise permission policy for `enabled_organizations` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (c *Client) EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, request EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq, params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (res EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/permissions/organizations"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise invokes enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// Replaces the list of self-hosted runners that are part of an enterprise runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (c *Client) EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, request EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq, params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) (res EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/runners"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminUpdateAttributeForEnterpriseGroup invokes enterprise-admin/update-attribute-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned groups individual attributes. To change a groups values,
// you must provide a specific Operations JSON format that contains at least one of the add, remove,
// or replace operations. For examples and more information on the SCIM operations format, see the
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
//
// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx context.Context, request EnterpriseAdminUpdateAttributeForEnterpriseGroupReq, params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-group"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Groups/"
	{
		// Encode "scim_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminUpdateAttributeForEnterpriseUser invokes enterprise-admin/update-attribute-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned user's individual attributes. To change a user's values, you
// must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`,
//  or `replace` operations. For examples and more information on the SCIM operations format, see the
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
// **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a
// `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
// **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example
// below), it removes the user from the enterprise, deletes the external identity, and deletes the
// associated `:scim_user_id`.
// ```
// {
// "Operations":[{
// "op":"replace",
// "value":{
// "active":false
// }
// }]
// }
// ```.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx context.Context, request EnterpriseAdminUpdateAttributeForEnterpriseUserReq, params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminUpdateAttributeForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise invokes enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (c *Client) EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, request OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq, params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) (res RunnerGroupsEnterprise, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-self-hosted-runner-group-for-enterprise"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/enterprises/"
	{
		// Encode "enterprise" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Enterprise))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/actions/runner-groups/"
	{
		// Encode "runner_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunnerGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsCheckIsStarred invokes gists/check-is-starred operation.
//
// GET /gists/{gist_id}/star
func (c *Client) GistsCheckIsStarred(ctx context.Context, params GistsCheckIsStarredParams) (res GistsCheckIsStarredRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/check-is-starred"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsCheckIsStarred",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/star"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsCheckIsStarredResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsCreate invokes gists/create operation.
//
// Allows you to add a new gist with one or more files.
// **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the
// automatic naming scheme that Gist uses internally.
//
// POST /gists
func (c *Client) GistsCreate(ctx context.Context, request GistsCreateReq) (res GistsCreateRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGistsCreateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/gists"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsCreateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsCreateComment invokes gists/create-comment operation.
//
// POST /gists/{gist_id}/comments
func (c *Client) GistsCreateComment(ctx context.Context, request GistsCreateCommentReq, params GistsCreateCommentParams) (res GistsCreateCommentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsCreateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGistsCreateCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsCreateCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsDelete invokes gists/delete operation.
//
// DELETE /gists/{gist_id}
func (c *Client) GistsDelete(ctx context.Context, params GistsDeleteParams) (res GistsDeleteRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsDeleteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsDeleteComment invokes gists/delete-comment operation.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (c *Client) GistsDeleteComment(ctx context.Context, params GistsDeleteCommentParams) (res GistsDeleteCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsDeleteComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsDeleteCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsFork invokes gists/fork operation.
//
// **Note**: This was previously `/gists/:gist_id/fork`.
//
// POST /gists/{gist_id}/forks
func (c *Client) GistsFork(ctx context.Context, params GistsForkParams) (res GistsForkRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/fork"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsFork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/forks"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsForkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsGet invokes gists/get operation.
//
// GET /gists/{gist_id}
func (c *Client) GistsGet(ctx context.Context, params GistsGetParams) (res GistsGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsGetComment invokes gists/get-comment operation.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (c *Client) GistsGetComment(ctx context.Context, params GistsGetCommentParams) (res GistsGetCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsGetComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsGetRevision invokes gists/get-revision operation.
//
// GET /gists/{gist_id}/{sha}
func (c *Client) GistsGetRevision(ctx context.Context, params GistsGetRevisionParams) (res GistsGetRevisionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-revision"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsGetRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Sha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetRevisionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsList invokes gists/list operation.
//
// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public
// gists:.
//
// GET /gists
func (c *Client) GistsList(ctx context.Context, params GistsListParams) (res GistsListRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListComments invokes gists/list-comments operation.
//
// GET /gists/{gist_id}/comments
func (c *Client) GistsListComments(ctx context.Context, params GistsListCommentsParams) (res GistsListCommentsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-comments"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListCommentsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListCommits invokes gists/list-commits operation.
//
// GET /gists/{gist_id}/commits
func (c *Client) GistsListCommits(ctx context.Context, params GistsListCommitsParams) (res GistsListCommitsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-commits"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListCommitsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListForUser invokes gists/list-for-user operation.
//
// Lists public gists for the specified user:.
//
// GET /users/{username}/gists
func (c *Client) GistsListForUser(ctx context.Context, params GistsListForUserParams) (res GistsListForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/gists"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListForks invokes gists/list-forks operation.
//
// GET /gists/{gist_id}/forks
func (c *Client) GistsListForks(ctx context.Context, params GistsListForksParams) (res GistsListForksRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-forks"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListForks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/forks"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListForksResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListPublic invokes gists/list-public operation.
//
// List public gists sorted by most recently updated to least recently updated.
// Note: With [pagination](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For
// example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
//
// GET /gists/public
func (c *Client) GistsListPublic(ctx context.Context, params GistsListPublicParams) (res GistsListPublicRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-public"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListPublic",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/public"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListPublicResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsListStarred invokes gists/list-starred operation.
//
// List the authenticated user's starred gists:.
//
// GET /gists/starred
func (c *Client) GistsListStarred(ctx context.Context, params GistsListStarredParams) (res GistsListStarredRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-starred"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsListStarred",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/starred"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsListStarredResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsStar invokes gists/star operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /gists/{gist_id}/star
func (c *Client) GistsStar(ctx context.Context, params GistsStarParams) (res GistsStarRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/star"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsStar",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/star"

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsStarResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsUnstar invokes gists/unstar operation.
//
// DELETE /gists/{gist_id}/star
func (c *Client) GistsUnstar(ctx context.Context, params GistsUnstarParams) (res GistsUnstarRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/unstar"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsUnstar",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/star"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsUnstarResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GistsUpdateComment invokes gists/update-comment operation.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (c *Client) GistsUpdateComment(ctx context.Context, request GistsUpdateCommentReq, params GistsUpdateCommentParams) (res GistsUpdateCommentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/update-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GistsUpdateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGistsUpdateCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/gists/"
	{
		// Encode "gist_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GistID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGistsUpdateCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateBlob invokes git/create-blob operation.
//
// POST /repos/{owner}/{repo}/git/blobs
func (c *Client) GitCreateBlob(ctx context.Context, request GitCreateBlobReq, params GitCreateBlobParams) (res GitCreateBlobRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-blob"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateBlob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGitCreateBlobRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/blobs"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateBlobResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateCommit invokes git/create-commit operation.
//
// Creates a new Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/commits
func (c *Client) GitCreateCommit(ctx context.Context, request GitCreateCommitReq, params GitCreateCommitParams) (res GitCreateCommitRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-commit"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGitCreateCommitRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/commits"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateCommitResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateRef invokes git/create-ref operation.
//
// Creates a reference for your repository. You are unable to create new references for empty
// repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
// without branches.
//
// POST /repos/{owner}/{repo}/git/refs
func (c *Client) GitCreateRef(ctx context.Context, request GitCreateRefReq, params GitCreateRefParams) (res GitCreateRefRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGitCreateRefRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/refs"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateTag invokes git/create-tag operation.
//
// Note that creating a tag object does not create the reference that makes a tag in Git. If you want
// to create an annotated tag in Git, you have to do this call to create the tag object, and then
// [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]`
// reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.
// com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/tags
func (c *Client) GitCreateTag(ctx context.Context, request GitCreateTagReq, params GitCreateTagParams) (res GitCreateTagRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tag"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGitCreateTagRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/tags"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateTagResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitCreateTree invokes git/create-tree operation.
//
// The tree creation API accepts nested entries. If you specify both a tree and a nested path
// modifying that tree, this endpoint will overwrite the contents of the tree with the new path
// contents, and create a new tree structure.
// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to
// commit the tree and then update a branch to point to the commit. For more information see "[Create
// a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
// reference](https://docs.github.com/rest/reference/git#update-a-reference).".
//
// POST /repos/{owner}/{repo}/git/trees
func (c *Client) GitCreateTree(ctx context.Context, request GitCreateTreeReq, params GitCreateTreeParams) (res GitCreateTreeRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tree"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitCreateTree",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGitCreateTreeRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/trees"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateTreeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitDeleteRef invokes git/delete-ref operation.
//
// DELETE /repos/{owner}/{repo}/git/refs/{ref}
func (c *Client) GitDeleteRef(ctx context.Context, params GitDeleteRefParams) (res GitDeleteRefRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/delete-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitDeleteRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/refs/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitDeleteRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetBlob invokes git/get-blob operation.
//
// The `content` in the response will always be Base64 encoded.
// _Note_: This API supports blobs up to 100 megabytes in size.
//
// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
func (c *Client) GitGetBlob(ctx context.Context, params GitGetBlobParams) (res GitGetBlobRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-blob"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetBlob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/blobs/"
	{
		// Encode "file_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "file_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FileSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitGetBlobResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetCommit invokes git/get-commit operation.
//
// Gets a Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (c *Client) GitGetCommit(ctx context.Context, params GitGetCommitParams) (res GitGetCommitRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-commit"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitGetCommitResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetRef invokes git/get-ref operation.
//
// Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
// `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an
// existing ref, a `404` is returned.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (c *Client) GitGetRef(ctx context.Context, params GitGetRefParams) (res GitGetRefRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/ref/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitGetRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetTag invokes git/get-tag operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (c *Client) GitGetTag(ctx context.Context, params GitGetTagParams) (res GitGetTagRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tag"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/tags/"
	{
		// Encode "tag_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TagSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitGetTagResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitGetTree invokes git/get-tree operation.
//
// Returns a single tree using the SHA1 value for that tree.
// If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our
// maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees,
// and fetch one sub-tree at a time.
//
// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
func (c *Client) GitGetTree(ctx context.Context, params GitGetTreeParams) (res GitGetTreeRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tree"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitGetTree",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/trees/"
	{
		// Encode "tree_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tree_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TreeSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "recursive" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Recursive.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["recursive"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitGetTreeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitListMatchingRefs invokes git/list-matching-refs operation.
//
// Returns an array of references from your Git database that match the supplied name. The `:ref` in
// the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If
// the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be
// returned as an array.
// When you use this endpoint without providing a `:ref`, it will return an array of all the
// references from your Git database, including notes and stashes if they exist on the server.
// Anything in the namespace is returned, not just `heads` and `tags`.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// If you request matching references for a branch named `feature` but the branch `feature` doesn't
// exist, the response can still include other matching head refs that start with the word `feature`,
// such as `featureA` and `featureB`.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (c *Client) GitListMatchingRefs(ctx context.Context, params GitListMatchingRefsParams) (res []GitRef, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/list-matching-refs"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitListMatchingRefs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/matching-refs/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitListMatchingRefsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitUpdateRef invokes git/update-ref operation.
//
// PATCH /repos/{owner}/{repo}/git/refs/{ref}
func (c *Client) GitUpdateRef(ctx context.Context, request GitUpdateRefReq, params GitUpdateRefParams) (res GitUpdateRefRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/update-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitUpdateRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeGitUpdateRefRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/git/refs/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitUpdateRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitignoreGetAllTemplates invokes gitignore/get-all-templates operation.
//
// List all templates available to pass as an option when [creating a repository](https://docs.github.
// com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
//
// GET /gitignore/templates
func (c *Client) GitignoreGetAllTemplates(ctx context.Context) (res GitignoreGetAllTemplatesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-all-templates"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitignoreGetAllTemplates",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gitignore/templates"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitignoreGetAllTemplatesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GitignoreGetTemplate invokes gitignore/get-template operation.
//
// The API also allows fetching the source of a single template.
// Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw
// contents.
//
// GET /gitignore/templates/{name}
func (c *Client) GitignoreGetTemplate(ctx context.Context, params GitignoreGetTemplateParams) (res GitignoreGetTemplateRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-template"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GitignoreGetTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gitignore/templates/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGitignoreGetTemplateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsRemoveRestrictionsForAuthenticatedUser invokes interactions/remove-restrictions-for-authenticated-user operation.
//
// Removes any interaction restrictions from your public repositories.
//
// DELETE /user/interaction-limits
func (c *Client) InteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context) (res InteractionsRemoveRestrictionsForAuthenticatedUserNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsRemoveRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/interaction-limits"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsRemoveRestrictionsForOrg invokes interactions/remove-restrictions-for-org operation.
//
// Removes all interaction restrictions from public repositories in the given organization. You must
// be an organization owner to remove restrictions.
//
// DELETE /orgs/{org}/interaction-limits
func (c *Client) InteractionsRemoveRestrictionsForOrg(ctx context.Context, params InteractionsRemoveRestrictionsForOrgParams) (res InteractionsRemoveRestrictionsForOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsRemoveRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/interaction-limits"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsRemoveRestrictionsForRepo invokes interactions/remove-restrictions-for-repo operation.
//
// Removes all interaction restrictions from the given repository. You must have owner or admin
// access to remove restrictions. If the interaction limit is set for the user or organization that
// owns this repository, you will receive a `409 Conflict` response and will not be able to use this
// endpoint to change the interaction limit for a single repository.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (c *Client) InteractionsRemoveRestrictionsForRepo(ctx context.Context, params InteractionsRemoveRestrictionsForRepoParams) (res InteractionsRemoveRestrictionsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsRemoveRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/interaction-limits"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsSetRestrictionsForAuthenticatedUser invokes interactions/set-restrictions-for-authenticated-user operation.
//
// Temporarily restricts which type of GitHub user can interact with your public repositories.
// Setting the interaction limit at the user level will overwrite any interaction limits that are set
// for individual repositories owned by the user.
//
// PUT /user/interaction-limits
func (c *Client) InteractionsSetRestrictionsForAuthenticatedUser(ctx context.Context, request InteractionLimit) (res InteractionsSetRestrictionsForAuthenticatedUserRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsSetRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeInteractionsSetRestrictionsForAuthenticatedUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/interaction-limits"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsSetRestrictionsForOrg invokes interactions/set-restrictions-for-org operation.
//
// Temporarily restricts interactions to a certain type of GitHub user in any public repository in
// the given organization. You must be an organization owner to set these restrictions. Setting the
// interaction limit at the organization level will overwrite any interaction limits that are set for
// individual repositories owned by the organization.
//
// PUT /orgs/{org}/interaction-limits
func (c *Client) InteractionsSetRestrictionsForOrg(ctx context.Context, request InteractionLimit, params InteractionsSetRestrictionsForOrgParams) (res InteractionsSetRestrictionsForOrgRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsSetRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeInteractionsSetRestrictionsForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/interaction-limits"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InteractionsSetRestrictionsForRepo invokes interactions/set-restrictions-for-repo operation.
//
// Temporarily restricts interactions to a certain type of GitHub user within the given repository.
// You must have owner or admin access to set these restrictions. If an interaction limit is set for
// the user or organization that owns this repository, you will receive a `409 Conflict` response and
// will not be able to use this endpoint to change the interaction limit for a single repository.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (c *Client) InteractionsSetRestrictionsForRepo(ctx context.Context, request InteractionLimit, params InteractionsSetRestrictionsForRepoParams) (res InteractionsSetRestrictionsForRepoRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "InteractionsSetRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeInteractionsSetRestrictionsForRepoRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/interaction-limits"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesAddAssignees invokes issues/add-assignees operation.
//
// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (c *Client) IssuesAddAssignees(ctx context.Context, request OptIssuesAddAssigneesReq, params IssuesAddAssigneesParams) (res IssueSimple, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/add-assignees"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesAddAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesAddAssigneesRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/assignees"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesAddAssigneesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCheckUserCanBeAssigned invokes issues/check-user-can-be-assigned operation.
//
// Checks if a user has permission to be assigned to an issue in this repository.
// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is
// returned.
// Otherwise a `404` status code is returned.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (c *Client) IssuesCheckUserCanBeAssigned(ctx context.Context, params IssuesCheckUserCanBeAssignedParams) (res IssuesCheckUserCanBeAssignedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/check-user-can-be-assigned"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCheckUserCanBeAssigned",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/assignees/"
	{
		// Encode "assignee" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "assignee",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Assignee))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCheckUserCanBeAssignedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreate invokes issues/create operation.
//
// Any user with pull access to a repository can create an issue. If [issues are disabled in the
// repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone`
// status.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues
func (c *Client) IssuesCreate(ctx context.Context, request IssuesCreateReq, params IssuesCreateParams) (res IssuesCreateRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesCreateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreateComment invokes issues/create-comment operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
func (c *Client) IssuesCreateComment(ctx context.Context, request IssuesCreateCommentReq, params IssuesCreateCommentParams) (res IssuesCreateCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesCreateCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreateLabel invokes issues/create-label operation.
//
// POST /repos/{owner}/{repo}/labels
func (c *Client) IssuesCreateLabel(ctx context.Context, request IssuesCreateLabelReq, params IssuesCreateLabelParams) (res IssuesCreateLabelRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-label"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreateLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesCreateLabelRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateLabelResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesCreateMilestone invokes issues/create-milestone operation.
//
// POST /repos/{owner}/{repo}/milestones
func (c *Client) IssuesCreateMilestone(ctx context.Context, request IssuesCreateMilestoneReq, params IssuesCreateMilestoneParams) (res IssuesCreateMilestoneRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-milestone"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesCreateMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesCreateMilestoneRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/milestones"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateMilestoneResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesDeleteComment invokes issues/delete-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (c *Client) IssuesDeleteComment(ctx context.Context, params IssuesDeleteCommentParams) (res IssuesDeleteCommentNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesDeleteComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesDeleteLabel invokes issues/delete-label operation.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (c *Client) IssuesDeleteLabel(ctx context.Context, params IssuesDeleteLabelParams) (res IssuesDeleteLabelNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-label"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesDeleteLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteLabelResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesDeleteMilestone invokes issues/delete-milestone operation.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (c *Client) IssuesDeleteMilestone(ctx context.Context, params IssuesDeleteMilestoneParams) (res IssuesDeleteMilestoneRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-milestone"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesDeleteMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteMilestoneResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGet invokes issues/get operation.
//
// The API returns a [`301 Moved Permanently` status](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
// [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to
// another repository. If
// the issue was transferred to or deleted from a repository where the authenticated user lacks read
// access, the API
// returns a `404 Not Found` status. If the issue was deleted from a repository where the
// authenticated user has read
// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted
// issues, subscribe
// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}
func (c *Client) IssuesGet(ctx context.Context, params IssuesGetParams) (res IssuesGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetComment invokes issues/get-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (c *Client) IssuesGetComment(ctx context.Context, params IssuesGetCommentParams) (res IssuesGetCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetEvent invokes issues/get-event operation.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (c *Client) IssuesGetEvent(ctx context.Context, params IssuesGetEventParams) (res IssuesGetEventRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-event"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/events/"
	{
		// Encode "event_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "event_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.EventID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetEventResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetLabel invokes issues/get-label operation.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (c *Client) IssuesGetLabel(ctx context.Context, params IssuesGetLabelParams) (res IssuesGetLabelRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-label"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetLabelResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesGetMilestone invokes issues/get-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (c *Client) IssuesGetMilestone(ctx context.Context, params IssuesGetMilestoneParams) (res IssuesGetMilestoneRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-milestone"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesGetMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetMilestoneResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesList invokes issues/list operation.
//
// List issues assigned to the authenticated user across all visible repositories including owned
// repositories, member
// repositories, and organization repositories. You can use the `filter` query parameter to fetch
// issues that are not
// necessarily assigned to you.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /issues
func (c *Client) IssuesList(ctx context.Context, params IssuesListParams) (res IssuesListRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/issues"

	q := u.Query()
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "labels" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["labels"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "collab" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Collab.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["collab"] = e.Result()
	}
	{
		// Encode "orgs" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Orgs.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["orgs"] = e.Result()
	}
	{
		// Encode "owned" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Owned.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["owned"] = e.Result()
	}
	{
		// Encode "pulls" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Pulls.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["pulls"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListAssignees invokes issues/list-assignees operation.
//
// Lists the [available assignees](https://help.github.
// com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
//
// GET /repos/{owner}/{repo}/assignees
func (c *Client) IssuesListAssignees(ctx context.Context, params IssuesListAssigneesParams) (res IssuesListAssigneesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-assignees"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/assignees"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListAssigneesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListComments invokes issues/list-comments operation.
//
// Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (c *Client) IssuesListComments(ctx context.Context, params IssuesListCommentsParams) (res IssuesListCommentsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListCommentsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListCommentsForRepo invokes issues/list-comments-for-repo operation.
//
// By default, Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/comments
func (c *Client) IssuesListCommentsForRepo(ctx context.Context, params IssuesListCommentsForRepoParams) (res IssuesListCommentsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListCommentsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListEventsForRepo invokes issues/list-events-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues/events
func (c *Client) IssuesListEventsForRepo(ctx context.Context, params IssuesListEventsForRepoParams) (res IssuesListEventsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-events-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListEventsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/events"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListEventsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListForAuthenticatedUser invokes issues/list-for-authenticated-user operation.
//
// List issues across owned and member repositories assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /user/issues
func (c *Client) IssuesListForAuthenticatedUser(ctx context.Context, params IssuesListForAuthenticatedUserParams) (res IssuesListForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/issues"

	q := u.Query()
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "labels" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["labels"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListForOrg invokes issues/list-for-org operation.
//
// List issues in an organization assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /orgs/{org}/issues
func (c *Client) IssuesListForOrg(ctx context.Context, params IssuesListForOrgParams) (res IssuesListForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues"

	q := u.Query()
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "labels" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["labels"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListForRepo invokes issues/list-for-repo operation.
//
// List issues in a repository.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues
func (c *Client) IssuesListForRepo(ctx context.Context, params IssuesListForRepoParams) (res IssuesListForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues"

	q := u.Query()
	{
		// Encode "milestone" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Milestone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["milestone"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "assignee" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Assignee.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["assignee"] = e.Result()
	}
	{
		// Encode "creator" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Creator.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["creator"] = e.Result()
	}
	{
		// Encode "mentioned" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Mentioned.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["mentioned"] = e.Result()
	}
	{
		// Encode "labels" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Labels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["labels"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListLabelsForMilestone invokes issues/list-labels-for-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (c *Client) IssuesListLabelsForMilestone(ctx context.Context, params IssuesListLabelsForMilestoneParams) (res []Label, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-milestone"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListLabelsForMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsForMilestoneResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListLabelsForRepo invokes issues/list-labels-for-repo operation.
//
// GET /repos/{owner}/{repo}/labels
func (c *Client) IssuesListLabelsForRepo(ctx context.Context, params IssuesListLabelsForRepoParams) (res IssuesListLabelsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListLabelsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListLabelsOnIssue invokes issues/list-labels-on-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (c *Client) IssuesListLabelsOnIssue(ctx context.Context, params IssuesListLabelsOnIssueParams) (res IssuesListLabelsOnIssueRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-on-issue"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListLabelsOnIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsOnIssueResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesListMilestones invokes issues/list-milestones operation.
//
// GET /repos/{owner}/{repo}/milestones
func (c *Client) IssuesListMilestones(ctx context.Context, params IssuesListMilestonesParams) (res IssuesListMilestonesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-milestones"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesListMilestones",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/milestones"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListMilestonesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesLock invokes issues/lock operation.
//
// Users with push access can lock an issue or pull request's conversation.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
func (c *Client) IssuesLock(ctx context.Context, request OptNilIssuesLockReq, params IssuesLockParams) (res IssuesLockRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/lock"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesLock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesLockRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/lock"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesLockResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesRemoveAllLabels invokes issues/remove-all-labels operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (c *Client) IssuesRemoveAllLabels(ctx context.Context, params IssuesRemoveAllLabelsParams) (res IssuesRemoveAllLabelsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-all-labels"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesRemoveAllLabels",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveAllLabelsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesRemoveAssignees invokes issues/remove-assignees operation.
//
// Removes one or more assignees from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (c *Client) IssuesRemoveAssignees(ctx context.Context, request OptIssuesRemoveAssigneesReq, params IssuesRemoveAssigneesParams) (res IssueSimple, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-assignees"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesRemoveAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesRemoveAssigneesRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/assignees"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveAssigneesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesRemoveLabel invokes issues/remove-label operation.
//
// Removes the specified label from the issue, and returns the remaining labels on the issue. This
// endpoint returns a `404 Not Found` status if the label does not exist.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (c *Client) IssuesRemoveLabel(ctx context.Context, params IssuesRemoveLabelParams) (res IssuesRemoveLabelRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-label"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesRemoveLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveLabelResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUnlock invokes issues/unlock operation.
//
// Users with push access can unlock an issue's conversation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (c *Client) IssuesUnlock(ctx context.Context, params IssuesUnlockParams) (res IssuesUnlockRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/unlock"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUnlock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/lock"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUnlockResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdate invokes issues/update operation.
//
// Issue owners and users with push access can edit an issue.
//
// PATCH /repos/{owner}/{repo}/issues/{issue_number}
func (c *Client) IssuesUpdate(ctx context.Context, request OptIssuesUpdateReq, params IssuesUpdateParams) (res IssuesUpdateRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesUpdateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdateComment invokes issues/update-comment operation.
//
// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
func (c *Client) IssuesUpdateComment(ctx context.Context, request IssuesUpdateCommentReq, params IssuesUpdateCommentParams) (res IssuesUpdateCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesUpdateCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdateLabel invokes issues/update-label operation.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (c *Client) IssuesUpdateLabel(ctx context.Context, request OptIssuesUpdateLabelReq, params IssuesUpdateLabelParams) (res Label, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-label"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdateLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesUpdateLabelRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/labels/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateLabelResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IssuesUpdateMilestone invokes issues/update-milestone operation.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (c *Client) IssuesUpdateMilestone(ctx context.Context, request OptIssuesUpdateMilestoneReq, params IssuesUpdateMilestoneParams) (res Milestone, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-milestone"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "IssuesUpdateMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeIssuesUpdateMilestoneRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/milestones/"
	{
		// Encode "milestone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MilestoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateMilestoneResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicensesGet invokes licenses/get operation.
//
// GET /licenses/{license}
func (c *Client) LicensesGet(ctx context.Context, params LicensesGetParams) (res LicensesGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "LicensesGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/licenses/"
	{
		// Encode "license" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "license",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.License))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicensesGetAllCommonlyUsed invokes licenses/get-all-commonly-used operation.
//
// GET /licenses
func (c *Client) LicensesGetAllCommonlyUsed(ctx context.Context, params LicensesGetAllCommonlyUsedParams) (res LicensesGetAllCommonlyUsedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-all-commonly-used"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "LicensesGetAllCommonlyUsed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/licenses"

	q := u.Query()
	{
		// Encode "featured" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Featured.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["featured"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetAllCommonlyUsedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicensesGetForRepo invokes licenses/get-for-repo operation.
//
// This method returns the contents of the repository's license file, if one is detected.
// Similar to [Get repository content](https://docs.github.
// com/rest/reference/repos#get-repository-content), this method also supports [custom media
// types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content
// or rendered license HTML.
//
// GET /repos/{owner}/{repo}/license
func (c *Client) LicensesGetForRepo(ctx context.Context, params LicensesGetForRepoParams) (res LicenseContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "LicensesGetForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/license"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetaGet invokes meta/get operation.
//
// Returns meta information about GitHub, including a list of GitHub's IP addresses. For more
// information, see "[About GitHub's IP addresses](https://help.github.
// com/articles/about-github-s-ip-addresses/)."
// **Note:** The IP addresses shown in the documentation's response are only example values. You must
// always query the API directly to get the latest list of IP addresses.
//
// GET /meta
func (c *Client) MetaGet(ctx context.Context) (res MetaGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MetaGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/meta"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetaRoot invokes meta/root operation.
//
// Get Hypermedia links to resources accessible in GitHub's REST API.
//
// GET /
func (c *Client) MetaRoot(ctx context.Context) (res MetaRootOK, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/root"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MetaRoot",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMetaRootResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsCancelImport invokes migrations/cancel-import operation.
//
// Stop an import for a repository.
//
// DELETE /repos/{owner}/{repo}/import
func (c *Client) MigrationsCancelImport(ctx context.Context, params MigrationsCancelImportParams) (res MigrationsCancelImportNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/cancel-import"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsCancelImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsCancelImportResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsDeleteArchiveForAuthenticatedUser invokes migrations/delete-archive-for-authenticated-user operation.
//
// Deletes a previous migration archive. Downloadable migration archives are automatically deleted
// after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.
// github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration
// status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints,
// will continue to be available even after an archive is deleted.
//
// DELETE /user/migrations/{migration_id}/archive
func (c *Client) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, params MigrationsDeleteArchiveForAuthenticatedUserParams) (res MigrationsDeleteArchiveForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsDeleteArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/archive"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDeleteArchiveForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsDeleteArchiveForOrg invokes migrations/delete-archive-for-org operation.
//
// Deletes a previous migration archive. Migration archives are automatically deleted after seven
// days.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (c *Client) MigrationsDeleteArchiveForOrg(ctx context.Context, params MigrationsDeleteArchiveForOrgParams) (res MigrationsDeleteArchiveForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsDeleteArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/archive"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDeleteArchiveForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsDownloadArchiveForOrg invokes migrations/download-archive-for-org operation.
//
// Fetches the URL to a migration archive.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (c *Client) MigrationsDownloadArchiveForOrg(ctx context.Context, params MigrationsDownloadArchiveForOrgParams) (res MigrationsDownloadArchiveForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/download-archive-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsDownloadArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/archive"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDownloadArchiveForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetArchiveForAuthenticatedUser invokes migrations/get-archive-for-authenticated-user operation.
//
// Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources
// your repository uses, the migration archive can contain JSON files with data for these objects:
// *   attachments
// *   bases
// *   commit\_comments
// *   issue\_comments
// *   issue\_events
// *   issues
// *   milestones
// *   organizations
// *   projects
// *   protected\_branches
// *   pull\_request\_reviews
// *   pull\_requests
// *   releases
// *   repositories
// *   review\_comments
// *   schema
// *   users
// The archive will also contain an `attachments` directory that includes all attachment files
// uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
//
// GET /user/migrations/{migration_id}/archive
func (c *Client) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, params MigrationsGetArchiveForAuthenticatedUserParams) (res MigrationsGetArchiveForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-archive-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/archive"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetArchiveForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetCommitAuthors invokes migrations/get-commit-authors operation.
//
// Each type of source control system represents authors in a different way. For example, a Git
// commit author has a display name and an email address, but a Subversion commit author just has a
// username. The GitHub Importer will make the author information valid, but the author might not be
// correct. For example, it will change the bare Subversion username `hubot` into something like
// `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
// This endpoint and the [Map a commit author](https://docs.github.
// com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git
// author information.
//
// GET /repos/{owner}/{repo}/import/authors
func (c *Client) MigrationsGetCommitAuthors(ctx context.Context, params MigrationsGetCommitAuthorsParams) (res MigrationsGetCommitAuthorsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-commit-authors"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetCommitAuthors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import/authors"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetCommitAuthorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetImportStatus invokes migrations/get-import-status operation.
//
// View the progress of an import.
// **Import status**
// This section includes details about the possible values of the `status` field of the Import
// Progress response.
// An import that does not have errors will progress through these steps:
// *   `detecting` - the "detection" step of the import is in progress because the request did not
// include a `vcs` parameter. The import is identifying the type of source control present at the URL.
// *   `importing` - the "raw" step of the import is in progress. This is where commit data is
// fetched from the original repository. The import progress response will include `commit_count`
// (the total number of raw commits that will be imported) and `percent` (0 - 100, the current
// progress through the import).
// *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are
// converted to Git branches, and where author updates are applied. The import progress response does
// not include progress information.
// *   `pushing` - the "push" step of the import is in progress. This is where the importer updates
// the repository on GitHub. The import progress response will include `push_percent`, which is the
// percent value reported by `git push` when it is "Writing objects".
// *   `complete` - the import is complete, and the repository is ready on GitHub.
// If there are problems, you will see one of these in the `status` field:
// *   `auth_failed` - the import requires authentication in order to connect to the original
// repository. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `error` - the import encountered an error. The import progress response will include the
// `failed_step` and an error message. Contact [GitHub Support](https://support.github.
// com/contact?tags=dotcom-rest-api) for more information.
// *   `detection_needs_auth` - the importer requires authentication for the originating repository
// to continue detection. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
// resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import)
// and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
// URL.
// *   `detection_found_multiple` - the importer found several projects or repositories at the
// provided URL. When this is the case, the Import Progress response will also include a
// `project_choices` field with the possible project choices as values. To update project choice,
// please see the [Update an import](https://docs.github.
// com/rest/reference/migrations#update-an-import) section.
// **The project_choices field**
// When multiple projects are found at the provided URL, the response hash will include a
// `project_choices` field, the value of which is an array of hashes each representing a project
// choice. The exact key/value pairs of the project hashes will differ depending on the version
// control type.
// **Git LFS related fields**
// This section includes details about Git LFS related fields that may be present in the Import
// Progress response.
// *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
// can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
// *   `has_large_files` - the boolean value describing whether files larger than 100MB were found
// during the `importing` step.
// *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the
// originating repository.
// *   `large_files_count` - the total number of files larger than 100MB found in the originating
// repository. To see a list of these files, make a "Get Large Files" request.
//
// GET /repos/{owner}/{repo}/import
func (c *Client) MigrationsGetImportStatus(ctx context.Context, params MigrationsGetImportStatusParams) (res MigrationsGetImportStatusRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-import-status"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetImportStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetImportStatusResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetLargeFiles invokes migrations/get-large-files operation.
//
// List files larger than 100MB found during the import.
//
// GET /repos/{owner}/{repo}/import/large_files
func (c *Client) MigrationsGetLargeFiles(ctx context.Context, params MigrationsGetLargeFilesParams) (res []PorterLargeFile, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-large-files"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetLargeFiles",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import/large_files"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetLargeFilesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetStatusForAuthenticatedUser invokes migrations/get-status-for-authenticated-user operation.
//
// Fetches a single user migration. The response includes the `state` of the migration, which can be
// one of the following values:
// *   `pending` - the migration hasn't started yet.
// *   `exporting` - the migration is in progress.
// *   `exported` - the migration finished successfully.
// *   `failed` - the migration failed.
// Once the migration has been `exported` you can [download the migration archive](https://docs.
// github.com/rest/reference/migrations#download-a-user-migration-archive).
//
// GET /user/migrations/{migration_id}
func (c *Client) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, params MigrationsGetStatusForAuthenticatedUserParams) (res MigrationsGetStatusForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetStatusForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "exclude" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Exclude {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["exclude"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetStatusForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsGetStatusForOrg invokes migrations/get-status-for-org operation.
//
// Fetches the status of a migration.
// The `state` of a migration can be one of the following values:
// *   `pending`, which means the migration hasn't started yet.
// *   `exporting`, which means the migration is in progress.
// *   `exported`, which means the migration finished successfully.
// *   `failed`, which means the migration failed.
//
// GET /orgs/{org}/migrations/{migration_id}
func (c *Client) MigrationsGetStatusForOrg(ctx context.Context, params MigrationsGetStatusForOrgParams) (res MigrationsGetStatusForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsGetStatusForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "exclude" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Exclude {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["exclude"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetStatusForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListForAuthenticatedUser invokes migrations/list-for-authenticated-user operation.
//
// Lists all migrations a user has started.
//
// GET /user/migrations
func (c *Client) MigrationsListForAuthenticatedUser(ctx context.Context, params MigrationsListForAuthenticatedUserParams) (res MigrationsListForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListForOrg invokes migrations/list-for-org operation.
//
// Lists the most recent migrations.
//
// GET /orgs/{org}/migrations
func (c *Client) MigrationsListForOrg(ctx context.Context, params MigrationsListForOrgParams) (res []Migration, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "exclude" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Exclude {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["exclude"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListReposForOrg invokes migrations/list-repos-for-org operation.
//
// List all the repositories for this organization migration.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (c *Client) MigrationsListReposForOrg(ctx context.Context, params MigrationsListReposForOrgParams) (res MigrationsListReposForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListReposForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListReposForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsListReposForUser invokes migrations/list-repos-for-user operation.
//
// Lists all the repositories for this user migration.
//
// GET /user/migrations/{migration_id}/repositories
func (c *Client) MigrationsListReposForUser(ctx context.Context, params MigrationsListReposForUserParams) (res MigrationsListReposForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsListReposForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repositories"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListReposForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsMapCommitAuthor invokes migrations/map-commit-author operation.
//
// Update an author's identity for the import. Your application can continue updating authors any
// time before you push new commits to the repository.
//
// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
func (c *Client) MigrationsMapCommitAuthor(ctx context.Context, request OptMigrationsMapCommitAuthorReq, params MigrationsMapCommitAuthorParams) (res MigrationsMapCommitAuthorRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/map-commit-author"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsMapCommitAuthor",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeMigrationsMapCommitAuthorRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import/authors/"
	{
		// Encode "author_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "author_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsMapCommitAuthorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsSetLfsPreference invokes migrations/set-lfs-preference operation.
//
// You can import repositories from Subversion, Mercurial, and TFS that include files larger than
// 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about
// our LFS feature and working with large files [on our help site](https://help.github.
// com/articles/versioning-large-files/).
//
// PATCH /repos/{owner}/{repo}/import/lfs
func (c *Client) MigrationsSetLfsPreference(ctx context.Context, request MigrationsSetLfsPreferenceReq, params MigrationsSetLfsPreferenceParams) (res MigrationsSetLfsPreferenceRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/set-lfs-preference"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsSetLfsPreference",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeMigrationsSetLfsPreferenceRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import/lfs"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsSetLfsPreferenceResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsStartForAuthenticatedUser invokes migrations/start-for-authenticated-user operation.
//
// Initiates the generation of a user migration archive.
//
// POST /user/migrations
func (c *Client) MigrationsStartForAuthenticatedUser(ctx context.Context, request MigrationsStartForAuthenticatedUserReq) (res MigrationsStartForAuthenticatedUserRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsStartForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeMigrationsStartForAuthenticatedUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsStartForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsStartForOrg invokes migrations/start-for-org operation.
//
// Initiates the generation of a migration archive.
//
// POST /orgs/{org}/migrations
func (c *Client) MigrationsStartForOrg(ctx context.Context, request MigrationsStartForOrgReq, params MigrationsStartForOrgParams) (res MigrationsStartForOrgRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsStartForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeMigrationsStartForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsStartForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsStartImport invokes migrations/start-import operation.
//
// Start a source import to a GitHub repository using GitHub Importer.
//
// PUT /repos/{owner}/{repo}/import
func (c *Client) MigrationsStartImport(ctx context.Context, request MigrationsStartImportReq, params MigrationsStartImportParams) (res MigrationsStartImportRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-import"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsStartImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeMigrationsStartImportRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsStartImportResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsUnlockRepoForAuthenticatedUser invokes migrations/unlock-repo-for-authenticated-user operation.
//
// Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.
// github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you
// can unlock each repository to begin using it again or [delete the repository](https://docs.github.
// com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a
// status of `404 Not Found` if the repository is not locked.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (c *Client) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, params MigrationsUnlockRepoForAuthenticatedUserParams) (res MigrationsUnlockRepoForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsUnlockRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "repo_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RepoName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/lock"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUnlockRepoForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsUnlockRepoForOrg invokes migrations/unlock-repo-for-org operation.
//
// Unlocks a repository that was locked for migration. You should unlock each migrated repository and
// [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration
// is complete and you no longer need the source data.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (c *Client) MigrationsUnlockRepoForOrg(ctx context.Context, params MigrationsUnlockRepoForOrgParams) (res MigrationsUnlockRepoForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsUnlockRepoForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/migrations/"
	{
		// Encode "migration_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.MigrationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "repo_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RepoName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/lock"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUnlockRepoForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrationsUpdateImport invokes migrations/update-import operation.
//
// An import can be updated with credentials or a project choice by passing in the appropriate
// parameters in this API
// request. If no parameters are provided, the import will be restarted.
//
// PATCH /repos/{owner}/{repo}/import
func (c *Client) MigrationsUpdateImport(ctx context.Context, request OptNilMigrationsUpdateImportReq, params MigrationsUpdateImportParams) (res Import, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/update-import"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "MigrationsUpdateImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeMigrationsUpdateImportRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/import"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUpdateImportResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsCreateAuthorization invokes oauth-authorizations/create-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates OAuth tokens using [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor
// authentication setup, Basic Authentication for this endpoint requires that you use a one-time
// password (OTP) and your username and password instead of tokens. For more information, see
// "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// To create tokens for a particular OAuth application using this endpoint, you must authenticate as
// the user you want to create an authorization for and provide the app's client ID and secret, found
// on your OAuth application's settings page. If your OAuth application intends to create multiple
// tokens for one user, use `fingerprint` to differentiate between them.
// You can also create tokens on GitHub from the [personal access tokens settings](https://github.
// com/settings/tokens) page. Read more about these tokens in [the GitHub Help
// documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
// Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about
// allowing tokens in [the GitHub Help documentation](https://help.github.
// com/articles/about-identity-and-access-management-with-saml-single-sign-on).
//
// POST /authorizations
func (c *Client) OAuthAuthorizationsCreateAuthorization(ctx context.Context, request OptOAuthAuthorizationsCreateAuthorizationReq) (res OAuthAuthorizationsCreateAuthorizationRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/create-authorization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsCreateAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOAuthAuthorizationsCreateAuthorizationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsCreateAuthorizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsDeleteAuthorization invokes oauth-authorizations/delete-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// DELETE /authorizations/{authorization_id}
func (c *Client) OAuthAuthorizationsDeleteAuthorization(ctx context.Context, params OAuthAuthorizationsDeleteAuthorizationParams) (res OAuthAuthorizationsDeleteAuthorizationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-authorization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations/"
	{
		// Encode "authorization_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorizationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsDeleteAuthorizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsDeleteGrant invokes oauth-authorizations/delete-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for your user. Once deleted, the application has no access to your account and is no
// longer listed on [the application authorizations settings screen within GitHub](https://github.
// com/settings/applications#authorized).
//
// DELETE /applications/grants/{grant_id}
func (c *Client) OAuthAuthorizationsDeleteGrant(ctx context.Context, params OAuthAuthorizationsDeleteGrantParams) (res OAuthAuthorizationsDeleteGrantRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-grant"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsDeleteGrant",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/applications/grants/"
	{
		// Encode "grant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "grant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GrantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsDeleteGrantResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetAuthorization invokes oauth-authorizations/get-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// GET /authorizations/{authorization_id}
func (c *Client) OAuthAuthorizationsGetAuthorization(ctx context.Context, params OAuthAuthorizationsGetAuthorizationParams) (res OAuthAuthorizationsGetAuthorizationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-authorization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations/"
	{
		// Encode "authorization_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorizationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetAuthorizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetGrant invokes oauth-authorizations/get-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// GET /applications/grants/{grant_id}
func (c *Client) OAuthAuthorizationsGetGrant(ctx context.Context, params OAuthAuthorizationsGetGrantParams) (res OAuthAuthorizationsGetGrantRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-grant"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetGrant",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/applications/grants/"
	{
		// Encode "grant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "grant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GrantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetGrantResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetOrCreateAuthorizationForApp invokes oauth-authorizations/get-or-create-authorization-for-app operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates a new authorization for the specified OAuth application, only if an authorization for that
// application doesn't already exist for the user. The URL includes the 20 character client ID for
// the OAuth app that is requesting the token. It returns the user's existing authorization for the
// application if one is present. Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// PUT /authorizations/clients/{client_id}
func (c *Client) OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, request OAuthAuthorizationsGetOrCreateAuthorizationForAppReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams) (res OAuthAuthorizationsGetOrCreateAuthorizationForAppRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations/clients/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint invokes oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// This method will create a new authorization for the specified OAuth application, only if an
// authorization for that application and fingerprint do not already exist for the user. The URL
// includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint`
// is a unique string to distinguish an authorization from others created for the same client ID and
// user. It returns the user's existing authorization for the application if one is present.
// Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication).".
//
// PUT /authorizations/clients/{client_id}/{fingerprint}
func (c *Client) OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, request OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq, params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams) (res OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations/clients/"
	{
		// Encode "client_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "client_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "fingerprint" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fingerprint",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Fingerprint))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsListAuthorizations invokes oauth-authorizations/list-authorizations operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// GET /authorizations
func (c *Client) OAuthAuthorizationsListAuthorizations(ctx context.Context, params OAuthAuthorizationsListAuthorizationsParams) (res OAuthAuthorizationsListAuthorizationsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-authorizations"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsListAuthorizations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "client_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ClientID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["client_id"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsListAuthorizationsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsListGrants invokes oauth-authorizations/list-grants operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// You can use this API to list the set of OAuth applications that have been granted access to your
// account. Unlike the [list your authorizations](https://docs.github.
// com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage
// individual tokens. This API will return one entry for each OAuth application that has been granted
// access to your account, regardless of the number of tokens an application has generated for your
// user. The list of OAuth applications returned matches what is shown on [the application
// authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
//  The `scopes` returned are the union of scopes authorized for the application. For example, if an
// application has one token with `repo` scope and another token with `user` scope, the grant will
// return `["repo", "user"]`.
//
// GET /applications/grants
func (c *Client) OAuthAuthorizationsListGrants(ctx context.Context, params OAuthAuthorizationsListGrantsParams) (res OAuthAuthorizationsListGrantsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-grants"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsListGrants",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/applications/grants"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "client_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ClientID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["client_id"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsListGrantsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthAuthorizationsUpdateAuthorization invokes oauth-authorizations/update-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// You can only send one of these scope keys at a time.
//
// PATCH /authorizations/{authorization_id}
func (c *Client) OAuthAuthorizationsUpdateAuthorization(ctx context.Context, request OptOAuthAuthorizationsUpdateAuthorizationReq, params OAuthAuthorizationsUpdateAuthorizationParams) (res OAuthAuthorizationsUpdateAuthorizationRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/update-authorization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthAuthorizationsUpdateAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOAuthAuthorizationsUpdateAuthorizationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/authorizations/"
	{
		// Encode "authorization_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AuthorizationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsUpdateAuthorizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsBlockUser invokes orgs/block-user operation.
//
// PUT /orgs/{org}/blocks/{username}
func (c *Client) OrgsBlockUser(ctx context.Context, params OrgsBlockUserParams) (res OrgsBlockUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/block-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsBlockUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsBlockUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCancelInvitation invokes orgs/cancel-invitation operation.
//
// Cancel an organization invitation. In order to cancel an organization invitation, the
// authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
//
// DELETE /orgs/{org}/invitations/{invitation_id}
func (c *Client) OrgsCancelInvitation(ctx context.Context, params OrgsCancelInvitationParams) (res OrgsCancelInvitationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/cancel-invitation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCancelInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCancelInvitationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCheckBlockedUser invokes orgs/check-blocked-user operation.
//
// GET /orgs/{org}/blocks/{username}
func (c *Client) OrgsCheckBlockedUser(ctx context.Context, params OrgsCheckBlockedUserParams) (res OrgsCheckBlockedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-blocked-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCheckBlockedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckBlockedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCheckMembershipForUser invokes orgs/check-membership-for-user operation.
//
// Check if a user is, publicly or privately, a member of the organization.
//
// GET /orgs/{org}/members/{username}
func (c *Client) OrgsCheckMembershipForUser(ctx context.Context, params OrgsCheckMembershipForUserParams) (res OrgsCheckMembershipForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-membership-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCheckMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckMembershipForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCheckPublicMembershipForUser invokes orgs/check-public-membership-for-user operation.
//
// GET /orgs/{org}/public_members/{username}
func (c *Client) OrgsCheckPublicMembershipForUser(ctx context.Context, params OrgsCheckPublicMembershipForUserParams) (res OrgsCheckPublicMembershipForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-public-membership-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCheckPublicMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/public_members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckPublicMembershipForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsConvertMemberToOutsideCollaborator invokes orgs/convert-member-to-outside-collaborator operation.
//
// When an organization member is converted to an outside collaborator, they'll only have access to
// the repositories that their current team membership allows. The user will no longer be a member of
// the organization. For more information, see "[Converting an organization member to an outside
// collaborator](https://help.github.
// com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (c *Client) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, params OrgsConvertMemberToOutsideCollaboratorParams) (res OrgsConvertMemberToOutsideCollaboratorRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/convert-member-to-outside-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsConvertMemberToOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/outside_collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsConvertMemberToOutsideCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCreateInvitation invokes orgs/create-invitation operation.
//
// Invite people to an organization by using their GitHub user ID or their email address. In order to
// create invitations in an organization, the authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /orgs/{org}/invitations
func (c *Client) OrgsCreateInvitation(ctx context.Context, request OptOrgsCreateInvitationReq, params OrgsCreateInvitationParams) (res OrgsCreateInvitationRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-invitation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCreateInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOrgsCreateInvitationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCreateInvitationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsCreateWebhook invokes orgs/create-webhook operation.
//
// Here's how you can create a hook that posts payloads in JSON format:.
//
// POST /orgs/{org}/hooks
func (c *Client) OrgsCreateWebhook(ctx context.Context, request OrgsCreateWebhookReq, params OrgsCreateWebhookParams) (res OrgsCreateWebhookRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOrgsCreateWebhookRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCreateWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsDeleteWebhook invokes orgs/delete-webhook operation.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (c *Client) OrgsDeleteWebhook(ctx context.Context, params OrgsDeleteWebhookParams) (res OrgsDeleteWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/delete-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsDeleteWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGet invokes orgs/get operation.
//
// To see many of the organization response values, you need to be an authenticated organization
// owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`,
// the organization requires all members, billing managers, and outside collaborators to enable
// [two-factor authentication](https://help.github.
// com/articles/securing-your-account-with-two-factor-authentication-2fa/).
// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information
// about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example
// response, see 'Response with GitHub plan information' below.".
//
// GET /orgs/{org}
func (c *Client) OrgsGet(ctx context.Context, params OrgsGetParams) (res OrgsGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetAuditLog invokes orgs/get-audit-log operation.
//
// Gets the audit log for an organization. For more information, see "[Reviewing the audit log for
// your organization](https://docs.github.
// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
// To use this endpoint, you must be an organization owner, and you must use an access token with the
// `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use
// this endpoint.
//
// GET /orgs/{org}/audit-log
func (c *Client) OrgsGetAuditLog(ctx context.Context, params OrgsGetAuditLogParams) (res []AuditLogEvent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-audit-log"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/audit-log"

	q := u.Query()
	{
		// Encode "phrase" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Phrase.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["phrase"] = e.Result()
	}
	{
		// Encode "include" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Include.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["include"] = e.Result()
	}
	{
		// Encode "after" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["after"] = e.Result()
	}
	{
		// Encode "before" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["before"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetAuditLogResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetMembershipForAuthenticatedUser invokes orgs/get-membership-for-authenticated-user operation.
//
// GET /user/memberships/orgs/{org}
func (c *Client) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, params OrgsGetMembershipForAuthenticatedUserParams) (res OrgsGetMembershipForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/memberships/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetMembershipForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetMembershipForUser invokes orgs/get-membership-for-user operation.
//
// In order to get a user's membership with an organization, the authenticated user must be an
// organization member. The `state` parameter in the response can be used to identify the user's
// membership status.
//
// GET /orgs/{org}/memberships/{username}
func (c *Client) OrgsGetMembershipForUser(ctx context.Context, params OrgsGetMembershipForUserParams) (res OrgsGetMembershipForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetMembershipForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetWebhook invokes orgs/get-webhook operation.
//
// Returns a webhook configured in an organization. To get only the webhook `config` properties, see
// "[Get a webhook configuration for an
// organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization).".
//
// GET /orgs/{org}/hooks/{hook_id}
func (c *Client) OrgsGetWebhook(ctx context.Context, params OrgsGetWebhookParams) (res OrgsGetWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetWebhookConfigForOrg invokes orgs/get-webhook-config-for-org operation.
//
// Returns the webhook configuration for an organization. To get more information about the webhook,
// including the `active` state and `events`, use "[Get an organization webhook
// ](/rest/reference/orgs#get-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:read` permission.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (c *Client) OrgsGetWebhookConfigForOrg(ctx context.Context, params OrgsGetWebhookConfigForOrgParams) (res WebhookConfig, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-config-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/config"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookConfigForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsGetWebhookDelivery invokes orgs/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
func (c *Client) OrgsGetWebhookDelivery(ctx context.Context, params OrgsGetWebhookDeliveryParams) (res OrgsGetWebhookDeliveryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-delivery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookDeliveryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsList invokes orgs/list operation.
//
// Lists all organizations, in the order that they were created on GitHub.
// **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of organizations.
//
// GET /organizations
func (c *Client) OrgsList(ctx context.Context, params OrgsListParams) (res OrgsListRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/organizations"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListBlockedUsers invokes orgs/list-blocked-users operation.
//
// List the users blocked by an organization.
//
// GET /orgs/{org}/blocks
func (c *Client) OrgsListBlockedUsers(ctx context.Context, params OrgsListBlockedUsersParams) (res OrgsListBlockedUsersRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-blocked-users"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListBlockedUsers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/blocks"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListBlockedUsersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListFailedInvitations invokes orgs/list-failed-invitations operation.
//
// The return hash contains `failed_at` and `failed_reason` fields which represent the time at which
// the invitation failed and the reason for the failure.
//
// GET /orgs/{org}/failed_invitations
func (c *Client) OrgsListFailedInvitations(ctx context.Context, params OrgsListFailedInvitationsParams) (res OrgsListFailedInvitationsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-failed-invitations"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListFailedInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/failed_invitations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListFailedInvitationsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListForAuthenticatedUser invokes orgs/list-for-authenticated-user operation.
//
// List organizations for the authenticated user.
// **OAuth scope requirements**
// This only lists organizations that your authorization allows you to operate on in some way (e.g.,
// you can list teams with `read:org` scope, you can publicize your organization membership with
// `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth
// requests with insufficient scope receive a `403 Forbidden` response.
//
// GET /user/orgs
func (c *Client) OrgsListForAuthenticatedUser(ctx context.Context, params OrgsListForAuthenticatedUserParams) (res OrgsListForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/orgs"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListForUser invokes orgs/list-for-user operation.
//
// List [public organization memberships](https://help.github.
// com/articles/publicizing-or-concealing-organization-membership) for the specified user.
// This method only lists _public_ memberships, regardless of authentication. If you need to fetch
// all of the organization memberships (public and private) for the authenticated user, use the [List
// organizations for the authenticated user](https://docs.github.
// com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
//
// GET /users/{username}/orgs
func (c *Client) OrgsListForUser(ctx context.Context, params OrgsListForUserParams) (res []OrganizationSimple, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/orgs"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListInvitationTeams invokes orgs/list-invitation-teams operation.
//
// List all teams associated with an invitation. In order to see invitations in an organization, the
// authenticated user must be an organization owner.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (c *Client) OrgsListInvitationTeams(ctx context.Context, params OrgsListInvitationTeamsParams) (res OrgsListInvitationTeamsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-invitation-teams"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListInvitationTeams",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListInvitationTeamsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListMembers invokes orgs/list-members operation.
//
// List all users who are members of an organization. If the authenticated user is also a member of
// this organization then both concealed and public members will be returned.
//
// GET /orgs/{org}/members
func (c *Client) OrgsListMembers(ctx context.Context, params OrgsListMembersParams) (res OrgsListMembersRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-members"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListMembers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members"

	q := u.Query()
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "role" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Role.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["role"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListMembersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListMembershipsForAuthenticatedUser invokes orgs/list-memberships-for-authenticated-user operation.
//
// GET /user/memberships/orgs
func (c *Client) OrgsListMembershipsForAuthenticatedUser(ctx context.Context, params OrgsListMembershipsForAuthenticatedUserParams) (res OrgsListMembershipsForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-memberships-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListMembershipsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/memberships/orgs"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListMembershipsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListOutsideCollaborators invokes orgs/list-outside-collaborators operation.
//
// List all users who are outside collaborators of an organization.
//
// GET /orgs/{org}/outside_collaborators
func (c *Client) OrgsListOutsideCollaborators(ctx context.Context, params OrgsListOutsideCollaboratorsParams) (res []SimpleUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-outside-collaborators"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListOutsideCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/outside_collaborators"

	q := u.Query()
	{
		// Encode "filter" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["filter"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListOutsideCollaboratorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListPendingInvitations invokes orgs/list-pending-invitations operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// GET /orgs/{org}/invitations
func (c *Client) OrgsListPendingInvitations(ctx context.Context, params OrgsListPendingInvitationsParams) (res OrgsListPendingInvitationsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-pending-invitations"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListPendingInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListPendingInvitationsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListPublicMembers invokes orgs/list-public-members operation.
//
// Members of an organization can choose to have their membership publicized or not.
//
// GET /orgs/{org}/public_members
func (c *Client) OrgsListPublicMembers(ctx context.Context, params OrgsListPublicMembersParams) (res []SimpleUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-public-members"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListPublicMembers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/public_members"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListPublicMembersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListSamlSSOAuthorizations invokes orgs/list-saml-sso-authorizations operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `read:org` scope can list all credential
// authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either
// personal access tokens or SSH keys that organization members have authorized for the organization.
// For more information, see [About authentication with SAML single sign-on](https://help.github.
// com/en/articles/about-authentication-with-saml-single-sign-on).
//
// GET /orgs/{org}/credential-authorizations
func (c *Client) OrgsListSamlSSOAuthorizations(ctx context.Context, params OrgsListSamlSSOAuthorizationsParams) (res []CredentialAuthorization, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-saml-sso-authorizations"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListSamlSSOAuthorizations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/credential-authorizations"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListSamlSSOAuthorizationsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListWebhookDeliveries invokes orgs/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries
func (c *Client) OrgsListWebhookDeliveries(ctx context.Context, params OrgsListWebhookDeliveriesParams) (res OrgsListWebhookDeliveriesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhook-deliveries"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deliveries"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "cursor" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["cursor"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListWebhookDeliveriesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsListWebhooks invokes orgs/list-webhooks operation.
//
// GET /orgs/{org}/hooks
func (c *Client) OrgsListWebhooks(ctx context.Context, params OrgsListWebhooksParams) (res OrgsListWebhooksRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhooks"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsListWebhooks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListWebhooksResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsPingWebhook invokes orgs/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (c *Client) OrgsPingWebhook(ctx context.Context, params OrgsPingWebhookParams) (res OrgsPingWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/ping-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsPingWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pings"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsPingWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRedeliverWebhookDelivery invokes orgs/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for a webhook configured in an organization.
//
// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (c *Client) OrgsRedeliverWebhookDelivery(ctx context.Context, params OrgsRedeliverWebhookDeliveryParams) (res OrgsRedeliverWebhookDeliveryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/redeliver-webhook-delivery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/attempts"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRedeliverWebhookDeliveryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveMember invokes orgs/remove-member operation.
//
// Removing a user from this list will remove them from all teams and they will no longer have any
// access to the organization's repositories.
//
// DELETE /orgs/{org}/members/{username}
func (c *Client) OrgsRemoveMember(ctx context.Context, params OrgsRemoveMemberParams) (res OrgsRemoveMemberRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-member"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveMemberResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveMembershipForUser invokes orgs/remove-membership-for-user operation.
//
// In order to remove a user's membership with an organization, the authenticated user must be an
// organization owner.
// If the specified user is an active member of the organization, this will remove them from the
// organization. If the specified user has been invited to the organization, this will cancel their
// invitation. The specified user will receive an email notification in both cases.
//
// DELETE /orgs/{org}/memberships/{username}
func (c *Client) OrgsRemoveMembershipForUser(ctx context.Context, params OrgsRemoveMembershipForUserParams) (res OrgsRemoveMembershipForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-membership-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveMembershipForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveOutsideCollaborator invokes orgs/remove-outside-collaborator operation.
//
// Removing a user from this list will remove them from all the organization's repositories.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (c *Client) OrgsRemoveOutsideCollaborator(ctx context.Context, params OrgsRemoveOutsideCollaboratorParams) (res OrgsRemoveOutsideCollaboratorRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-outside-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/outside_collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveOutsideCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemovePublicMembershipForAuthenticatedUser invokes orgs/remove-public-membership-for-authenticated-user operation.
//
// DELETE /orgs/{org}/public_members/{username}
func (c *Client) OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsRemovePublicMembershipForAuthenticatedUserParams) (res OrgsRemovePublicMembershipForAuthenticatedUserNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-public-membership-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemovePublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/public_members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsRemoveSamlSSOAuthorization invokes orgs/remove-saml-sso-authorization operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `admin:org` scope can remove a credential
// authorization for an organization that uses SAML SSO. Once you remove someone's credential
// authorization, they will need to create a new personal access token or SSH key and authorize it
// for the organization they want to access.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (c *Client) OrgsRemoveSamlSSOAuthorization(ctx context.Context, params OrgsRemoveSamlSSOAuthorizationParams) (res OrgsRemoveSamlSSOAuthorizationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-saml-sso-authorization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsRemoveSamlSSOAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/credential-authorizations/"
	{
		// Encode "credential_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "credential_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CredentialID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveSamlSSOAuthorizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsSetMembershipForUser invokes orgs/set-membership-for-user operation.
//
// Only authenticated organization owners can add a member to the organization or update the member's
// role.
// *   If the authenticated user is _adding_ a member to the organization, the invited user will
// receive an email inviting them to the organization. The user's [membership status](https://docs.
// github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until
// they accept the invitation.
// *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the
// authenticated user changes a member's role to `admin`, the affected user will receive an email
// notifying them that they've been made an organization owner. If the authenticated user changes an
// owner's role to `member`, no email will be sent.
// **Rate limits**
// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour
// period. If the organization is more than one month old or on a paid plan, the limit is 500
// invitations per 24 hour period.
//
// PUT /orgs/{org}/memberships/{username}
func (c *Client) OrgsSetMembershipForUser(ctx context.Context, request OptOrgsSetMembershipForUserReq, params OrgsSetMembershipForUserParams) (res OrgsSetMembershipForUserRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-membership-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsSetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOrgsSetMembershipForUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsSetMembershipForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsSetPublicMembershipForAuthenticatedUser invokes orgs/set-public-membership-for-authenticated-user operation.
//
// The user can publicize their own membership. (A user cannot publicize the membership for another
// user.)
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /orgs/{org}/public_members/{username}
func (c *Client) OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsSetPublicMembershipForAuthenticatedUserParams) (res OrgsSetPublicMembershipForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-public-membership-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsSetPublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/public_members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsSetPublicMembershipForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUnblockUser invokes orgs/unblock-user operation.
//
// DELETE /orgs/{org}/blocks/{username}
func (c *Client) OrgsUnblockUser(ctx context.Context, params OrgsUnblockUserParams) (res OrgsUnblockUserNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/unblock-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUnblockUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUnblockUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUpdateMembershipForAuthenticatedUser invokes orgs/update-membership-for-authenticated-user operation.
//
// PATCH /user/memberships/orgs/{org}
func (c *Client) OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, request OrgsUpdateMembershipForAuthenticatedUserReq, params OrgsUpdateMembershipForAuthenticatedUserParams) (res OrgsUpdateMembershipForAuthenticatedUserRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-membership-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUpdateMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOrgsUpdateMembershipForAuthenticatedUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/memberships/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateMembershipForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUpdateWebhook invokes orgs/update-webhook operation.
//
// Updates a webhook configured in an organization. When you update a webhook, the `secret` will be
// overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new
// `secret` or the secret will be removed. If you are only updating individual webhook `config`
// properties, use "[Update a webhook configuration for an
// organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization).".
//
// PATCH /orgs/{org}/hooks/{hook_id}
func (c *Client) OrgsUpdateWebhook(ctx context.Context, request OptOrgsUpdateWebhookReq, params OrgsUpdateWebhookParams) (res OrgsUpdateWebhookRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOrgsUpdateWebhookRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrgsUpdateWebhookConfigForOrg invokes orgs/update-webhook-config-for-org operation.
//
// Updates the webhook configuration for an organization. To update more information about the
// webhook, including the `active` state and `events`, use "[Update an organization webhook
// ](/rest/reference/orgs#update-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:write` permission.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (c *Client) OrgsUpdateWebhookConfigForOrg(ctx context.Context, request OptOrgsUpdateWebhookConfigForOrgReq, params OrgsUpdateWebhookConfigForOrgParams) (res WebhookConfig, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook-config-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrgsUpdateWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeOrgsUpdateWebhookConfigForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/config"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateWebhookConfigForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageForAuthenticatedUser invokes packages/delete-package-for-authenticated-user operation.
//
// Deletes a package owned by the authenticated user. You cannot delete a public package if any
// version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for
// further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}
func (c *Client) PackagesDeletePackageForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageForAuthenticatedUserParams) (res PackagesDeletePackageForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageForOrg invokes packages/delete-package-for-org operation.
//
// Deletes an entire package in an organization. You cannot delete a public package if any version of
// the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (c *Client) PackagesDeletePackageForOrg(ctx context.Context, params PackagesDeletePackageForOrgParams) (res PackagesDeletePackageForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageForUser invokes packages/delete-package-for-user operation.
//
// Deletes an entire package for a user. You cannot delete a public package if any version of the
// package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (c *Client) PackagesDeletePackageForUser(ctx context.Context, params PackagesDeletePackageForUserParams) (res PackagesDeletePackageForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageVersionForAuthenticatedUser invokes packages/delete-package-version-for-authenticated-user operation.
//
// Deletes a specific package version for a package owned by the authenticated user.  If the package
// is public and the package version has more than 5,000 downloads, you cannot delete the package
// version. In this scenario, contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageVersionForAuthenticatedUserParams) (res PackagesDeletePackageVersionForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageVersionForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageVersionForOrg invokes packages/delete-package-version-for-org operation.
//
// Deletes a specific package version in an organization. If the package is public and the package
// version has more than 5,000 downloads, you cannot delete the package version. In this scenario,
// contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesDeletePackageVersionForOrg(ctx context.Context, params PackagesDeletePackageVersionForOrgParams) (res PackagesDeletePackageVersionForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageVersionForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesDeletePackageVersionForUser invokes packages/delete-package-version-for-user operation.
//
// Deletes a specific package version for a user. If the package is public and the package version
// has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact
// GitHub support for further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesDeletePackageVersionForUser(ctx context.Context, params PackagesDeletePackageVersionForUserParams) (res PackagesDeletePackageVersionForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesDeletePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageVersionForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser invokes packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// Returns all package versions for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) (res PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByOrg invokes packages/get-all-package-versions-for-package-owned-by-org operation.
//
// Returns all package versions for a package owned by an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams) (res PackagesGetAllPackageVersionsForPackageOwnedByOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByUser invokes packages/get-all-package-versions-for-package-owned-by-user operation.
//
// Returns all package versions for a public package owned by a specified user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByUserParams) (res PackagesGetAllPackageVersionsForPackageOwnedByUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetAllPackageVersionsForPackageOwnedByUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageForAuthenticatedUser invokes packages/get-package-for-authenticated-user operation.
//
// Gets a specific package for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}
func (c *Client) PackagesGetPackageForAuthenticatedUser(ctx context.Context, params PackagesGetPackageForAuthenticatedUserParams) (res Package, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageForOrganization invokes packages/get-package-for-organization operation.
//
// Gets a specific package in an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (c *Client) PackagesGetPackageForOrganization(ctx context.Context, params PackagesGetPackageForOrganizationParams) (res Package, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageForOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageForUser invokes packages/get-package-for-user operation.
//
// Gets a specific package metadata for a public package owned by a user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (c *Client) PackagesGetPackageForUser(ctx context.Context, params PackagesGetPackageForUserParams) (res Package, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageVersionForAuthenticatedUser invokes packages/get-package-version-for-authenticated-user operation.
//
// Gets a specific package version for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, params PackagesGetPackageVersionForAuthenticatedUserParams) (res PackageVersion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageVersionForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageVersionForOrganization invokes packages/get-package-version-for-organization operation.
//
// Gets a specific package version in an organization.
// You must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesGetPackageVersionForOrganization(ctx context.Context, params PackagesGetPackageVersionForOrganizationParams) (res PackageVersion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageVersionForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageVersionForOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesGetPackageVersionForUser invokes packages/get-package-version-for-user operation.
//
// Gets a specific package version for a public package owned by a specified user.
// At this time, to use this endpoint, you must authenticate using an access token with the
// `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (c *Client) PackagesGetPackageVersionForUser(ctx context.Context, params PackagesGetPackageVersionForUserParams) (res PackageVersion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesGetPackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageVersionForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesListPackagesForAuthenticatedUser invokes packages/list-packages-for-authenticated-user operation.
//
// Lists packages owned by the authenticated user within the user's namespace.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages
func (c *Client) PackagesListPackagesForAuthenticatedUser(ctx context.Context, params PackagesListPackagesForAuthenticatedUserParams) (res []Package, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesListPackagesForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages"

	q := u.Query()
	{
		// Encode "package_type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["package_type"] = e.Result()
	}
	{
		// Encode "visibility" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["visibility"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesListPackagesForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesListPackagesForOrganization invokes packages/list-packages-for-organization operation.
//
// Lists all packages in an organization readable by the user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages
func (c *Client) PackagesListPackagesForOrganization(ctx context.Context, params PackagesListPackagesForOrganizationParams) (res PackagesListPackagesForOrganizationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-organization"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesListPackagesForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages"

	q := u.Query()
	{
		// Encode "package_type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["package_type"] = e.Result()
	}
	{
		// Encode "visibility" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["visibility"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesListPackagesForOrganizationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesListPackagesForUser invokes packages/list-packages-for-user operation.
//
// Lists all packages in a user's namespace for which the requesting user has access.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages
func (c *Client) PackagesListPackagesForUser(ctx context.Context, params PackagesListPackagesForUserParams) (res PackagesListPackagesForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesListPackagesForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages"

	q := u.Query()
	{
		// Encode "package_type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["package_type"] = e.Result()
	}
	{
		// Encode "visibility" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["visibility"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesListPackagesForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageForAuthenticatedUser invokes packages/restore-package-for-authenticated-user operation.
//
// Restores a package owned by the authenticated user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (c *Client) PackagesRestorePackageForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageForAuthenticatedUserParams) (res PackagesRestorePackageForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/restore"

	q := u.Query()
	{
		// Encode "token" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["token"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageForOrg invokes packages/restore-package-for-org operation.
//
// Restores an entire package in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (c *Client) PackagesRestorePackageForOrg(ctx context.Context, params PackagesRestorePackageForOrgParams) (res PackagesRestorePackageForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/restore"

	q := u.Query()
	{
		// Encode "token" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["token"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageForUser invokes packages/restore-package-for-user operation.
//
// Restores an entire package for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (c *Client) PackagesRestorePackageForUser(ctx context.Context, params PackagesRestorePackageForUserParams) (res PackagesRestorePackageForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/restore"

	q := u.Query()
	{
		// Encode "token" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["token"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageVersionForAuthenticatedUser invokes packages/restore-package-version-for-authenticated-user operation.
//
// Restores a package version owned by the authenticated user.
// You can restore a deleted package version under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (c *Client) PackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageVersionForAuthenticatedUserParams) (res PackagesRestorePackageVersionForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/restore"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageVersionForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageVersionForOrg invokes packages/restore-package-version-for-org operation.
//
// Restores a specific package version in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (c *Client) PackagesRestorePackageVersionForOrg(ctx context.Context, params PackagesRestorePackageVersionForOrgParams) (res PackagesRestorePackageVersionForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/restore"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageVersionForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PackagesRestorePackageVersionForUser invokes packages/restore-package-version-for-user operation.
//
// Restores a specific package version for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (c *Client) PackagesRestorePackageVersionForUser(ctx context.Context, params PackagesRestorePackageVersionForUserParams) (res PackagesRestorePackageVersionForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PackagesRestorePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/packages/"
	{
		// Encode "package_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.PackageType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "package_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PackageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/versions/"
	{
		// Encode "package_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "package_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PackageVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/restore"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageVersionForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsAddCollaborator invokes projects/add-collaborator operation.
//
// Adds a collaborator to an organization project and sets their permission level. You must be an
// organization owner or a project `admin` to add a collaborator.
//
// PUT /projects/{project_id}/collaborators/{username}
func (c *Client) ProjectsAddCollaborator(ctx context.Context, request OptNilProjectsAddCollaboratorReq, params ProjectsAddCollaboratorParams) (res ProjectsAddCollaboratorRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/add-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsAddCollaboratorRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsAddCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateColumn invokes projects/create-column operation.
//
// POST /projects/{project_id}/columns
func (c *Client) ProjectsCreateColumn(ctx context.Context, request ProjectsCreateColumnReq, params ProjectsCreateColumnParams) (res ProjectsCreateColumnRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-column"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsCreateColumnRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/columns"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateColumnResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateForAuthenticatedUser invokes projects/create-for-authenticated-user operation.
//
// POST /user/projects
func (c *Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, request ProjectsCreateForAuthenticatedUserReq) (res ProjectsCreateForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsCreateForAuthenticatedUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/projects"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateForOrg invokes projects/create-for-org operation.
//
// Creates an organization project board. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /orgs/{org}/projects
func (c *Client) ProjectsCreateForOrg(ctx context.Context, request ProjectsCreateForOrgReq, params ProjectsCreateForOrgParams) (res ProjectsCreateForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsCreateForOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsCreateForRepo invokes projects/create-for-repo operation.
//
// Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /repos/{owner}/{repo}/projects
func (c *Client) ProjectsCreateForRepo(ctx context.Context, request ProjectsCreateForRepoReq, params ProjectsCreateForRepoParams) (res ProjectsCreateForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsCreateForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsCreateForRepoRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsDelete invokes projects/delete operation.
//
// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
//
// DELETE /projects/{project_id}
func (c *Client) ProjectsDelete(ctx context.Context, params ProjectsDeleteParams) (res ProjectsDeleteRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsDeleteCard invokes projects/delete-card operation.
//
// DELETE /projects/columns/cards/{card_id}
func (c *Client) ProjectsDeleteCard(ctx context.Context, params ProjectsDeleteCardParams) (res ProjectsDeleteCardRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-card"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsDeleteCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteCardResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsDeleteColumn invokes projects/delete-column operation.
//
// DELETE /projects/columns/{column_id}
func (c *Client) ProjectsDeleteColumn(ctx context.Context, params ProjectsDeleteColumnParams) (res ProjectsDeleteColumnRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-column"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsDeleteColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteColumnResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGet invokes projects/get operation.
//
// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do
// not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status
// is returned.
//
// GET /projects/{project_id}
func (c *Client) ProjectsGet(ctx context.Context, params ProjectsGetParams) (res ProjectsGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGetCard invokes projects/get-card operation.
//
// GET /projects/columns/cards/{card_id}
func (c *Client) ProjectsGetCard(ctx context.Context, params ProjectsGetCardParams) (res ProjectsGetCardRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-card"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGetCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetCardResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGetColumn invokes projects/get-column operation.
//
// GET /projects/columns/{column_id}
func (c *Client) ProjectsGetColumn(ctx context.Context, params ProjectsGetColumnParams) (res ProjectsGetColumnRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-column"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGetColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetColumnResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGetPermissionForUser invokes projects/get-permission-for-user operation.
//
// Returns the collaborator's permission level for an organization project. Possible values for the
// `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project
// `admin` to review a user's permission level.
//
// GET /projects/{project_id}/collaborators/{username}/permission
func (c *Client) ProjectsGetPermissionForUser(ctx context.Context, params ProjectsGetPermissionForUserParams) (res ProjectsGetPermissionForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-permission-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsGetPermissionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/permission"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetPermissionForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListCards invokes projects/list-cards operation.
//
// GET /projects/columns/{column_id}/cards
func (c *Client) ProjectsListCards(ctx context.Context, params ProjectsListCardsParams) (res ProjectsListCardsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-cards"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListCards",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/cards"

	q := u.Query()
	{
		// Encode "archived_state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.ArchivedState.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["archived_state"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListCardsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListCollaborators invokes projects/list-collaborators operation.
//
// Lists the collaborators for an organization project. For a project, the list of collaborators
// includes outside collaborators, organization members that are direct collaborators, organization
// members with access through team memberships, organization members with access through default
// organization permissions, and organization owners. You must be an organization owner or a project
// `admin` to list collaborators.
//
// GET /projects/{project_id}/collaborators
func (c *Client) ProjectsListCollaborators(ctx context.Context, params ProjectsListCollaboratorsParams) (res ProjectsListCollaboratorsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-collaborators"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators"

	q := u.Query()
	{
		// Encode "affiliation" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Affiliation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["affiliation"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListCollaboratorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListColumns invokes projects/list-columns operation.
//
// GET /projects/{project_id}/columns
func (c *Client) ProjectsListColumns(ctx context.Context, params ProjectsListColumnsParams) (res ProjectsListColumnsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-columns"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListColumns",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/columns"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListColumnsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListForOrg invokes projects/list-for-org operation.
//
// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /orgs/{org}/projects
func (c *Client) ProjectsListForOrg(ctx context.Context, params ProjectsListForOrgParams) (res ProjectsListForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListForRepo invokes projects/list-for-repo operation.
//
// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /repos/{owner}/{repo}/projects
func (c *Client) ProjectsListForRepo(ctx context.Context, params ProjectsListForRepoParams) (res ProjectsListForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsListForUser invokes projects/list-for-user operation.
//
// GET /users/{username}/projects
func (c *Client) ProjectsListForUser(ctx context.Context, params ProjectsListForUserParams) (res ProjectsListForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsMoveCard invokes projects/move-card operation.
//
// POST /projects/columns/cards/{card_id}/moves
func (c *Client) ProjectsMoveCard(ctx context.Context, request ProjectsMoveCardReq, params ProjectsMoveCardParams) (res ProjectsMoveCardRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-card"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsMoveCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsMoveCardRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/moves"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsMoveCardResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsMoveColumn invokes projects/move-column operation.
//
// POST /projects/columns/{column_id}/moves
func (c *Client) ProjectsMoveColumn(ctx context.Context, request ProjectsMoveColumnReq, params ProjectsMoveColumnParams) (res ProjectsMoveColumnRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-column"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsMoveColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsMoveColumnRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/moves"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsMoveColumnResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsRemoveCollaborator invokes projects/remove-collaborator operation.
//
// Removes a collaborator from an organization project. You must be an organization owner or a
// project `admin` to remove a collaborator.
//
// DELETE /projects/{project_id}/collaborators/{username}
func (c *Client) ProjectsRemoveCollaborator(ctx context.Context, params ProjectsRemoveCollaboratorParams) (res ProjectsRemoveCollaboratorRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/remove-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsRemoveCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsUpdate invokes projects/update operation.
//
// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled.
// If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410
// Gone` status is returned.
//
// PATCH /projects/{project_id}
func (c *Client) ProjectsUpdate(ctx context.Context, request OptProjectsUpdateReq, params ProjectsUpdateParams) (res ProjectsUpdateRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsUpdateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsUpdateCard invokes projects/update-card operation.
//
// PATCH /projects/columns/cards/{card_id}
func (c *Client) ProjectsUpdateCard(ctx context.Context, request OptProjectsUpdateCardReq, params ProjectsUpdateCardParams) (res ProjectsUpdateCardRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-card"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsUpdateCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsUpdateCardRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/cards/"
	{
		// Encode "card_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateCardResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsUpdateColumn invokes projects/update-column operation.
//
// PATCH /projects/columns/{column_id}
func (c *Client) ProjectsUpdateColumn(ctx context.Context, request ProjectsUpdateColumnReq, params ProjectsUpdateColumnParams) (res ProjectsUpdateColumnRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-column"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ProjectsUpdateColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeProjectsUpdateColumnRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/projects/columns/"
	{
		// Encode "column_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ColumnID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateColumnResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCheckIfMerged invokes pulls/check-if-merged operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (c *Client) PullsCheckIfMerged(ctx context.Context, params PullsCheckIfMergedParams) (res PullsCheckIfMergedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/check-if-merged"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCheckIfMerged",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/merge"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsCheckIfMergedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreate invokes pulls/create operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
// You can create a new pull request.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls
func (c *Client) PullsCreate(ctx context.Context, request PullsCreateReq, params PullsCreateParams) (res PullsCreateRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsCreateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreateReplyForReviewComment invokes pulls/create-reply-for-review-comment operation.
//
// Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of
// the review comment you are replying to. This must be the ID of a _top-level review comment_, not a
// reply to that comment. Replies to replies are not supported.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (c *Client) PullsCreateReplyForReviewComment(ctx context.Context, request PullsCreateReplyForReviewCommentReq, params PullsCreateReplyForReviewCommentParams) (res PullsCreateReplyForReviewCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-reply-for-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreateReplyForReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsCreateReplyForReviewCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/replies"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReplyForReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreateReview invokes pulls/create-review operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in
// the response.
// **Note:** To comment on a specific line in a file, you need to first determine the _position_ of
// that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media
// type](https://docs.github.
// com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request
// diff, add this media type to the `Accept` header of a call to the [single pull
// request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
// The `position` value equals the number of lines down from the first "@@" hunk header in the file
// you want to add a comment. The line just below the "@@" line is position 1, the next line is
// position 2, and so on. The position in the diff continues to increase through lines of whitespace
// and additional hunks until the beginning of a new file.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (c *Client) PullsCreateReview(ctx context.Context, request OptPullsCreateReviewReq, params PullsCreateReviewParams) (res PullsCreateReviewRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreateReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsCreateReviewRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsCreateReviewComment invokes pulls/create-review-comment operation.
//
// Creates a review comment in the pull request diff. To add a regular comment to a pull request
// timeline, see "[Create an issue comment](https://docs.github.
// com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using
// `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than
// one line in the pull request diff.
// You can still create a review comment using the `position` parameter. When you use `position`, the
// `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information,
// see the [`comfort-fade` preview notice](https://docs.github.
// com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
// **Note:** The position value equals the number of lines down from the first "@@" hunk header in
// the file you want to add a comment. The line just below the "@@" line is position 1, the next line
// is position 2, and so on. The position in the diff continues to increase through lines of
// whitespace and additional hunks until the beginning of a new file.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (c *Client) PullsCreateReviewComment(ctx context.Context, request PullsCreateReviewCommentReq, params PullsCreateReviewCommentParams) (res PullsCreateReviewCommentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsCreateReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsCreateReviewCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsDeletePendingReview invokes pulls/delete-pending-review operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (c *Client) PullsDeletePendingReview(ctx context.Context, params PullsDeletePendingReviewParams) (res PullsDeletePendingReviewRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-pending-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsDeletePendingReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsDeletePendingReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsDeleteReviewComment invokes pulls/delete-review-comment operation.
//
// Deletes a review comment.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (c *Client) PullsDeleteReviewComment(ctx context.Context, params PullsDeleteReviewCommentParams) (res PullsDeleteReviewCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsDeleteReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsDeleteReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsDismissReview invokes pulls/dismiss-review operation.
//
// **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.
// com/rest/reference/repos#branches), you must be a repository administrator or be included in the
// list of people or teams who can dismiss pull request reviews.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (c *Client) PullsDismissReview(ctx context.Context, request PullsDismissReviewReq, params PullsDismissReviewParams) (res PullsDismissReviewRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/dismiss-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsDismissReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsDismissReviewRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/dismissals"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsDismissReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsGet invokes pulls/get operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists details of a pull request by providing its number.
// When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or
// [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub
// creates a merge commit to test whether the pull request can be automatically merged into the base
// branch. This test commit is not added to the base branch or the head branch. You can review the
// status of the test commit using the `mergeable` key. For more information, see "[Checking
// mergeability of pull requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`,
// then GitHub has started a background job to compute the mergeability. After giving the job time to
// complete, resubmit the request. When the job finishes, you will see a non-`null` value for the
// `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be
// the SHA of the _test_ merge commit.
// The value of the `merge_commit_sha` attribute changes depending on the state of the pull request.
// Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge
// commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how
// you merged the pull request:
// *   If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/),
//  `merge_commit_sha` represents the SHA of the merge commit.
// *   If merged via a [squash](https://help.github.
// com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha`
// represents the SHA of the squashed commit on the base branch.
// *   If [rebased](https://help.github.
// com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha`
// represents the commit that the base branch was updated to.
// Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (c *Client) PullsGet(ctx context.Context, params PullsGetParams) (res PullsGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsGetReview invokes pulls/get-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (c *Client) PullsGetReview(ctx context.Context, params PullsGetReviewParams) (res PullsGetReviewRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsGetReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsGetReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsGetReviewComment invokes pulls/get-review-comment operation.
//
// Provides details for a review comment.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (c *Client) PullsGetReviewComment(ctx context.Context, params PullsGetReviewCommentParams) (res PullsGetReviewCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsGetReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsGetReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsList invokes pulls/list operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/pulls
func (c *Client) PullsList(ctx context.Context, params PullsListParams) (res PullsListRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "head" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Head.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["head"] = e.Result()
	}
	{
		// Encode "base" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Base.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["base"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListCommentsForReview invokes pulls/list-comments-for-review operation.
//
// List comments for a specific pull request review.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (c *Client) PullsListCommentsForReview(ctx context.Context, params PullsListCommentsForReviewParams) (res PullsListCommentsForReviewRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-comments-for-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListCommentsForReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListCommentsForReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListCommits invokes pulls/list-commits operation.
//
// Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull
// requests with more than 250 commits, use the [List commits](https://docs.github.
// com/rest/reference/repos#list-commits) endpoint.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (c *Client) PullsListCommits(ctx context.Context, params PullsListCommitsParams) (res []Commit, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-commits"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListCommitsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListFiles invokes pulls/list-files operation.
//
// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per
// page by default.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
func (c *Client) PullsListFiles(ctx context.Context, params PullsListFilesParams) (res PullsListFilesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-files"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListFiles",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/files"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListFilesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListRequestedReviewers invokes pulls/list-requested-reviewers operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (c *Client) PullsListRequestedReviewers(ctx context.Context, params PullsListRequestedReviewersParams) (res PullRequestReviewRequest, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-requested-reviewers"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/requested_reviewers"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListRequestedReviewersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListReviewComments invokes pulls/list-review-comments operation.
//
// Lists all review comments for a pull request. By default, review comments are in ascending order
// by ID.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (c *Client) PullsListReviewComments(ctx context.Context, params PullsListReviewCommentsParams) (res []PullRequestReviewComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListReviewComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewCommentsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListReviewCommentsForRepo invokes pulls/list-review-comments-for-repo operation.
//
// Lists review comments for all pull requests in a repository. By default, review comments are in
// ascending order by ID.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (c *Client) PullsListReviewCommentsForRepo(ctx context.Context, params PullsListReviewCommentsForRepoParams) (res []PullRequestReviewComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListReviewCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewCommentsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsListReviews invokes pulls/list-reviews operation.
//
// The list of reviews returns in chronological order.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (c *Client) PullsListReviews(ctx context.Context, params PullsListReviewsParams) (res []PullRequestReview, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-reviews"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsListReviews",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsMerge invokes pulls/merge operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (c *Client) PullsMerge(ctx context.Context, request OptNilPullsMergeReq, params PullsMergeParams) (res PullsMergeRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/merge"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsMerge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsMergeRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/merge"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsMergeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsRemoveRequestedReviewers invokes pulls/remove-requested-reviewers operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (c *Client) PullsRemoveRequestedReviewers(ctx context.Context, request PullsRemoveRequestedReviewersReq, params PullsRemoveRequestedReviewersParams) (res PullsRemoveRequestedReviewersRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/remove-requested-reviewers"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsRemoveRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsRemoveRequestedReviewersRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/requested_reviewers"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsRemoveRequestedReviewersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsSubmitReview invokes pulls/submit-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (c *Client) PullsSubmitReview(ctx context.Context, request PullsSubmitReviewReq, params PullsSubmitReviewParams) (res PullsSubmitReviewRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/submit-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsSubmitReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsSubmitReviewRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/events"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsSubmitReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdate invokes pulls/update operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
//
// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
func (c *Client) PullsUpdate(ctx context.Context, request OptPullsUpdateReq, params PullsUpdateParams) (res PullsUpdateRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsUpdateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdateBranch invokes pulls/update-branch operation.
//
// Updates the pull request branch with the latest upstream changes by merging HEAD from the base
// branch into the pull request branch.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
func (c *Client) PullsUpdateBranch(ctx context.Context, request OptNilPullsUpdateBranchReq, params PullsUpdateBranchParams) (res PullsUpdateBranchRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-branch"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdateBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsUpdateBranchRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/update-branch"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateBranchResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdateReview invokes pulls/update-review operation.
//
// Update the review summary comment with new text.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (c *Client) PullsUpdateReview(ctx context.Context, request PullsUpdateReviewReq, params PullsUpdateReviewParams) (res PullsUpdateReviewRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdateReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsUpdateReviewRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/"
	{
		// Encode "pull_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.PullNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reviews/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateReviewResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PullsUpdateReviewComment invokes pulls/update-review-comment operation.
//
// Enables you to edit a review comment.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (c *Client) PullsUpdateReviewComment(ctx context.Context, request PullsUpdateReviewCommentReq, params PullsUpdateReviewCommentParams) (res PullRequestReviewComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PullsUpdateReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodePullsUpdateReviewCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RateLimitGet invokes rate-limit/get operation.
//
// **Note:** Accessing this endpoint does not count against your REST API rate limit.
// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating
// existing code, you should use the `core` object instead of the `rate` object. The `core` object
// contains the same information that is present in the `rate` object.
//
// GET /rate_limit
func (c *Client) RateLimitGet(ctx context.Context) (res RateLimitGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rate-limit/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "RateLimitGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/rate_limit"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRateLimitGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForCommitComment invokes reactions/create-for-commit-comment operation.
//
// Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this commit
// comment.
//
// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (c *Client) ReactionsCreateForCommitComment(ctx context.Context, request ReactionsCreateForCommitCommentReq, params ReactionsCreateForCommitCommentParams) (res ReactionsCreateForCommitCommentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForCommitCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForIssue invokes reactions/create-for-issue operation.
//
// Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with
// an HTTP `200` status means that you already added the reaction type to this issue.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (c *Client) ReactionsCreateForIssue(ctx context.Context, request ReactionsCreateForIssueReq, params ReactionsCreateForIssueParams) (res ReactionsCreateForIssueRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForIssueRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForIssueResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForIssueComment invokes reactions/create-for-issue-comment operation.
//
// Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this issue
// comment.
//
// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (c *Client) ReactionsCreateForIssueComment(ctx context.Context, request ReactionsCreateForIssueCommentReq, params ReactionsCreateForIssueCommentParams) (res ReactionsCreateForIssueCommentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForIssueCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForIssueCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForPullRequestReviewComment invokes reactions/create-for-pull-request-review-comment operation.
//
// Create a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already
// added the reaction type to this pull request review comment.
//
// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (c *Client) ReactionsCreateForPullRequestReviewComment(ctx context.Context, request ReactionsCreateForPullRequestReviewCommentReq, params ReactionsCreateForPullRequestReviewCommentParams) (res ReactionsCreateForPullRequestReviewCommentRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-pull-request-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForPullRequestReviewCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForPullRequestReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForRelease invokes reactions/create-for-release operation.
//
// Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A
// response with a `Status: 200 OK` means that you already added the reaction type to this release.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
func (c *Client) ReactionsCreateForRelease(ctx context.Context, request ReactionsCreateForReleaseReq, params ReactionsCreateForReleaseParams) (res ReactionsCreateForReleaseRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-release"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForReleaseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForReleaseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionCommentInOrg invokes reactions/create-for-team-discussion-comment-in-org operation.
//
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, request ReactionsCreateForTeamDiscussionCommentInOrgReq, params ReactionsCreateForTeamDiscussionCommentInOrgParams) (res ReactionsCreateForTeamDiscussionCommentInOrgRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForTeamDiscussionCommentInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionCommentInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionCommentLegacy invokes reactions/create-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Create reaction for a team discussion
// comment](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, request ReactionsCreateForTeamDiscussionCommentLegacyReq, params ReactionsCreateForTeamDiscussionCommentLegacyParams) (res Reaction, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForTeamDiscussionCommentLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionCommentLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionInOrg invokes reactions/create-for-team-discussion-in-org operation.
//
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//  OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, request ReactionsCreateForTeamDiscussionInOrgReq, params ReactionsCreateForTeamDiscussionInOrgParams) (res ReactionsCreateForTeamDiscussionInOrgRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForTeamDiscussionInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsCreateForTeamDiscussionLegacy invokes reactions/create-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create reaction for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//  OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, request ReactionsCreateForTeamDiscussionLegacyReq, params ReactionsCreateForTeamDiscussionLegacyParams) (res Reaction, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsCreateForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReactionsCreateForTeamDiscussionLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForCommitComment invokes reactions/delete-for-commit-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForCommitComment(ctx context.Context, params ReactionsDeleteForCommitCommentParams) (res ReactionsDeleteForCommitCommentNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForIssue invokes reactions/delete-for-issue operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
// Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForIssue(ctx context.Context, params ReactionsDeleteForIssueParams) (res ReactionsDeleteForIssueNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForIssueResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForIssueComment invokes reactions/delete-for-issue-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete
// /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForIssueComment(ctx context.Context, params ReactionsDeleteForIssueCommentParams) (res ReactionsDeleteForIssueCommentNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForIssueCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForPullRequestComment invokes reactions/delete-for-pull-request-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
// Delete a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForPullRequestComment(ctx context.Context, params ReactionsDeleteForPullRequestCommentParams) (res ReactionsDeleteForPullRequestCommentNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-pull-request-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForPullRequestComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForPullRequestCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForTeamDiscussion invokes reactions/delete-for-team-discussion operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//  OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, params ReactionsDeleteForTeamDiscussionParams) (res ReactionsDeleteForTeamDiscussionNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForTeamDiscussion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForTeamDiscussionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteForTeamDiscussionComment invokes reactions/delete-for-team-discussion-comment operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (c *Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, params ReactionsDeleteForTeamDiscussionCommentParams) (res ReactionsDeleteForTeamDiscussionCommentNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteForTeamDiscussionComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForTeamDiscussionCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsDeleteLegacy invokes reactions/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions
// API. We recommend migrating your existing code to use the new delete reactions endpoints. For more
// information, see this [blog post](https://developer.github.
// com/changes/2020-02-26-new-delete-reactions-endpoints/).
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team
// discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion
// comment](https://docs.github.com/rest/reference/teams#discussion-comments).
//
// DELETE /reactions/{reaction_id}
func (c *Client) ReactionsDeleteLegacy(ctx context.Context, params ReactionsDeleteLegacyParams) (res ReactionsDeleteLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/reactions/"
	{
		// Encode "reaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForCommitComment invokes reactions/list-for-commit-comment operation.
//
// List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (c *Client) ReactionsListForCommitComment(ctx context.Context, params ReactionsListForCommitCommentParams) (res ReactionsListForCommitCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForIssue invokes reactions/list-for-issue operation.
//
// List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (c *Client) ReactionsListForIssue(ctx context.Context, params ReactionsListForIssueParams) (res ReactionsListForIssueRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/"
	{
		// Encode "issue_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.IssueNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForIssueResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForIssueComment invokes reactions/list-for-issue-comment operation.
//
// List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (c *Client) ReactionsListForIssueComment(ctx context.Context, params ReactionsListForIssueCommentParams) (res ReactionsListForIssueCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/issues/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForIssueCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForPullRequestReviewComment invokes reactions/list-for-pull-request-review-comment operation.
//
// List the reactions to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (c *Client) ReactionsListForPullRequestReviewComment(ctx context.Context, params ReactionsListForPullRequestReviewCommentParams) (res ReactionsListForPullRequestReviewCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-pull-request-review-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForPullRequestReviewCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionCommentInOrg invokes reactions/list-for-team-discussion-comment-in-org operation.
//
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, params ReactionsListForTeamDiscussionCommentInOrgParams) (res []Reaction, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionCommentInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionCommentLegacy invokes reactions/list-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team discussion
// comment`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, params ReactionsListForTeamDiscussionCommentLegacyParams) (res []Reaction, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionCommentLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionInOrg invokes reactions/list-for-team-discussion-in-org operation.
//
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionInOrg(ctx context.Context, params ReactionsListForTeamDiscussionInOrgParams) (res []Reaction, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReactionsListForTeamDiscussionLegacy invokes reactions/list-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (c *Client) ReactionsListForTeamDiscussionLegacy(ctx context.Context, params ReactionsListForTeamDiscussionLegacyParams) (res []Reaction, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReactionsListForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reactions"

	q := u.Query()
	{
		// Encode "content" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Content.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["content"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAcceptInvitation invokes repos/accept-invitation operation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (c *Client) ReposAcceptInvitation(ctx context.Context, params ReposAcceptInvitationParams) (res ReposAcceptInvitationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/accept-invitation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAcceptInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/repository_invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposAcceptInvitationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddAppAccessRestrictions invokes repos/add-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified apps push access for this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//                                                                     |
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposAddAppAccessRestrictions(ctx context.Context, request OptReposAddAppAccessRestrictionsReq, params ReposAddAppAccessRestrictionsParams) (res ReposAddAppAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-app-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposAddAppAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/apps"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposAddAppAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddCollaborator invokes repos/add-collaborator operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// For more information the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// The invitee will receive a notification that they have been invited to the repository, which they
// must accept or decline. They may do this via the notifications page, the email they receive, or by
// using the [repository invitations API endpoints](https://docs.github.
// com/rest/reference/repos#invitations).
// **Rate limits**
// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no
// limit if you are inviting organization members to an organization repository.
//
// PUT /repos/{owner}/{repo}/collaborators/{username}
func (c *Client) ReposAddCollaborator(ctx context.Context, request OptReposAddCollaboratorReq, params ReposAddCollaboratorParams) (res ReposAddCollaboratorRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposAddCollaboratorRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposAddCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddStatusCheckContexts invokes repos/add-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposAddStatusCheckContexts(ctx context.Context, request OptReposAddStatusCheckContextsReq, params ReposAddStatusCheckContextsParams) (res ReposAddStatusCheckContextsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-status-check-contexts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposAddStatusCheckContextsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks/contexts"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposAddStatusCheckContextsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddTeamAccessRestrictions invokes repos/add-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified teams push access for this branch. You can also give push access to child
// teams.
// | Type    | Description
//                                                     |
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposAddTeamAccessRestrictions(ctx context.Context, request OptReposAddTeamAccessRestrictionsReq, params ReposAddTeamAccessRestrictionsParams) (res ReposAddTeamAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-team-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposAddTeamAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/teams"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposAddTeamAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposAddUserAccessRestrictions invokes repos/add-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified people push access for this branch.
// | Type    | Description
//                                        |
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposAddUserAccessRestrictions(ctx context.Context, request OptReposAddUserAccessRestrictionsReq, params ReposAddUserAccessRestrictionsParams) (res ReposAddUserAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-user-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposAddUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposAddUserAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/users"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposAddUserAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCheckCollaborator invokes repos/check-collaborator operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (c *Client) ReposCheckCollaborator(ctx context.Context, params ReposCheckCollaboratorParams) (res ReposCheckCollaboratorRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCheckCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCheckCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCheckVulnerabilityAlerts invokes repos/check-vulnerability-alerts operation.
//
// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user
// must have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (c *Client) ReposCheckVulnerabilityAlerts(ctx context.Context, params ReposCheckVulnerabilityAlertsParams) (res ReposCheckVulnerabilityAlertsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-vulnerability-alerts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCheckVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/vulnerability-alerts"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCheckVulnerabilityAlertsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCompareCommits invokes repos/compare-commits operation.
//
// The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in
// `repo`. To compare branches across other repositories in the same network as `repo`, use the
// format `<USERNAME>:branch`.
// The response from the API is equivalent to running the `git log base..head` command; however,
// commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
// The response also includes details on the files that were changed between the two commits. This
// includes the status of the change (for example, if a file was added, removed, modified, or
// renamed), and details of the change itself. For example, files with a `renamed` status have a
// `previous_filename` field showing the previous filename of the file, and files with a `modified`
// status have a `patch` field showing the changes made to the file.
// **Working with large comparisons**
// To process a response with a large number of commits, you can use (`per_page` or `page`) to
// paginate the results. When using paging, the list of changed files is only returned with page 1,
// but includes all changed files for the entire comparison. For more information on working with
// pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
// When calling this API without any paging parameters (`per_page` or `page`), the returned list is
// limited to 250 commits and the last commit in the list is the most recent of the entire comparison.
//  When a paging parameter is specified, the first commit in the returned list of each page is the
// earliest.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (c *Client) ReposCompareCommits(ctx context.Context, params ReposCompareCommitsParams) (res ReposCompareCommitsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/compare-commits"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCompareCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/compare/"
	{
		// Encode "basehead" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "basehead",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Basehead))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCompareCommitsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateAutolink invokes repos/create-autolink operation.
//
// Users with admin access to the repository can create an autolink.
//
// POST /repos/{owner}/{repo}/autolinks
func (c *Client) ReposCreateAutolink(ctx context.Context, request ReposCreateAutolinkReq, params ReposCreateAutolinkParams) (res ReposCreateAutolinkRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-autolink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateAutolinkRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/autolinks"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateAutolinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateCommitComment invokes repos/create-commit-comment operation.
//
// Create a comment for a commit using its `:commit_sha`.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (c *Client) ReposCreateCommitComment(ctx context.Context, request ReposCreateCommitCommentReq, params ReposCreateCommitCommentParams) (res ReposCreateCommitCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateCommitCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateCommitSignatureProtection invokes repos/create-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// require signed commits on a branch. You must enable branch protection to require signed commits.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (c *Client) ReposCreateCommitSignatureProtection(ctx context.Context, params ReposCreateCommitSignatureProtectionParams) (res ReposCreateCommitSignatureProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-signature-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_signatures"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitSignatureProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateCommitStatus invokes repos/create-commit-status operation.
//
// Users with push access in a repository can create commit statuses for a given SHA.
// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
// create more than 1000 statuses will result in a validation error.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (c *Client) ReposCreateCommitStatus(ctx context.Context, request ReposCreateCommitStatusReq, params ReposCreateCommitStatusParams) (res Status, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-status"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateCommitStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateCommitStatusRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/statuses/"
	{
		// Encode "sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Sha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitStatusResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDeployKey invokes repos/create-deploy-key operation.
//
// You can create a read-only deploy key.
//
// POST /repos/{owner}/{repo}/keys
func (c *Client) ReposCreateDeployKey(ctx context.Context, request ReposCreateDeployKeyReq, params ReposCreateDeployKeyParams) (res ReposCreateDeployKeyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deploy-key"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateDeployKeyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/keys"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDeployKeyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDeployment invokes repos/create-deployment operation.
//
// Deployments offer a few configurable parameters with certain defaults.
// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and
// verify them
// before we merge a pull request.
// The `environment` parameter allows deployments to be issued to different runtime environments.
// Teams often have
// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`.
// This parameter
// makes it easier to track which environments have requested deployments. The default environment is
// `production`.
// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's
// default branch. If
// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If
// the merge succeeds,
// the API will return a successful merge commit. If merge conflicts prevent the merge from
// succeeding, the API will
// return a failure response.
// By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every
// submitted context must be in a `success`
// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be
// `success`, or to
// specify contexts that have not yet been submitted. You are not required to use commit statuses to
// deploy. If you do
// not require any contexts or create any commit statuses, the deployment will always succeed.
// The `payload` parameter is available for any extra information that a deployment system might need.
//  It is a JSON text
// field that will be passed on when a deployment event is dispatched.
// The `task` parameter is used by the deployment system to allow different execution paths. In the
// web world this might
// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a
// flag to compile an
// application with debugging enabled.
// Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
// #### Merged branch response
// You will see this response when GitHub automatically merges the base branch into the topic branch
// instead of creating
// a deployment. This auto-merge happens when:
// *   Auto-merge option is enabled in the repository
// *   Topic branch does not include the latest changes on the base branch, which is `master` in the
// response example
// *   There are no merge conflicts
// If there are no new commits in the base branch, a new request to create a deployment should give a
// successful
// response.
// #### Merge conflict response
// This error happens when the `auto_merge` option is enabled and when the default branch (in this
// case `master`), can't
// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge
// conflicts.
// #### Failed commit status checks
// This error happens when the `required_contexts` parameter indicates that one or more contexts need
// to have a `success`
// status for the commit to be deployed, but one or more of the required contexts do not have a state
// of `success`.
//
// POST /repos/{owner}/{repo}/deployments
func (c *Client) ReposCreateDeployment(ctx context.Context, request ReposCreateDeploymentReq, params ReposCreateDeploymentParams) (res ReposCreateDeploymentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateDeploymentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDeploymentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDeploymentStatus invokes repos/create-deployment-status operation.
//
// Users with `push` access can create deployment statuses for a given deployment.
// GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo
// contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
//
// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (c *Client) ReposCreateDeploymentStatus(ctx context.Context, request ReposCreateDeploymentStatusReq, params ReposCreateDeploymentStatusParams) (res ReposCreateDeploymentStatusRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment-status"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateDeploymentStatusRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/statuses"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDeploymentStatusResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateDispatchEvent invokes repos/create-dispatch-event operation.
//
// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want
// activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook.
//  You must configure your GitHub Actions workflow or GitHub App to run when the
// `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
// "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
// The `client_payload` parameter is available for any extra information that your workflow might
// need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched.
//  For example, the `client_payload` can include a message that a user would like to send using a
// GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
// This endpoint requires write access to the repository by providing either:
// - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access
// token for the command line](https://help.github.
// com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help
// documentation.
// - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
// This input example shows how you can use the `client_payload` as a test to debug your workflow.
//
// POST /repos/{owner}/{repo}/dispatches
func (c *Client) ReposCreateDispatchEvent(ctx context.Context, request ReposCreateDispatchEventReq, params ReposCreateDispatchEventParams) (res ReposCreateDispatchEventRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-dispatch-event"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateDispatchEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateDispatchEventRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/dispatches"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDispatchEventResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateForAuthenticatedUser invokes repos/create-for-authenticated-user operation.
//
// Creates a new repository for the authenticated user.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /user/repos
func (c *Client) ReposCreateForAuthenticatedUser(ctx context.Context, request ReposCreateForAuthenticatedUserReq) (res ReposCreateForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateForAuthenticatedUserRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/repos"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateFork invokes repos/create-fork operation.
//
// Create a fork for the authenticated user.
// **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time
// before you can access the git objects. If this takes longer than 5 minutes, be sure to contact
// [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
//
// POST /repos/{owner}/{repo}/forks
func (c *Client) ReposCreateFork(ctx context.Context, request OptNilReposCreateForkReq, params ReposCreateForkParams) (res ReposCreateForkRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-fork"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateFork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateForkRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/forks"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateForkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateInOrg invokes repos/create-in-org operation.
//
// Creates a new repository in the specified organization. The authenticated user must be a member of
// the organization.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /orgs/{org}/repos
func (c *Client) ReposCreateInOrg(ctx context.Context, request ReposCreateInOrgReq, params ReposCreateInOrgParams) (res ReposCreateInOrgRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateOrUpdateFileContents invokes repos/create-or-update-file-contents operation.
//
// Creates a new file or replaces an existing file in a repository.
//
// PUT /repos/{owner}/{repo}/contents/{path}
func (c *Client) ReposCreateOrUpdateFileContents(ctx context.Context, request ReposCreateOrUpdateFileContentsReq, params ReposCreateOrUpdateFileContentsParams) (res ReposCreateOrUpdateFileContentsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-or-update-file-contents"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateOrUpdateFileContents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateOrUpdateFileContentsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/contents/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateOrUpdateFileContentsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreatePagesSite invokes repos/create-pages-site operation.
//
// Configures a GitHub Pages site. For more information, see "[About GitHub
// Pages](/github/working-with-github-pages/about-github-pages).".
//
// POST /repos/{owner}/{repo}/pages
func (c *Client) ReposCreatePagesSite(ctx context.Context, request NilReposCreatePagesSiteReq, params ReposCreatePagesSiteParams) (res ReposCreatePagesSiteRes, err error) {
	if err := func() error {
		if err := request.Value.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-pages-site"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreatePagesSite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreatePagesSiteRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreatePagesSiteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateRelease invokes repos/create-release operation.
//
// Users with push access to the repository can create a release.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/releases
func (c *Client) ReposCreateRelease(ctx context.Context, request ReposCreateReleaseReq, params ReposCreateReleaseParams) (res ReposCreateReleaseRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-release"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateReleaseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateReleaseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateUsingTemplate invokes repos/create-using-template operation.
//
// Creates a new repository using a repository template. Use the `template_owner` and `template_repo`
// route parameters to specify the repository to use as the template. The authenticated user must own
// or be a member of an organization that owns the repository. To check if a repository is available
// to use as a template, get the repository's information using the [Get a repository](https://docs.
// github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is
// `true`.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (c *Client) ReposCreateUsingTemplate(ctx context.Context, request ReposCreateUsingTemplateReq, params ReposCreateUsingTemplateParams) (res Repository, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-using-template"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateUsingTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateUsingTemplateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "template_owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "template_owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateOwner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "template_repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "template_repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateRepo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/generate"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateUsingTemplateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposCreateWebhook invokes repos/create-webhook operation.
//
// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`.
// Multiple webhooks can
// share the same `config` as long as those webhooks do not have any `events` that overlap.
//
// POST /repos/{owner}/{repo}/hooks
func (c *Client) ReposCreateWebhook(ctx context.Context, request OptNilReposCreateWebhookReq, params ReposCreateWebhookParams) (res ReposCreateWebhookRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposCreateWebhookRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeclineInvitation invokes repos/decline-invitation operation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (c *Client) ReposDeclineInvitation(ctx context.Context, params ReposDeclineInvitationParams) (res ReposDeclineInvitationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/decline-invitation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeclineInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/repository_invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeclineInvitationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDelete invokes repos/delete operation.
//
// Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
// If an organization owner has configured the organization to prevent members from deleting
// organization-owned
// repositories, you will get a `403 Forbidden` response.
//
// DELETE /repos/{owner}/{repo}
func (c *Client) ReposDelete(ctx context.Context, params ReposDeleteParams) (res ReposDeleteRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAccessRestrictions invokes repos/delete-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Disables the ability to restrict who can push to this branch.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (c *Client) ReposDeleteAccessRestrictions(ctx context.Context, params ReposDeleteAccessRestrictionsParams) (res ReposDeleteAccessRestrictionsNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAdminBranchProtection invokes repos/delete-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removing admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (c *Client) ReposDeleteAdminBranchProtection(ctx context.Context, params ReposDeleteAdminBranchProtectionParams) (res ReposDeleteAdminBranchProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-admin-branch-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/enforce_admins"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAdminBranchProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAnEnvironment invokes repos/delete-an-environment operation.
//
// You must authenticate using an access token with the repo scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (c *Client) ReposDeleteAnEnvironment(ctx context.Context, params ReposDeleteAnEnvironmentParams) (res ReposDeleteAnEnvironmentNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-an-environment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAnEnvironment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/environments/"
	{
		// Encode "environment_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAnEnvironmentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteAutolink invokes repos/delete-autolink operation.
//
// This deletes a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (c *Client) ReposDeleteAutolink(ctx context.Context, params ReposDeleteAutolinkParams) (res ReposDeleteAutolinkRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-autolink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/autolinks/"
	{
		// Encode "autolink_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autolink_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AutolinkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAutolinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteBranchProtection invokes repos/delete-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (c *Client) ReposDeleteBranchProtection(ctx context.Context, params ReposDeleteBranchProtectionParams) (res ReposDeleteBranchProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-branch-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteBranchProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteCommitComment invokes repos/delete-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (c *Client) ReposDeleteCommitComment(ctx context.Context, params ReposDeleteCommitCommentParams) (res ReposDeleteCommitCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteCommitSignatureProtection invokes repos/delete-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// disable required signed commits on a branch. You must enable branch protection to require signed
// commits.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (c *Client) ReposDeleteCommitSignatureProtection(ctx context.Context, params ReposDeleteCommitSignatureProtectionParams) (res ReposDeleteCommitSignatureProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-signature-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_signatures"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteCommitSignatureProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteDeployKey invokes repos/delete-deploy-key operation.
//
// Deploy keys are immutable. If you need to update a key, remove the key and create a new one
// instead.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (c *Client) ReposDeleteDeployKey(ctx context.Context, params ReposDeleteDeployKeyParams) (res ReposDeleteDeployKeyNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deploy-key"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteDeployKeyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteDeployment invokes repos/delete-deployment operation.
//
// To ensure there can always be an active deployment, you can only delete an _inactive_ deployment.
// Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
// To set a deployment as inactive, you must:
// *   Create a new deployment that is active so that the system has a record of the current state,
// then delete the previously active deployment.
// *   Mark the active deployment as inactive by adding any non-successful deployment status.
// For more information, see "[Create a deployment](https://docs.github.
// com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.
// github.com/rest/reference/repos#create-a-deployment-status).".
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (c *Client) ReposDeleteDeployment(ctx context.Context, params ReposDeleteDeploymentParams) (res ReposDeleteDeploymentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deployment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteDeploymentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteFile invokes repos/delete-file operation.
//
// Deletes a file in a repository.
// You can provide an additional `committer` parameter, which is an object containing information
// about the committer. Or, you can provide an `author` parameter, which is an object containing
// information about the author.
// The `author` section is optional and is filled in with the `committer` information if omitted. If
// the `committer` information is omitted, the authenticated user's information is used.
// You must provide values for both `name` and `email`, whether you choose to use `author` or
// `committer`. Otherwise, you'll receive a `422` status code.
//
// DELETE /repos/{owner}/{repo}/contents/{path}
func (c *Client) ReposDeleteFile(ctx context.Context, request ReposDeleteFileReq, params ReposDeleteFileParams) (res ReposDeleteFileRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-file"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteFile",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposDeleteFileRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/contents/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteFileResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteInvitation invokes repos/delete-invitation operation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (c *Client) ReposDeleteInvitation(ctx context.Context, params ReposDeleteInvitationParams) (res ReposDeleteInvitationNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-invitation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteInvitationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeletePagesSite invokes repos/delete-pages-site operation.
//
// DELETE /repos/{owner}/{repo}/pages
func (c *Client) ReposDeletePagesSite(ctx context.Context, params ReposDeletePagesSiteParams) (res ReposDeletePagesSiteRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pages-site"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeletePagesSite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeletePagesSiteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeletePullRequestReviewProtection invokes repos/delete-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (c *Client) ReposDeletePullRequestReviewProtection(ctx context.Context, params ReposDeletePullRequestReviewProtectionParams) (res ReposDeletePullRequestReviewProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pull-request-review-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeletePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_pull_request_reviews"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeletePullRequestReviewProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteRelease invokes repos/delete-release operation.
//
// Users with push access to the repository can delete a release.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (c *Client) ReposDeleteRelease(ctx context.Context, params ReposDeleteReleaseParams) (res ReposDeleteReleaseNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteReleaseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteReleaseAsset invokes repos/delete-release-asset operation.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (c *Client) ReposDeleteReleaseAsset(ctx context.Context, params ReposDeleteReleaseAssetParams) (res ReposDeleteReleaseAssetNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release-asset"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/assets/"
	{
		// Encode "asset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AssetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteReleaseAssetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDeleteWebhook invokes repos/delete-webhook operation.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (c *Client) ReposDeleteWebhook(ctx context.Context, params ReposDeleteWebhookParams) (res ReposDeleteWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDisableAutomatedSecurityFixes invokes repos/disable-automated-security-fixes operation.
//
// Disables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (c *Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, params ReposDisableAutomatedSecurityFixesParams) (res ReposDisableAutomatedSecurityFixesNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-automated-security-fixes"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDisableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/automated-security-fixes"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableAutomatedSecurityFixesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDisableLfsForRepo invokes repos/disable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// DELETE /repos/{owner}/{repo}/lfs
func (c *Client) ReposDisableLfsForRepo(ctx context.Context, params ReposDisableLfsForRepoParams) (res ReposDisableLfsForRepoNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-lfs-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDisableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/lfs"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableLfsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDisableVulnerabilityAlerts invokes repos/disable-vulnerability-alerts operation.
//
// Disables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (c *Client) ReposDisableVulnerabilityAlerts(ctx context.Context, params ReposDisableVulnerabilityAlertsParams) (res ReposDisableVulnerabilityAlertsNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-vulnerability-alerts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDisableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/vulnerability-alerts"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableVulnerabilityAlertsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDownloadTarballArchive invokes repos/download-tarball-archive operation.
//
// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
// repositorys default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (c *Client) ReposDownloadTarballArchive(ctx context.Context, params ReposDownloadTarballArchiveParams) (res ReposDownloadTarballArchiveFound, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-tarball-archive"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDownloadTarballArchive",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/tarball/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDownloadTarballArchiveResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposDownloadZipballArchive invokes repos/download-zipball-archive operation.
//
// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
// repositorys default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (c *Client) ReposDownloadZipballArchive(ctx context.Context, params ReposDownloadZipballArchiveParams) (res ReposDownloadZipballArchiveFound, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-zipball-archive"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposDownloadZipballArchive",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/zipball/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposDownloadZipballArchiveResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposEnableAutomatedSecurityFixes invokes repos/enable-automated-security-fixes operation.
//
// Enables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (c *Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, params ReposEnableAutomatedSecurityFixesParams) (res ReposEnableAutomatedSecurityFixesNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-automated-security-fixes"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposEnableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/automated-security-fixes"

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableAutomatedSecurityFixesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposEnableLfsForRepo invokes repos/enable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// PUT /repos/{owner}/{repo}/lfs
func (c *Client) ReposEnableLfsForRepo(ctx context.Context, params ReposEnableLfsForRepoParams) (res ReposEnableLfsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-lfs-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposEnableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/lfs"

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableLfsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposEnableVulnerabilityAlerts invokes repos/enable-vulnerability-alerts operation.
//
// Enables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (c *Client) ReposEnableVulnerabilityAlerts(ctx context.Context, params ReposEnableVulnerabilityAlertsParams) (res ReposEnableVulnerabilityAlertsNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-vulnerability-alerts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposEnableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/vulnerability-alerts"

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableVulnerabilityAlertsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGet invokes repos/get operation.
//
// The `parent` and `source` objects are present when the repository is a fork. `parent` is the
// repository this repository was forked from, `source` is the ultimate source for the network.
//
// GET /repos/{owner}/{repo}
func (c *Client) ReposGet(ctx context.Context, params ReposGetParams) (res ReposGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAccessRestrictions invokes repos/get-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists who has access to this protected branch.
// **Note**: Users, apps, and teams `restrictions` are only available for organization-owned
// repositories.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (c *Client) ReposGetAccessRestrictions(ctx context.Context, params ReposGetAccessRestrictionsParams) (res ReposGetAccessRestrictionsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAdminBranchProtection invokes repos/get-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (c *Client) ReposGetAdminBranchProtection(ctx context.Context, params ReposGetAdminBranchProtectionParams) (res ProtectedBranchAdminEnforced, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-admin-branch-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/enforce_admins"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAdminBranchProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAllStatusCheckContexts invokes repos/get-all-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposGetAllStatusCheckContexts(ctx context.Context, params ReposGetAllStatusCheckContextsParams) (res ReposGetAllStatusCheckContextsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-status-check-contexts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAllStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks/contexts"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllStatusCheckContextsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAllTopics invokes repos/get-all-topics operation.
//
// GET /repos/{owner}/{repo}/topics
func (c *Client) ReposGetAllTopics(ctx context.Context, params ReposGetAllTopicsParams) (res ReposGetAllTopicsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-topics"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAllTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/topics"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllTopicsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAppsWithAccessToProtectedBranch invokes repos/get-apps-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with
// `write` access to the `contents` permission can be added as authorized actors on a protected
// branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, params ReposGetAppsWithAccessToProtectedBranchParams) (res ReposGetAppsWithAccessToProtectedBranchRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-apps-with-access-to-protected-branch"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAppsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/apps"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAppsWithAccessToProtectedBranchResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetAutolink invokes repos/get-autolink operation.
//
// This returns a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (c *Client) ReposGetAutolink(ctx context.Context, params ReposGetAutolinkParams) (res ReposGetAutolinkRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-autolink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/autolinks/"
	{
		// Encode "autolink_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autolink_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AutolinkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAutolinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetBranch invokes repos/get-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (c *Client) ReposGetBranch(ctx context.Context, params ReposGetBranchParams) (res ReposGetBranchRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetBranchResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetBranchProtection invokes repos/get-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (c *Client) ReposGetBranchProtection(ctx context.Context, params ReposGetBranchProtectionParams) (res ReposGetBranchProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetBranchProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetClones invokes repos/get-clones operation.
//
// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (c *Client) ReposGetClones(ctx context.Context, params ReposGetClonesParams) (res ReposGetClonesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-clones"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetClones",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/traffic/clones"

	q := u.Query()
	{
		// Encode "per" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Per.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetClonesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCodeFrequencyStats invokes repos/get-code-frequency-stats operation.
//
// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (c *Client) ReposGetCodeFrequencyStats(ctx context.Context, params ReposGetCodeFrequencyStatsParams) (res ReposGetCodeFrequencyStatsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-code-frequency-stats"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCodeFrequencyStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/stats/code_frequency"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCodeFrequencyStatsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCollaboratorPermissionLevel invokes repos/get-collaborator-permission-level operation.
//
// Checks the repository permission of a collaborator. The possible repository permissions are
// `admin`, `write`, `read`, and `none`.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (c *Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, params ReposGetCollaboratorPermissionLevelParams) (res ReposGetCollaboratorPermissionLevelRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-collaborator-permission-level"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCollaboratorPermissionLevel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/permission"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCollaboratorPermissionLevelResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCombinedStatusForRef invokes repos/get-combined-status-for-ref operation.
//
// Users with pull access in a repository can access a combined view of commit statuses for a given
// ref. The ref can be a SHA, a branch name, or a tag name.
// The most recent status for each context is returned, up to 100. This field
// [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there
// are over 100 contexts.
// Additionally, a combined `state` is returned. The `state` is one of:
// *   **failure** if any of the contexts report as `error` or `failure`
// *   **pending** if there are no statuses or a context is `pending`
// *   **success** if the latest status for all contexts is `success`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (c *Client) ReposGetCombinedStatusForRef(ctx context.Context, params ReposGetCombinedStatusForRefParams) (res ReposGetCombinedStatusForRefRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-combined-status-for-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCombinedStatusForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/status"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCombinedStatusForRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommit invokes repos/get-commit operation.
//
// Returns the contents of a single commit reference. You must have `read` access for the repository
// to use this endpoint.
// **Note:** If there are more than 300 files in the commit diff, the response will include
// pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains
// the static commit information, and the only changes are to the file listing.
// You can pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and
// `patch` formats. Diffs with binary data will have no `patch` property.
// To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
// type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header.
//  You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local
// reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits/{ref}
func (c *Client) ReposGetCommit(ctx context.Context, params ReposGetCommitParams) (res ReposGetCommitRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommitActivityStats invokes repos/get-commit-activity-stats operation.
//
// Returns the last year of commit activity grouped by week. The `days` array is a group of commits
// per day, starting on `Sunday`.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (c *Client) ReposGetCommitActivityStats(ctx context.Context, params ReposGetCommitActivityStatsParams) (res ReposGetCommitActivityStatsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-activity-stats"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommitActivityStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/stats/commit_activity"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitActivityStatsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommitComment invokes repos/get-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (c *Client) ReposGetCommitComment(ctx context.Context, params ReposGetCommitCommentParams) (res ReposGetCommitCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommitSignatureProtection invokes repos/get-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// check whether a branch requires signed commits. An enabled status of `true` indicates you must
// sign commits on this branch. For more information, see [Signing commits with GPG](https://help.
// github.com/articles/signing-commits-with-gpg) in GitHub Help.
// **Note**: You must enable branch protection to require signed commits.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (c *Client) ReposGetCommitSignatureProtection(ctx context.Context, params ReposGetCommitSignatureProtectionParams) (res ReposGetCommitSignatureProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-signature-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_signatures"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitSignatureProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetCommunityProfileMetrics invokes repos/get-community-profile-metrics operation.
//
// This endpoint will return all community profile metrics, including an
// overall health score, repository description, the presence of documentation, detected
// code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
// README, and CONTRIBUTING files.
// The `health_percentage` score is defined as a percentage of how many of
// these four documents are present: README, CONTRIBUTING, LICENSE, and
// CODE_OF_CONDUCT. For example, if all four documents are present, then
// the `health_percentage` is `100`. If only one is present, then the
// `health_percentage` is `25`.
// `content_reports_enabled` is only returned for organization-owned repositories.
//
// GET /repos/{owner}/{repo}/community/profile
func (c *Client) ReposGetCommunityProfileMetrics(ctx context.Context, params ReposGetCommunityProfileMetricsParams) (res CommunityProfile, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-community-profile-metrics"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetCommunityProfileMetrics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/community/profile"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommunityProfileMetricsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetContributorsStats invokes repos/get-contributors-stats operation.
//
// Returns the `total` number of commits authored by the contributor. In addition, the response
// includes a Weekly Hash (`weeks` array) with the following information:
// *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
// *   `a` - Number of additions
// *   `d` - Number of deletions
// *   `c` - Number of commits.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (c *Client) ReposGetContributorsStats(ctx context.Context, params ReposGetContributorsStatsParams) (res ReposGetContributorsStatsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-contributors-stats"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetContributorsStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/stats/contributors"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetContributorsStatsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetDeployKey invokes repos/get-deploy-key operation.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (c *Client) ReposGetDeployKey(ctx context.Context, params ReposGetDeployKeyParams) (res ReposGetDeployKeyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deploy-key"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeployKeyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetDeployment invokes repos/get-deployment operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}
func (c *Client) ReposGetDeployment(ctx context.Context, params ReposGetDeploymentParams) (res ReposGetDeploymentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeploymentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetDeploymentStatus invokes repos/get-deployment-status operation.
//
// Users with pull access can view a deployment status for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (c *Client) ReposGetDeploymentStatus(ctx context.Context, params ReposGetDeploymentStatusParams) (res ReposGetDeploymentStatusRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment-status"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/statuses/"
	{
		// Encode "status_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "status_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.StatusID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeploymentStatusResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetLatestPagesBuild invokes repos/get-latest-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (c *Client) ReposGetLatestPagesBuild(ctx context.Context, params ReposGetLatestPagesBuildParams) (res PageBuild, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-pages-build"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetLatestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages/builds/latest"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetLatestPagesBuildResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetLatestRelease invokes repos/get-latest-release operation.
//
// View the latest published full release for the repository.
// The latest release is the most recent non-prerelease, non-draft release, sorted by the
// `created_at` attribute. The `created_at` attribute is the date of the commit used for the release,
// and not the date when the release was drafted or published.
//
// GET /repos/{owner}/{repo}/releases/latest
func (c *Client) ReposGetLatestRelease(ctx context.Context, params ReposGetLatestReleaseParams) (res Release, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-release"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetLatestRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/latest"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetLatestReleaseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPages invokes repos/get-pages operation.
//
// GET /repos/{owner}/{repo}/pages
func (c *Client) ReposGetPages(ctx context.Context, params ReposGetPagesParams) (res ReposGetPagesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPagesBuild invokes repos/get-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (c *Client) ReposGetPagesBuild(ctx context.Context, params ReposGetPagesBuildParams) (res PageBuild, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-build"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages/builds/"
	{
		// Encode "build_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "build_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.BuildID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesBuildResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPagesHealthCheck invokes repos/get-pages-health-check operation.
//
// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
// GitHub Pages.
// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous
// background task to get the results for the domain. After the background task completes, subsequent
// requests to this endpoint return a `200 OK` status with the health check results in the response.
// Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and
// `administration:write` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/pages/health
func (c *Client) ReposGetPagesHealthCheck(ctx context.Context, params ReposGetPagesHealthCheckParams) (res ReposGetPagesHealthCheckRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-health-check"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPagesHealthCheck",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages/health"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesHealthCheckResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetParticipationStats invokes repos/get-participation-stats operation.
//
// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
// everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit
// counts for non-owners, you can subtract `owner` from `all`.
// The array order is oldest week (index 0) to most recent week.
//
// GET /repos/{owner}/{repo}/stats/participation
func (c *Client) ReposGetParticipationStats(ctx context.Context, params ReposGetParticipationStatsParams) (res ReposGetParticipationStatsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-participation-stats"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetParticipationStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/stats/participation"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetParticipationStatsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPullRequestReviewProtection invokes repos/get-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (c *Client) ReposGetPullRequestReviewProtection(ctx context.Context, params ReposGetPullRequestReviewProtectionParams) (res ProtectedBranchPullRequestReview, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pull-request-review-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_pull_request_reviews"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPullRequestReviewProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetPunchCardStats invokes repos/get-punch-card-stats operation.
//
// Each array contains the day number, hour number, and number of commits:
// *   `0-6`: Sunday - Saturday
// *   `0-23`: Hour of day
// *   Number of commits
// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on
// Tuesdays. All times are based on the time zone of individual commits.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (c *Client) ReposGetPunchCardStats(ctx context.Context, params ReposGetPunchCardStatsParams) (res ReposGetPunchCardStatsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-punch-card-stats"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetPunchCardStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/stats/punch_card"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPunchCardStatsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReadme invokes repos/get-readme operation.
//
// Gets the preferred README for a repository.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme
func (c *Client) ReposGetReadme(ctx context.Context, params ReposGetReadmeParams) (res ReposGetReadmeRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReadme",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/readme"

	q := u.Query()
	{
		// Encode "ref" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Ref.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["ref"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReadmeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReadmeInDirectory invokes repos/get-readme-in-directory operation.
//
// Gets the README from a repository directory.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme/{dir}
func (c *Client) ReposGetReadmeInDirectory(ctx context.Context, params ReposGetReadmeInDirectoryParams) (res ReposGetReadmeInDirectoryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme-in-directory"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReadmeInDirectory",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/readme/"
	{
		// Encode "dir" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dir",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Dir))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	q := u.Query()
	{
		// Encode "ref" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Ref.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["ref"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReadmeInDirectoryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetRelease invokes repos/get-release operation.
//
// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release
// assets. This key is a [hypermedia resource](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia).
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (c *Client) ReposGetRelease(ctx context.Context, params ReposGetReleaseParams) (res ReposGetReleaseRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReleaseAsset invokes repos/get-release-asset operation.
//
// To download the asset's binary content, set the `Accept` header of the request to
// [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
// either redirect the client to the location, or stream it directly if possible. API clients should
// handle both a `200` or `302` response.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (c *Client) ReposGetReleaseAsset(ctx context.Context, params ReposGetReleaseAssetParams) (res ReposGetReleaseAssetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-asset"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/assets/"
	{
		// Encode "asset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AssetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseAssetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetReleaseByTag invokes repos/get-release-by-tag operation.
//
// Get a published release with the specified tag.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (c *Client) ReposGetReleaseByTag(ctx context.Context, params ReposGetReleaseByTagParams) (res ReposGetReleaseByTagRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-by-tag"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetReleaseByTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/tags/"
	{
		// Encode "tag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Tag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseByTagResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetStatusChecksProtection invokes repos/get-status-checks-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (c *Client) ReposGetStatusChecksProtection(ctx context.Context, params ReposGetStatusChecksProtectionParams) (res ReposGetStatusChecksProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-status-checks-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetStatusChecksProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetStatusChecksProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetTeamsWithAccessToProtectedBranch invokes repos/get-teams-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the teams who have push access to this branch. The list includes child teams.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, params ReposGetTeamsWithAccessToProtectedBranchParams) (res ReposGetTeamsWithAccessToProtectedBranchRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-teams-with-access-to-protected-branch"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetTeamsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/teams"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTeamsWithAccessToProtectedBranchResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetTopPaths invokes repos/get-top-paths operation.
//
// Get the top 10 popular contents over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (c *Client) ReposGetTopPaths(ctx context.Context, params ReposGetTopPathsParams) (res ReposGetTopPathsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-paths"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetTopPaths",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/traffic/popular/paths"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTopPathsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetTopReferrers invokes repos/get-top-referrers operation.
//
// Get the top 10 referrers over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (c *Client) ReposGetTopReferrers(ctx context.Context, params ReposGetTopReferrersParams) (res ReposGetTopReferrersRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-referrers"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetTopReferrers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/traffic/popular/referrers"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTopReferrersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetUsersWithAccessToProtectedBranch invokes repos/get-users-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the people who have push access to this branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, params ReposGetUsersWithAccessToProtectedBranchParams) (res ReposGetUsersWithAccessToProtectedBranchRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-users-with-access-to-protected-branch"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetUsersWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/users"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetUsersWithAccessToProtectedBranchResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetViews invokes repos/get-views operation.
//
// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/views
func (c *Client) ReposGetViews(ctx context.Context, params ReposGetViewsParams) (res ReposGetViewsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-views"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetViews",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/traffic/views"

	q := u.Query()
	{
		// Encode "per" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Per.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetViewsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetWebhook invokes repos/get-webhook operation.
//
// Returns a webhook configured in a repository. To get only the webhook `config` properties, see
// "[Get a webhook configuration for a
// repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (c *Client) ReposGetWebhook(ctx context.Context, params ReposGetWebhookParams) (res ReposGetWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetWebhookConfigForRepo invokes repos/get-webhook-config-for-repo operation.
//
// Returns the webhook configuration for a repository. To get more information about the webhook,
// including the `active` state and `events`, use "[Get a repository
// webhook](/rest/reference/orgs#get-a-repository-webhook)."
// Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:read` permission.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (c *Client) ReposGetWebhookConfigForRepo(ctx context.Context, params ReposGetWebhookConfigForRepoParams) (res WebhookConfig, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-config-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/config"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetWebhookConfigForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposGetWebhookDelivery invokes repos/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
func (c *Client) ReposGetWebhookDelivery(ctx context.Context, params ReposGetWebhookDeliveryParams) (res ReposGetWebhookDeliveryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-delivery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposGetWebhookDeliveryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListAutolinks invokes repos/list-autolinks operation.
//
// This returns a list of autolinks configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks
func (c *Client) ReposListAutolinks(ctx context.Context, params ReposListAutolinksParams) (res []Autolink, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-autolinks"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListAutolinks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/autolinks"

	q := u.Query()
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListAutolinksResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListBranches invokes repos/list-branches operation.
//
// GET /repos/{owner}/{repo}/branches
func (c *Client) ReposListBranches(ctx context.Context, params ReposListBranchesParams) (res ReposListBranchesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListBranches",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches"

	q := u.Query()
	{
		// Encode "protected" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Protected.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["protected"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListBranchesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListBranchesForHeadCommit invokes repos/list-branches-for-head-commit operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
func (c *Client) ReposListBranchesForHeadCommit(ctx context.Context, params ReposListBranchesForHeadCommitParams) (res ReposListBranchesForHeadCommitRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches-for-head-commit"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListBranchesForHeadCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches-where-head"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListBranchesForHeadCommitResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCollaborators invokes repos/list-collaborators operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators
func (c *Client) ReposListCollaborators(ctx context.Context, params ReposListCollaboratorsParams) (res ReposListCollaboratorsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-collaborators"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators"

	q := u.Query()
	{
		// Encode "affiliation" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Affiliation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["affiliation"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListCollaboratorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommentsForCommit invokes repos/list-comments-for-commit operation.
//
// Use the `:commit_sha` to specify the commit that will have its comments listed.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (c *Client) ReposListCommentsForCommit(ctx context.Context, params ReposListCommentsForCommitParams) (res []CommitComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-comments-for-commit"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommentsForCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommentsForCommitResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommitCommentsForRepo invokes repos/list-commit-comments-for-repo operation.
//
// Commit Comments use [these custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types). You can read more about the use of media types in
// the API [here](https://docs.github.com/rest/overview/media-types/).
// Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/comments
func (c *Client) ReposListCommitCommentsForRepo(ctx context.Context, params ReposListCommitCommentsForRepoParams) (res []CommitComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-comments-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommitCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitCommentsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommitStatusesForRef invokes repos/list-commit-statuses-for-ref operation.
//
// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a
// SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first
// status in the list will be the latest one.
// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (c *Client) ReposListCommitStatusesForRef(ctx context.Context, params ReposListCommitStatusesForRefParams) (res ReposListCommitStatusesForRefRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-statuses-for-ref"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommitStatusesForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "ref" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Ref))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/statuses"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitStatusesForRefResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListCommits invokes repos/list-commits operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits
func (c *Client) ReposListCommits(ctx context.Context, params ReposListCommitsParams) (res ReposListCommitsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commits"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits"

	q := u.Query()
	{
		// Encode "sha" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sha.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sha"] = e.Result()
	}
	{
		// Encode "path" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Path.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["path"] = e.Result()
	}
	{
		// Encode "author" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Author.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["author"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "until" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["until"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListContributors invokes repos/list-contributors operation.
//
// Lists contributors to the specified repository and sorts them by the number of commits per
// contributor in descending order. This endpoint may return information that is a few hours old
// because the GitHub REST API v3 caches contributor data to improve performance.
// GitHub identifies contributors by author email address. This endpoint groups contribution counts
// by GitHub user, which includes all associated email addresses. To improve performance, only the
// first 500 author email addresses in the repository link to GitHub users. The rest will appear as
// anonymous contributors without associated GitHub user information.
//
// GET /repos/{owner}/{repo}/contributors
func (c *Client) ReposListContributors(ctx context.Context, params ReposListContributorsParams) (res ReposListContributorsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-contributors"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListContributors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/contributors"

	q := u.Query()
	{
		// Encode "anon" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Anon.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["anon"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListContributorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListDeployKeys invokes repos/list-deploy-keys operation.
//
// GET /repos/{owner}/{repo}/keys
func (c *Client) ReposListDeployKeys(ctx context.Context, params ReposListDeployKeysParams) (res []DeployKey, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deploy-keys"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListDeployKeys",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/keys"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeployKeysResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListDeploymentStatuses invokes repos/list-deployment-statuses operation.
//
// Users with pull access can view deployment statuses for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (c *Client) ReposListDeploymentStatuses(ctx context.Context, params ReposListDeploymentStatusesParams) (res ReposListDeploymentStatusesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployment-statuses"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListDeploymentStatuses",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments/"
	{
		// Encode "deployment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeploymentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/statuses"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeploymentStatusesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListDeployments invokes repos/list-deployments operation.
//
// Simple filtering of deployments is available via query parameters:.
//
// GET /repos/{owner}/{repo}/deployments
func (c *Client) ReposListDeployments(ctx context.Context, params ReposListDeploymentsParams) (res []Deployment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployments"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListDeployments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deployments"

	q := u.Query()
	{
		// Encode "sha" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sha.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sha"] = e.Result()
	}
	{
		// Encode "ref" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Ref.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["ref"] = e.Result()
	}
	{
		// Encode "task" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Task.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["task"] = e.Result()
	}
	{
		// Encode "environment" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Environment.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["environment"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeploymentsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForAuthenticatedUser invokes repos/list-for-authenticated-user operation.
//
// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
//
// GET /user/repos
func (c *Client) ReposListForAuthenticatedUser(ctx context.Context, params ReposListForAuthenticatedUserParams) (res ReposListForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/repos"

	q := u.Query()
	{
		// Encode "visibility" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Visibility.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["visibility"] = e.Result()
	}
	{
		// Encode "affiliation" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Affiliation.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["affiliation"] = e.Result()
	}
	{
		// Encode "type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["type"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "before" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.TimeToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["before"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForOrg invokes repos/list-for-org operation.
//
// Lists repositories for the specified organization.
//
// GET /orgs/{org}/repos
func (c *Client) ReposListForOrg(ctx context.Context, params ReposListForOrgParams) (res []MinimalRepository, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos"

	q := u.Query()
	{
		// Encode "type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["type"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForUser invokes repos/list-for-user operation.
//
// Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list
// internal repositories for the specified user.
//
// GET /users/{username}/repos
func (c *Client) ReposListForUser(ctx context.Context, params ReposListForUserParams) (res []MinimalRepository, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos"

	q := u.Query()
	{
		// Encode "type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["type"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListForks invokes repos/list-forks operation.
//
// GET /repos/{owner}/{repo}/forks
func (c *Client) ReposListForks(ctx context.Context, params ReposListForksParams) (res ReposListForksRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-forks"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListForks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/forks"

	q := u.Query()
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListForksResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListInvitations invokes repos/list-invitations operation.
//
// When authenticating as a user with admin rights to a repository, this endpoint will list all
// currently open repository invitations.
//
// GET /repos/{owner}/{repo}/invitations
func (c *Client) ReposListInvitations(ctx context.Context, params ReposListInvitationsParams) (res []RepositoryInvitation, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListInvitationsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListInvitationsForAuthenticatedUser invokes repos/list-invitations-for-authenticated-user operation.
//
// When authenticating as a user, this endpoint will list all currently open repository invitations
// for that user.
//
// GET /user/repository_invitations
func (c *Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, params ReposListInvitationsForAuthenticatedUserParams) (res ReposListInvitationsForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListInvitationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/repository_invitations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListInvitationsForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListLanguages invokes repos/list-languages operation.
//
// Lists languages for the specified repository. The value shown for each language is the number of
// bytes of code written in that language.
//
// GET /repos/{owner}/{repo}/languages
func (c *Client) ReposListLanguages(ctx context.Context, params ReposListLanguagesParams) (res Language, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-languages"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListLanguages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/languages"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListLanguagesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListPagesBuilds invokes repos/list-pages-builds operation.
//
// GET /repos/{owner}/{repo}/pages/builds
func (c *Client) ReposListPagesBuilds(ctx context.Context, params ReposListPagesBuildsParams) (res []PageBuild, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pages-builds"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListPagesBuilds",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages/builds"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListPagesBuildsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListPublic invokes repos/list-public operation.
//
// Lists all public repositories in the order that they were created.
// Note:
// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users
// on the enterprise.
// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page
// of repositories.
//
// GET /repositories
func (c *Client) ReposListPublic(ctx context.Context, params ReposListPublicParams) (res ReposListPublicRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-public"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListPublic",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repositories"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListPublicResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListPullRequestsAssociatedWithCommit invokes repos/list-pull-requests-associated-with-commit operation.
//
// Lists the merged pull request that introduced the commit to the repository. If the commit is not
// present in the default branch, additionally returns open pull requests associated with the commit.
// The results may include open and closed pull requests. Additional preview headers may be required
// to see certain details for associated pull requests, such as whether a pull request is in a draft
// state. For more information about previews that might affect this endpoint, see the [List pull
// requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (c *Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, params ReposListPullRequestsAssociatedWithCommitParams) (res []PullRequestSimple, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pull-requests-associated-with-commit"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListPullRequestsAssociatedWithCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/commits/"
	{
		// Encode "commit_sha" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommitSha))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pulls"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListPullRequestsAssociatedWithCommitResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListReleaseAssets invokes repos/list-release-assets operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (c *Client) ReposListReleaseAssets(ctx context.Context, params ReposListReleaseAssetsParams) (res []ReleaseAsset, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-release-assets"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListReleaseAssets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/assets"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListReleaseAssetsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListReleases invokes repos/list-releases operation.
//
// This returns a list of releases, which does not include regular Git tags that have not been
// associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.
// github.com/rest/reference/repos#list-repository-tags).
// Information about published releases are available to everyone. Only users with push access will
// receive listings for draft releases.
//
// GET /repos/{owner}/{repo}/releases
func (c *Client) ReposListReleases(ctx context.Context, params ReposListReleasesParams) (res ReposListReleasesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-releases"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListReleases",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListReleasesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListTags invokes repos/list-tags operation.
//
// GET /repos/{owner}/{repo}/tags
func (c *Client) ReposListTags(ctx context.Context, params ReposListTagsParams) (res []Tag, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-tags"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListTags",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/tags"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListTagsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListTeams invokes repos/list-teams operation.
//
// GET /repos/{owner}/{repo}/teams
func (c *Client) ReposListTeams(ctx context.Context, params ReposListTeamsParams) (res []Team, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-teams"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListTeams",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListTeamsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListWebhookDeliveries invokes repos/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
func (c *Client) ReposListWebhookDeliveries(ctx context.Context, params ReposListWebhookDeliveriesParams) (res ReposListWebhookDeliveriesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhook-deliveries"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deliveries"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "cursor" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["cursor"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListWebhookDeliveriesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposListWebhooks invokes repos/list-webhooks operation.
//
// GET /repos/{owner}/{repo}/hooks
func (c *Client) ReposListWebhooks(ctx context.Context, params ReposListWebhooksParams) (res ReposListWebhooksRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhooks"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposListWebhooks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposListWebhooksResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposMerge invokes repos/merge operation.
//
// POST /repos/{owner}/{repo}/merges
func (c *Client) ReposMerge(ctx context.Context, request ReposMergeReq, params ReposMergeParams) (res ReposMergeRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposMerge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposMergeRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/merges"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposMergeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposMergeUpstream invokes repos/merge-upstream operation.
//
// **Note:** This endpoint is currently in beta and subject to change.
// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (c *Client) ReposMergeUpstream(ctx context.Context, request ReposMergeUpstreamReq, params ReposMergeUpstreamParams) (res ReposMergeUpstreamRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge-upstream"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposMergeUpstream",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposMergeUpstreamRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/merge-upstream"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposMergeUpstreamResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposPingWebhook invokes repos/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (c *Client) ReposPingWebhook(ctx context.Context, params ReposPingWebhookParams) (res ReposPingWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/ping-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposPingWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pings"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposPingWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRedeliverWebhookDelivery invokes repos/redeliver-webhook-delivery operation.
//
// Redeliver a webhook delivery for a webhook configured in a repository.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (c *Client) ReposRedeliverWebhookDelivery(ctx context.Context, params ReposRedeliverWebhookDeliveryParams) (res ReposRedeliverWebhookDeliveryRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/redeliver-webhook-delivery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/deliveries/"
	{
		// Encode "delivery_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "delivery_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DeliveryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/attempts"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRedeliverWebhookDeliveryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveAppAccessRestrictions invokes repos/remove-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//                                                                     |
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposRemoveAppAccessRestrictions(ctx context.Context, request OptReposRemoveAppAccessRestrictionsReq, params ReposRemoveAppAccessRestrictionsParams) (res ReposRemoveAppAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-app-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposRemoveAppAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/apps"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveAppAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveCollaborator invokes repos/remove-collaborator operation.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (c *Client) ReposRemoveCollaborator(ctx context.Context, params ReposRemoveCollaboratorParams) (res ReposRemoveCollaboratorNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-collaborator"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/collaborators/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveCollaboratorResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveStatusCheckContexts invokes repos/remove-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposRemoveStatusCheckContexts(ctx context.Context, request OptReposRemoveStatusCheckContextsReq, params ReposRemoveStatusCheckContextsParams) (res ReposRemoveStatusCheckContextsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-contexts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposRemoveStatusCheckContextsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks/contexts"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveStatusCheckContextsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveStatusCheckProtection invokes repos/remove-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (c *Client) ReposRemoveStatusCheckProtection(ctx context.Context, params ReposRemoveStatusCheckProtectionParams) (res ReposRemoveStatusCheckProtectionNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks"

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveStatusCheckProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveTeamAccessRestrictions invokes repos/remove-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a team to push to this branch. You can also remove push access for child
// teams.
// | Type    | Description
//                                                              |
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The
// list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposRemoveTeamAccessRestrictions(ctx context.Context, request OptReposRemoveTeamAccessRestrictionsReq, params ReposRemoveTeamAccessRestrictionsParams) (res ReposRemoveTeamAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-team-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposRemoveTeamAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/teams"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveTeamAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRemoveUserAccessRestrictions invokes repos/remove-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a user to push to this branch.
// | Type    | Description
//                                                        |
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposRemoveUserAccessRestrictions(ctx context.Context, request OptReposRemoveUserAccessRestrictionsReq, params ReposRemoveUserAccessRestrictionsParams) (res ReposRemoveUserAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-user-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRemoveUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposRemoveUserAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/users"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveUserAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRenameBranch invokes repos/rename-branch operation.
//
// Renames a branch in a repository.
// **Note:** Although the API responds immediately, the branch rename process might take some extra
// time to complete in the background. You won't be able to push to the old branch name while the
// rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.
// com/github/administering-a-repository/renaming-a-branch)".
// The permissions required to use this endpoint depends on whether you are renaming the default
// branch.
// To rename a non-default branch:
// * Users must have push access.
// * GitHub Apps must have the `contents:write` repository permission.
// To rename the default branch:
// * Users must have admin or owner permissions.
// * GitHub Apps must have the `administration:write` repository permission.
//
// POST /repos/{owner}/{repo}/branches/{branch}/rename
func (c *Client) ReposRenameBranch(ctx context.Context, request OptReposRenameBranchReq, params ReposRenameBranchParams) (res ReposRenameBranchRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/rename-branch"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRenameBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposRenameBranchRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/rename"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRenameBranchResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposReplaceAllTopics invokes repos/replace-all-topics operation.
//
// PUT /repos/{owner}/{repo}/topics
func (c *Client) ReposReplaceAllTopics(ctx context.Context, request ReposReplaceAllTopicsReq, params ReposReplaceAllTopicsParams) (res ReposReplaceAllTopicsRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/replace-all-topics"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposReplaceAllTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposReplaceAllTopicsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/topics"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposReplaceAllTopicsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposRequestPagesBuild invokes repos/request-pages-build operation.
//
// You can request that your site be built from the latest revision on the default branch. This has
// the same effect as pushing a commit to your default branch, but does not require an additional
// commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
// Build requests are limited to one concurrent build per repository and one concurrent build per
// requester. If you request a build while another is still in progress, the second request will be
// queued until the first completes.
//
// POST /repos/{owner}/{repo}/pages/builds
func (c *Client) ReposRequestPagesBuild(ctx context.Context, params ReposRequestPagesBuildParams) (res PageBuildStatus, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/request-pages-build"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposRequestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/pages/builds"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposRequestPagesBuildResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetAdminBranchProtection invokes repos/set-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Adding admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (c *Client) ReposSetAdminBranchProtection(ctx context.Context, params ReposSetAdminBranchProtectionParams) (res ProtectedBranchAdminEnforced, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-admin-branch-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/enforce_admins"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposSetAdminBranchProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetAppAccessRestrictions invokes repos/set-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of apps that have push access to this branch. This removes all apps that
// previously had push access and grants push access to the new list of apps. Only installed GitHub
// Apps with `write` access to the `contents` permission can be added as authorized actors on a
// protected branch.
// | Type    | Description
//                                                                     |
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (c *Client) ReposSetAppAccessRestrictions(ctx context.Context, request OptReposSetAppAccessRestrictionsReq, params ReposSetAppAccessRestrictionsParams) (res ReposSetAppAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-app-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposSetAppAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/apps"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposSetAppAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetStatusCheckContexts invokes repos/set-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (c *Client) ReposSetStatusCheckContexts(ctx context.Context, request OptReposSetStatusCheckContextsReq, params ReposSetStatusCheckContextsParams) (res ReposSetStatusCheckContextsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-status-check-contexts"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposSetStatusCheckContextsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks/contexts"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposSetStatusCheckContextsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetTeamAccessRestrictions invokes repos/set-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of teams that have push access to this branch. This removes all teams that
// previously had push access and grants push access to the new list of teams. Team restrictions
// include child teams.
// | Type    | Description
//                                                     |
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (c *Client) ReposSetTeamAccessRestrictions(ctx context.Context, request OptReposSetTeamAccessRestrictionsReq, params ReposSetTeamAccessRestrictionsParams) (res ReposSetTeamAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-team-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposSetTeamAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/teams"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposSetTeamAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposSetUserAccessRestrictions invokes repos/set-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of people that have push access to this branch. This removes all people that
// previously had push access and grants push access to the new list of people.
// | Type    | Description
//                                        |
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (c *Client) ReposSetUserAccessRestrictions(ctx context.Context, request OptReposSetUserAccessRestrictionsReq, params ReposSetUserAccessRestrictionsParams) (res ReposSetUserAccessRestrictionsRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-user-access-restrictions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposSetUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposSetUserAccessRestrictionsRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/restrictions/users"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposSetUserAccessRestrictionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposTestPushWebhook invokes repos/test-push-webhook operation.
//
// This will trigger the hook with the latest push to the current repository if the hook is
// subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
// respond with 204 but no test POST will be generated.
// **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (c *Client) ReposTestPushWebhook(ctx context.Context, params ReposTestPushWebhookParams) (res ReposTestPushWebhookRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/test-push-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposTestPushWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/tests"

	r := ht.NewRequest(ctx, "POST", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposTestPushWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposTransfer invokes repos/transfer operation.
//
// A transfer request will need to be accepted by the new owner when transferring a personal
// repository to another user. The response will contain the original `owner`, and the transfer will
// continue asynchronously. For more details on the requirements to transfer personal and
// organization-owned repositories, see [about repository transfers](https://help.github.
// com/articles/about-repository-transfers/).
//
// POST /repos/{owner}/{repo}/transfer
func (c *Client) ReposTransfer(ctx context.Context, request ReposTransferReq, params ReposTransferParams) (res MinimalRepository, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/transfer"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposTransfer",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposTransferRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/transfer"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposTransferResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdate invokes repos/update operation.
//
// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.
// github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
//
// PATCH /repos/{owner}/{repo}
func (c *Client) ReposUpdate(ctx context.Context, request OptReposUpdateReq, params ReposUpdateParams) (res ReposUpdateRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateBranchProtection invokes repos/update-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Protecting a branch requires admin or owner permissions to the repository.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
// **Note**: The list of users, apps, and teams in total is limited to 100 items.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (c *Client) ReposUpdateBranchProtection(ctx context.Context, request ReposUpdateBranchProtectionReq, params ReposUpdateBranchProtectionParams) (res ReposUpdateBranchProtectionRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-branch-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateBranchProtectionRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection"

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateBranchProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateCommitComment invokes repos/update-commit-comment operation.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (c *Client) ReposUpdateCommitComment(ctx context.Context, request ReposUpdateCommitCommentReq, params ReposUpdateCommitCommentParams) (res ReposUpdateCommitCommentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-commit-comment"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateCommitCommentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateCommitCommentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateInvitation invokes repos/update-invitation operation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (c *Client) ReposUpdateInvitation(ctx context.Context, request OptReposUpdateInvitationReq, params ReposUpdateInvitationParams) (res RepositoryInvitation, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-invitation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateInvitationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateInvitationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdatePullRequestReviewProtection invokes repos/update-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating pull request review enforcement requires admin or owner permissions to the repository and
// branch protection to be enabled.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (c *Client) ReposUpdatePullRequestReviewProtection(ctx context.Context, request OptReposUpdatePullRequestReviewProtectionReq, params ReposUpdatePullRequestReviewProtectionParams) (res ReposUpdatePullRequestReviewProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-pull-request-review-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdatePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdatePullRequestReviewProtectionRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_pull_request_reviews"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdatePullRequestReviewProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateRelease invokes repos/update-release operation.
//
// Users with push access to the repository can edit a release.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (c *Client) ReposUpdateRelease(ctx context.Context, request OptReposUpdateReleaseReq, params ReposUpdateReleaseParams) (res ReposUpdateReleaseRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateReleaseRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/"
	{
		// Encode "release_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ReleaseID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateReleaseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateReleaseAsset invokes repos/update-release-asset operation.
//
// Users with push access to the repository can edit a release asset.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (c *Client) ReposUpdateReleaseAsset(ctx context.Context, request OptReposUpdateReleaseAssetReq, params ReposUpdateReleaseAssetParams) (res ReleaseAsset, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release-asset"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateReleaseAssetRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/releases/assets/"
	{
		// Encode "asset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.AssetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateReleaseAssetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateStatusCheckProtection invokes repos/update-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating required status checks requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (c *Client) ReposUpdateStatusCheckProtection(ctx context.Context, request OptReposUpdateStatusCheckProtectionReq, params ReposUpdateStatusCheckProtectionParams) (res ReposUpdateStatusCheckProtectionRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-status-check-protection"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateStatusCheckProtectionRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/branches/"
	{
		// Encode "branch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Branch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/protection/required_status_checks"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateStatusCheckProtectionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateWebhook invokes repos/update-webhook operation.
//
// Updates a webhook configured in a repository. If you previously had a `secret` set, you must
// provide the same `secret` or set a new `secret` or the secret will be removed. If you are only
// updating individual webhook `config` properties, use "[Update a webhook configuration for a
// repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
func (c *Client) ReposUpdateWebhook(ctx context.Context, request OptReposUpdateWebhookReq, params ReposUpdateWebhookParams) (res ReposUpdateWebhookRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateWebhookRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReposUpdateWebhookConfigForRepo invokes repos/update-webhook-config-for-repo operation.
//
// Updates the webhook configuration for a repository. To update more information about the webhook,
// including the `active` state and `events`, use "[Update a repository
// webhook](/rest/reference/orgs#update-a-repository-webhook)."
// Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:write` permission.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (c *Client) ReposUpdateWebhookConfigForRepo(ctx context.Context, request OptReposUpdateWebhookConfigForRepoReq, params ReposUpdateWebhookConfigForRepoParams) (res WebhookConfig, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook-config-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReposUpdateWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeReposUpdateWebhookConfigForRepoRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hooks/"
	{
		// Encode "hook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.HookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/config"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateWebhookConfigForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScimDeleteUserFromOrg invokes scim/delete-user-from-org operation.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (c *Client) ScimDeleteUserFromOrg(ctx context.Context, params ScimDeleteUserFromOrgParams) (res ScimDeleteUserFromOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scim/delete-user-from-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ScimDeleteUserFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/scim/v2/organizations/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/Users/"
	{
		// Encode "scim_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScimUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeScimDeleteUserFromOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCode invokes search/code operation.
//
// Searches for query terms inside of a file. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for code, you can get text match metadata for the file **content** and file
// **path** fields when you pass the `text-match` media type. For more details about how to receive
// highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the definition of the `addClass` function inside
// [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
// `q=addClass+in:file+language:js+repo:jquery/jquery`
// This query searches for the keyword `addClass` within a file's contents. The query limits the
// search to files where the language is JavaScript in the `jquery/jquery` repository.
// #### Considerations for code search
// Due to the complexity of searching code, there are a few restrictions on how searches are
// performed:
// *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
// *   Only files smaller than 384 KB are searchable.
// *   You must always include at least one search term when searching source code. For example,
// searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code)
// is not valid, while [`amazing
// language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
//
// GET /search/code
func (c *Client) SearchCode(ctx context.Context, params SearchCodeParams) (res SearchCodeRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/code"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchCode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/code"

	q := u.Query()
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchCodeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCommits invokes search/commits operation.
//
// Find commits via various criteria on the default branch (usually `master`). This method returns up
// to 100 results [per page](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for commits, you can get text match metadata for the **message** field when you
// provide the `text-match` media type. For more details about how to receive highlighted search
// results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to find commits related to CSS in the
// [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look
// something like this:
// `q=repo:octocat/Spoon-Knife+css`.
//
// GET /search/commits
func (c *Client) SearchCommits(ctx context.Context, params SearchCommitsParams) (res SearchCommitsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/commits"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/commits"

	q := u.Query()
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchCommitsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchIssuesAndPullRequests invokes search/issues-and-pull-requests operation.
//
// Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for issues, you can get text match metadata for the issue **title**, issue **body**,
//  and issue **comment body** fields when you pass the `text-match` media type. For more details
// about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might
// look something like this.
// `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
// This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The
// search runs across repositories whose primary language is Python. The results are sorted by
// creation date in ascending order, which means the oldest issues appear first in the search results.
// **Note:** For [user-to-server](https://docs.github.
// com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests)
// GitHub App requests, you can't retrieve a combination of issues and pull requests in a single
// query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an
// HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you
// must send separate queries for issues and pull requests. For more information about the `is`
// qualifier, see "[Searching only issues or pull requests](https://docs.github.
// com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests).".
//
// GET /search/issues
func (c *Client) SearchIssuesAndPullRequests(ctx context.Context, params SearchIssuesAndPullRequestsParams) (res SearchIssuesAndPullRequestsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/issues-and-pull-requests"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchIssuesAndPullRequests",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/issues"

	q := u.Query()
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchIssuesAndPullRequestsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchLabels invokes search/labels operation.
//
// Find labels in a repository with names or descriptions that match search keywords. Returns up to
// 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for labels, you can get text match metadata for the label **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`,
// or `enhancement`. Your query might look like this:
// `q=bug+defect+enhancement&repository_id=64778136`
// The labels that best match the query appear first in the search results.
//
// GET /search/labels
func (c *Client) SearchLabels(ctx context.Context, params SearchLabelsParams) (res SearchLabelsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/labels"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchLabels",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/labels"

	q := u.Query()
	{
		// Encode "repository_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RepositoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["repository_id"] = e.Result()
	}
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchLabelsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchRepos invokes search/repos operation.
//
// Find repositories via various criteria. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for repositories, you can get text match metadata for the **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to search for popular Tetris repositories written in assembly code, your
// query might look like this:
// `q=tetris+language:assembly&sort=stars&order=desc`
// This query searches for repositories with the word `tetris` in the name, the description, or the
// README. The results are limited to repositories where the primary language is assembly. The
// results are sorted by stars in descending order, so that the most popular repositories appear
// first in the search results.
// When you include the `mercy` preview header, you can also search for multiple topics by adding
// more `topic:` instances. For example, your query might look like this:
// `q=topic:ruby+topic:rails`.
//
// GET /search/repositories
func (c *Client) SearchRepos(ctx context.Context, params SearchReposParams) (res SearchReposRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/repos"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchRepos",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/repositories"

	q := u.Query()
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchReposResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchTopics invokes search/topics operation.
//
// Find topics via various criteria. Results are sorted by best match. This method returns up to 100
// results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list
// of qualifiers.
// When searching for topics, you can get text match metadata for the topic's **short\_description**,
// **description**, **name**, or **display\_name** field when you pass the `text-match` media type.
// For more details about how to receive highlighted search results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to search for topics related to Ruby that are featured on https://github.
// com/topics. Your query might look like this:
// `q=ruby+is:featured`
// This query searches for topics with the keyword `ruby` and limits the results to find only topics
// that are featured. The topics that are the best match for the query appear first in the search
// results.
//
// GET /search/topics
func (c *Client) SearchTopics(ctx context.Context, params SearchTopicsParams) (res SearchTopicsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/topics"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/topics"

	q := u.Query()
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchTopicsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchUsers invokes search/users operation.
//
// Find users via various criteria. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for users, you can get text match metadata for the issue **login**, **email**, and
// **name** fields when you pass the `text-match` media type. For more details about highlighting
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you're looking for a list of popular users, you might try this query:
// `q=tom+repos:%3E42+followers:%3E1000`
// This query searches for users with the name `tom`. The results are restricted to users with more
// than 42 repositories and over 1,000 followers.
//
// GET /search/users
func (c *Client) SearchUsers(ctx context.Context, params SearchUsersParams) (res SearchUsersRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/users"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchUsers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/search/users"

	q := u.Query()
	{
		// Encode "q" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Q))
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["q"] = e.Result()
	}
	{
		// Encode "sort" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["sort"] = e.Result()
	}
	{
		// Encode "order" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["order"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchUsersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningGetAlert invokes secret-scanning/get-alert operation.
//
// Gets a single secret scanning alert detected in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (c *Client) SecretScanningGetAlert(ctx context.Context, params SecretScanningGetAlertParams) (res SecretScanningGetAlertRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/get-alert"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secret-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningGetAlertResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningListAlertsForOrg invokes secret-scanning/list-alerts-for-org operation.
//
// Lists all secret scanning alerts for all eligible repositories in an organization, from newest to
// oldest.
// To use this endpoint, you must be an administrator for the repository or organization, and you
// must use an access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /orgs/{org}/secret-scanning/alerts
func (c *Client) SecretScanningListAlertsForOrg(ctx context.Context, params SecretScanningListAlertsForOrgParams) (res SecretScanningListAlertsForOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningListAlertsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secret-scanning/alerts"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "secret_type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.SecretType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["secret_type"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningListAlertsForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningListAlertsForRepo invokes secret-scanning/list-alerts-for-repo operation.
//
// Lists all secret scanning alerts for a private repository, from newest to oldest. To use this
// endpoint, you must be an administrator for the repository or organization, and you must use an
// access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (c *Client) SecretScanningListAlertsForRepo(ctx context.Context, params SecretScanningListAlertsForRepoParams) (res SecretScanningListAlertsForRepoRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-repo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secret-scanning/alerts"

	q := u.Query()
	{
		// Encode "state" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["state"] = e.Result()
	}
	{
		// Encode "secret_type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.SecretType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["secret_type"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningListAlertsForRepoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecretScanningUpdateAlert invokes secret-scanning/update-alert operation.
//
// Updates the status of a secret scanning alert in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (c *Client) SecretScanningUpdateAlert(ctx context.Context, request SecretScanningUpdateAlertReq, params SecretScanningUpdateAlertParams) (res SecretScanningUpdateAlertRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/update-alert"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SecretScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeSecretScanningUpdateAlertRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/secret-scanning/alerts/"
	{
		// Encode "alert_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int(params.AlertNumber); true {
				return e.EncodeValue(conv.IntToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningUpdateAlertResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddMemberLegacy invokes teams/add-member-legacy operation.
//
// The "Add team member" endpoint (described below) is deprecated.
// We recommend using the [Add or update team membership for a user](https://docs.github.
// com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you
// to invite new organization members to your teams.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To add someone to a team, the authenticated user must be an organization owner or a team
// maintainer in the team they're changing. The person being added to the team must be a member of
// the team's organization.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /teams/{team_id}/members/{username}
func (c *Client) TeamsAddMemberLegacy(ctx context.Context, params TeamsAddMemberLegacyParams) (res TeamsAddMemberLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-member-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddMemberLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateMembershipForUserInOrg invokes teams/add-or-update-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Adds an organization member to a team. An authenticated organization owner or team maintainer can
// add organization members to a team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// An organization owner can add someone who is not part of the team's organization to a team. When
// an organization owner adds someone to a team who is not an organization member, this endpoint will
// send an invitation to the person via email. This newly-created membership will be in the "pending"
// state until the person accepts the invitation, at which point the membership will transition to
// the "active" state and the user will be added as a member of the team.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (c *Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserInOrgReq, params TeamsAddOrUpdateMembershipForUserInOrgParams) (res TeamsAddOrUpdateMembershipForUserInOrgRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsAddOrUpdateMembershipForUserInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateMembershipForUserInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateMembershipForUserLegacy invokes teams/add-or-update-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team membership for a
// user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// If the user is already a member of the team's organization, this endpoint will add the user to the
// team. To add a membership between an organization member and a team, the authenticated user must
// be an organization owner or a team maintainer.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to
// the user via email. This newly-created membership will be in the "pending" state until the user
// accepts the invitation, at which point the membership will transition to the "active" state and
// the user will be added as a member of the team. To add a membership between an unaffiliated user
// and a team, the authenticated user must be an organization owner.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
//
// PUT /teams/{team_id}/memberships/{username}
func (c *Client) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, request OptTeamsAddOrUpdateMembershipForUserLegacyReq, params TeamsAddOrUpdateMembershipForUserLegacyParams) (res TeamsAddOrUpdateMembershipForUserLegacyRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsAddOrUpdateMembershipForUserLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateMembershipForUserLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateProjectPermissionsInOrg invokes teams/add-or-update-project-permissions-in-org operation.
//
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (c *Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, request OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq, params TeamsAddOrUpdateProjectPermissionsInOrgParams) (res TeamsAddOrUpdateProjectPermissionsInOrgRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateProjectPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsAddOrUpdateProjectPermissionsInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateProjectPermissionsLegacy invokes teams/add-or-update-project-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team project
// permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions)
// endpoint.
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
//
// PUT /teams/{team_id}/projects/{project_id}
func (c *Client) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateProjectPermissionsLegacyReq, params TeamsAddOrUpdateProjectPermissionsLegacyParams) (res TeamsAddOrUpdateProjectPermissionsLegacyRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateProjectPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsAddOrUpdateProjectPermissionsLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateRepoPermissionsInOrg invokes teams/add-or-update-repo-permissions-in-org operation.
//
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to
// set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP
// verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
// For more information about the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (c *Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsInOrgReq, params TeamsAddOrUpdateRepoPermissionsInOrgParams) (res TeamsAddOrUpdateRepoPermissionsInOrgNoContent, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateRepoPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsAddOrUpdateRepoPermissionsInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsAddOrUpdateRepoPermissionsLegacy invokes teams/add-or-update-repo-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Add or update team repository
// permissions](https://docs.github.
// com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /teams/{team_id}/repos/{owner}/{repo}
func (c *Client) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, request OptTeamsAddOrUpdateRepoPermissionsLegacyReq, params TeamsAddOrUpdateRepoPermissionsLegacyParams) (res TeamsAddOrUpdateRepoPermissionsLegacyRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsAddOrUpdateRepoPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsAddOrUpdateRepoPermissionsLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForProjectInOrg invokes teams/check-permissions-for-project-in-org operation.
//
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (c *Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, params TeamsCheckPermissionsForProjectInOrgParams) (res TeamsCheckPermissionsForProjectInOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForProjectInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForProjectLegacy invokes teams/check-permissions-for-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project)
// endpoint.
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
//
// GET /teams/{team_id}/projects/{project_id}
func (c *Client) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, params TeamsCheckPermissionsForProjectLegacyParams) (res TeamsCheckPermissionsForProjectLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForProjectLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForRepoInOrg invokes teams/check-permissions-for-repo-in-org operation.
//
// Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a
// repository. Repositories inherited through a parent team will also be checked.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
// If a team doesn't have permission for the repository, you will receive a `404 Not Found` response
// status.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (c *Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, params TeamsCheckPermissionsForRepoInOrgParams) (res TeamsCheckPermissionsForRepoInOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForRepoInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCheckPermissionsForRepoLegacy invokes teams/check-permissions-for-repo-legacy operation.
//
// **Note**: Repositories inherited through a parent team will also be checked.
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository)
// endpoint.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `Accept` header:.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (c *Client) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, params TeamsCheckPermissionsForRepoLegacyParams) (res TeamsCheckPermissionsForRepoLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCheckPermissionsForRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForRepoLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreate invokes teams/create operation.
//
// To create a team, the authenticated user must be a member or owner of `{org}`. By default,
// organization members can create teams. Organization owners can limit team creation to organization
// owners. For more information, see "[Setting team creation permissions](https://help.github.
// com/en/articles/setting-team-creation-permissions-in-your-organization)."
// When you create a new team, you automatically become a team maintainer without explicitly adding
// yourself to the optional array of `maintainers`. For more information, see "[About
// teams](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
//
// POST /orgs/{org}/teams
func (c *Client) TeamsCreate(ctx context.Context, request TeamsCreateReq, params TeamsCreateParams) (res TeamsCreateRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionCommentInOrg invokes teams/create-discussion-comment-in-org operation.
//
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (c *Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, request TeamsCreateDiscussionCommentInOrgReq, params TeamsCreateDiscussionCommentInOrgParams) (res TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateDiscussionCommentInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionCommentInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionCommentLegacy invokes teams/create-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Create a discussion
// comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (c *Client) TeamsCreateDiscussionCommentLegacy(ctx context.Context, request TeamsCreateDiscussionCommentLegacyReq, params TeamsCreateDiscussionCommentLegacyParams) (res TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateDiscussionCommentLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionCommentLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionInOrg invokes teams/create-discussion-in-org operation.
//
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (c *Client) TeamsCreateDiscussionInOrg(ctx context.Context, request TeamsCreateDiscussionInOrgReq, params TeamsCreateDiscussionInOrgParams) (res TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateDiscussionInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateDiscussionLegacy invokes teams/create-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.
// github.com/rest/reference/teams#create-a-discussion) endpoint.
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /teams/{team_id}/discussions
func (c *Client) TeamsCreateDiscussionLegacy(ctx context.Context, request TeamsCreateDiscussionLegacyReq, params TeamsCreateDiscussionLegacyParams) (res TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateDiscussionLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateOrUpdateIdpGroupConnectionsInOrg invokes teams/create-or-update-idp-group-connections-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, request TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq, params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) (res GroupMapping, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/team-sync/group-mappings"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsCreateOrUpdateIdpGroupConnectionsLegacy invokes teams/create-or-update-idp-group-connections-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create or update IdP group
// connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
//
// PATCH /teams/{team_id}/team-sync/group-mappings
func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, request TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq, params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams) (res TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/team-sync/group-mappings"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionCommentInOrg invokes teams/delete-discussion-comment-in-org operation.
//
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, params TeamsDeleteDiscussionCommentInOrgParams) (res TeamsDeleteDiscussionCommentInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionCommentInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionCommentLegacy invokes teams/delete-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a discussion
// comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, params TeamsDeleteDiscussionCommentLegacyParams) (res TeamsDeleteDiscussionCommentLegacyNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionCommentLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionInOrg invokes teams/delete-discussion-in-org operation.
//
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (c *Client) TeamsDeleteDiscussionInOrg(ctx context.Context, params TeamsDeleteDiscussionInOrgParams) (res TeamsDeleteDiscussionInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteDiscussionLegacy invokes teams/delete-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.
// github.com/rest/reference/teams#delete-a-discussion) endpoint.
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (c *Client) TeamsDeleteDiscussionLegacy(ctx context.Context, params TeamsDeleteDiscussionLegacyParams) (res TeamsDeleteDiscussionLegacyNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteInOrg invokes teams/delete-in-org operation.
//
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (c *Client) TeamsDeleteInOrg(ctx context.Context, params TeamsDeleteInOrgParams) (res TeamsDeleteInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsDeleteLegacy invokes teams/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a team](https://docs.github.
// com/rest/reference/teams#delete-a-team) endpoint.
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
//
// DELETE /teams/{team_id}
func (c *Client) TeamsDeleteLegacy(ctx context.Context, params TeamsDeleteLegacyParams) (res TeamsDeleteLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetByName invokes teams/get-by-name operation.
//
// Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}`.
//
// GET /orgs/{org}/teams/{team_slug}
func (c *Client) TeamsGetByName(ctx context.Context, params TeamsGetByNameParams) (res TeamsGetByNameRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-by-name"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetByName",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetByNameResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionCommentInOrg invokes teams/get-discussion-comment-in-org operation.
//
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, params TeamsGetDiscussionCommentInOrgParams) (res TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionCommentInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionCommentLegacy invokes teams/get-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.
// github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsGetDiscussionCommentLegacy(ctx context.Context, params TeamsGetDiscussionCommentLegacyParams) (res TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionCommentLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionInOrg invokes teams/get-discussion-in-org operation.
//
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (c *Client) TeamsGetDiscussionInOrg(ctx context.Context, params TeamsGetDiscussionInOrgParams) (res TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetDiscussionLegacy invokes teams/get-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.
// com/rest/reference/teams#get-a-discussion) endpoint.
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (c *Client) TeamsGetDiscussionLegacy(ctx context.Context, params TeamsGetDiscussionLegacyParams) (res TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetLegacy invokes teams/get-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the [Get a team by name](https://docs.github.
// com/rest/reference/teams#get-a-team-by-name) endpoint.
//
// GET /teams/{team_id}
func (c *Client) TeamsGetLegacy(ctx context.Context, params TeamsGetLegacyParams) (res TeamsGetLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetMemberLegacy invokes teams/get-member-legacy operation.
//
// The "Get team member" endpoint (described below) is deprecated.
// We recommend using the [Get team membership for a user](https://docs.github.
// com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get
// both active and pending memberships.
// To list members in a team, the team must be visible to the authenticated user.
//
// GET /teams/{team_id}/members/{username}
func (c *Client) TeamsGetMemberLegacy(ctx context.Context, params TeamsGetMemberLegacyParams) (res TeamsGetMemberLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-member-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMemberLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetMembershipForUserInOrg invokes teams/get-membership-for-user-in-org operation.
//
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (c *Client) TeamsGetMembershipForUserInOrg(ctx context.Context, params TeamsGetMembershipForUserInOrgParams) (res TeamsGetMembershipForUserInOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMembershipForUserInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGetMembershipForUserLegacy invokes teams/get-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get team membership for a
// user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// GET /teams/{team_id}/memberships/{username}
func (c *Client) TeamsGetMembershipForUserLegacy(ctx context.Context, params TeamsGetMembershipForUserLegacyParams) (res TeamsGetMembershipForUserLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsGetMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMembershipForUserLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsList invokes teams/list operation.
//
// Lists all teams in an organization that are visible to the authenticated user.
//
// GET /orgs/{org}/teams
func (c *Client) TeamsList(ctx context.Context, params TeamsListParams) (res TeamsListRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListChildInOrg invokes teams/list-child-in-org operation.
//
// Lists the child teams of the team specified by `{team_slug}`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/teams`.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (c *Client) TeamsListChildInOrg(ctx context.Context, params TeamsListChildInOrgParams) (res []Team, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListChildInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListChildInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListChildLegacy invokes teams/list-child-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.
// com/rest/reference/teams#list-child-teams) endpoint.
//
// GET /teams/{team_id}/teams
func (c *Client) TeamsListChildLegacy(ctx context.Context, params TeamsListChildLegacyParams) (res TeamsListChildLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListChildLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListChildLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionCommentsInOrg invokes teams/list-discussion-comments-in-org operation.
//
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (c *Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, params TeamsListDiscussionCommentsInOrgParams) (res []TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionCommentsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionCommentsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionCommentsLegacy invokes teams/list-discussion-comments-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List discussion comments](https://docs.
// github.com/rest/reference/teams#list-discussion-comments) endpoint.
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (c *Client) TeamsListDiscussionCommentsLegacy(ctx context.Context, params TeamsListDiscussionCommentsLegacyParams) (res []TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionCommentsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments"

	q := u.Query()
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionCommentsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionsInOrg invokes teams/list-discussions-in-org operation.
//
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (c *Client) TeamsListDiscussionsInOrg(ctx context.Context, params TeamsListDiscussionsInOrgParams) (res []TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions"

	q := u.Query()
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	{
		// Encode "pinned" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Pinned.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["pinned"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListDiscussionsLegacy invokes teams/list-discussions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.
// com/rest/reference/teams#list-discussions) endpoint.
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /teams/{team_id}/discussions
func (c *Client) TeamsListDiscussionsLegacy(ctx context.Context, params TeamsListDiscussionsLegacyParams) (res []TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListDiscussionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions"

	q := u.Query()
	{
		// Encode "direction" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["direction"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListForAuthenticatedUser invokes teams/list-for-authenticated-user operation.
//
// List all of the teams across all of the organizations to which the authenticated user belongs.
// This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via
// [OAuth](https://docs.github.com/apps/building-oauth-apps/).
//
// GET /user/teams
func (c *Client) TeamsListForAuthenticatedUser(ctx context.Context, params TeamsListForAuthenticatedUserParams) (res TeamsListForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/teams"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListIdpGroupsForLegacy invokes teams/list-idp-groups-for-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List IdP groups for a
// team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (c *Client) TeamsListIdpGroupsForLegacy(ctx context.Context, params TeamsListIdpGroupsForLegacyParams) (res TeamsListIdpGroupsForLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListIdpGroupsForLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/team-sync/group-mappings"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsForLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListIdpGroupsForOrg invokes teams/list-idp-groups-for-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups available in an organization. You can limit your page results using the `per_page`
// parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next
// page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination
// explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89).".
//
// GET /orgs/{org}/team-sync/groups
func (c *Client) TeamsListIdpGroupsForOrg(ctx context.Context, params TeamsListIdpGroupsForOrgParams) (res GroupMapping, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListIdpGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/team-sync/groups"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsForOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListIdpGroupsInOrg invokes teams/list-idp-groups-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (c *Client) TeamsListIdpGroupsInOrg(ctx context.Context, params TeamsListIdpGroupsInOrgParams) (res GroupMapping, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListIdpGroupsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/team-sync/group-mappings"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListMembersInOrg invokes teams/list-members-in-org operation.
//
// Team members will include the members of child teams.
// To list members in a team, the team must be visible to the authenticated user.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (c *Client) TeamsListMembersInOrg(ctx context.Context, params TeamsListMembersInOrgParams) (res []SimpleUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListMembersInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members"

	q := u.Query()
	{
		// Encode "role" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Role.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["role"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListMembersInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListMembersLegacy invokes teams/list-members-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team members`](https://docs.github.
// com/rest/reference/teams#list-team-members) endpoint.
// Team members will include the members of child teams.
//
// GET /teams/{team_id}/members
func (c *Client) TeamsListMembersLegacy(ctx context.Context, params TeamsListMembersLegacyParams) (res TeamsListMembersLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListMembersLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members"

	q := u.Query()
	{
		// Encode "role" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Role.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["role"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListMembersLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListPendingInvitationsInOrg invokes teams/list-pending-invitations-in-org operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/invitations`.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (c *Client) TeamsListPendingInvitationsInOrg(ctx context.Context, params TeamsListPendingInvitationsInOrgParams) (res []OrganizationInvitation, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListPendingInvitationsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListPendingInvitationsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListPendingInvitationsLegacy invokes teams/list-pending-invitations-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List pending team
// invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// GET /teams/{team_id}/invitations
func (c *Client) TeamsListPendingInvitationsLegacy(ctx context.Context, params TeamsListPendingInvitationsLegacyParams) (res []OrganizationInvitation, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListPendingInvitationsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/invitations"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListPendingInvitationsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListProjectsInOrg invokes teams/list-projects-in-org operation.
//
// Lists the organization projects for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects`.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (c *Client) TeamsListProjectsInOrg(ctx context.Context, params TeamsListProjectsInOrgParams) (res []TeamProject, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListProjectsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListProjectsInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListProjectsLegacy invokes teams/list-projects-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team projects`](https://docs.
// github.com/rest/reference/teams#list-team-projects) endpoint.
// Lists the organization projects for a team.
//
// GET /teams/{team_id}/projects
func (c *Client) TeamsListProjectsLegacy(ctx context.Context, params TeamsListProjectsLegacyParams) (res TeamsListProjectsLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListProjectsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListProjectsLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListReposInOrg invokes teams/list-repos-in-org operation.
//
// Lists a team's repositories visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos`.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (c *Client) TeamsListReposInOrg(ctx context.Context, params TeamsListReposInOrgParams) (res []MinimalRepository, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListReposInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListReposInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsListReposLegacy invokes teams/list-repos-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List team repositories](https://docs.
// github.com/rest/reference/teams#list-team-repositories) endpoint.
//
// GET /teams/{team_id}/repos
func (c *Client) TeamsListReposLegacy(ctx context.Context, params TeamsListReposLegacyParams) (res TeamsListReposLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsListReposLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListReposLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveMemberLegacy invokes teams/remove-member-legacy operation.
//
// The "Remove team member" endpoint (described below) is deprecated.
// We recommend using the [Remove team membership for a user](https://docs.github.
// com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to
// remove both active and pending memberships.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an
// owner of the org that the team is associated with. Removing a team member does not delete the user,
//  it just removes them from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// DELETE /teams/{team_id}/members/{username}
func (c *Client) TeamsRemoveMemberLegacy(ctx context.Context, params TeamsRemoveMemberLegacyParams) (res TeamsRemoveMemberLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-member-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMemberLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveMembershipForUserInOrg invokes teams/remove-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (c *Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, params TeamsRemoveMembershipForUserInOrgParams) (res TeamsRemoveMembershipForUserInOrgRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMembershipForUserInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveMembershipForUserLegacy invokes teams/remove-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove team membership for a
// user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// DELETE /teams/{team_id}/memberships/{username}
func (c *Client) TeamsRemoveMembershipForUserLegacy(ctx context.Context, params TeamsRemoveMembershipForUserLegacyParams) (res TeamsRemoveMembershipForUserLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/memberships/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMembershipForUserLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveProjectInOrg invokes teams/remove-project-in-org operation.
//
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. This endpoint removes the project from the team, but does not delete the project.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (c *Client) TeamsRemoveProjectInOrg(ctx context.Context, params TeamsRemoveProjectInOrgParams) (res TeamsRemoveProjectInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveProjectInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveProjectLegacy invokes teams/remove-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a project from a
// team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
//
// DELETE /teams/{team_id}/projects/{project_id}
func (c *Client) TeamsRemoveProjectLegacy(ctx context.Context, params TeamsRemoveProjectLegacyParams) (res TeamsRemoveProjectLegacyRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveProjectLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveRepoInOrg invokes teams/remove-repo-in-org operation.
//
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team. This
// does not delete the repository, it just removes it from the team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (c *Client) TeamsRemoveRepoInOrg(ctx context.Context, params TeamsRemoveRepoInOrgParams) (res TeamsRemoveRepoInOrgNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveRepoInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsRemoveRepoLegacy invokes teams/remove-repo-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a repository from a
// team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team.
// NOTE: This does not delete the repository, it just removes it from the team.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (c *Client) TeamsRemoveRepoLegacy(ctx context.Context, params TeamsRemoveRepoLegacyParams) (res TeamsRemoveRepoLegacyNoContent, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsRemoveRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/repos/"
	{
		// Encode "owner" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Owner))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/"
	{
		// Encode "repo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Repo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveRepoLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionCommentInOrg invokes teams/update-discussion-comment-in-org operation.
//
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, request TeamsUpdateDiscussionCommentInOrgReq, params TeamsUpdateDiscussionCommentInOrgParams) (res TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsUpdateDiscussionCommentInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionCommentInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionCommentLegacy invokes teams/update-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion
// comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (c *Client) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, request TeamsUpdateDiscussionCommentLegacyReq, params TeamsUpdateDiscussionCommentLegacyParams) (res TeamDiscussionComment, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsUpdateDiscussionCommentLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/comments/"
	{
		// Encode "comment_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.CommentNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionCommentLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionInOrg invokes teams/update-discussion-in-org operation.
//
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (c *Client) TeamsUpdateDiscussionInOrg(ctx context.Context, request OptTeamsUpdateDiscussionInOrgReq, params TeamsUpdateDiscussionInOrgParams) (res TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsUpdateDiscussionInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateDiscussionLegacy invokes teams/update-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.
// com/rest/reference/teams#update-a-discussion) endpoint.
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (c *Client) TeamsUpdateDiscussionLegacy(ctx context.Context, request OptTeamsUpdateDiscussionLegacyReq, params TeamsUpdateDiscussionLegacyParams) (res TeamDiscussion, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsUpdateDiscussionLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/discussions/"
	{
		// Encode "discussion_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.DiscussionNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateInOrg invokes teams/update-in-org operation.
//
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}`.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (c *Client) TeamsUpdateInOrg(ctx context.Context, request OptTeamsUpdateInOrgReq, params TeamsUpdateInOrgParams) (res TeamFull, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-in-org"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsUpdateInOrgRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/orgs/"
	{
		// Encode "org" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Org))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/teams/"
	{
		// Encode "team_slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateInOrgResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsUpdateLegacy invokes teams/update-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a team](https://docs.github.
// com/rest/reference/teams#update-a-team) endpoint.
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
//
// PATCH /teams/{team_id}
func (c *Client) TeamsUpdateLegacy(ctx context.Context, request TeamsUpdateLegacyReq, params TeamsUpdateLegacyParams) (res TeamsUpdateLegacyRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-legacy"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "TeamsUpdateLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeTeamsUpdateLegacyRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/teams/"
	{
		// Encode "team_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TeamID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateLegacyResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersAddEmailForAuthenticated invokes users/add-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// POST /user/emails
func (c *Client) UsersAddEmailForAuthenticated(ctx context.Context, request OptUsersAddEmailForAuthenticatedReq) (res UsersAddEmailForAuthenticatedRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/add-email-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersAddEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeUsersAddEmailForAuthenticatedRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/emails"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersAddEmailForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBlock invokes users/block operation.
//
// PUT /user/blocks/{username}
func (c *Client) UsersBlock(ctx context.Context, params UsersBlockParams) (res UsersBlockRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/block"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersBlock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersBlockResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCheckBlocked invokes users/check-blocked operation.
//
// GET /user/blocks/{username}
func (c *Client) UsersCheckBlocked(ctx context.Context, params UsersCheckBlockedParams) (res UsersCheckBlockedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-blocked"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCheckBlocked",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckBlockedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCheckFollowingForUser invokes users/check-following-for-user operation.
//
// GET /users/{username}/following/{target_user}
func (c *Client) UsersCheckFollowingForUser(ctx context.Context, params UsersCheckFollowingForUserParams) (res UsersCheckFollowingForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-following-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCheckFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/following/"
	{
		// Encode "target_user" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "target_user",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TargetUser))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckFollowingForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCheckPersonIsFollowedByAuthenticated invokes users/check-person-is-followed-by-authenticated operation.
//
// GET /user/following/{username}
func (c *Client) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, params UsersCheckPersonIsFollowedByAuthenticatedParams) (res UsersCheckPersonIsFollowedByAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-person-is-followed-by-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCheckPersonIsFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/following/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckPersonIsFollowedByAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCreateGpgKeyForAuthenticated invokes users/create-gpg-key-for-authenticated operation.
//
// Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via
// Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/gpg_keys
func (c *Client) UsersCreateGpgKeyForAuthenticated(ctx context.Context, request UsersCreateGpgKeyForAuthenticatedReq) (res UsersCreateGpgKeyForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-gpg-key-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCreateGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeUsersCreateGpgKeyForAuthenticatedRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/gpg_keys"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersCreateGpgKeyForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCreatePublicSSHKeyForAuthenticated invokes users/create-public-ssh-key-for-authenticated operation.
//
// Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/keys
func (c *Client) UsersCreatePublicSSHKeyForAuthenticated(ctx context.Context, request UsersCreatePublicSSHKeyForAuthenticatedReq) (res UsersCreatePublicSSHKeyForAuthenticatedRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-public-ssh-key-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersCreatePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeUsersCreatePublicSSHKeyForAuthenticatedRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/keys"

	r := ht.NewRequest(ctx, "POST", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersCreatePublicSSHKeyForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeleteEmailForAuthenticated invokes users/delete-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// DELETE /user/emails
func (c *Client) UsersDeleteEmailForAuthenticated(ctx context.Context, request OptUsersDeleteEmailForAuthenticatedReq) (res UsersDeleteEmailForAuthenticatedRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-email-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersDeleteEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeUsersDeleteEmailForAuthenticatedRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/emails"

	r := ht.NewRequest(ctx, "DELETE", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeleteEmailForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeleteGpgKeyForAuthenticated invokes users/delete-gpg-key-for-authenticated operation.
//
// Removes a GPG key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/gpg_keys/{gpg_key_id}
func (c *Client) UsersDeleteGpgKeyForAuthenticated(ctx context.Context, params UsersDeleteGpgKeyForAuthenticatedParams) (res UsersDeleteGpgKeyForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-gpg-key-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersDeleteGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/gpg_keys/"
	{
		// Encode "gpg_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gpg_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GpgKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeleteGpgKeyForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeletePublicSSHKeyForAuthenticated invokes users/delete-public-ssh-key-for-authenticated operation.
//
// Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/keys/{key_id}
func (c *Client) UsersDeletePublicSSHKeyForAuthenticated(ctx context.Context, params UsersDeletePublicSSHKeyForAuthenticatedParams) (res UsersDeletePublicSSHKeyForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-public-ssh-key-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersDeletePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeletePublicSSHKeyForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersFollow invokes users/follow operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with
// the `user:follow` scope.
//
// PUT /user/following/{username}
func (c *Client) UsersFollow(ctx context.Context, params UsersFollowParams) (res UsersFollowRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/follow"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersFollow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/following/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "PUT", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersFollowResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetAuthenticated invokes users/get-authenticated operation.
//
// If the authenticated user is authenticated through basic authentication or OAuth with the `user`
// scope, then the response lists public and private profile information.
// If the authenticated user is authenticated through OAuth without the `user` scope, then the
// response lists only public profile information.
//
// GET /user
func (c *Client) UsersGetAuthenticated(ctx context.Context) (res UsersGetAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetByUsername invokes users/get-by-username operation.
//
// Provides publicly available information about someone with a GitHub account.
// GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a
// user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
// authorizing users for GitHub Apps](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details
// about authentication. For an example response, see 'Response with GitHub plan information' below"
// The `email` key in the following response is the publicly visible email address from your GitHub
// [profile page](https://github.com/settings/profile). When setting up your profile, you can select
// a primary email address to be public which provides an email entry for this endpoint. If you
// do not set a public email address for `email`, then it will have a value of `null`. You only see
// publicly visible email addresses when authenticated with GitHub. For more information, see
// [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
// The Emails API enables you to list all of your email addresses, and toggle a primary email to be
// visible publicly. For more information, see "[Emails API](https://docs.github.
// com/rest/reference/users#emails)".
//
// GET /users/{username}
func (c *Client) UsersGetByUsername(ctx context.Context, params UsersGetByUsernameParams) (res UsersGetByUsernameRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-by-username"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetByUsername",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetByUsernameResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetContextForUser invokes users/get-context-for-user operation.
//
// Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
// scope. You can find out more about someone in relation to their pull requests, issues,
// repositories, and organizations.
// The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which
// returns more information than without the parameters. For example, if you wanted to find out more
// about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
// ```shell
// curl -u username:token
// https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
// ```.
//
// GET /users/{username}/hovercard
func (c *Client) UsersGetContextForUser(ctx context.Context, params UsersGetContextForUserParams) (res UsersGetContextForUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-context-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetContextForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/hovercard"

	q := u.Query()
	{
		// Encode "subject_type" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.SubjectType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["subject_type"] = e.Result()
	}
	{
		// Encode "subject_id" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.SubjectID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["subject_id"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetContextForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetGpgKeyForAuthenticated invokes users/get-gpg-key-for-authenticated operation.
//
// View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or
// via OAuth with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys/{gpg_key_id}
func (c *Client) UsersGetGpgKeyForAuthenticated(ctx context.Context, params UsersGetGpgKeyForAuthenticatedParams) (res UsersGetGpgKeyForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-gpg-key-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/gpg_keys/"
	{
		// Encode "gpg_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gpg_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GpgKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetGpgKeyForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetPublicSSHKeyForAuthenticated invokes users/get-public-ssh-key-for-authenticated operation.
//
// View extended details for a single public SSH key. Requires that you are authenticated via Basic
// Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys/{key_id}
func (c *Client) UsersGetPublicSSHKeyForAuthenticated(ctx context.Context, params UsersGetPublicSSHKeyForAuthenticatedParams) (res UsersGetPublicSSHKeyForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-public-ssh-key-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersGetPublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/keys/"
	{
		// Encode "key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.KeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetPublicSSHKeyForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersList invokes users/list operation.
//
// Lists all users, in the order that they signed up on GitHub. This list includes personal user
// accounts and organization accounts.
// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of users.
//
// GET /users
func (c *Client) UsersList(ctx context.Context, params UsersListParams) (res UsersListRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users"

	q := u.Query()
	{
		// Encode "since" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["since"] = e.Result()
	}
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListBlockedByAuthenticated invokes users/list-blocked-by-authenticated operation.
//
// List the users you've blocked on your personal account.
//
// GET /user/blocks
func (c *Client) UsersListBlockedByAuthenticated(ctx context.Context) (res UsersListBlockedByAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-blocked-by-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListBlockedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/blocks"

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListBlockedByAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListEmailsForAuthenticated invokes users/list-emails-for-authenticated operation.
//
// Lists all of your email addresses, and specifies which one is visible to the public. This endpoint
// is accessible with the `user:email` scope.
//
// GET /user/emails
func (c *Client) UsersListEmailsForAuthenticated(ctx context.Context, params UsersListEmailsForAuthenticatedParams) (res UsersListEmailsForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-emails-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/emails"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListEmailsForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowedByAuthenticated invokes users/list-followed-by-authenticated operation.
//
// Lists the people who the authenticated user follows.
//
// GET /user/following
func (c *Client) UsersListFollowedByAuthenticated(ctx context.Context, params UsersListFollowedByAuthenticatedParams) (res UsersListFollowedByAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followed-by-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/following"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowedByAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowersForAuthenticatedUser invokes users/list-followers-for-authenticated-user operation.
//
// Lists the people following the authenticated user.
//
// GET /user/followers
func (c *Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, params UsersListFollowersForAuthenticatedUserParams) (res UsersListFollowersForAuthenticatedUserRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-authenticated-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowersForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/followers"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowersForAuthenticatedUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowersForUser invokes users/list-followers-for-user operation.
//
// Lists the people following the specified user.
//
// GET /users/{username}/followers
func (c *Client) UsersListFollowersForUser(ctx context.Context, params UsersListFollowersForUserParams) (res []SimpleUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowersForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/followers"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowersForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListFollowingForUser invokes users/list-following-for-user operation.
//
// Lists the people who the specified user follows.
//
// GET /users/{username}/following
func (c *Client) UsersListFollowingForUser(ctx context.Context, params UsersListFollowingForUserParams) (res []SimpleUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-following-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/following"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowingForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListGpgKeysForAuthenticated invokes users/list-gpg-keys-for-authenticated operation.
//
// Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth
// with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys
func (c *Client) UsersListGpgKeysForAuthenticated(ctx context.Context, params UsersListGpgKeysForAuthenticatedParams) (res UsersListGpgKeysForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListGpgKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/gpg_keys"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListGpgKeysForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListGpgKeysForUser invokes users/list-gpg-keys-for-user operation.
//
// Lists the GPG keys for a user. This information is accessible by anyone.
//
// GET /users/{username}/gpg_keys
func (c *Client) UsersListGpgKeysForUser(ctx context.Context, params UsersListGpgKeysForUserParams) (res []GpgKey, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListGpgKeysForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/gpg_keys"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListGpgKeysForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListPublicEmailsForAuthenticated invokes users/list-public-emails-for-authenticated operation.
//
// Lists your publicly visible email address, which you can set with the [Set primary email
// visibility for the authenticated user](https://docs.github.
// com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This
// endpoint is accessible with the `user:email` scope.
//
// GET /user/public_emails
func (c *Client) UsersListPublicEmailsForAuthenticated(ctx context.Context, params UsersListPublicEmailsForAuthenticatedParams) (res UsersListPublicEmailsForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-emails-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListPublicEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/public_emails"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicEmailsForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListPublicKeysForUser invokes users/list-public-keys-for-user operation.
//
// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
//
// GET /users/{username}/keys
func (c *Client) UsersListPublicKeysForUser(ctx context.Context, params UsersListPublicKeysForUserParams) (res []KeySimple, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-keys-for-user"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListPublicKeysForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/users/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/keys"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicKeysForUserResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersListPublicSSHKeysForAuthenticated invokes users/list-public-ssh-keys-for-authenticated operation.
//
// Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys
func (c *Client) UsersListPublicSSHKeysForAuthenticated(ctx context.Context, params UsersListPublicSSHKeysForAuthenticatedParams) (res UsersListPublicSSHKeysForAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-ssh-keys-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersListPublicSSHKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/keys"

	q := u.Query()
	{
		// Encode "per_page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["per_page"] = e.Result()
	}
	{
		// Encode "page" parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		if err := func() error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
		q["page"] = e.Result()
	}
	u.RawQuery = q.Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicSSHKeysForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersSetPrimaryEmailVisibilityForAuthenticated invokes users/set-primary-email-visibility-for-authenticated operation.
//
// Sets the visibility for your primary email addresses.
//
// PATCH /user/email/visibility
func (c *Client) UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, request UsersSetPrimaryEmailVisibilityForAuthenticatedReq) (res UsersSetPrimaryEmailVisibilityForAuthenticatedRes, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/set-primary-email-visibility-for-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersSetPrimaryEmailVisibilityForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user/email/visibility"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUnblock invokes users/unblock operation.
//
// DELETE /user/blocks/{username}
func (c *Client) UsersUnblock(ctx context.Context, params UsersUnblockParams) (res UsersUnblockRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unblock"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersUnblock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/blocks/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersUnblockResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUnfollow invokes users/unfollow operation.
//
// Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth
// with the `user:follow` scope.
//
// DELETE /user/following/{username}
func (c *Client) UsersUnfollow(ctx context.Context, params UsersUnfollowParams) (res UsersUnfollowRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unfollow"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersUnfollow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/user/following/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersUnfollowResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUpdateAuthenticated invokes users/update-authenticated operation.
//
// **Note:** If your email is set to private and you send an `email` parameter as part of this
// request to update your profile, your privacy settings are still enforced: the email address will
// not be displayed on your public profile or via the API.
//
// PATCH /user
func (c *Client) UsersUpdateAuthenticated(ctx context.Context, request OptUsersUpdateAuthenticatedReq) (res UsersUpdateAuthenticatedRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/update-authenticated"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersUpdateAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     io.Reader
	)
	contentType = "application/json"
	buf, err := encodeUsersUpdateAuthenticatedRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	defer jx.PutEncoder(buf)
	reqBody = bytes.NewReader(buf.Bytes())

	u := uri.Clone(c.serverURL)
	u.Path += "/user"

	r := ht.NewRequest(ctx, "PATCH", u, reqBody)
	defer ht.PutRequest(r)

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersUpdateAuthenticatedResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
