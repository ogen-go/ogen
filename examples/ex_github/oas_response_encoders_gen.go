// Code generated by ogen, DO NOT EDIT.

package api

import (
	"io"
	"net/http"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
)

func encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsAddSelectedRepoToOrgSecretResponse(response ActionsAddSelectedRepoToOrgSecretRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActionsAddSelectedRepoToOrgSecretNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ActionsAddSelectedRepoToOrgSecretConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response ActionsAddSelfHostedRunnerToGroupForOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsApproveWorkflowRunResponse(response ActionsApproveWorkflowRunRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *EmptyObject:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActionsApproveWorkflowRunApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActionsApproveWorkflowRunApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/actions/runs/{run_id}/approve"+`: unexpected response type: %T`, response)
	}
}
func encodeActionsCancelWorkflowRunResponse(response ActionsCancelWorkflowRunAccepted, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)
	span.SetStatus(codes.Ok, http.StatusText(202))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsCreateOrUpdateEnvironmentSecretResponse(response ActionsCreateOrUpdateEnvironmentSecretRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *EmptyObject:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActionsCreateOrUpdateEnvironmentSecretNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"+`: unexpected response type: %T`, response)
	}
}
func encodeActionsCreateOrUpdateOrgSecretResponse(response ActionsCreateOrUpdateOrgSecretRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *EmptyObject:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActionsCreateOrUpdateOrgSecretNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/actions/secrets/{secret_name}"+`: unexpected response type: %T`, response)
	}
}
func encodeActionsCreateOrUpdateRepoSecretResponse(response ActionsCreateOrUpdateRepoSecretRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActionsCreateOrUpdateRepoSecretCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActionsCreateOrUpdateRepoSecretNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/actions/secrets/{secret_name}"+`: unexpected response type: %T`, response)
	}
}
func encodeActionsCreateRegistrationTokenForOrgResponse(response AuthenticationToken, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsCreateRegistrationTokenForRepoResponse(response AuthenticationToken, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsCreateRemoveTokenForOrgResponse(response AuthenticationToken, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsCreateRemoveTokenForRepoResponse(response AuthenticationToken, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response RunnerGroupsOrg, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsDeleteArtifactResponse(response ActionsDeleteArtifactNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteEnvironmentSecretResponse(response ActionsDeleteEnvironmentSecretNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteOrgSecretResponse(response ActionsDeleteOrgSecretNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteRepoSecretResponse(response ActionsDeleteRepoSecretNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response ActionsDeleteSelfHostedRunnerFromOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response ActionsDeleteSelfHostedRunnerFromRepoNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteWorkflowRunResponse(response ActionsDeleteWorkflowRunNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDeleteWorkflowRunLogsResponse(response ActionsDeleteWorkflowRunLogsNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsDownloadArtifactResponse(response ActionsDownloadArtifactFound, w http.ResponseWriter, span trace.Span) error {
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(302)
	span.SetStatus(codes.Ok, http.StatusText(302))
	return nil

}
func encodeActionsDownloadJobLogsForWorkflowRunResponse(response ActionsDownloadJobLogsForWorkflowRunFound, w http.ResponseWriter, span trace.Span) error {
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(302)
	span.SetStatus(codes.Ok, http.StatusText(302))
	return nil

}
func encodeActionsDownloadWorkflowRunLogsResponse(response ActionsDownloadWorkflowRunLogsFound, w http.ResponseWriter, span trace.Span) error {
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(302)
	span.SetStatus(codes.Ok, http.StatusText(302))
	return nil

}
func encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsGetAllowedActionsOrganizationResponse(response SelectedActions, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetAllowedActionsRepositoryResponse(response SelectedActions, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetArtifactResponse(response Artifact, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetEnvironmentPublicKeyResponse(response ActionsPublicKey, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetEnvironmentSecretResponse(response ActionsSecret, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetGithubActionsPermissionsOrganizationResponse(response ActionsOrganizationPermissions, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetGithubActionsPermissionsRepositoryResponse(response ActionsRepositoryPermissions, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetJobForWorkflowRunResponse(response Job, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetOrgPublicKeyResponse(response ActionsPublicKey, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetOrgSecretResponse(response OrganizationActionsSecret, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetRepoPublicKeyResponse(response ActionsPublicKey, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetRepoSecretResponse(response ActionsSecret, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetReviewsForRunResponse(response []EnvironmentApprovals, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetSelfHostedRunnerForOrgResponse(response Runner, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetSelfHostedRunnerForRepoResponse(response Runner, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response RunnerGroupsOrg, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetWorkflowRunResponse(response WorkflowRun, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsGetWorkflowRunUsageResponse(response WorkflowRunUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListArtifactsForRepoResponse(response ActionsListArtifactsForRepoOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListEnvironmentSecretsResponse(response ActionsListEnvironmentSecretsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListJobsForWorkflowRunResponse(response ActionsListJobsForWorkflowRunOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListOrgSecretsResponse(response ActionsListOrgSecretsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListRepoSecretsResponse(response ActionsListRepoSecretsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListRepoWorkflowsResponse(response ActionsListRepoWorkflowsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListRunnerApplicationsForOrgResponse(response []RunnerApplication, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListRunnerApplicationsForRepoResponse(response []RunnerApplication, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListSelectedReposForOrgSecretResponse(response ActionsListSelectedReposForOrgSecretOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response ActionsListSelfHostedRunnerGroupsForOrgOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListSelfHostedRunnersForOrgResponse(response ActionsListSelfHostedRunnersForOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListSelfHostedRunnersForRepoResponse(response ActionsListSelfHostedRunnersForRepoOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response ActionsListSelfHostedRunnersInGroupForOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListWorkflowRunArtifactsResponse(response ActionsListWorkflowRunArtifactsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsListWorkflowRunsForRepoResponse(response ActionsListWorkflowRunsForRepoOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsReRunWorkflowResponse(response ActionsReRunWorkflowCreated, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response ActionsRemoveSelectedRepoFromOrgSecretRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActionsRemoveSelectedRepoFromOrgSecretNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ActionsRemoveSelectedRepoFromOrgSecretConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsRetryWorkflowResponse(response ActionsRetryWorkflowCreated, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsReviewPendingDeploymentsForRunResponse(response []Deployment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActionsSetAllowedActionsOrganizationResponse(response ActionsSetAllowedActionsOrganizationNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetAllowedActionsRepositoryResponse(response ActionsSetAllowedActionsRepositoryNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetGithubActionsPermissionsOrganizationResponse(response ActionsSetGithubActionsPermissionsOrganizationNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetGithubActionsPermissionsRepositoryResponse(response ActionsSetGithubActionsPermissionsRepositoryNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetSelectedReposForOrgSecretResponse(response ActionsSetSelectedReposForOrgSecretNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response ActionsSetSelfHostedRunnersInGroupForOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response RunnerGroupsOrg, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response ActivityCheckRepoIsStarredByAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityCheckRepoIsStarredByAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/starred/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityDeleteRepoSubscriptionResponse(response ActivityDeleteRepoSubscriptionNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeActivityDeleteThreadSubscriptionResponse(response ActivityDeleteThreadSubscriptionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityDeleteThreadSubscriptionNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityDeleteThreadSubscriptionApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications/threads/{thread_id}/subscription"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityGetFeedsResponse(response Feed, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityGetRepoSubscriptionResponse(response ActivityGetRepoSubscriptionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RepositorySubscription:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityGetRepoSubscriptionNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/subscription"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityGetThreadResponse(response ActivityGetThreadRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Thread:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityGetThreadApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityGetThreadApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications/threads/{thread_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response ActivityGetThreadSubscriptionForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ThreadSubscription:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications/threads/{thread_id}/subscription"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityListEventsForAuthenticatedUserResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListNotificationsForAuthenticatedUserResponse(response ActivityListNotificationsForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityListNotificationsForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityListOrgEventsForAuthenticatedUserResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListPublicEventsResponse(response ActivityListPublicEventsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityListPublicEventsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/events"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityListPublicEventsForRepoNetworkResponse(response ActivityListPublicEventsForRepoNetworkRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityListPublicEventsForRepoNetworkOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/networks/{owner}/{repo}/events"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityListPublicEventsForUserResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListPublicOrgEventsResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListReceivedEventsForUserResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListReceivedPublicEventsForUserResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListRepoEventsResponse(response []Event, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response ActivityListRepoNotificationsForAuthenticatedUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListReposStarredByAuthenticatedUserResponse(response ActivityListReposStarredByAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityListReposStarredByAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/starred"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityListReposWatchedByUserResponse(response ActivityListReposWatchedByUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityListWatchedReposForAuthenticatedUserResponse(response ActivityListWatchedReposForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityListWatchedReposForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/subscriptions"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityListWatchersForRepoResponse(response ActivityListWatchersForRepoOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivityMarkNotificationsAsReadResponse(response ActivityMarkNotificationsAsReadRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityMarkNotificationsAsReadAccepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityMarkNotificationsAsReadResetContent:
		w.WriteHeader(205)
		span.SetStatus(codes.Ok, http.StatusText(205))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityMarkNotificationsAsReadApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityMarkNotificationsAsReadApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityMarkRepoNotificationsAsReadResponse(response ActivityMarkRepoNotificationsAsReadRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityMarkRepoNotificationsAsReadAccepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityMarkRepoNotificationsAsReadResetContent:
		w.WriteHeader(205)
		span.SetStatus(codes.Ok, http.StatusText(205))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/notifications"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityMarkThreadAsReadResponse(response ActivityMarkThreadAsReadRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityMarkThreadAsReadResetContent:
		w.WriteHeader(205)
		span.SetStatus(codes.Ok, http.StatusText(205))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications/threads/{thread_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeActivitySetRepoSubscriptionResponse(response RepositorySubscription, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeActivitySetThreadSubscriptionResponse(response ActivitySetThreadSubscriptionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ThreadSubscription:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivitySetThreadSubscriptionApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivitySetThreadSubscriptionApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/notifications/threads/{thread_id}/subscription"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityStarRepoForAuthenticatedUserResponse(response ActivityStarRepoForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityStarRepoForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/starred/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeActivityUnstarRepoForAuthenticatedUserResponse(response ActivityUnstarRepoForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ActivityUnstarRepoForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/starred/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsAddRepoToInstallationResponse(response AppsAddRepoToInstallationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsAddRepoToInstallationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *AppsAddRepoToInstallationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsAddRepoToInstallationApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/installations/{installation_id}/repositories/{repository_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsCheckTokenResponse(response AppsCheckTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Authorization:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/{client_id}/token"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsCreateContentAttachmentResponse(response AppsCreateContentAttachmentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ContentReferenceAttachment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *AppsCreateContentAttachmentApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsCreateContentAttachmentApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsCreateContentAttachmentApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsCreateFromManifestResponse(response AppsCreateFromManifestRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsCreateFromManifestCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app-manifests/{code}/conversions"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsCreateInstallationAccessTokenResponse(response AppsCreateInstallationAccessTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *InstallationToken:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsCreateInstallationAccessTokenApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsCreateInstallationAccessTokenApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsCreateInstallationAccessTokenApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/installations/{installation_id}/access_tokens"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsDeleteAuthorizationResponse(response AppsDeleteAuthorizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsDeleteAuthorizationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/{client_id}/grant"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsDeleteInstallationResponse(response AppsDeleteInstallationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsDeleteInstallationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/installations/{installation_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsDeleteTokenResponse(response AppsDeleteTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsDeleteTokenNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/{client_id}/token"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsGetAuthenticatedResponse(response Integration, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeAppsGetBySlugResponse(response AppsGetBySlugRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Integration:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsGetBySlugApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsGetBySlugApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/apps/{app_slug}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsGetSubscriptionPlanForAccountResponse(response AppsGetSubscriptionPlanForAccountRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MarketplacePurchase:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsGetSubscriptionPlanForAccountApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/marketplace_listing/accounts/{account_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response AppsGetSubscriptionPlanForAccountStubbedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MarketplacePurchase:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsGetSubscriptionPlanForAccountStubbedNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/marketplace_listing/stubbed/accounts/{account_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsGetWebhookConfigForAppResponse(response WebhookConfig, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeAppsGetWebhookDeliveryResponse(response AppsGetWebhookDeliveryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *HookDelivery:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/hook/deliveries/{delivery_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListAccountsForPlanResponse(response AppsListAccountsForPlanRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListAccountsForPlanOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListAccountsForPlanApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListAccountsForPlanApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/marketplace_listing/plans/{plan_id}/accounts"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListAccountsForPlanStubbedResponse(response AppsListAccountsForPlanStubbedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListAccountsForPlanStubbedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/marketplace_listing/stubbed/plans/{plan_id}/accounts"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListInstallationReposForAuthenticatedUserResponse(response AppsListInstallationReposForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListInstallationReposForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/installations/{installation_id}/repositories"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListPlansResponse(response AppsListPlansRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListPlansOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListPlansApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListPlansApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/marketplace_listing/plans"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListPlansStubbedResponse(response AppsListPlansStubbedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListPlansStubbedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/marketplace_listing/stubbed/plans"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListReposAccessibleToInstallationResponse(response AppsListReposAccessibleToInstallationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListReposAccessibleToInstallationOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *AppsListReposAccessibleToInstallationApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListReposAccessibleToInstallationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/installation/repositories"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListSubscriptionsForAuthenticatedUserResponse(response AppsListSubscriptionsForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListSubscriptionsForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/marketplace_purchases"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response AppsListSubscriptionsForAuthenticatedUserStubbedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListSubscriptionsForAuthenticatedUserStubbedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/marketplace_purchases/stubbed"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsListWebhookDeliveriesResponse(response AppsListWebhookDeliveriesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsListWebhookDeliveriesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/hook/deliveries"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsRedeliverWebhookDeliveryResponse(response AppsRedeliverWebhookDeliveryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/hook/deliveries/{delivery_id}/attempts"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsRemoveRepoFromInstallationResponse(response AppsRemoveRepoFromInstallationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsRemoveRepoFromInstallationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *AppsRemoveRepoFromInstallationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsRemoveRepoFromInstallationApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/installations/{installation_id}/repositories/{repository_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsResetTokenResponse(response AppsResetTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Authorization:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/{client_id}/token"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsRevokeInstallationAccessTokenResponse(response AppsRevokeInstallationAccessTokenNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeAppsScopeTokenResponse(response AppsScopeTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Authorization:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsScopeTokenApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsScopeTokenApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *AppsScopeTokenApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/{client_id}/token/scoped"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsSuspendInstallationResponse(response AppsSuspendInstallationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsSuspendInstallationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/installations/{installation_id}/suspended"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsUnsuspendInstallationResponse(response AppsUnsuspendInstallationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AppsUnsuspendInstallationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/app/installations/{installation_id}/suspended"+`: unexpected response type: %T`, response)
	}
}
func encodeAppsUpdateWebhookConfigForAppResponse(response WebhookConfig, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetGithubActionsBillingGheResponse(response ActionsBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetGithubActionsBillingOrgResponse(response ActionsBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetGithubActionsBillingUserResponse(response ActionsBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetGithubPackagesBillingGheResponse(response PackagesBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetGithubPackagesBillingOrgResponse(response PackagesBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetGithubPackagesBillingUserResponse(response PackagesBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetSharedStorageBillingGheResponse(response CombinedBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetSharedStorageBillingOrgResponse(response CombinedBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeBillingGetSharedStorageBillingUserResponse(response CombinedBillingUsage, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksCreateSuiteResponse(response ChecksCreateSuiteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ChecksCreateSuiteApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ChecksCreateSuiteApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/check-suites"+`: unexpected response type: %T`, response)
	}
}
func encodeChecksGetResponse(response CheckRun, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksGetSuiteResponse(response CheckSuite, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksListAnnotationsResponse(response ChecksListAnnotationsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksListForRefResponse(response ChecksListForRefOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksListForSuiteResponse(response ChecksListForSuiteOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksListSuitesForRefResponse(response ChecksListSuitesForRefOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksRerequestSuiteResponse(response ChecksRerequestSuiteCreated, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeChecksSetSuitesPreferencesResponse(response CheckSuitePreference, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeCodeScanningDeleteAnalysisResponse(response CodeScanningDeleteAnalysisRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningAnalysisDeletion:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningDeleteAnalysisApplicationJSONBadRequest:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningDeleteAnalysisApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningDeleteAnalysisApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningGetAlertResponse(response CodeScanningGetAlertRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningAlert:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningGetAlertApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningGetAlertApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningGetAnalysisResponse(response CodeScanningGetAnalysisRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningAnalysis:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningGetAnalysisApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningGetAnalysisApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningGetSarifResponse(response CodeScanningGetSarifRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningSarifsStatus:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningGetSarifNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningListAlertInstancesResponse(response CodeScanningListAlertInstancesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningListAlertInstancesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningListAlertInstancesApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningListAlertInstancesApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningListAlertsForRepoResponse(response CodeScanningListAlertsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningListAlertsForRepoOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningListAlertsForRepoApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningListAlertsForRepoApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/alerts"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningListRecentAnalysesResponse(response CodeScanningListRecentAnalysesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningListRecentAnalysesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningListRecentAnalysesApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningListRecentAnalysesApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/analyses"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningUpdateAlertResponse(response CodeScanningUpdateAlertRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningAlert:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningUpdateAlertApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningUpdateAlertApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeCodeScanningUploadSarifResponse(response CodeScanningUploadSarifRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeScanningSarifsReceipt:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningUploadSarifBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		return nil

	case *CodeScanningUploadSarifApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningUploadSarifApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *CodeScanningUploadSarifRequestEntityTooLarge:
		w.WriteHeader(413)
		span.SetStatus(codes.Error, http.StatusText(413))
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/code-scanning/sarifs"+`: unexpected response type: %T`, response)
	}
}
func encodeCodesOfConductGetAllCodesOfConductResponse(response CodesOfConductGetAllCodesOfConductRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodesOfConductGetAllCodesOfConductOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/codes_of_conduct"+`: unexpected response type: %T`, response)
	}
}
func encodeCodesOfConductGetConductCodeResponse(response CodesOfConductGetConductCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CodeOfConduct:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/codes_of_conduct/{key}"+`: unexpected response type: %T`, response)
	}
}
func encodeEmojisGetResponse(response EmojisGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *EmojisGetOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/emojis"+`: unexpected response type: %T`, response)
	}
}
func encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response AuthenticationToken, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response AuthenticationToken, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response RunnerGroupsEnterprise, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response EnterpriseAdminDeleteUserFromEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response SelectedActions, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminGetAuditLogResponse(response []AuditLogEvent, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response ActionsEnterprisePermissions, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response ScimEnterpriseGroup, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response ScimEnterpriseUser, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response Runner, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response RunnerGroupsEnterprise, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response ScimGroupListEnterprise, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response ScimUserListEnterprise, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response []RunnerApplication, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response ScimEnterpriseGroup, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response ScimEnterpriseUser, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response EnterpriseAdminSetAllowedActionsEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response ScimEnterpriseGroup, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response ScimEnterpriseUser, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(response ScimEnterpriseGroup, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response ScimEnterpriseUser, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response RunnerGroupsEnterprise, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeGistsCheckIsStarredResponse(response GistsCheckIsStarredRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsCheckIsStarredNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsCheckIsStarredNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/star"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsCreateResponse(response GistsCreateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistSimpleHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsCreateApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsCreateApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsCreateCommentResponse(response GistsCreateCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistCommentHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsCreateCommentApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsCreateCommentApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsDeleteResponse(response GistsDeleteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsDeleteNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsDeleteApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsDeleteApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsDeleteCommentResponse(response GistsDeleteCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsDeleteCommentNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsDeleteCommentApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsDeleteCommentApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsForkResponse(response GistsForkRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *BaseGistHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsForkApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsForkApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/forks"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsGetResponse(response GistsGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ForbiddenGist:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsGetCommentResponse(response GistsGetCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ForbiddenGist:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsGetRevisionResponse(response GistsGetRevisionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsGetRevisionApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsGetRevisionApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/{sha}"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListResponse(response GistsListRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListCommentsResponse(response GistsListCommentsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListCommentsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsListCommentsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsListCommentsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListCommitsResponse(response GistsListCommitsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListCommitsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsListCommitsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsListCommitsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/commits"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListForUserResponse(response GistsListForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListForUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/gists"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListForksResponse(response GistsListForksRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListForksOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsListForksApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsListForksApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/forks"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListPublicResponse(response GistsListPublicRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListPublicOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/public"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsListStarredResponse(response GistsListStarredRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsListStarredOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsListStarredApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsListStarredApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/starred"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsStarResponse(response GistsStarRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsStarNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsStarApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsStarApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/star"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsUnstarResponse(response GistsUnstarRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistsUnstarNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *GistsUnstarApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GistsUnstarApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/star"+`: unexpected response type: %T`, response)
	}
}
func encodeGistsUpdateCommentResponse(response GistsUpdateCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GistComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/gists/{gist_id}/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitCreateBlobResponse(response GitCreateBlobRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ShortBlobHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitCreateBlobApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitCreateBlobApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitCreateBlobApplicationJSONConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/blobs"+`: unexpected response type: %T`, response)
	}
}
func encodeGitCreateCommitResponse(response GitCreateCommitRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitCommitHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/commits"+`: unexpected response type: %T`, response)
	}
}
func encodeGitCreateRefResponse(response GitCreateRefRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitRefHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/refs"+`: unexpected response type: %T`, response)
	}
}
func encodeGitCreateTagResponse(response GitCreateTagRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitTagHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/tags"+`: unexpected response type: %T`, response)
	}
}
func encodeGitCreateTreeResponse(response GitCreateTreeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitTreeHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitCreateTreeApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitCreateTreeApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/trees"+`: unexpected response type: %T`, response)
	}
}
func encodeGitDeleteRefResponse(response GitDeleteRefRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitDeleteRefNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/refs/{ref}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitGetBlobResponse(response GitGetBlobRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Blob:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitGetBlobApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *GitGetBlobApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/blobs/{file_sha}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitGetCommitResponse(response GitGetCommitRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitCommit:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/commits/{commit_sha}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitGetRefResponse(response GitGetRefRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitRef:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/ref/{ref}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitGetTagResponse(response GitGetTagRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitTag:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/tags/{tag_sha}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitGetTreeResponse(response GitGetTreeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitTree:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/trees/{tree_sha}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitListMatchingRefsResponse(response GitListMatchingRefsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeGitUpdateRefResponse(response GitUpdateRefRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitRef:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/git/refs/{ref}"+`: unexpected response type: %T`, response)
	}
}
func encodeGitignoreGetAllTemplatesResponse(response GitignoreGetAllTemplatesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitignoreGetAllTemplatesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/gitignore/templates"+`: unexpected response type: %T`, response)
	}
}
func encodeGitignoreGetTemplateResponse(response GitignoreGetTemplateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GitignoreTemplate:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/gitignore/templates/{name}"+`: unexpected response type: %T`, response)
	}
}
func encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response InteractionsRemoveRestrictionsForAuthenticatedUserNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeInteractionsRemoveRestrictionsForOrgResponse(response InteractionsRemoveRestrictionsForOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeInteractionsRemoveRestrictionsForRepoResponse(response InteractionsRemoveRestrictionsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *InteractionsRemoveRestrictionsForRepoNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *InteractionsRemoveRestrictionsForRepoConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/interaction-limits"+`: unexpected response type: %T`, response)
	}
}
func encodeInteractionsSetRestrictionsForAuthenticatedUserResponse(response InteractionsSetRestrictionsForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *InteractionLimitResponse:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/interaction-limits"+`: unexpected response type: %T`, response)
	}
}
func encodeInteractionsSetRestrictionsForOrgResponse(response InteractionsSetRestrictionsForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *InteractionLimitResponse:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/interaction-limits"+`: unexpected response type: %T`, response)
	}
}
func encodeInteractionsSetRestrictionsForRepoResponse(response InteractionsSetRestrictionsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *InteractionLimitResponse:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *InteractionsSetRestrictionsForRepoConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/interaction-limits"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesAddAssigneesResponse(response IssueSimple, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeIssuesCheckUserCanBeAssignedResponse(response IssuesCheckUserCanBeAssignedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesCheckUserCanBeAssignedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/assignees/{assignee}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesCreateResponse(response IssuesCreateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssueHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesCreateApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesCreateApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesCreateApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesCreateCommentResponse(response IssuesCreateCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssueCommentHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesCreateCommentApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesCreateCommentApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesCreateCommentApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesCreateLabelResponse(response IssuesCreateLabelRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LabelHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/labels"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesCreateMilestoneResponse(response IssuesCreateMilestoneRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MilestoneHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/milestones"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesDeleteCommentResponse(response IssuesDeleteCommentNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeIssuesDeleteLabelResponse(response IssuesDeleteLabelNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeIssuesDeleteMilestoneResponse(response IssuesDeleteMilestoneRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesDeleteMilestoneNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/milestones/{milestone_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesGetResponse(response IssuesGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Issue:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesGetApplicationJSONMovedPermanently:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *IssuesGetApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesGetApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesGetCommentResponse(response IssuesGetCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssueComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesGetEventResponse(response IssuesGetEventRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssueEvent:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesGetEventApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesGetEventApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesGetEventApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/events/{event_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesGetLabelResponse(response IssuesGetLabelRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Label:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/labels/{name}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesGetMilestoneResponse(response IssuesGetMilestoneRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Milestone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/milestones/{milestone_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListResponse(response IssuesListRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/issues"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListAssigneesResponse(response IssuesListAssigneesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListAssigneesOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/assignees"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListCommentsResponse(response IssuesListCommentsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListCommentsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesListCommentsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesListCommentsApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListCommentsForRepoResponse(response IssuesListCommentsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListCommentsForRepoOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/comments"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListEventsForRepoResponse(response IssuesListEventsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListEventsForRepoOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/events"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListForAuthenticatedUserResponse(response IssuesListForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/issues"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListForOrgResponse(response IssuesListForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListForOrgOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/issues"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListForRepoResponse(response IssuesListForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListForRepoOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesListForRepoApplicationJSONMovedPermanently:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesListForRepoApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListLabelsForMilestoneResponse(response IssuesListLabelsForMilestoneOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeIssuesListLabelsForRepoResponse(response IssuesListLabelsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListLabelsForRepoOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/labels"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListLabelsOnIssueResponse(response IssuesListLabelsOnIssueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListLabelsOnIssueOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/labels"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesListMilestonesResponse(response IssuesListMilestonesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesListMilestonesOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/milestones"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesLockResponse(response IssuesLockRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesLockNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *IssuesLockApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesLockApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesLockApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/lock"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesRemoveAllLabelsResponse(response IssuesRemoveAllLabelsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesRemoveAllLabelsNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/labels"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesRemoveAssigneesResponse(response IssueSimple, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeIssuesRemoveLabelResponse(response IssuesRemoveLabelRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesRemoveLabelOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesRemoveLabelApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesRemoveLabelApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesUnlockResponse(response IssuesUnlockRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssuesUnlockNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *IssuesUnlockApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesUnlockApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/lock"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesUpdateResponse(response IssuesUpdateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Issue:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesUpdateApplicationJSONMovedPermanently:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesUpdateApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesUpdateApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *IssuesUpdateApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesUpdateCommentResponse(response IssuesUpdateCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *IssueComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeIssuesUpdateLabelResponse(response Label, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeIssuesUpdateMilestoneResponse(response Milestone, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeLicensesGetResponse(response LicensesGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *License:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *LicensesGetApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *LicensesGetApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/licenses/{license}"+`: unexpected response type: %T`, response)
	}
}
func encodeLicensesGetAllCommonlyUsedResponse(response LicensesGetAllCommonlyUsedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LicensesGetAllCommonlyUsedOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/licenses"+`: unexpected response type: %T`, response)
	}
}
func encodeLicensesGetForRepoResponse(response LicenseContent, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeMetaGetResponse(response MetaGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *APIOverview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/meta"+`: unexpected response type: %T`, response)
	}
}
func encodeMetaGetZenResponse(response MetaGetZenOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	if _, err := io.Copy(w, response); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeMetaRootResponse(response MetaRootOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeMigrationsCancelImportResponse(response MigrationsCancelImportNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response MigrationsDeleteArchiveForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsDeleteArchiveForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations/{migration_id}/archive"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsDeleteArchiveForOrgResponse(response MigrationsDeleteArchiveForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsDeleteArchiveForOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/migrations/{migration_id}/archive"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsDownloadArchiveForOrgResponse(response MigrationsDownloadArchiveForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsDownloadArchiveForOrgFound:
		w.WriteHeader(302)
		span.SetStatus(codes.Ok, http.StatusText(302))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/migrations/{migration_id}/archive"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsGetArchiveForAuthenticatedUserResponse(response MigrationsGetArchiveForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsGetArchiveForAuthenticatedUserFound:
		w.WriteHeader(302)
		span.SetStatus(codes.Ok, http.StatusText(302))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations/{migration_id}/archive"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsGetCommitAuthorsResponse(response MigrationsGetCommitAuthorsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsGetCommitAuthorsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/import/authors"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsGetImportStatusResponse(response MigrationsGetImportStatusRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Import:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/import"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsGetLargeFilesResponse(response []PorterLargeFile, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeMigrationsGetStatusForAuthenticatedUserResponse(response MigrationsGetStatusForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Migration:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations/{migration_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsGetStatusForOrgResponse(response MigrationsGetStatusForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Migration:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/migrations/{migration_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsListForAuthenticatedUserResponse(response MigrationsListForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsListForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *MigrationsListForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsListForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsListForOrgResponse(response MigrationsListForOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeMigrationsListReposForOrgResponse(response MigrationsListReposForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsListReposForOrgOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/migrations/{migration_id}/repositories"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsListReposForUserResponse(response MigrationsListReposForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsListReposForUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations/{migration_id}/repositories"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsMapCommitAuthorResponse(response MigrationsMapCommitAuthorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PorterAuthor:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/import/authors/{author_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsSetLfsPreferenceResponse(response MigrationsSetLfsPreferenceRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Import:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/import/lfs"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsStartForAuthenticatedUserResponse(response MigrationsStartForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Migration:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsStartForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsStartForOrgResponse(response MigrationsStartForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Migration:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/migrations"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsStartImportResponse(response MigrationsStartImportRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ImportHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/import"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response MigrationsUnlockRepoForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsUnlockRepoForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/migrations/{migration_id}/repos/{repo_name}/lock"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsUnlockRepoForOrgResponse(response MigrationsUnlockRepoForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MigrationsUnlockRepoForOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"+`: unexpected response type: %T`, response)
	}
}
func encodeMigrationsUpdateImportResponse(response Import, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOAuthAuthorizationsCreateAuthorizationResponse(response OAuthAuthorizationsCreateAuthorizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AuthorizationHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsCreateAuthorizationApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsDeleteAuthorizationResponse(response OAuthAuthorizationsDeleteAuthorizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OAuthAuthorizationsDeleteAuthorizationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations/{authorization_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsDeleteGrantResponse(response OAuthAuthorizationsDeleteGrantRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OAuthAuthorizationsDeleteGrantNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsDeleteGrantApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/grants/{grant_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsGetAuthorizationResponse(response OAuthAuthorizationsGetAuthorizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Authorization:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations/{authorization_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsGetGrantResponse(response OAuthAuthorizationsGetGrantRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ApplicationGrant:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsGetGrantApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsGetGrantApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/grants/{grant_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(response OAuthAuthorizationsGetOrCreateAuthorizationForAppRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations/clients/{client_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(response OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations/clients/{client_id}/{fingerprint}"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsListAuthorizationsResponse(response OAuthAuthorizationsListAuthorizationsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OAuthAuthorizationsListAuthorizationsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsListGrantsResponse(response OAuthAuthorizationsListGrantsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OAuthAuthorizationsListGrantsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OAuthAuthorizationsListGrantsApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsListGrantsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OAuthAuthorizationsListGrantsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/applications/grants"+`: unexpected response type: %T`, response)
	}
}
func encodeOAuthAuthorizationsUpdateAuthorizationResponse(response OAuthAuthorizationsUpdateAuthorizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Authorization:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/authorizations/{authorization_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsBlockUserResponse(response OrgsBlockUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsBlockUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/blocks/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsCancelInvitationResponse(response OrgsCancelInvitationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsCancelInvitationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/invitations/{invitation_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsCheckBlockedUserResponse(response OrgsCheckBlockedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsCheckBlockedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/blocks/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsCheckMembershipForUserResponse(response OrgsCheckMembershipForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsCheckMembershipForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *OrgsCheckMembershipForUserFound:
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(302)
		span.SetStatus(codes.Ok, http.StatusText(302))
		return nil

	case *OrgsCheckMembershipForUserNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsCheckPublicMembershipForUserResponse(response OrgsCheckPublicMembershipForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsCheckPublicMembershipForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *OrgsCheckPublicMembershipForUserNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/public_members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsConvertMemberToOutsideCollaboratorResponse(response OrgsConvertMemberToOutsideCollaboratorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsConvertMemberToOutsideCollaboratorAccepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsConvertMemberToOutsideCollaboratorNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *OrgsConvertMemberToOutsideCollaboratorForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/outside_collaborators/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsCreateInvitationResponse(response OrgsCreateInvitationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrganizationInvitation:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/invitations"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsCreateWebhookResponse(response OrgsCreateWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgHookHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsDeleteWebhookResponse(response OrgsDeleteWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsDeleteWebhookNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsGetResponse(response OrgsGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrganizationFull:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsGetAuditLogResponse(response []AuditLogEvent, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOrgsGetMembershipForAuthenticatedUserResponse(response OrgsGetMembershipForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/memberships/orgs/{org}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsGetMembershipForUserResponse(response OrgsGetMembershipForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsGetMembershipForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsGetMembershipForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsGetWebhookResponse(response OrgsGetWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgHook:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsGetWebhookConfigForOrgResponse(response WebhookConfig, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOrgsGetWebhookDeliveryResponse(response OrgsGetWebhookDeliveryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *HookDelivery:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListResponse(response OrgsListRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/organizations"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListBlockedUsersResponse(response OrgsListBlockedUsersRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListBlockedUsersOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/blocks"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListFailedInvitationsResponse(response OrgsListFailedInvitationsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListFailedInvitationsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/failed_invitations"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListForAuthenticatedUserResponse(response OrgsListForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OrgsListForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsListForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/orgs"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListForUserResponse(response OrgsListForUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOrgsListInvitationTeamsResponse(response OrgsListInvitationTeamsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListInvitationTeamsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/invitations/{invitation_id}/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListMembersResponse(response OrgsListMembersRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListMembersOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsListMembersFound:
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(302)
		span.SetStatus(codes.Ok, http.StatusText(302))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/members"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListMembershipsForAuthenticatedUserResponse(response OrgsListMembershipsForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListMembershipsForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/memberships/orgs"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListOutsideCollaboratorsResponse(response OrgsListOutsideCollaboratorsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOrgsListPendingInvitationsResponse(response OrgsListPendingInvitationsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListPendingInvitationsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/invitations"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListPublicMembersResponse(response OrgsListPublicMembersOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOrgsListSamlSSOAuthorizationsResponse(response []CredentialAuthorization, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeOrgsListWebhookDeliveriesResponse(response OrgsListWebhookDeliveriesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListWebhookDeliveriesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}/deliveries"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsListWebhooksResponse(response OrgsListWebhooksRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsListWebhooksOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsPingWebhookResponse(response OrgsPingWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsPingWebhookNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}/pings"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsRedeliverWebhookDeliveryResponse(response OrgsRedeliverWebhookDeliveryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsRemoveMemberResponse(response OrgsRemoveMemberRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsRemoveMemberNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsRemoveMembershipForUserResponse(response OrgsRemoveMembershipForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsRemoveMembershipForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *OrgsRemoveMembershipForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsRemoveMembershipForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsRemoveOutsideCollaboratorResponse(response OrgsRemoveOutsideCollaboratorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsRemoveOutsideCollaboratorNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *OrgsRemoveOutsideCollaboratorUnprocessableEntity:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/outside_collaborators/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response OrgsRemovePublicMembershipForAuthenticatedUserNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeOrgsRemoveSamlSSOAuthorizationResponse(response OrgsRemoveSamlSSOAuthorizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsRemoveSamlSSOAuthorizationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/credential-authorizations/{credential_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsSetMembershipForUserResponse(response OrgsSetMembershipForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response OrgsSetPublicMembershipForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgsSetPublicMembershipForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/public_members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsUnblockUserResponse(response OrgsUnblockUserNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeOrgsUpdateMembershipForAuthenticatedUserResponse(response OrgsUpdateMembershipForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/memberships/orgs/{org}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsUpdateWebhookResponse(response OrgsUpdateWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *OrgHook:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/hooks/{hook_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeOrgsUpdateWebhookConfigForOrgResponse(response WebhookConfig, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesDeletePackageForAuthenticatedUserResponse(response PackagesDeletePackageForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesDeletePackageForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/packages/{package_type}/{package_name}"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesDeletePackageForOrgResponse(response PackagesDeletePackageForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesDeletePackageForOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesDeletePackageForOrgApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageForOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageForOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/packages/{package_type}/{package_name}"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesDeletePackageForUserResponse(response PackagesDeletePackageForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesDeletePackageForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesDeletePackageForUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/packages/{package_type}/{package_name}"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response PackagesDeletePackageVersionForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesDeletePackageVersionForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/packages/{package_type}/{package_name}/versions/{package_version_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesDeletePackageVersionForOrgResponse(response PackagesDeletePackageVersionForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesDeletePackageVersionForOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageVersionForOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageVersionForOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesDeletePackageVersionForUserResponse(response PackagesDeletePackageVersionForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesDeletePackageVersionForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesDeletePackageVersionForUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageVersionForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesDeletePackageVersionForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/packages/{package_type}/{package_name}/versions"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response PackagesGetAllPackageVersionsForPackageOwnedByOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/packages/{package_type}/{package_name}/versions"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response PackagesGetAllPackageVersionsForPackageOwnedByUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/packages/{package_type}/{package_name}/versions"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesGetPackageForAuthenticatedUserResponse(response Package, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesGetPackageForOrganizationResponse(response Package, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesGetPackageForUserResponse(response Package, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesGetPackageVersionForAuthenticatedUserResponse(response PackageVersion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesGetPackageVersionForOrganizationResponse(response PackageVersion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesGetPackageVersionForUserResponse(response PackageVersion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesListPackagesForAuthenticatedUserResponse(response []Package, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePackagesListPackagesForOrganizationResponse(response PackagesListPackagesForOrganizationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesListPackagesForOrganizationOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesListPackagesForOrganizationApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesListPackagesForOrganizationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/packages"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesListPackagesForUserResponse(response PackagesListPackagesForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesListPackagesForUserOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesListPackagesForUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesListPackagesForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/packages"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesRestorePackageForAuthenticatedUserResponse(response PackagesRestorePackageForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesRestorePackageForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/packages/{package_type}/{package_name}/restore"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesRestorePackageForOrgResponse(response PackagesRestorePackageForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesRestorePackageForOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesRestorePackageForOrgApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageForOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageForOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/packages/{package_type}/{package_name}/restore"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesRestorePackageForUserResponse(response PackagesRestorePackageForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesRestorePackageForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesRestorePackageForUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/packages/{package_type}/{package_name}/restore"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response PackagesRestorePackageVersionForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesRestorePackageVersionForAuthenticatedUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesRestorePackageVersionForOrgResponse(response PackagesRestorePackageVersionForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesRestorePackageVersionForOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageVersionForOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageVersionForOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"+`: unexpected response type: %T`, response)
	}
}
func encodePackagesRestorePackageVersionForUserResponse(response PackagesRestorePackageVersionForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PackagesRestorePackageVersionForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PackagesRestorePackageVersionForUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageVersionForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PackagesRestorePackageVersionForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsAddCollaboratorResponse(response ProjectsAddCollaboratorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsAddCollaboratorNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsAddCollaboratorApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsAddCollaboratorApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsAddCollaboratorApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}/collaborators/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsCreateColumnResponse(response ProjectsCreateColumnRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectColumn:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsCreateColumnApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateColumnApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}/columns"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsCreateForAuthenticatedUserResponse(response ProjectsCreateForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Project:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsCreateForOrgResponse(response ProjectsCreateForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Project:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForOrgApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForOrgApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsCreateForRepoResponse(response ProjectsCreateForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Project:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForRepoApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForRepoApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForRepoApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsCreateForRepoApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsDeleteResponse(response ProjectsDeleteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsDeleteNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsDeleteApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsDeleteForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsDeleteApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsDeleteApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsDeleteCardResponse(response ProjectsDeleteCardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsDeleteCardNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsDeleteCardApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsDeleteCardForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsDeleteCardApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/cards/{card_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsDeleteColumnResponse(response ProjectsDeleteColumnRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsDeleteColumnNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsDeleteColumnApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsDeleteColumnApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/{column_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsGetResponse(response ProjectsGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Project:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsGetApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsGetCardResponse(response ProjectsGetCardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectCard:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsGetCardApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetCardApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetCardApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/cards/{card_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsGetColumnResponse(response ProjectsGetColumnRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectColumn:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsGetColumnApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetColumnApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetColumnApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/{column_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsGetPermissionForUserResponse(response ProjectsGetPermissionForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RepositoryCollaboratorPermission:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsGetPermissionForUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetPermissionForUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsGetPermissionForUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}/collaborators/{username}/permission"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsListCardsResponse(response ProjectsListCardsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsListCardsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsListCardsApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListCardsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/{column_id}/cards"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsListCollaboratorsResponse(response ProjectsListCollaboratorsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsListCollaboratorsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsListCollaboratorsApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListCollaboratorsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListCollaboratorsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}/collaborators"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsListColumnsResponse(response ProjectsListColumnsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsListColumnsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsListColumnsApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListColumnsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}/columns"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsListForOrgResponse(response ProjectsListForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsListForOrgOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsListForRepoResponse(response ProjectsListForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsListForRepoOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListForRepoApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListForRepoApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListForRepoApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsListForRepoApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsListForUserResponse(response ProjectsListForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsListForUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsMoveCardResponse(response ProjectsMoveCardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsMoveCardCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsMoveCardForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsMoveCardServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/cards/{card_id}/moves"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsMoveColumnResponse(response ProjectsMoveColumnRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsMoveColumnCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsMoveColumnApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsMoveColumnApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/{column_id}/moves"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsRemoveCollaboratorResponse(response ProjectsRemoveCollaboratorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectsRemoveCollaboratorNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsRemoveCollaboratorApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsRemoveCollaboratorApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsRemoveCollaboratorApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}/collaborators/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsUpdateResponse(response ProjectsUpdateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Project:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsUpdateApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsUpdateForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsUpdateNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *ProjectsUpdateApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsUpdateCardResponse(response ProjectsUpdateCardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectCard:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsUpdateCardApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsUpdateCardApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsUpdateCardApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/cards/{card_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeProjectsUpdateColumnResponse(response ProjectsUpdateColumnRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProjectColumn:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ProjectsUpdateColumnApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ProjectsUpdateColumnApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/projects/columns/{column_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsCheckIfMergedResponse(response PullsCheckIfMergedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullsCheckIfMergedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *PullsCheckIfMergedNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/merge"+`: unexpected response type: %T`, response)
	}
}
func encodePullsCreateResponse(response PullsCreateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls"+`: unexpected response type: %T`, response)
	}
}
func encodePullsCreateReplyForReviewCommentResponse(response PullsCreateReplyForReviewCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReviewCommentHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"+`: unexpected response type: %T`, response)
	}
}
func encodePullsCreateReviewResponse(response PullsCreateReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews"+`: unexpected response type: %T`, response)
	}
}
func encodePullsCreateReviewCommentResponse(response PullsCreateReviewCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReviewCommentHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodePullsDeletePendingReviewResponse(response PullsDeletePendingReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsDeleteReviewCommentResponse(response PullsDeleteReviewCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullsDeleteReviewCommentNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsDismissReviewResponse(response PullsDismissReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"+`: unexpected response type: %T`, response)
	}
}
func encodePullsGetResponse(response PullsGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequest:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *PullsGetApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsGetApplicationJSONInternalServerError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsGetReviewResponse(response PullsGetReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsGetReviewCommentResponse(response PullsGetReviewCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReviewComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsListResponse(response PullsListRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullsListOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls"+`: unexpected response type: %T`, response)
	}
}
func encodePullsListCommentsForReviewResponse(response PullsListCommentsForReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullsListCommentsForReviewOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodePullsListCommitsResponse(response PullsListCommitsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePullsListFilesResponse(response PullsListFilesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullsListFilesOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/files"+`: unexpected response type: %T`, response)
	}
}
func encodePullsListRequestedReviewersResponse(response PullRequestReviewRequestHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePullsListReviewCommentsResponse(response PullsListReviewCommentsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePullsListReviewCommentsForRepoResponse(response PullsListReviewCommentsForRepoOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePullsListReviewsResponse(response PullsListReviewsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodePullsMergeResponse(response PullsMergeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestMergeResult:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsMergeApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsMergeApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsMergeMethodNotAllowed:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsMergeConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/merge"+`: unexpected response type: %T`, response)
	}
}
func encodePullsRemoveRequestedReviewersResponse(response PullsRemoveRequestedReviewersRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"+`: unexpected response type: %T`, response)
	}
}
func encodePullsSubmitReviewResponse(response PullsSubmitReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsSubmitReviewApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PullsSubmitReviewApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"+`: unexpected response type: %T`, response)
	}
}
func encodePullsUpdateResponse(response PullsUpdateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequest:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsUpdateBranchResponse(response PullsUpdateBranchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullsUpdateBranchAccepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"+`: unexpected response type: %T`, response)
	}
}
func encodePullsUpdateReviewResponse(response PullsUpdateReviewRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"+`: unexpected response type: %T`, response)
	}
}
func encodePullsUpdateReviewCommentResponse(response PullRequestReviewComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeRateLimitGetResponse(response RateLimitGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RateLimitOverviewHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "X-RateLimit-Limit" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Limit",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitLimit.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Limit header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Reset" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Reset",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReset.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Reset header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/rate_limit"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForCommitCommentResponse(response ReactionsCreateForCommitCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForCommitCommentApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForCommitCommentApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/comments/{comment_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForIssueResponse(response ReactionsCreateForIssueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForIssueApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForIssueApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForIssueCommentResponse(response ReactionsCreateForIssueCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForIssueCommentApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForIssueCommentApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForPullRequestReviewCommentResponse(response ReactionsCreateForPullRequestReviewCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForPullRequestReviewCommentApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForReleaseResponse(response ReactionsCreateForReleaseRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForReleaseApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForReleaseApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases/{release_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response ReactionsCreateForTeamDiscussionCommentInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response Reaction, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReactionsCreateForTeamDiscussionInOrgResponse(response ReactionsCreateForTeamDiscussionInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsCreateForTeamDiscussionLegacyResponse(response Reaction, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReactionsDeleteForCommitCommentResponse(response ReactionsDeleteForCommitCommentNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReactionsDeleteForIssueResponse(response ReactionsDeleteForIssueNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReactionsDeleteForIssueCommentResponse(response ReactionsDeleteForIssueCommentNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReactionsDeleteForPullRequestCommentResponse(response ReactionsDeleteForPullRequestCommentNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReactionsDeleteForTeamDiscussionResponse(response ReactionsDeleteForTeamDiscussionNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReactionsDeleteForTeamDiscussionCommentResponse(response ReactionsDeleteForTeamDiscussionCommentNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReactionsDeleteLegacyResponse(response ReactionsDeleteLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsDeleteLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ReactionsDeleteLegacyApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsDeleteLegacyApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsDeleteLegacyApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/reactions/{reaction_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsListForCommitCommentResponse(response ReactionsListForCommitCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsListForCommitCommentOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/comments/{comment_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsListForIssueResponse(response ReactionsListForIssueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsListForIssueOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsListForIssueApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReactionsListForIssueApplicationJSONGone:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(410)
		span.SetStatus(codes.Error, http.StatusText(410))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/{issue_number}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsListForIssueCommentResponse(response ReactionsListForIssueCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsListForIssueCommentOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsListForPullRequestReviewCommentResponse(response ReactionsListForPullRequestReviewCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReactionsListForPullRequestReviewCommentOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"+`: unexpected response type: %T`, response)
	}
}
func encodeReactionsListForTeamDiscussionCommentInOrgResponse(response ReactionsListForTeamDiscussionCommentInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReactionsListForTeamDiscussionCommentLegacyResponse(response ReactionsListForTeamDiscussionCommentLegacyOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReactionsListForTeamDiscussionInOrgResponse(response ReactionsListForTeamDiscussionInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReactionsListForTeamDiscussionLegacyResponse(response ReactionsListForTeamDiscussionLegacyOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposAcceptInvitationResponse(response ReposAcceptInvitationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposAcceptInvitationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ReposAcceptInvitationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposAcceptInvitationApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposAcceptInvitationApplicationJSONConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/repository_invitations/{invitation_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposAddAppAccessRestrictionsResponse(response ReposAddAppAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposAddAppAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"+`: unexpected response type: %T`, response)
	}
}
func encodeReposAddCollaboratorResponse(response ReposAddCollaboratorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RepositoryInvitation:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposAddCollaboratorNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/collaborators/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposAddStatusCheckContextsResponse(response ReposAddStatusCheckContextsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposAddStatusCheckContextsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposAddStatusCheckContextsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposAddStatusCheckContextsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"+`: unexpected response type: %T`, response)
	}
}
func encodeReposAddTeamAccessRestrictionsResponse(response ReposAddTeamAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposAddTeamAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeReposAddUserAccessRestrictionsResponse(response ReposAddUserAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposAddUserAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCheckCollaboratorResponse(response ReposCheckCollaboratorRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposCheckCollaboratorNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ReposCheckCollaboratorNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/collaborators/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCheckVulnerabilityAlertsResponse(response ReposCheckVulnerabilityAlertsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposCheckVulnerabilityAlertsNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ReposCheckVulnerabilityAlertsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/vulnerability-alerts"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCompareCommitsResponse(response ReposCompareCommitsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CommitComparison:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCompareCommitsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCompareCommitsApplicationJSONInternalServerError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/compare/{basehead}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateAutolinkResponse(response ReposCreateAutolinkRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AutolinkHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/autolinks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateCommitCommentResponse(response ReposCreateCommitCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CommitCommentHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/commits/{commit_sha}/comments"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateCommitSignatureProtectionResponse(response ReposCreateCommitSignatureProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProtectedBranchAdminEnforced:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateCommitStatusResponse(response StatusHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposCreateDeployKeyResponse(response ReposCreateDeployKeyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeployKeyHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/keys"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateDeploymentResponse(response ReposCreateDeploymentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Deployment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateDeploymentAccepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateDeploymentConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/deployments"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateDeploymentStatusResponse(response ReposCreateDeploymentStatusRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeploymentStatusHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateDispatchEventResponse(response ReposCreateDispatchEventRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposCreateDispatchEventNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/dispatches"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateForAuthenticatedUserResponse(response ReposCreateForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RepositoryHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ReposCreateForAuthenticatedUserApplicationJSONBadRequest:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/repos"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateForkResponse(response ReposCreateForkRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *FullRepository:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateForkApplicationJSONBadRequest:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateForkApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateForkApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/forks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateInOrgResponse(response ReposCreateInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RepositoryHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/repos"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateOrUpdateFileContentsResponse(response ReposCreateOrUpdateFileContentsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposCreateOrUpdateFileContentsApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateOrUpdateFileContentsApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateOrUpdateFileContentsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateOrUpdateFileContentsApplicationJSONConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/contents/{path}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreatePagesSiteResponse(response ReposCreatePagesSiteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Page:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pages"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateReleaseResponse(response ReposCreateReleaseRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReleaseHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases"+`: unexpected response type: %T`, response)
	}
}
func encodeReposCreateUsingTemplateResponse(response RepositoryHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposCreateWebhookResponse(response ReposCreateWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *HookHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Location" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Location",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Location.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Location header")
				}
			}
		}
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateWebhookApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposCreateWebhookApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeclineInvitationResponse(response ReposDeclineInvitationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeclineInvitationNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ReposDeclineInvitationApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposDeclineInvitationApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposDeclineInvitationApplicationJSONConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/repository_invitations/{invitation_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteResponse(response ReposDeleteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ReposDeleteApplicationJSONTemporaryRedirect:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(307)
		span.SetStatus(codes.Ok, http.StatusText(307))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposDeleteForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposDeleteApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteAccessRestrictionsResponse(response ReposDeleteAccessRestrictionsNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDeleteAdminBranchProtectionResponse(response ReposDeleteAdminBranchProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteAdminBranchProtectionNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteAnEnvironmentResponse(response ReposDeleteAnEnvironmentNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDeleteAutolinkResponse(response ReposDeleteAutolinkRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteAutolinkNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/autolinks/{autolink_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteBranchProtectionResponse(response ReposDeleteBranchProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteBranchProtectionNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteCommitCommentResponse(response ReposDeleteCommitCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteCommitCommentNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteCommitSignatureProtectionResponse(response ReposDeleteCommitSignatureProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteCommitSignatureProtectionNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteDeployKeyResponse(response ReposDeleteDeployKeyNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDeleteDeploymentResponse(response ReposDeleteDeploymentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteDeploymentNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/deployments/{deployment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteFileResponse(response ReposDeleteFileRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *FileCommit:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposDeleteFileApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposDeleteFileApplicationJSONConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/contents/{path}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteInvitationResponse(response ReposDeleteInvitationNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDeletePagesSiteResponse(response ReposDeletePagesSiteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeletePagesSiteNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pages"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeletePullRequestReviewProtectionResponse(response ReposDeletePullRequestReviewProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeletePullRequestReviewProtectionNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDeleteReleaseResponse(response ReposDeleteReleaseNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDeleteReleaseAssetResponse(response ReposDeleteReleaseAssetNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDeleteWebhookResponse(response ReposDeleteWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposDeleteWebhookNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposDisableAutomatedSecurityFixesResponse(response ReposDisableAutomatedSecurityFixesNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDisableLfsForRepoResponse(response ReposDisableLfsForRepoNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDisableVulnerabilityAlertsResponse(response ReposDisableVulnerabilityAlertsNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposDownloadTarballArchiveResponse(response ReposDownloadTarballArchiveFound, w http.ResponseWriter, span trace.Span) error {
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(302)
	span.SetStatus(codes.Ok, http.StatusText(302))
	return nil

}
func encodeReposDownloadZipballArchiveResponse(response ReposDownloadZipballArchiveFound, w http.ResponseWriter, span trace.Span) error {
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Location" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Location",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Location.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Location header")
			}
		}
	}
	w.WriteHeader(302)
	span.SetStatus(codes.Ok, http.StatusText(302))
	return nil

}
func encodeReposEnableAutomatedSecurityFixesResponse(response ReposEnableAutomatedSecurityFixesNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposEnableLfsForRepoResponse(response ReposEnableLfsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposEnableLfsForRepoForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/lfs"+`: unexpected response type: %T`, response)
	}
}
func encodeReposEnableVulnerabilityAlertsResponse(response ReposEnableVulnerabilityAlertsNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposGetResponse(response ReposGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *FullRepository:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetApplicationJSONMovedPermanently:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetAccessRestrictionsResponse(response ReposGetAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *BranchRestrictionPolicy:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetAdminBranchProtectionResponse(response ProtectedBranchAdminEnforced, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetAllStatusCheckContextsResponse(response ReposGetAllStatusCheckContextsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetAllStatusCheckContextsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetAllTopicsResponse(response ReposGetAllTopicsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Topic:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/topics"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetAppsWithAccessToProtectedBranchResponse(response ReposGetAppsWithAccessToProtectedBranchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetAutolinkResponse(response ReposGetAutolinkRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Autolink:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/autolinks/{autolink_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetBranchResponse(response ReposGetBranchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *BranchWithProtection:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetBranchApplicationJSONMovedPermanently:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetBranchApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetBranchProtectionResponse(response ReposGetBranchProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *BranchProtection:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetClonesResponse(response ReposGetClonesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CloneTraffic:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/traffic/clones"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCodeFrequencyStatsResponse(response ReposGetCodeFrequencyStatsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetCodeFrequencyStatsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/stats/code_frequency"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCollaboratorPermissionLevelResponse(response ReposGetCollaboratorPermissionLevelRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *RepositoryCollaboratorPermission:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/collaborators/{username}/permission"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCombinedStatusForRefResponse(response ReposGetCombinedStatusForRefRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CombinedCommitStatus:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/commits/{ref}/status"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCommitResponse(response ReposGetCommitRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Commit:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetCommitApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetCommitApplicationJSONInternalServerError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/commits/{ref}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCommitActivityStatsResponse(response ReposGetCommitActivityStatsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetCommitActivityStatsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/stats/commit_activity"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCommitCommentResponse(response ReposGetCommitCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CommitComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCommitSignatureProtectionResponse(response ReposGetCommitSignatureProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProtectedBranchAdminEnforced:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetCommunityProfileMetricsResponse(response CommunityProfile, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetContributorsStatsResponse(response ReposGetContributorsStatsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetContributorsStatsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/stats/contributors"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetDeployKeyResponse(response ReposGetDeployKeyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeployKey:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/keys/{key_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetDeploymentResponse(response ReposGetDeploymentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Deployment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/deployments/{deployment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetDeploymentStatusResponse(response ReposGetDeploymentStatusRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeploymentStatus:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetLatestPagesBuildResponse(response PageBuild, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetLatestReleaseResponse(response Release, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetPagesResponse(response ReposGetPagesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Page:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pages"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetPagesBuildResponse(response PageBuild, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetPagesHealthCheckResponse(response ReposGetPagesHealthCheckRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PagesHealthCheck:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *EmptyObject:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetPagesHealthCheckBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposGetPagesHealthCheckUnprocessableEntity:
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/pages/health"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetParticipationStatsResponse(response ReposGetParticipationStatsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ParticipationStats:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/stats/participation"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetPullRequestReviewProtectionResponse(response ProtectedBranchPullRequestReview, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetPunchCardStatsResponse(response ReposGetPunchCardStatsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetPunchCardStatsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/stats/punch_card"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetReadmeResponse(response ReposGetReadmeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ContentFile:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/readme"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetReadmeInDirectoryResponse(response ReposGetReadmeInDirectoryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ContentFile:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/readme/{dir}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetReleaseResponse(response ReposGetReleaseRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Release:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases/{release_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetReleaseAssetResponse(response ReposGetReleaseAssetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReleaseAsset:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *Found:
		w.WriteHeader(302)
		span.SetStatus(codes.Ok, http.StatusText(302))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases/assets/{asset_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetReleaseByTagResponse(response ReposGetReleaseByTagRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Release:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases/tags/{tag}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetStatusChecksProtectionResponse(response ReposGetStatusChecksProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *StatusCheckPolicy:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetTeamsWithAccessToProtectedBranchResponse(response ReposGetTeamsWithAccessToProtectedBranchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetTopPathsResponse(response ReposGetTopPathsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetTopPathsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/traffic/popular/paths"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetTopReferrersResponse(response ReposGetTopReferrersRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetTopReferrersOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/traffic/popular/referrers"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetUsersWithAccessToProtectedBranchResponse(response ReposGetUsersWithAccessToProtectedBranchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetViewsResponse(response ReposGetViewsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ViewTraffic:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/traffic/views"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetWebhookResponse(response ReposGetWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Hook:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposGetWebhookConfigForRepoResponse(response WebhookConfig, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposGetWebhookDeliveryResponse(response ReposGetWebhookDeliveryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *HookDelivery:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListAutolinksResponse(response []Autolink, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListBranchesResponse(response ReposListBranchesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListBranchesOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListBranchesForHeadCommitResponse(response ReposListBranchesForHeadCommitRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListBranchesForHeadCommitOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListCollaboratorsResponse(response ReposListCollaboratorsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListCollaboratorsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/collaborators"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListCommentsForCommitResponse(response ReposListCommentsForCommitOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListCommitCommentsForRepoResponse(response ReposListCommitCommentsForRepoOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListCommitStatusesForRefResponse(response ReposListCommitStatusesForRefRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListCommitStatusesForRefOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(301)
		span.SetStatus(codes.Ok, http.StatusText(301))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/commits/{ref}/statuses"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListCommitsResponse(response ReposListCommitsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListCommitsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListCommitsApplicationJSONBadRequest:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListCommitsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListCommitsApplicationJSONConflict:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListCommitsApplicationJSONInternalServerError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/commits"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListContributorsResponse(response ReposListContributorsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListContributorsOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListContributorsNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *ReposListContributorsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListContributorsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/contributors"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListDeployKeysResponse(response ReposListDeployKeysOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListDeploymentStatusesResponse(response ReposListDeploymentStatusesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListDeploymentStatusesOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListDeploymentsResponse(response ReposListDeploymentsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListForAuthenticatedUserResponse(response ReposListForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListForAuthenticatedUserOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ReposListForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/repos"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListForOrgResponse(response ReposListForOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListForUserResponse(response ReposListForUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListForksResponse(response ReposListForksRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListForksOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/forks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListInvitationsResponse(response ReposListInvitationsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListInvitationsForAuthenticatedUserResponse(response ReposListInvitationsForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListInvitationsForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/repository_invitations"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListLanguagesResponse(response Language, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListPagesBuildsResponse(response ReposListPagesBuildsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListPublicResponse(response ReposListPublicRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListPublicOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repositories"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListPullRequestsAssociatedWithCommitResponse(response ReposListPullRequestsAssociatedWithCommitOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListReleaseAssetsResponse(response ReposListReleaseAssetsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListReleasesResponse(response ReposListReleasesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListReleasesOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListTagsResponse(response ReposListTagsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListTeamsResponse(response ReposListTeamsOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposListWebhookDeliveriesResponse(response ReposListWebhookDeliveriesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListWebhookDeliveriesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"+`: unexpected response type: %T`, response)
	}
}
func encodeReposListWebhooksResponse(response ReposListWebhooksRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposListWebhooksOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposMergeResponse(response ReposMergeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Commit:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposMergeNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposMergeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *ReposMergeConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/merges"+`: unexpected response type: %T`, response)
	}
}
func encodeReposMergeUpstreamResponse(response ReposMergeUpstreamRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MergedUpstream:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposMergeUpstreamConflict:
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))
		return nil

	case *ReposMergeUpstreamUnprocessableEntity:
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/merge-upstream"+`: unexpected response type: %T`, response)
	}
}
func encodeReposPingWebhookResponse(response ReposPingWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposPingWebhookNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}/pings"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRedeliverWebhookDeliveryResponse(response ReposRedeliverWebhookDeliveryRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRemoveAppAccessRestrictionsResponse(response ReposRemoveAppAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposRemoveAppAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRemoveCollaboratorResponse(response ReposRemoveCollaboratorNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposRemoveStatusCheckContextsResponse(response ReposRemoveStatusCheckContextsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposRemoveStatusCheckContextsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRemoveStatusCheckProtectionResponse(response ReposRemoveStatusCheckProtectionNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeReposRemoveTeamAccessRestrictionsResponse(response ReposRemoveTeamAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposRemoveTeamAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRemoveUserAccessRestrictionsResponse(response ReposRemoveUserAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposRemoveUserAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRenameBranchResponse(response ReposRenameBranchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *BranchWithProtection:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposRenameBranchApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposRenameBranchApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/rename"+`: unexpected response type: %T`, response)
	}
}
func encodeReposReplaceAllTopicsResponse(response ReposReplaceAllTopicsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Topic:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/topics"+`: unexpected response type: %T`, response)
	}
}
func encodeReposRequestPagesBuildResponse(response PageBuildStatus, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposSetAdminBranchProtectionResponse(response ProtectedBranchAdminEnforced, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposSetAppAccessRestrictionsResponse(response ReposSetAppAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposSetAppAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"+`: unexpected response type: %T`, response)
	}
}
func encodeReposSetStatusCheckContextsResponse(response ReposSetStatusCheckContextsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposSetStatusCheckContextsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"+`: unexpected response type: %T`, response)
	}
}
func encodeReposSetTeamAccessRestrictionsResponse(response ReposSetTeamAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposSetTeamAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeReposSetUserAccessRestrictionsResponse(response ReposSetUserAccessRestrictionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposSetUserAccessRestrictionsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"+`: unexpected response type: %T`, response)
	}
}
func encodeReposTestPushWebhookResponse(response ReposTestPushWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ReposTestPushWebhookNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}/tests"+`: unexpected response type: %T`, response)
	}
}
func encodeReposTransferResponse(response MinimalRepository, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)
	span.SetStatus(codes.Ok, http.StatusText(202))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposUpdateResponse(response ReposUpdateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *FullRepository:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposUpdateApplicationJSONTemporaryRedirect:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(307)
		span.SetStatus(codes.Ok, http.StatusText(307))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposUpdateApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposUpdateApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateBranchProtectionResponse(response ReposUpdateBranchProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProtectedBranch:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposUpdateBranchProtectionApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ReposUpdateBranchProtectionApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationErrorSimple:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateCommitCommentResponse(response ReposUpdateCommitCommentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CommitComment:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/comments/{comment_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateInvitationResponse(response RepositoryInvitation, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposUpdatePullRequestReviewProtectionResponse(response ReposUpdatePullRequestReviewProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ProtectedBranchPullRequestReview:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateReleaseResponse(response ReposUpdateReleaseRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Release:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/releases/{release_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateReleaseAssetResponse(response ReleaseAsset, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeReposUpdateStatusCheckProtectionResponse(response ReposUpdateStatusCheckProtectionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *StatusCheckPolicy:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateWebhookResponse(response ReposUpdateWebhookRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Hook:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/hooks/{hook_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeReposUpdateWebhookConfigForRepoResponse(response WebhookConfig, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeScimDeleteUserFromOrgResponse(response ScimDeleteUserFromOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ScimDeleteUserFromOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ScimDeleteUserFromOrgApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ScimDeleteUserFromOrgApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/scim/v2/organizations/{org}/Users/{scim_user_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchCodeResponse(response SearchCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchCodeOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/code"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchCommitsResponse(response SearchCommitsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchCommitsOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/commits"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchIssuesAndPullRequestsResponse(response SearchIssuesAndPullRequestsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchIssuesAndPullRequestsOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/issues"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchLabelsResponse(response SearchLabelsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchLabelsOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *SearchLabelsApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *SearchLabelsApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/labels"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchReposResponse(response SearchReposRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchReposOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/repositories"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchTopicsResponse(response SearchTopicsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchTopicsOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/topics"+`: unexpected response type: %T`, response)
	}
}
func encodeSearchUsersResponse(response SearchUsersRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SearchUsersOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/search/users"+`: unexpected response type: %T`, response)
	}
}
func encodeSecretScanningGetAlertResponse(response SecretScanningGetAlertRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SecretScanningAlert:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *SecretScanningGetAlertNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeSecretScanningListAlertsForOrgResponse(response SecretScanningListAlertsForOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SecretScanningListAlertsForOrgOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/secret-scanning/alerts"+`: unexpected response type: %T`, response)
	}
}
func encodeSecretScanningListAlertsForRepoResponse(response SecretScanningListAlertsForRepoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SecretScanningListAlertsForRepoOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *SecretScanningListAlertsForRepoNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/secret-scanning/alerts"+`: unexpected response type: %T`, response)
	}
}
func encodeSecretScanningUpdateAlertResponse(response SecretScanningUpdateAlertRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SecretScanningAlert:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *SecretScanningUpdateAlertNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *SecretScanningUpdateAlertUnprocessableEntity:
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		return nil

	case *ServiceUnavailable:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsAddMemberLegacyResponse(response TeamsAddMemberLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsAddMemberLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsAddMemberLegacyNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	case *TeamsAddMemberLegacyUnprocessableEntity:
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response TeamsAddOrUpdateMembershipForUserInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsAddOrUpdateMembershipForUserInOrgForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		return nil

	case *TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity:
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response TeamsAddOrUpdateMembershipForUserLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsAddOrUpdateMembershipForUserLegacyForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity:
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response TeamsAddOrUpdateProjectPermissionsInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsAddOrUpdateProjectPermissionsInOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsAddOrUpdateProjectPermissionsInOrgForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(response TeamsAddOrUpdateProjectPermissionsLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsAddOrUpdateProjectPermissionsLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsAddOrUpdateProjectPermissionsLegacyForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response TeamsAddOrUpdateRepoPermissionsInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(response TeamsAddOrUpdateRepoPermissionsLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsAddOrUpdateRepoPermissionsLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/repos/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsCheckPermissionsForProjectInOrgResponse(response TeamsCheckPermissionsForProjectInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamProject:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsCheckPermissionsForProjectInOrgNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsCheckPermissionsForProjectLegacyResponse(response TeamsCheckPermissionsForProjectLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamProject:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsCheckPermissionsForProjectLegacyNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsCheckPermissionsForRepoInOrgResponse(response TeamsCheckPermissionsForRepoInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamRepository:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsCheckPermissionsForRepoInOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsCheckPermissionsForRepoInOrgNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsCheckPermissionsForRepoLegacyResponse(response TeamsCheckPermissionsForRepoLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamRepository:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsCheckPermissionsForRepoLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsCheckPermissionsForRepoLegacyNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/repos/{owner}/{repo}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsCreateResponse(response TeamsCreateRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamFull:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsCreateDiscussionCommentInOrgResponse(response TeamDiscussionComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsCreateDiscussionCommentLegacyResponse(response TeamDiscussionComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsCreateDiscussionInOrgResponse(response TeamDiscussion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsCreateDiscussionLegacyResponse(response TeamDiscussion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response GroupMapping, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(response TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GroupMapping:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/team-sync/group-mappings"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsDeleteDiscussionCommentInOrgResponse(response TeamsDeleteDiscussionCommentInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsDeleteDiscussionCommentLegacyResponse(response TeamsDeleteDiscussionCommentLegacyNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsDeleteDiscussionInOrgResponse(response TeamsDeleteDiscussionInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsDeleteDiscussionLegacyResponse(response TeamsDeleteDiscussionLegacyNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsDeleteInOrgResponse(response TeamsDeleteInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsDeleteLegacyResponse(response TeamsDeleteLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsDeleteLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsGetByNameResponse(response TeamsGetByNameRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamFull:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsGetDiscussionCommentInOrgResponse(response TeamDiscussionComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsGetDiscussionCommentLegacyResponse(response TeamDiscussionComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsGetDiscussionInOrgResponse(response TeamDiscussion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsGetDiscussionLegacyResponse(response TeamDiscussion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsGetLegacyResponse(response TeamsGetLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamFull:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsGetMemberLegacyResponse(response TeamsGetMemberLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsGetMemberLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsGetMemberLegacyNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsGetMembershipForUserInOrgResponse(response TeamsGetMembershipForUserInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsGetMembershipForUserInOrgNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsGetMembershipForUserLegacyResponse(response TeamsGetMembershipForUserLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamMembership:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListResponse(response TeamsListRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsListOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListChildInOrgResponse(response TeamsListChildInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListChildLegacyResponse(response TeamsListChildLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsListChildLegacyOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsListChildLegacyApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsListChildLegacyApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListDiscussionCommentsInOrgResponse(response TeamsListDiscussionCommentsInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListDiscussionCommentsLegacyResponse(response TeamsListDiscussionCommentsLegacyOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListDiscussionsInOrgResponse(response TeamsListDiscussionsInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListDiscussionsLegacyResponse(response TeamsListDiscussionsLegacyOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListForAuthenticatedUserResponse(response TeamsListForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsListForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *TeamsListForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsListForAuthenticatedUserApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/teams"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListIdpGroupsForLegacyResponse(response TeamsListIdpGroupsForLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GroupMapping:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsListIdpGroupsForLegacyApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsListIdpGroupsForLegacyApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/team-sync/group-mappings"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListIdpGroupsForOrgResponse(response GroupMappingHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListIdpGroupsInOrgResponse(response GroupMapping, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListMembersInOrgResponse(response TeamsListMembersInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListMembersLegacyResponse(response TeamsListMembersLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsListMembersLegacyOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/members"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListPendingInvitationsInOrgResponse(response TeamsListPendingInvitationsInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListPendingInvitationsLegacyResponse(response TeamsListPendingInvitationsLegacyOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListProjectsInOrgResponse(response TeamsListProjectsInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListProjectsLegacyResponse(response TeamsListProjectsLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsListProjectsLegacyOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/projects"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsListReposInOrgResponse(response TeamsListReposInOrgOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsListReposLegacyResponse(response TeamsListReposLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsListReposLegacyOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/repos"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsRemoveMemberLegacyResponse(response TeamsRemoveMemberLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsRemoveMemberLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsRemoveMemberLegacyNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/members/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsRemoveMembershipForUserInOrgResponse(response TeamsRemoveMembershipForUserInOrgRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsRemoveMembershipForUserInOrgNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsRemoveMembershipForUserInOrgForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		return nil

	default:
		return errors.Errorf("/orgs/{org}/teams/{team_slug}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsRemoveMembershipForUserLegacyResponse(response TeamsRemoveMembershipForUserLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsRemoveMembershipForUserLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *TeamsRemoveMembershipForUserLegacyForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/memberships/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsRemoveProjectInOrgResponse(response TeamsRemoveProjectInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsRemoveProjectLegacyResponse(response TeamsRemoveProjectLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsRemoveProjectLegacyNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}/projects/{project_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeTeamsRemoveRepoInOrgResponse(response TeamsRemoveRepoInOrgNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsRemoveRepoLegacyResponse(response TeamsRemoveRepoLegacyNoContent, w http.ResponseWriter, span trace.Span) error {
	w.WriteHeader(204)
	span.SetStatus(codes.Ok, http.StatusText(204))
	return nil

}
func encodeTeamsUpdateDiscussionCommentInOrgResponse(response TeamDiscussionComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsUpdateDiscussionCommentLegacyResponse(response TeamDiscussionComment, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsUpdateDiscussionInOrgResponse(response TeamDiscussion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsUpdateDiscussionLegacyResponse(response TeamDiscussion, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsUpdateInOrgResponse(response TeamFull, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)
	span.SetStatus(codes.Ok, http.StatusText(201))
	e := jx.GetEncoder()

	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeTeamsUpdateLegacyResponse(response TeamsUpdateLegacyRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TeamsUpdateLegacyApplicationJSONOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsUpdateLegacyApplicationJSONCreated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsUpdateLegacyApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *TeamsUpdateLegacyApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/teams/{team_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersAddEmailForAuthenticatedResponse(response UsersAddEmailForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersAddEmailForAuthenticatedCreatedApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersAddEmailForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersAddEmailForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersAddEmailForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/emails"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersBlockResponse(response UsersBlockRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersBlockNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersBlockApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersBlockApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersBlockApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/blocks/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersCheckBlockedResponse(response UsersCheckBlockedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersCheckBlockedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersCheckBlockedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCheckBlockedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCheckBlockedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/blocks/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersCheckFollowingForUserResponse(response UsersCheckFollowingForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersCheckFollowingForUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *UsersCheckFollowingForUserNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		return nil

	default:
		return errors.Errorf("/users/{username}/following/{target_user}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response UsersCheckPersonIsFollowedByAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersCheckPersonIsFollowedByAuthenticatedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/following/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersCreateGpgKeyForAuthenticatedResponse(response UsersCreateGpgKeyForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GpgKey:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/gpg_keys"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersCreatePublicSSHKeyForAuthenticatedResponse(response UsersCreatePublicSSHKeyForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Key:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/keys"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersDeleteEmailForAuthenticatedResponse(response UsersDeleteEmailForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersDeleteEmailForAuthenticatedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersDeleteEmailForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersDeleteEmailForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/emails"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersDeleteGpgKeyForAuthenticatedResponse(response UsersDeleteGpgKeyForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersDeleteGpgKeyForAuthenticatedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/gpg_keys/{gpg_key_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response UsersDeletePublicSSHKeyForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersDeletePublicSSHKeyForAuthenticatedNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/keys/{key_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersFollowResponse(response UsersFollowRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersFollowNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersFollowApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersFollowApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersFollowApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/following/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersGetAuthenticatedResponse(response UsersGetAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersGetAuthenticatedOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersGetAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersGetAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersGetByUsernameResponse(response UsersGetByUsernameRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersGetByUsernameOK:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *Accepted:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersGetContextForUserResponse(response UsersGetContextForUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Hovercard:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *BasicError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/users/{username}/hovercard"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersGetGpgKeyForAuthenticatedResponse(response UsersGetGpgKeyForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GpgKey:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/gpg_keys/{gpg_key_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response UsersGetPublicSSHKeyForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *Key:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/keys/{key_id}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListResponse(response UsersListRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	default:
		return errors.Errorf("/users"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListBlockedByAuthenticatedResponse(response UsersListBlockedByAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListBlockedByAuthenticatedOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListBlockedByAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListBlockedByAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListBlockedByAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *PreviewHeaderMissing:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/blocks"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListEmailsForAuthenticatedResponse(response UsersListEmailsForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListEmailsForAuthenticatedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListEmailsForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListEmailsForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListEmailsForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/emails"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListFollowedByAuthenticatedResponse(response UsersListFollowedByAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListFollowedByAuthenticatedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListFollowedByAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListFollowedByAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/following"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListFollowersForAuthenticatedUserResponse(response UsersListFollowersForAuthenticatedUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListFollowersForAuthenticatedUserOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListFollowersForAuthenticatedUserApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/followers"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListFollowersForUserResponse(response UsersListFollowersForUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeUsersListFollowingForUserResponse(response UsersListFollowingForUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeUsersListGpgKeysForAuthenticatedResponse(response UsersListGpgKeysForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListGpgKeysForAuthenticatedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListGpgKeysForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListGpgKeysForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/gpg_keys"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListGpgKeysForUserResponse(response UsersListGpgKeysForUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeUsersListPublicEmailsForAuthenticatedResponse(response UsersListPublicEmailsForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListPublicEmailsForAuthenticatedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/public_emails"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersListPublicKeysForUserResponse(response UsersListPublicKeysForUserOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Link" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Link",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Link.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Link header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))
	e := jx.GetEncoder()

	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil

}
func encodeUsersListPublicSSHKeysForAuthenticatedResponse(response UsersListPublicSSHKeysForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersListPublicSSHKeysForAuthenticatedOKHeaders:
		w.Header().Set("Content-Type", "application/json")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Link" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Link",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Link.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Link header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/keys"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(response UsersSetPrimaryEmailVisibilityForAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/email/visibility"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersUnblockResponse(response UsersUnblockRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersUnblockNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersUnblockApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersUnblockApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersUnblockApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/blocks/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersUnfollowResponse(response UsersUnfollowRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UsersUnfollowNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersUnfollowApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersUnfollowApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersUnfollowApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user/following/{username}"+`: unexpected response type: %T`, response)
	}
}
func encodeUsersUpdateAuthenticatedResponse(response UsersUpdateAuthenticatedRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *PrivateUser:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *NotModified:
		w.WriteHeader(304)
		span.SetStatus(codes.Ok, http.StatusText(304))
		return nil

	case *UsersUpdateAuthenticatedApplicationJSONUnauthorized:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersUpdateAuthenticatedApplicationJSONForbidden:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *UsersUpdateAuthenticatedApplicationJSONNotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	case *ValidationError:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))
		e := jx.GetEncoder()

		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}
		return nil

	default:
		return errors.Errorf("/user"+`: unexpected response type: %T`, response)
	}
}
