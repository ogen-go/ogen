// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode implements json.Marshaler.
func (s CreatePetCategoriesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Pets != nil {
			e.Comma()
		}
		if s.Pets != nil {
			e.RawStr("\"pets\"" + ":")
			e.ArrStart()
			if len(s.Pets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pets[0]
					e.Int(elem)
				}
				for _, elem := range s.Pets[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreatePetCategoriesReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes CreatePetCategoriesReq from json.
func (s *CreatePetCategoriesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreatePetCategoriesReq to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "pets":
			s.Pets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Pets = append(s.Pets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetCategoriesReq) {
					name = jsonFieldsNameOfCreatePetCategoriesReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreatePetFriendsReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			e.Comma()
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Int(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		e.Int(s.Owner)
	}
	{
		if s.Friends != nil {
			e.Comma()
		}
		if s.Friends != nil {
			e.RawStr("\"friends\"" + ":")
			e.ArrStart()
			if len(s.Friends) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Friends[0]
					e.Int(elem)
				}
				for _, elem := range s.Friends[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreatePetFriendsReq = [6]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "categories",
	4: "owner",
	5: "friends",
}

// Decode decodes CreatePetFriendsReq from json.
func (s *CreatePetFriendsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreatePetFriendsReq to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "categories":
			s.Categories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Categories = append(s.Categories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.Owner = int(v)
			if err != nil {
				return err
			}
		case "friends":
			s.Friends = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Friends = append(s.Friends, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetFriendsReq) {
					name = jsonFieldsNameOfCreatePetFriendsReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreatePetOwnerReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		if s.Pets != nil {
			e.Comma()
		}
		if s.Pets != nil {
			e.RawStr("\"pets\"" + ":")
			e.ArrStart()
			if len(s.Pets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pets[0]
					e.Int(elem)
				}
				for _, elem := range s.Pets[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreatePetOwnerReq = [3]string{
	0: "name",
	1: "age",
	2: "pets",
}

// Decode decodes CreatePetOwnerReq from json.
func (s *CreatePetOwnerReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreatePetOwnerReq to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "age":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.Age = int(v)
			if err != nil {
				return err
			}
		case "pets":
			s.Pets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Pets = append(s.Pets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetOwnerReq) {
					name = jsonFieldsNameOfCreatePetOwnerReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreatePetReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			e.Comma()
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Int(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		e.Int(s.Owner)
	}
	{
		if s.Friends != nil {
			e.Comma()
		}
		if s.Friends != nil {
			e.RawStr("\"friends\"" + ":")
			e.ArrStart()
			if len(s.Friends) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Friends[0]
					e.Int(elem)
				}
				for _, elem := range s.Friends[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreatePetReq = [6]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "categories",
	4: "owner",
	5: "friends",
}

// Decode decodes CreatePetReq from json.
func (s *CreatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreatePetReq to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "categories":
			s.Categories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Categories = append(s.Categories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.Owner = int(v)
			if err != nil {
				return err
			}
		case "friends":
			s.Friends = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Friends = append(s.Friends, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetReq) {
					name = jsonFieldsNameOfCreatePetReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ListPetCategoriesOKApplicationJSON as json.
func (s ListPetCategoriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PetCategoriesList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListPetCategoriesOKApplicationJSON from json.
func (s *ListPetCategoriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPetCategoriesOKApplicationJSON to nil`)
	}
	var unwrapped []PetCategoriesList
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetCategoriesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetCategoriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListPetFriendsOKApplicationJSON as json.
func (s ListPetFriendsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PetFriendsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListPetFriendsOKApplicationJSON from json.
func (s *ListPetFriendsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPetFriendsOKApplicationJSON to nil`)
	}
	var unwrapped []PetFriendsList
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetFriendsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetFriendsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListPetOKApplicationJSON as json.
func (s ListPetOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PetList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListPetOKApplicationJSON from json.
func (s *ListPetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPetOKApplicationJSON to nil`)
	}
	var unwrapped []PetList
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTime`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s PetCategoriesCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCategoriesCreate = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes PetCategoriesCreate from json.
func (s *PetCategoriesCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetCategoriesCreate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCategoriesCreate) {
					name = jsonFieldsNameOfPetCategoriesCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCategoriesList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCategoriesList = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes PetCategoriesList from json.
func (s *PetCategoriesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetCategoriesList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCategoriesList) {
					name = jsonFieldsNameOfPetCategoriesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			e.Comma()
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					elem.Encode(e)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCreate = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "categories",
	5: "owner",
}

// Decode decodes PetCreate from json.
func (s *PetCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetCreate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "categories":
			s.Categories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PetCreateCategories
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Categories = append(s.Categories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "owner":
			requiredBitSet[0] |= 1 << 5
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreate) {
					name = jsonFieldsNameOfPetCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCreateCategories) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCreateCategories = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes PetCreateCategories from json.
func (s *PetCreateCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetCreateCategories to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateCategories) {
					name = jsonFieldsNameOfPetCreateCategories[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCreateOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCreateOwner = [3]string{
	0: "id",
	1: "name",
	2: "age",
}

// Decode decodes PetCreateOwner from json.
func (s *PetCreateOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetCreateOwner to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Age = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateOwner) {
					name = jsonFieldsNameOfPetCreateOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetFriendsCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetFriendsCreate = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetFriendsCreate from json.
func (s *PetFriendsCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetFriendsCreate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetFriendsCreate) {
					name = jsonFieldsNameOfPetFriendsCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetFriendsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetFriendsList = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetFriendsList from json.
func (s *PetFriendsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetFriendsList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetFriendsList) {
					name = jsonFieldsNameOfPetFriendsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetList = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetList from json.
func (s *PetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetList) {
					name = jsonFieldsNameOfPetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetOwnerCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetOwnerCreate = [3]string{
	0: "id",
	1: "name",
	2: "age",
}

// Decode decodes PetOwnerCreate from json.
func (s *PetOwnerCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetOwnerCreate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Age = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetOwnerCreate) {
					name = jsonFieldsNameOfPetOwnerCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetOwnerRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetOwnerRead = [3]string{
	0: "id",
	1: "name",
	2: "age",
}

// Decode decodes PetOwnerRead from json.
func (s *PetOwnerRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetOwnerRead to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Age = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetOwnerRead) {
					name = jsonFieldsNameOfPetOwnerRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetRead = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetRead from json.
func (s *PetRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetRead to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetRead) {
					name = jsonFieldsNameOfPetRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetUpdate = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetUpdate from json.
func (s *PetUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PetUpdate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetUpdate) {
					name = jsonFieldsNameOfPetUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R400) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR400 = [2]string{
	0: "code",
	1: "status",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode R400 to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.Code = int(v)
			if err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R404) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR404 = [2]string{
	0: "code",
	1: "status",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode R404 to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.Code = int(v)
			if err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R409) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR409 = [2]string{
	0: "code",
	1: "status",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode R409 to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.Code = int(v)
			if err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R500) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR500 = [2]string{
	0: "code",
	1: "status",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode R500 to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.Code = int(v)
			if err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdatePetReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			e.Comma()
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Int(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		e.Int(s.Owner)
	}
	{
		if s.Friends != nil {
			e.Comma()
		}
		if s.Friends != nil {
			e.RawStr("\"friends\"" + ":")
			e.ArrStart()
			if len(s.Friends) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Friends[0]
					e.Int(elem)
				}
				for _, elem := range s.Friends[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdatePetReq = [6]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "categories",
	4: "owner",
	5: "friends",
}

// Decode decodes UpdatePetReq from json.
func (s *UpdatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UpdatePetReq to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "weight":
			s.Weight.Reset()
			if err := s.Weight.Decode(d); err != nil {
				return err
			}
		case "birthday":
			s.Birthday.Reset()
			if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "categories":
			s.Categories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Categories = append(s.Categories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.Owner = int(v)
			if err != nil {
				return err
			}
		case "friends":
			s.Friends = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Friends = append(s.Friends, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePetReq) {
					name = jsonFieldsNameOfUpdatePetReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}
