// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCreatePetCategoriesReq_EncodeDecode(t *testing.T) {
	var typ CreatePetCategoriesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetCategoriesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetFriendsReq_EncodeDecode(t *testing.T) {
	var typ CreatePetFriendsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetFriendsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetOwnerReq_EncodeDecode(t *testing.T) {
	var typ CreatePetOwnerReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetOwnerReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetReq_EncodeDecode(t *testing.T) {
	var typ CreatePetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFiveHundred_EncodeDecode(t *testing.T) {
	var typ FiveHundred
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FiveHundred
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFourHundred_EncodeDecode(t *testing.T) {
	var typ FourHundred
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FourHundred
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFourHundredFour_EncodeDecode(t *testing.T) {
	var typ FourHundredFour
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FourHundredFour
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFourHundredNine_EncodeDecode(t *testing.T) {
	var typ FourHundredNine
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FourHundredNine
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetCategoriesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetCategoriesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetCategoriesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetFriendsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetFriendsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetFriendsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCategoriesCreate_EncodeDecode(t *testing.T) {
	var typ PetCategoriesCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCategoriesCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCategoriesList_EncodeDecode(t *testing.T) {
	var typ PetCategoriesList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCategoriesList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreate_EncodeDecode(t *testing.T) {
	var typ PetCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreateCategories_EncodeDecode(t *testing.T) {
	var typ PetCreateCategories
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreateCategories
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreateOwner_EncodeDecode(t *testing.T) {
	var typ PetCreateOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreateOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetFriendsCreate_EncodeDecode(t *testing.T) {
	var typ PetFriendsCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetFriendsCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetFriendsList_EncodeDecode(t *testing.T) {
	var typ PetFriendsList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetFriendsList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetList_EncodeDecode(t *testing.T) {
	var typ PetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetOwnerCreate_EncodeDecode(t *testing.T) {
	var typ PetOwnerCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetOwnerCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetOwnerRead_EncodeDecode(t *testing.T) {
	var typ PetOwnerRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetOwnerRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetRead_EncodeDecode(t *testing.T) {
	var typ PetRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetUpdate_EncodeDecode(t *testing.T) {
	var typ PetUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdatePetReq_EncodeDecode(t *testing.T) {
	var typ UpdatePetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdatePetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
