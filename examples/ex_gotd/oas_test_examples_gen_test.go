// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/netip"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/metric/nonrecording"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

import (
	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

// No-op definition for keeping imports.
var (
	_ = bytes.NewReader
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = io.Copy
	_ = math.Mod
	_ = big.Rat{}
	_ = bits.LeadingZeros64
	_ = net.IP{}
	_ = http.MethodGet
	_ = netip.Addr{}
	_ = url.URL{}
	_ = regexp.MustCompile
	_ = sort.Ints
	_ = strconv.ParseInt
	_ = strings.Builder{}
	_ = sync.Pool{}
	_ = time.Time{}

	_ = errors.Is
	_ = jx.Null
	_ = uuid.UUID{}
	_ = otel.GetTracerProvider
	_ = attribute.KeyValue{}
	_ = codes.Unset
	_ = metric.MeterConfig{}
	_ = syncint64.Counter(nil)
	_ = nonrecording.NewNoopMeterProvider
	_ = trace.TraceIDFromHex

	_ = conv.ToInt32
	_ = ht.NewRequest
	_ = json.Marshal
	_ = otelogen.Version
	_ = uri.PathEncoder{}
	_ = validate.Int{}
)

var (
	_ = std.Marshal
	_ = testing.TB(nil)
	_ = require.NoError
)

func TestAddStickerToSet_EncodeDecode(t *testing.T) {
	var typ AddStickerToSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddStickerToSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnimation_EncodeDecode(t *testing.T) {
	var typ Animation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Animation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnswerCallbackQuery_EncodeDecode(t *testing.T) {
	var typ AnswerCallbackQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnswerCallbackQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnswerInlineQuery_EncodeDecode(t *testing.T) {
	var typ AnswerInlineQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnswerInlineQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnswerPreCheckoutQuery_EncodeDecode(t *testing.T) {
	var typ AnswerPreCheckoutQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnswerPreCheckoutQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnswerShippingQuery_EncodeDecode(t *testing.T) {
	var typ AnswerShippingQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnswerShippingQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApproveChatJoinRequest_EncodeDecode(t *testing.T) {
	var typ ApproveChatJoinRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApproveChatJoinRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAudio_EncodeDecode(t *testing.T) {
	var typ Audio
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Audio
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBanChatMember_EncodeDecode(t *testing.T) {
	var typ BanChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BanChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBanChatSenderChat_EncodeDecode(t *testing.T) {
	var typ BanChatSenderChat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BanChatSenderChat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommand_EncodeDecode(t *testing.T) {
	var typ BotCommand
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommand
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScope_EncodeDecode(t *testing.T) {
	var typ BotCommandScope
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScope
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeAllChatAdministrators_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeAllChatAdministrators
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeAllChatAdministrators
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeAllGroupChats_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeAllGroupChats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeAllGroupChats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeAllPrivateChats_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeAllPrivateChats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeAllPrivateChats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeChat_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeChat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeChat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeChatAdministrators_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeChatAdministrators
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeChatAdministrators
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeChatMember_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBotCommandScopeDefault_EncodeDecode(t *testing.T) {
	var typ BotCommandScopeDefault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BotCommandScopeDefault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCallbackGame_EncodeDecode(t *testing.T) {
	var typ CallbackGame
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CallbackGame
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCallbackQuery_EncodeDecode(t *testing.T) {
	var typ CallbackQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CallbackQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChat_EncodeDecode(t *testing.T) {
	var typ Chat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Chat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatInviteLink_EncodeDecode(t *testing.T) {
	var typ ChatInviteLink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatInviteLink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatJoinRequest_EncodeDecode(t *testing.T) {
	var typ ChatJoinRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatJoinRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatLocation_EncodeDecode(t *testing.T) {
	var typ ChatLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMember_EncodeDecode(t *testing.T) {
	var typ ChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberAdministrator_EncodeDecode(t *testing.T) {
	var typ ChatMemberAdministrator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberAdministrator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberBanned_EncodeDecode(t *testing.T) {
	var typ ChatMemberBanned
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberBanned
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberLeft_EncodeDecode(t *testing.T) {
	var typ ChatMemberLeft
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberLeft
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberMember_EncodeDecode(t *testing.T) {
	var typ ChatMemberMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberOwner_EncodeDecode(t *testing.T) {
	var typ ChatMemberOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberRestricted_EncodeDecode(t *testing.T) {
	var typ ChatMemberRestricted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberRestricted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatMemberUpdated_EncodeDecode(t *testing.T) {
	var typ ChatMemberUpdated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatMemberUpdated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatPermissions_EncodeDecode(t *testing.T) {
	var typ ChatPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatPhoto_EncodeDecode(t *testing.T) {
	var typ ChatPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatType_EncodeDecode(t *testing.T) {
	var typ ChatType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChosenInlineResult_EncodeDecode(t *testing.T) {
	var typ ChosenInlineResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChosenInlineResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContact_EncodeDecode(t *testing.T) {
	var typ Contact
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Contact
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCopyMessage_EncodeDecode(t *testing.T) {
	var typ CopyMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CopyMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateChatInviteLink_EncodeDecode(t *testing.T) {
	var typ CreateChatInviteLink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateChatInviteLink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateNewStickerSet_EncodeDecode(t *testing.T) {
	var typ CreateNewStickerSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateNewStickerSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeclineChatJoinRequest_EncodeDecode(t *testing.T) {
	var typ DeclineChatJoinRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeclineChatJoinRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteChatPhoto_EncodeDecode(t *testing.T) {
	var typ DeleteChatPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteChatPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteChatStickerSet_EncodeDecode(t *testing.T) {
	var typ DeleteChatStickerSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteChatStickerSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessage_EncodeDecode(t *testing.T) {
	var typ DeleteMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMyCommands_EncodeDecode(t *testing.T) {
	var typ DeleteMyCommands
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMyCommands
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteStickerFromSet_EncodeDecode(t *testing.T) {
	var typ DeleteStickerFromSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteStickerFromSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteWebhook_EncodeDecode(t *testing.T) {
	var typ DeleteWebhook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWebhook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDice_EncodeDecode(t *testing.T) {
	var typ Dice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDocument_EncodeDecode(t *testing.T) {
	var typ Document
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Document
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditChatInviteLink_EncodeDecode(t *testing.T) {
	var typ EditChatInviteLink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditChatInviteLink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditMessageCaption_EncodeDecode(t *testing.T) {
	var typ EditMessageCaption
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditMessageCaption
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditMessageLiveLocation_EncodeDecode(t *testing.T) {
	var typ EditMessageLiveLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditMessageLiveLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditMessageMedia_EncodeDecode(t *testing.T) {
	var typ EditMessageMedia
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditMessageMedia
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditMessageReplyMarkup_EncodeDecode(t *testing.T) {
	var typ EditMessageReplyMarkup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditMessageReplyMarkup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditMessageText_EncodeDecode(t *testing.T) {
	var typ EditMessageText
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditMessageText
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptedCredentials_EncodeDecode(t *testing.T) {
	var typ EncryptedCredentials
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptedCredentials
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptedPassportElement_EncodeDecode(t *testing.T) {
	var typ EncryptedPassportElement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptedPassportElement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptedPassportElementType_EncodeDecode(t *testing.T) {
	var typ EncryptedPassportElementType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptedPassportElementType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExportChatInviteLink_EncodeDecode(t *testing.T) {
	var typ ExportChatInviteLink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExportChatInviteLink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFile_EncodeDecode(t *testing.T) {
	var typ File
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 File
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForceReply_EncodeDecode(t *testing.T) {
	var typ ForceReply
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForceReply
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForwardMessage_EncodeDecode(t *testing.T) {
	var typ ForwardMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForwardMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGame_EncodeDecode(t *testing.T) {
	var typ Game
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Game
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGameHighScore_EncodeDecode(t *testing.T) {
	var typ GameHighScore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GameHighScore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetChat_EncodeDecode(t *testing.T) {
	var typ GetChat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetChat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetChatAdministrators_EncodeDecode(t *testing.T) {
	var typ GetChatAdministrators
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetChatAdministrators
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetChatMember_EncodeDecode(t *testing.T) {
	var typ GetChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetChatMemberCount_EncodeDecode(t *testing.T) {
	var typ GetChatMemberCount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetChatMemberCount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetFile_EncodeDecode(t *testing.T) {
	var typ GetFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGameHighScores_EncodeDecode(t *testing.T) {
	var typ GetGameHighScores
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGameHighScores
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMyCommands_EncodeDecode(t *testing.T) {
	var typ GetMyCommands
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMyCommands
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStickerSet_EncodeDecode(t *testing.T) {
	var typ GetStickerSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStickerSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUpdates_EncodeDecode(t *testing.T) {
	var typ GetUpdates
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUpdates
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserProfilePhotos_EncodeDecode(t *testing.T) {
	var typ GetUserProfilePhotos
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserProfilePhotos
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestID_EncodeDecode(t *testing.T) {
	var typ ID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineKeyboardButton_EncodeDecode(t *testing.T) {
	var typ InlineKeyboardButton
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineKeyboardButton
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineKeyboardMarkup_EncodeDecode(t *testing.T) {
	var typ InlineKeyboardMarkup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineKeyboardMarkup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQuery_EncodeDecode(t *testing.T) {
	var typ InlineQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryChatType_EncodeDecode(t *testing.T) {
	var typ InlineQueryChatType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryChatType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResult_EncodeDecode(t *testing.T) {
	var typ InlineQueryResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultArticle_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultArticle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultArticle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultAudio_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultAudio
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultAudio
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedAudio_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedAudio
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedAudio
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedDocument_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedDocument
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedDocument
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedGif_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedGif
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedGif
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedMpeg4Gif_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedMpeg4Gif
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedMpeg4Gif
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedPhoto_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedSticker_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedSticker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedSticker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedVideo_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedVideo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedVideo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultCachedVoice_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultCachedVoice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultCachedVoice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultContact_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultContact
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultContact
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultDocument_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultDocument
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultDocument
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultGame_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultGame
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultGame
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultGif_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultGif
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultGif
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultLocation_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultMpeg4Gif_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultMpeg4Gif
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultMpeg4Gif
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultPhoto_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultVenue_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultVenue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultVenue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultVideo_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultVideo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultVideo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInlineQueryResultVoice_EncodeDecode(t *testing.T) {
	var typ InlineQueryResultVoice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InlineQueryResultVoice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputContactMessageContent_EncodeDecode(t *testing.T) {
	var typ InputContactMessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputContactMessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputInvoiceMessageContent_EncodeDecode(t *testing.T) {
	var typ InputInvoiceMessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputInvoiceMessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputLocationMessageContent_EncodeDecode(t *testing.T) {
	var typ InputLocationMessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputLocationMessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMedia_EncodeDecode(t *testing.T) {
	var typ InputMedia
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMedia
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMediaAnimation_EncodeDecode(t *testing.T) {
	var typ InputMediaAnimation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMediaAnimation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMediaAudio_EncodeDecode(t *testing.T) {
	var typ InputMediaAudio
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMediaAudio
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMediaDocument_EncodeDecode(t *testing.T) {
	var typ InputMediaDocument
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMediaDocument
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMediaPhoto_EncodeDecode(t *testing.T) {
	var typ InputMediaPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMediaPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMediaVideo_EncodeDecode(t *testing.T) {
	var typ InputMediaVideo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMediaVideo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputMessageContent_EncodeDecode(t *testing.T) {
	var typ InputMessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputMessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputTextMessageContent_EncodeDecode(t *testing.T) {
	var typ InputTextMessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputTextMessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInputVenueMessageContent_EncodeDecode(t *testing.T) {
	var typ InputVenueMessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InputVenueMessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInvoice_EncodeDecode(t *testing.T) {
	var typ Invoice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Invoice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyboardButton_EncodeDecode(t *testing.T) {
	var typ KeyboardButton
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyboardButton
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyboardButtonObject_EncodeDecode(t *testing.T) {
	var typ KeyboardButtonObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyboardButtonObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyboardButtonPollType_EncodeDecode(t *testing.T) {
	var typ KeyboardButtonPollType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyboardButtonPollType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabeledPrice_EncodeDecode(t *testing.T) {
	var typ LabeledPrice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabeledPrice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeaveChat_EncodeDecode(t *testing.T) {
	var typ LeaveChat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeaveChat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLocation_EncodeDecode(t *testing.T) {
	var typ Location
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Location
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginUrl_EncodeDecode(t *testing.T) {
	var typ LoginUrl
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginUrl
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMaskPosition_EncodeDecode(t *testing.T) {
	var typ MaskPosition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MaskPosition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessage_EncodeDecode(t *testing.T) {
	var typ Message
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Message
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageAutoDeleteTimerChanged_EncodeDecode(t *testing.T) {
	var typ MessageAutoDeleteTimerChanged
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageAutoDeleteTimerChanged
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageEntity_EncodeDecode(t *testing.T) {
	var typ MessageEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageEntityType_EncodeDecode(t *testing.T) {
	var typ MessageEntityType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageEntityType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageId_EncodeDecode(t *testing.T) {
	var typ MessageId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrderInfo_EncodeDecode(t *testing.T) {
	var typ OrderInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrderInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportData_EncodeDecode(t *testing.T) {
	var typ PassportData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementError_EncodeDecode(t *testing.T) {
	var typ PassportElementError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorDataField_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorDataField
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorDataField
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorFile_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorFiles_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorFiles
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorFiles
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorFrontSide_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorFrontSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorFrontSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorReverseSide_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorReverseSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorReverseSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorSelfie_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorSelfie
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorSelfie
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorTranslationFile_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorTranslationFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorTranslationFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorTranslationFiles_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorTranslationFiles
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorTranslationFiles
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportElementErrorUnspecified_EncodeDecode(t *testing.T) {
	var typ PassportElementErrorUnspecified
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportElementErrorUnspecified
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassportFile_EncodeDecode(t *testing.T) {
	var typ PassportFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PassportFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPhotoSize_EncodeDecode(t *testing.T) {
	var typ PhotoSize
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PhotoSize
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPinChatMessage_EncodeDecode(t *testing.T) {
	var typ PinChatMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PinChatMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPoll_EncodeDecode(t *testing.T) {
	var typ Poll
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Poll
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPollAnswer_EncodeDecode(t *testing.T) {
	var typ PollAnswer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PollAnswer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPollOption_EncodeDecode(t *testing.T) {
	var typ PollOption
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PollOption
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPollType_EncodeDecode(t *testing.T) {
	var typ PollType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PollType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPreCheckoutQuery_EncodeDecode(t *testing.T) {
	var typ PreCheckoutQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PreCheckoutQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPromoteChatMember_EncodeDecode(t *testing.T) {
	var typ PromoteChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PromoteChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProximityAlertTriggered_EncodeDecode(t *testing.T) {
	var typ ProximityAlertTriggered
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProximityAlertTriggered
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReplyKeyboardMarkup_EncodeDecode(t *testing.T) {
	var typ ReplyKeyboardMarkup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReplyKeyboardMarkup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReplyKeyboardRemove_EncodeDecode(t *testing.T) {
	var typ ReplyKeyboardRemove
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReplyKeyboardRemove
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponse_EncodeDecode(t *testing.T) {
	var typ Response
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Response
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRestrictChatMember_EncodeDecode(t *testing.T) {
	var typ RestrictChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RestrictChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResult_EncodeDecode(t *testing.T) {
	var typ Result
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Result
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultArrayOfBotCommand_EncodeDecode(t *testing.T) {
	var typ ResultArrayOfBotCommand
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultArrayOfBotCommand
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultArrayOfChatMember_EncodeDecode(t *testing.T) {
	var typ ResultArrayOfChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultArrayOfChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultArrayOfGameHighScore_EncodeDecode(t *testing.T) {
	var typ ResultArrayOfGameHighScore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultArrayOfGameHighScore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultArrayOfMessage_EncodeDecode(t *testing.T) {
	var typ ResultArrayOfMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultArrayOfMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultArrayOfUpdate_EncodeDecode(t *testing.T) {
	var typ ResultArrayOfUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultArrayOfUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultChat_EncodeDecode(t *testing.T) {
	var typ ResultChat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultChat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultChatInviteLink_EncodeDecode(t *testing.T) {
	var typ ResultChatInviteLink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultChatInviteLink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultChatMember_EncodeDecode(t *testing.T) {
	var typ ResultChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultFile_EncodeDecode(t *testing.T) {
	var typ ResultFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultInt_EncodeDecode(t *testing.T) {
	var typ ResultInt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultInt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultMessage_EncodeDecode(t *testing.T) {
	var typ ResultMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultMessageId_EncodeDecode(t *testing.T) {
	var typ ResultMessageId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultMessageId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultMessageOrBoolean_EncodeDecode(t *testing.T) {
	var typ ResultMessageOrBoolean
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultMessageOrBoolean
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultMessageOrBooleanResult_EncodeDecode(t *testing.T) {
	var typ ResultMessageOrBooleanResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultMessageOrBooleanResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultPoll_EncodeDecode(t *testing.T) {
	var typ ResultPoll
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultPoll
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultStickerSet_EncodeDecode(t *testing.T) {
	var typ ResultStickerSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultStickerSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultString_EncodeDecode(t *testing.T) {
	var typ ResultString
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultString
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultUser_EncodeDecode(t *testing.T) {
	var typ ResultUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultUserProfilePhotos_EncodeDecode(t *testing.T) {
	var typ ResultUserProfilePhotos
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultUserProfilePhotos
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResultWebhookInfo_EncodeDecode(t *testing.T) {
	var typ ResultWebhookInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResultWebhookInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRevokeChatInviteLink_EncodeDecode(t *testing.T) {
	var typ RevokeChatInviteLink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RevokeChatInviteLink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendAnimation_EncodeDecode(t *testing.T) {
	var typ SendAnimation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendAnimation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendAudio_EncodeDecode(t *testing.T) {
	var typ SendAudio
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendAudio
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendChatAction_EncodeDecode(t *testing.T) {
	var typ SendChatAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendChatAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendContact_EncodeDecode(t *testing.T) {
	var typ SendContact
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendContact
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendDice_EncodeDecode(t *testing.T) {
	var typ SendDice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendDice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendDocument_EncodeDecode(t *testing.T) {
	var typ SendDocument
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendDocument
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendGame_EncodeDecode(t *testing.T) {
	var typ SendGame
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendGame
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendInvoice_EncodeDecode(t *testing.T) {
	var typ SendInvoice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendInvoice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendLocation_EncodeDecode(t *testing.T) {
	var typ SendLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMediaGroup_EncodeDecode(t *testing.T) {
	var typ SendMediaGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMediaGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMediaGroupMediaItem_EncodeDecode(t *testing.T) {
	var typ SendMediaGroupMediaItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMediaGroupMediaItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMessage_EncodeDecode(t *testing.T) {
	var typ SendMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendPhoto_EncodeDecode(t *testing.T) {
	var typ SendPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendPoll_EncodeDecode(t *testing.T) {
	var typ SendPoll
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendPoll
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendReplyMarkup_EncodeDecode(t *testing.T) {
	var typ SendReplyMarkup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendReplyMarkup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendSticker_EncodeDecode(t *testing.T) {
	var typ SendSticker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendSticker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendVenue_EncodeDecode(t *testing.T) {
	var typ SendVenue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendVenue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendVideo_EncodeDecode(t *testing.T) {
	var typ SendVideo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendVideo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendVideoNote_EncodeDecode(t *testing.T) {
	var typ SendVideoNote
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendVideoNote
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendVoice_EncodeDecode(t *testing.T) {
	var typ SendVoice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendVoice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetChatAdministratorCustomTitle_EncodeDecode(t *testing.T) {
	var typ SetChatAdministratorCustomTitle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetChatAdministratorCustomTitle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetChatDescription_EncodeDecode(t *testing.T) {
	var typ SetChatDescription
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetChatDescription
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetChatPermissions_EncodeDecode(t *testing.T) {
	var typ SetChatPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetChatPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetChatPhoto_EncodeDecode(t *testing.T) {
	var typ SetChatPhoto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetChatPhoto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetChatStickerSet_EncodeDecode(t *testing.T) {
	var typ SetChatStickerSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetChatStickerSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetChatTitle_EncodeDecode(t *testing.T) {
	var typ SetChatTitle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetChatTitle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetGameScore_EncodeDecode(t *testing.T) {
	var typ SetGameScore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetGameScore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetMyCommands_EncodeDecode(t *testing.T) {
	var typ SetMyCommands
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetMyCommands
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetPassportDataErrors_EncodeDecode(t *testing.T) {
	var typ SetPassportDataErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetPassportDataErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetStickerPositionInSet_EncodeDecode(t *testing.T) {
	var typ SetStickerPositionInSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetStickerPositionInSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetStickerSetThumb_EncodeDecode(t *testing.T) {
	var typ SetStickerSetThumb
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetStickerSetThumb
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetWebhook_EncodeDecode(t *testing.T) {
	var typ SetWebhook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetWebhook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShippingAddress_EncodeDecode(t *testing.T) {
	var typ ShippingAddress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShippingAddress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShippingOption_EncodeDecode(t *testing.T) {
	var typ ShippingOption
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShippingOption
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShippingQuery_EncodeDecode(t *testing.T) {
	var typ ShippingQuery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShippingQuery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSticker_EncodeDecode(t *testing.T) {
	var typ Sticker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Sticker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStickerSet_EncodeDecode(t *testing.T) {
	var typ StickerSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StickerSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStopMessageLiveLocation_EncodeDecode(t *testing.T) {
	var typ StopMessageLiveLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StopMessageLiveLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStopPoll_EncodeDecode(t *testing.T) {
	var typ StopPoll
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StopPoll
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSuccessfulPayment_EncodeDecode(t *testing.T) {
	var typ SuccessfulPayment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SuccessfulPayment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnbanChatMember_EncodeDecode(t *testing.T) {
	var typ UnbanChatMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnbanChatMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnbanChatSenderChat_EncodeDecode(t *testing.T) {
	var typ UnbanChatSenderChat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnbanChatSenderChat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnpinAllChatMessages_EncodeDecode(t *testing.T) {
	var typ UnpinAllChatMessages
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnpinAllChatMessages
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnpinChatMessage_EncodeDecode(t *testing.T) {
	var typ UnpinChatMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnpinChatMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdate_EncodeDecode(t *testing.T) {
	var typ Update
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Update
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUploadStickerFile_EncodeDecode(t *testing.T) {
	var typ UploadStickerFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UploadStickerFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserProfilePhotos_EncodeDecode(t *testing.T) {
	var typ UserProfilePhotos
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserProfilePhotos
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVenue_EncodeDecode(t *testing.T) {
	var typ Venue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Venue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVideo_EncodeDecode(t *testing.T) {
	var typ Video
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Video
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVideoNote_EncodeDecode(t *testing.T) {
	var typ VideoNote
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VideoNote
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVoice_EncodeDecode(t *testing.T) {
	var typ Voice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Voice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVoiceChatEnded_EncodeDecode(t *testing.T) {
	var typ VoiceChatEnded
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VoiceChatEnded
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVoiceChatParticipantsInvited_EncodeDecode(t *testing.T) {
	var typ VoiceChatParticipantsInvited
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VoiceChatParticipantsInvited
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVoiceChatScheduled_EncodeDecode(t *testing.T) {
	var typ VoiceChatScheduled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VoiceChatScheduled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVoiceChatStarted_EncodeDecode(t *testing.T) {
	var typ VoiceChatStarted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VoiceChatStarted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWebhookInfo_EncodeDecode(t *testing.T) {
	var typ WebhookInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WebhookInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
