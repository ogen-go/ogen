// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode implements json.Marshaler.
func (s AddStickerToSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("name")
	e.Str(s.Name)
	if s.PNGSticker.Set {
		e.FieldStart("png_sticker")
		s.PNGSticker.Encode(e)
	}
	if s.TgsSticker.Set {
		e.FieldStart("tgs_sticker")
		s.TgsSticker.Encode(e)
	}

	e.FieldStart("emojis")
	e.Str(s.Emojis)
	if s.MaskPosition.Set {
		e.FieldStart("mask_position")
		s.MaskPosition.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AddStickerToSet from json.
func (s *AddStickerToSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AddStickerToSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "png_sticker":
			s.PNGSticker.Reset()
			if err := s.PNGSticker.Decode(d); err != nil {
				return err
			}
		case "tgs_sticker":
			s.TgsSticker.Reset()
			if err := s.TgsSticker.Decode(d); err != nil {
				return err
			}
		case "emojis":
			v, err := d.Str()
			s.Emojis = string(v)
			if err != nil {
				return err
			}
		case "mask_position":
			s.MaskPosition.Reset()
			if err := s.MaskPosition.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Animation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("width")
	e.Int(s.Width)

	e.FieldStart("height")
	e.Int(s.Height)

	e.FieldStart("duration")
	e.Int(s.Duration)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.FileName.Set {
		e.FieldStart("file_name")
		s.FileName.Encode(e)
	}
	if s.MimeType.Set {
		e.FieldStart("mime_type")
		s.MimeType.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Animation from json.
func (s *Animation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Animation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AnswerCallbackQuery) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("callback_query_id")
	e.Str(s.CallbackQueryID)
	if s.Text.Set {
		e.FieldStart("text")
		s.Text.Encode(e)
	}
	if s.ShowAlert.Set {
		e.FieldStart("show_alert")
		s.ShowAlert.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.CacheTime.Set {
		e.FieldStart("cache_time")
		s.CacheTime.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AnswerCallbackQuery from json.
func (s *AnswerCallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerCallbackQuery to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "callback_query_id":
			v, err := d.Str()
			s.CallbackQueryID = string(v)
			if err != nil {
				return err
			}
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "show_alert":
			s.ShowAlert.Reset()
			if err := s.ShowAlert.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "cache_time":
			s.CacheTime.Reset()
			if err := s.CacheTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AnswerInlineQuery) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("inline_query_id")
	e.Str(s.InlineQueryID)

	e.FieldStart("results")
	e.ArrStart()
	for _, elem := range s.Results {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.CacheTime.Set {
		e.FieldStart("cache_time")
		s.CacheTime.Encode(e)
	}
	if s.IsPersonal.Set {
		e.FieldStart("is_personal")
		s.IsPersonal.Encode(e)
	}
	if s.NextOffset.Set {
		e.FieldStart("next_offset")
		s.NextOffset.Encode(e)
	}
	if s.SwitchPmText.Set {
		e.FieldStart("switch_pm_text")
		s.SwitchPmText.Encode(e)
	}
	if s.SwitchPmParameter.Set {
		e.FieldStart("switch_pm_parameter")
		s.SwitchPmParameter.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AnswerInlineQuery from json.
func (s *AnswerInlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerInlineQuery to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_query_id":
			v, err := d.Str()
			s.InlineQueryID = string(v)
			if err != nil {
				return err
			}
		case "results":
			s.Results = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem InlineQueryResult
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					elem = InlineQueryResult(unwrapped)
				}
				s.Results = append(s.Results, elem)
				return nil
			}); err != nil {
				return err
			}
		case "cache_time":
			s.CacheTime.Reset()
			if err := s.CacheTime.Decode(d); err != nil {
				return err
			}
		case "is_personal":
			s.IsPersonal.Reset()
			if err := s.IsPersonal.Decode(d); err != nil {
				return err
			}
		case "next_offset":
			s.NextOffset.Reset()
			if err := s.NextOffset.Decode(d); err != nil {
				return err
			}
		case "switch_pm_text":
			s.SwitchPmText.Reset()
			if err := s.SwitchPmText.Decode(d); err != nil {
				return err
			}
		case "switch_pm_parameter":
			s.SwitchPmParameter.Reset()
			if err := s.SwitchPmParameter.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AnswerPreCheckoutQuery) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("pre_checkout_query_id")
	e.Str(s.PreCheckoutQueryID)

	e.FieldStart("ok")
	e.Bool(s.Ok)
	if s.ErrorMessage.Set {
		e.FieldStart("error_message")
		s.ErrorMessage.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AnswerPreCheckoutQuery from json.
func (s *AnswerPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerPreCheckoutQuery to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pre_checkout_query_id":
			v, err := d.Str()
			s.PreCheckoutQueryID = string(v)
			if err != nil {
				return err
			}
		case "ok":
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		case "error_message":
			s.ErrorMessage.Reset()
			if err := s.ErrorMessage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AnswerShippingQuery) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("shipping_query_id")
	e.Str(s.ShippingQueryID)

	e.FieldStart("ok")
	e.Bool(s.Ok)
	if s.ShippingOptions != nil {
		e.FieldStart("shipping_options")
		e.ArrStart()
		for _, elem := range s.ShippingOptions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.ErrorMessage.Set {
		e.FieldStart("error_message")
		s.ErrorMessage.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AnswerShippingQuery from json.
func (s *AnswerShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerShippingQuery to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shipping_query_id":
			v, err := d.Str()
			s.ShippingQueryID = string(v)
			if err != nil {
				return err
			}
		case "ok":
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		case "shipping_options":
			s.ShippingOptions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ShippingOption
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ShippingOptions = append(s.ShippingOptions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "error_message":
			s.ErrorMessage.Reset()
			if err := s.ErrorMessage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ApproveChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	e.ObjEnd()
}

// Decode decodes ApproveChatJoinRequest from json.
func (s *ApproveChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ApproveChatJoinRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Audio) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("duration")
	e.Int(s.Duration)
	if s.Performer.Set {
		e.FieldStart("performer")
		s.Performer.Encode(e)
	}
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.FileName.Set {
		e.FieldStart("file_name")
		s.FileName.Encode(e)
	}
	if s.MimeType.Set {
		e.FieldStart("mime_type")
		s.MimeType.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Audio from json.
func (s *Audio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Audio to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BanChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	if s.UntilDate.Set {
		e.FieldStart("until_date")
		s.UntilDate.Encode(e)
	}
	if s.RevokeMessages.Set {
		e.FieldStart("revoke_messages")
		s.RevokeMessages.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BanChatMember from json.
func (s *BanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BanChatMember to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "until_date":
			s.UntilDate.Reset()
			if err := s.UntilDate.Decode(d); err != nil {
				return err
			}
		case "revoke_messages":
			s.RevokeMessages.Reset()
			if err := s.RevokeMessages.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommand) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("command")
	e.Str(s.Command)

	e.FieldStart("description")
	e.Str(s.Description)
	e.ObjEnd()
}

// Decode decodes BotCommand from json.
func (s *BotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommand to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			v, err := d.Str()
			s.Command = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes BotCommandScope as json.
func (s BotCommandScope) Encode(e *jx.Encoder) {
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		s.BotCommandScopeDefault.Encode(e)
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		s.BotCommandScopeAllPrivateChats.Encode(e)
	case BotCommandScopeAllGroupChatsBotCommandScope:
		s.BotCommandScopeAllGroupChats.Encode(e)
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		s.BotCommandScopeAllChatAdministrators.Encode(e)
	case BotCommandScopeChatBotCommandScope:
		s.BotCommandScopeChat.Encode(e)
	case BotCommandScopeChatAdministratorsBotCommandScope:
		s.BotCommandScopeChatAdministrators.Encode(e)
	case BotCommandScopeChatMemberBotCommandScope:
		s.BotCommandScopeChatMember.Encode(e)
	}
}

// Decode decodes BotCommandScope from json.
func (s *BotCommandScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScope to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "all_chat_administrators":
					s.Type = BotCommandScopeAllChatAdministratorsBotCommandScope
					found = true
				case "all_group_chats":
					s.Type = BotCommandScopeAllGroupChatsBotCommandScope
					found = true
				case "all_private_chats":
					s.Type = BotCommandScopeAllPrivateChatsBotCommandScope
					found = true
				case "chat":
					s.Type = BotCommandScopeChatBotCommandScope
					found = true
				case "chat_administrators":
					s.Type = BotCommandScopeChatAdministratorsBotCommandScope
					found = true
				case "chat_member":
					s.Type = BotCommandScopeChatMemberBotCommandScope
					found = true
				case "default":
					s.Type = BotCommandScopeDefaultBotCommandScope
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		if err := s.BotCommandScopeDefault.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		if err := s.BotCommandScopeAllPrivateChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllGroupChatsBotCommandScope:
		if err := s.BotCommandScopeAllGroupChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeAllChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatBotCommandScope:
		if err := s.BotCommandScopeChat.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatMemberBotCommandScope:
		if err := s.BotCommandScopeChatMember.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeAllChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeAllChatAdministrators from json.
func (s *BotCommandScopeAllChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeAllChatAdministrators to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommandScopeAllGroupChats) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeAllGroupChats from json.
func (s *BotCommandScopeAllGroupChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeAllGroupChats to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommandScopeAllPrivateChats) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeAllPrivateChats from json.
func (s *BotCommandScopeAllPrivateChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeAllPrivateChats to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommandScopeChat) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeChat from json.
func (s *BotCommandScopeChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeChat to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommandScopeChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeChatAdministrators from json.
func (s *BotCommandScopeChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeChatAdministrators to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommandScopeChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeChatMember from json.
func (s *BotCommandScopeChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeChatMember to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BotCommandScopeDefault) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes BotCommandScopeDefault from json.
func (s *BotCommandScopeDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeDefault to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CallbackGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes CallbackGame from json.
func (s *CallbackGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CallbackGame to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Chat) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("type")
	e.Str(s.Type)
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.Username.Set {
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	if s.FirstName.Set {
		e.FieldStart("first_name")
		s.FirstName.Encode(e)
	}
	if s.LastName.Set {
		e.FieldStart("last_name")
		s.LastName.Encode(e)
	}
	if s.Photo.Set {
		e.FieldStart("photo")
		s.Photo.Encode(e)
	}
	if s.Bio.Set {
		e.FieldStart("bio")
		s.Bio.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.InviteLink.Set {
		e.FieldStart("invite_link")
		s.InviteLink.Encode(e)
	}
	if s.PinnedMessage != nil {
		e.FieldStart("pinned_message")
		s.PinnedMessage.Encode(e)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.SlowModeDelay.Set {
		e.FieldStart("slow_mode_delay")
		s.SlowModeDelay.Encode(e)
	}
	if s.MessageAutoDeleteTime.Set {
		e.FieldStart("message_auto_delete_time")
		s.MessageAutoDeleteTime.Encode(e)
	}
	if s.StickerSetName.Set {
		e.FieldStart("sticker_set_name")
		s.StickerSetName.Encode(e)
	}
	if s.CanSetStickerSet.Set {
		e.FieldStart("can_set_sticker_set")
		s.CanSetStickerSet.Encode(e)
	}
	if s.LinkedChatID.Set {
		e.FieldStart("linked_chat_id")
		s.LinkedChatID.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Chat from json.
func (s *Chat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Chat to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		case "first_name":
			s.FirstName.Reset()
			if err := s.FirstName.Decode(d); err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "photo":
			s.Photo.Reset()
			if err := s.Photo.Decode(d); err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			s.InviteLink.Reset()
			if err := s.InviteLink.Decode(d); err != nil {
				return err
			}
		case "pinned_message":
			s.PinnedMessage = nil
			var elem Message
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.PinnedMessage = &elem
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "slow_mode_delay":
			s.SlowModeDelay.Reset()
			if err := s.SlowModeDelay.Decode(d); err != nil {
				return err
			}
		case "message_auto_delete_time":
			s.MessageAutoDeleteTime.Reset()
			if err := s.MessageAutoDeleteTime.Decode(d); err != nil {
				return err
			}
		case "sticker_set_name":
			s.StickerSetName.Reset()
			if err := s.StickerSetName.Decode(d); err != nil {
				return err
			}
		case "can_set_sticker_set":
			s.CanSetStickerSet.Reset()
			if err := s.CanSetStickerSet.Decode(d); err != nil {
				return err
			}
		case "linked_chat_id":
			s.LinkedChatID.Reset()
			if err := s.LinkedChatID.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChatLocation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("location")
	s.Location.Encode(e)

	e.FieldStart("address")
	e.Str(s.Address)
	e.ObjEnd()
}

// Decode decodes ChatLocation from json.
func (s *ChatLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "address":
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChatPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.CanSendMessages.Set {
		e.FieldStart("can_send_messages")
		s.CanSendMessages.Encode(e)
	}
	if s.CanSendMediaMessages.Set {
		e.FieldStart("can_send_media_messages")
		s.CanSendMediaMessages.Encode(e)
	}
	if s.CanSendPolls.Set {
		e.FieldStart("can_send_polls")
		s.CanSendPolls.Encode(e)
	}
	if s.CanSendOtherMessages.Set {
		e.FieldStart("can_send_other_messages")
		s.CanSendOtherMessages.Encode(e)
	}
	if s.CanAddWebPagePreviews.Set {
		e.FieldStart("can_add_web_page_previews")
		s.CanAddWebPagePreviews.Encode(e)
	}
	if s.CanChangeInfo.Set {
		e.FieldStart("can_change_info")
		s.CanChangeInfo.Encode(e)
	}
	if s.CanInviteUsers.Set {
		e.FieldStart("can_invite_users")
		s.CanInviteUsers.Encode(e)
	}
	if s.CanPinMessages.Set {
		e.FieldStart("can_pin_messages")
		s.CanPinMessages.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ChatPermissions from json.
func (s *ChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_send_messages":
			s.CanSendMessages.Reset()
			if err := s.CanSendMessages.Decode(d); err != nil {
				return err
			}
		case "can_send_media_messages":
			s.CanSendMediaMessages.Reset()
			if err := s.CanSendMediaMessages.Decode(d); err != nil {
				return err
			}
		case "can_send_polls":
			s.CanSendPolls.Reset()
			if err := s.CanSendPolls.Decode(d); err != nil {
				return err
			}
		case "can_send_other_messages":
			s.CanSendOtherMessages.Reset()
			if err := s.CanSendOtherMessages.Decode(d); err != nil {
				return err
			}
		case "can_add_web_page_previews":
			s.CanAddWebPagePreviews.Reset()
			if err := s.CanAddWebPagePreviews.Decode(d); err != nil {
				return err
			}
		case "can_change_info":
			s.CanChangeInfo.Reset()
			if err := s.CanChangeInfo.Decode(d); err != nil {
				return err
			}
		case "can_invite_users":
			s.CanInviteUsers.Reset()
			if err := s.CanInviteUsers.Decode(d); err != nil {
				return err
			}
		case "can_pin_messages":
			s.CanPinMessages.Reset()
			if err := s.CanPinMessages.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("small_file_id")
	e.Str(s.SmallFileID)

	e.FieldStart("small_file_unique_id")
	e.Str(s.SmallFileUniqueID)

	e.FieldStart("big_file_id")
	e.Str(s.BigFileID)

	e.FieldStart("big_file_unique_id")
	e.Str(s.BigFileUniqueID)
	e.ObjEnd()
}

// Decode decodes ChatPhoto from json.
func (s *ChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatPhoto to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "small_file_id":
			v, err := d.Str()
			s.SmallFileID = string(v)
			if err != nil {
				return err
			}
		case "small_file_unique_id":
			v, err := d.Str()
			s.SmallFileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "big_file_id":
			v, err := d.Str()
			s.BigFileID = string(v)
			if err != nil {
				return err
			}
		case "big_file_unique_id":
			v, err := d.Str()
			s.BigFileUniqueID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Contact) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("phone_number")
	e.Str(s.PhoneNumber)

	e.FieldStart("first_name")
	e.Str(s.FirstName)
	if s.LastName.Set {
		e.FieldStart("last_name")
		s.LastName.Encode(e)
	}
	if s.UserID.Set {
		e.FieldStart("user_id")
		s.UserID.Encode(e)
	}
	if s.Vcard.Set {
		e.FieldStart("vcard")
		s.Vcard.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Contact from json.
func (s *Contact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Contact to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			v, err := d.Str()
			s.PhoneNumber = string(v)
			if err != nil {
				return err
			}
		case "first_name":
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "user_id":
			s.UserID.Reset()
			if err := s.UserID.Decode(d); err != nil {
				return err
			}
		case "vcard":
			s.Vcard.Reset()
			if err := s.Vcard.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CopyMessage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("from_chat_id")
	s.FromChatID.Encode(e)

	e.FieldStart("message_id")
	e.Int(s.MessageID)
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CopyMessage from json.
func (s *CopyMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CopyMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "from_chat_id":
			if err := s.FromChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem CopyMessageReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CopyMessageReplyMarkup as json.
func (s CopyMessageReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupCopyMessageReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupCopyMessageReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveCopyMessageReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplyCopyMessageReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes CopyMessageReplyMarkup from json.
func (s *CopyMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CopyMessageReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupCopyMessageReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupCopyMessageReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupCopyMessageReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupCopyMessageReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveCopyMessageReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplyCopyMessageReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplyCopyMessageReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplyCopyMessageReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupCopyMessageReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupCopyMessageReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveCopyMessageReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplyCopyMessageReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s CreateChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.ExpireDate.Set {
		e.FieldStart("expire_date")
		s.ExpireDate.Encode(e)
	}
	if s.MemberLimit.Set {
		e.FieldStart("member_limit")
		s.MemberLimit.Encode(e)
	}
	if s.CreatesJoinRequest.Set {
		e.FieldStart("creates_join_request")
		s.CreatesJoinRequest.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CreateChatInviteLink from json.
func (s *CreateChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreateChatInviteLink to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "expire_date":
			s.ExpireDate.Reset()
			if err := s.ExpireDate.Decode(d); err != nil {
				return err
			}
		case "member_limit":
			s.MemberLimit.Reset()
			if err := s.MemberLimit.Decode(d); err != nil {
				return err
			}
		case "creates_join_request":
			s.CreatesJoinRequest.Reset()
			if err := s.CreatesJoinRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CreateNewStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("title")
	e.Str(s.Title)
	if s.PNGSticker.Set {
		e.FieldStart("png_sticker")
		s.PNGSticker.Encode(e)
	}
	if s.TgsSticker.Set {
		e.FieldStart("tgs_sticker")
		s.TgsSticker.Encode(e)
	}

	e.FieldStart("emojis")
	e.Str(s.Emojis)
	if s.ContainsMasks.Set {
		e.FieldStart("contains_masks")
		s.ContainsMasks.Encode(e)
	}
	if s.MaskPosition.Set {
		e.FieldStart("mask_position")
		s.MaskPosition.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CreateNewStickerSet from json.
func (s *CreateNewStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreateNewStickerSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "png_sticker":
			s.PNGSticker.Reset()
			if err := s.PNGSticker.Decode(d); err != nil {
				return err
			}
		case "tgs_sticker":
			s.TgsSticker.Reset()
			if err := s.TgsSticker.Decode(d); err != nil {
				return err
			}
		case "emojis":
			v, err := d.Str()
			s.Emojis = string(v)
			if err != nil {
				return err
			}
		case "contains_masks":
			s.ContainsMasks.Reset()
			if err := s.ContainsMasks.Decode(d); err != nil {
				return err
			}
		case "mask_position":
			s.MaskPosition.Reset()
			if err := s.MaskPosition.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeclineChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	e.ObjEnd()
}

// Decode decodes DeclineChatJoinRequest from json.
func (s *DeclineChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeclineChatJoinRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeleteChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes DeleteChatPhoto from json.
func (s *DeleteChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteChatPhoto to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeleteChatStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes DeleteChatStickerSet from json.
func (s *DeleteChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteChatStickerSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeleteMessage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("message_id")
	e.Int(s.MessageID)
	e.ObjEnd()
}

// Decode decodes DeleteMessage from json.
func (s *DeleteMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeleteMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Scope != nil {
		e.FieldStart("scope")
		s.Scope.Encode(e)
	}
	if s.LanguageCode.Set {
		e.FieldStart("language_code")
		s.LanguageCode.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes DeleteMyCommands from json.
func (s *DeleteMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteMyCommands to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			s.Scope = nil
			var elem BotCommandScope
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Scope = &elem
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeleteStickerFromSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sticker")
	e.Str(s.Sticker)
	e.ObjEnd()
}

// Decode decodes DeleteStickerFromSet from json.
func (s *DeleteStickerFromSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteStickerFromSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			v, err := d.Str()
			s.Sticker = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeleteWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.DropPendingUpdates.Set {
		e.FieldStart("drop_pending_updates")
		s.DropPendingUpdates.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes DeleteWebhook from json.
func (s *DeleteWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteWebhook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drop_pending_updates":
			s.DropPendingUpdates.Reset()
			if err := s.DropPendingUpdates.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Dice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("emoji")
	e.Str(s.Emoji)

	e.FieldStart("value")
	e.Int(s.Value)
	e.ObjEnd()
}

// Decode decodes Dice from json.
func (s *Dice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Dice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emoji":
			v, err := d.Str()
			s.Emoji = string(v)
			if err != nil {
				return err
			}
		case "value":
			v, err := d.Int()
			s.Value = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Document) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.FileName.Set {
		e.FieldStart("file_name")
		s.FileName.Encode(e)
	}
	if s.MimeType.Set {
		e.FieldStart("mime_type")
		s.MimeType.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Document from json.
func (s *Document) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Document to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EditChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("invite_link")
	e.Str(s.InviteLink)
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.ExpireDate.Set {
		e.FieldStart("expire_date")
		s.ExpireDate.Encode(e)
	}
	if s.MemberLimit.Set {
		e.FieldStart("member_limit")
		s.MemberLimit.Encode(e)
	}
	if s.CreatesJoinRequest.Set {
		e.FieldStart("creates_join_request")
		s.CreatesJoinRequest.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EditChatInviteLink from json.
func (s *EditChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditChatInviteLink to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			v, err := d.Str()
			s.InviteLink = string(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "expire_date":
			s.ExpireDate.Reset()
			if err := s.ExpireDate.Decode(d); err != nil {
				return err
			}
		case "member_limit":
			s.MemberLimit.Reset()
			if err := s.MemberLimit.Decode(d); err != nil {
				return err
			}
		case "creates_join_request":
			s.CreatesJoinRequest.Reset()
			if err := s.CreatesJoinRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EditMessageCaption) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ChatID != nil {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EditMessageCaption from json.
func (s *EditMessageCaption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageCaption to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID = nil
			var elem ID
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ChatID = &elem
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EditMessageLiveLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ChatID != nil {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}

	e.FieldStart("latitude")
	e.Float64(s.Latitude)

	e.FieldStart("longitude")
	e.Float64(s.Longitude)
	if s.HorizontalAccuracy.Set {
		e.FieldStart("horizontal_accuracy")
		s.HorizontalAccuracy.Encode(e)
	}
	if s.Heading.Set {
		e.FieldStart("heading")
		s.Heading.Encode(e)
	}
	if s.ProximityAlertRadius.Set {
		e.FieldStart("proximity_alert_radius")
		s.ProximityAlertRadius.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EditMessageLiveLocation from json.
func (s *EditMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageLiveLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID = nil
			var elem ID
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ChatID = &elem
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "latitude":
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EditMessageMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ChatID != nil {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}

	e.FieldStart("media")
	s.Media.Encode(e)
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EditMessageMedia from json.
func (s *EditMessageMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageMedia to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID = nil
			var elem ID
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ChatID = &elem
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "media":
			if err := s.Media.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EditMessageReplyMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ChatID != nil {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EditMessageReplyMarkup from json.
func (s *EditMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageReplyMarkup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID = nil
			var elem ID
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ChatID = &elem
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EditMessageText) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ChatID != nil {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}

	e.FieldStart("text")
	e.Str(s.Text)
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.Entities != nil {
		e.FieldStart("entities")
		e.ArrStart()
		for _, elem := range s.Entities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableWebPagePreview.Set {
		e.FieldStart("disable_web_page_preview")
		s.DisableWebPagePreview.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EditMessageText from json.
func (s *EditMessageText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageText to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID = nil
			var elem ID
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ChatID = &elem
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_web_page_preview":
			s.DisableWebPagePreview.Reset()
			if err := s.DisableWebPagePreview.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EncryptedCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("data")
	e.Str(s.Data)

	e.FieldStart("hash")
	e.Str(s.Hash)

	e.FieldStart("secret")
	e.Str(s.Secret)
	e.ObjEnd()
}

// Decode decodes EncryptedCredentials from json.
func (s *EncryptedCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EncryptedCredentials to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			v, err := d.Str()
			s.Data = string(v)
			if err != nil {
				return err
			}
		case "hash":
			v, err := d.Str()
			s.Hash = string(v)
			if err != nil {
				return err
			}
		case "secret":
			v, err := d.Str()
			s.Secret = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EncryptedPassportElement) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)
	if s.Data.Set {
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	if s.PhoneNumber.Set {
		e.FieldStart("phone_number")
		s.PhoneNumber.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Files != nil {
		e.FieldStart("files")
		e.ArrStart()
		for _, elem := range s.Files {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.FrontSide.Set {
		e.FieldStart("front_side")
		s.FrontSide.Encode(e)
	}
	if s.ReverseSide.Set {
		e.FieldStart("reverse_side")
		s.ReverseSide.Encode(e)
	}
	if s.Selfie.Set {
		e.FieldStart("selfie")
		s.Selfie.Encode(e)
	}
	if s.Translation != nil {
		e.FieldStart("translation")
		e.ArrStart()
		for _, elem := range s.Translation {
			elem.Encode(e)
		}
		e.ArrEnd()
	}

	e.FieldStart("hash")
	e.Str(s.Hash)
	e.ObjEnd()
}

// Decode decodes EncryptedPassportElement from json.
func (s *EncryptedPassportElement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EncryptedPassportElement to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "data":
			s.Data.Reset()
			if err := s.Data.Decode(d); err != nil {
				return err
			}
		case "phone_number":
			s.PhoneNumber.Reset()
			if err := s.PhoneNumber.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PassportFile
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Files = append(s.Files, elem)
				return nil
			}); err != nil {
				return err
			}
		case "front_side":
			s.FrontSide.Reset()
			if err := s.FrontSide.Decode(d); err != nil {
				return err
			}
		case "reverse_side":
			s.ReverseSide.Reset()
			if err := s.ReverseSide.Decode(d); err != nil {
				return err
			}
		case "selfie":
			s.Selfie.Reset()
			if err := s.Selfie.Decode(d); err != nil {
				return err
			}
		case "translation":
			s.Translation = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PassportFile
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Translation = append(s.Translation, elem)
				return nil
			}); err != nil {
				return err
			}
		case "hash":
			v, err := d.Str()
			s.Hash = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ok")
	e.Bool(s.Ok)

	e.FieldStart("error_code")
	e.Int(s.ErrorCode)

	e.FieldStart("description")
	e.Str(s.Description)
	if s.Parameters.Set {
		e.FieldStart("parameters")
		s.Parameters.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Error to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		case "error_code":
			v, err := d.Int()
			s.ErrorCode = int(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "parameters":
			s.Parameters.Reset()
			if err := s.Parameters.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ErrorStatusCode) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ErrorStatusCode from json.
func (s *ErrorStatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ErrorStatusCode to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ExportChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes ExportChatInviteLink from json.
func (s *ExportChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ExportChatInviteLink to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ForceReply) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("force_reply")
	e.Bool(s.ForceReply)
	if s.InputFieldPlaceholder.Set {
		e.FieldStart("input_field_placeholder")
		s.InputFieldPlaceholder.Encode(e)
	}
	if s.Selective.Set {
		e.FieldStart("selective")
		s.Selective.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ForceReply from json.
func (s *ForceReply) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForceReply to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force_reply":
			v, err := d.Bool()
			s.ForceReply = bool(v)
			if err != nil {
				return err
			}
		case "input_field_placeholder":
			s.InputFieldPlaceholder.Reset()
			if err := s.InputFieldPlaceholder.Decode(d); err != nil {
				return err
			}
		case "selective":
			s.Selective.Reset()
			if err := s.Selective.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ForwardMessage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("from_chat_id")
	s.FromChatID.Encode(e)
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}

	e.FieldStart("message_id")
	e.Int(s.MessageID)
	e.ObjEnd()
}

// Decode decodes ForwardMessage from json.
func (s *ForwardMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForwardMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "from_chat_id":
			if err := s.FromChatID.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "message_id":
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Game) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("photo")
	e.ArrStart()
	for _, elem := range s.Photo {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Text.Set {
		e.FieldStart("text")
		s.Text.Encode(e)
	}
	if s.TextEntities != nil {
		e.FieldStart("text_entities")
		e.ArrStart()
		for _, elem := range s.TextEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Animation.Set {
		e.FieldStart("animation")
		s.Animation.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Game from json.
func (s *Game) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Game to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "photo":
			s.Photo = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PhotoSize
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Photo = append(s.Photo, elem)
				return nil
			}); err != nil {
				return err
			}
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "text_entities":
			s.TextEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TextEntities = append(s.TextEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "animation":
			s.Animation.Reset()
			if err := s.Animation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetChat) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes GetChat from json.
func (s *GetChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChat to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes GetChatAdministrators from json.
func (s *GetChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChatAdministrators to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	e.ObjEnd()
}

// Decode decodes GetChatMember from json.
func (s *GetChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChatMember to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetChatMemberCount) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes GetChatMemberCount from json.
func (s *GetChatMemberCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChatMemberCount to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)
	e.ObjEnd()
}

// Decode decodes GetFile from json.
func (s *GetFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetGameHighScores) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)
	if s.ChatID.Set {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GetGameHighScores from json.
func (s *GetGameHighScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetGameHighScores to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Scope != nil {
		e.FieldStart("scope")
		s.Scope.Encode(e)
	}
	if s.LanguageCode.Set {
		e.FieldStart("language_code")
		s.LanguageCode.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GetMyCommands from json.
func (s *GetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetMyCommands to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			s.Scope = nil
			var elem BotCommandScope
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Scope = &elem
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes GetStickerSet from json.
func (s *GetStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetStickerSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetUpdates) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Offset.Set {
		e.FieldStart("offset")
		s.Offset.Encode(e)
	}
	if s.Limit.Set {
		e.FieldStart("limit")
		s.Limit.Encode(e)
	}
	if s.Timeout.Set {
		e.FieldStart("timeout")
		s.Timeout.Encode(e)
	}
	if s.AllowedUpdates != nil {
		e.FieldStart("allowed_updates")
		e.ArrStart()
		for _, elem := range s.AllowedUpdates {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes GetUpdates from json.
func (s *GetUpdates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetUpdates to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			s.Offset.Reset()
			if err := s.Offset.Decode(d); err != nil {
				return err
			}
		case "limit":
			s.Limit.Reset()
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		case "timeout":
			s.Timeout.Reset()
			if err := s.Timeout.Decode(d); err != nil {
				return err
			}
		case "allowed_updates":
			s.AllowedUpdates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedUpdates = append(s.AllowedUpdates, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GetUserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)
	if s.Offset.Set {
		e.FieldStart("offset")
		s.Offset.Encode(e)
	}
	if s.Limit.Set {
		e.FieldStart("limit")
		s.Limit.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GetUserProfilePhotos from json.
func (s *GetUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetUserProfilePhotos to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "offset":
			s.Offset.Reset()
			if err := s.Offset.Decode(d); err != nil {
				return err
			}
		case "limit":
			s.Limit.Reset()
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ID as json.
func (s ID) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringID:
		e.Str(s.String)
	case IntID:
		e.Int(s.Int)
	}
}

// Decode decodes ID from json.
func (s *ID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringID
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s InlineKeyboardButton) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("text")
	e.Str(s.Text)
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.LoginURL.Set {
		e.FieldStart("login_url")
		s.LoginURL.Encode(e)
	}
	if s.CallbackData.Set {
		e.FieldStart("callback_data")
		s.CallbackData.Encode(e)
	}
	if s.SwitchInlineQuery.Set {
		e.FieldStart("switch_inline_query")
		s.SwitchInlineQuery.Encode(e)
	}
	if s.SwitchInlineQueryCurrentChat.Set {
		e.FieldStart("switch_inline_query_current_chat")
		s.SwitchInlineQueryCurrentChat.Encode(e)
	}
	if s.CallbackGame != nil {
		e.FieldStart("callback_game")
		s.CallbackGame.Encode(e)
	}
	if s.Pay.Set {
		e.FieldStart("pay")
		s.Pay.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes InlineKeyboardButton from json.
func (s *InlineKeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineKeyboardButton to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "login_url":
			s.LoginURL.Reset()
			if err := s.LoginURL.Decode(d); err != nil {
				return err
			}
		case "callback_data":
			s.CallbackData.Reset()
			if err := s.CallbackData.Decode(d); err != nil {
				return err
			}
		case "switch_inline_query":
			s.SwitchInlineQuery.Reset()
			if err := s.SwitchInlineQuery.Decode(d); err != nil {
				return err
			}
		case "switch_inline_query_current_chat":
			s.SwitchInlineQueryCurrentChat.Reset()
			if err := s.SwitchInlineQueryCurrentChat.Decode(d); err != nil {
				return err
			}
		case "callback_game":
			s.CallbackGame = nil
			var elem CallbackGame
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.CallbackGame = &elem
		case "pay":
			s.Pay.Reset()
			if err := s.Pay.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InlineKeyboardMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("inline_keyboard")
	e.ArrStart()
	for _, elem := range s.InlineKeyboard {
		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes InlineKeyboardMarkup from json.
func (s *InlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineKeyboardMarkup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_keyboard":
			s.InlineKeyboard = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []InlineKeyboardButton
				elem = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem InlineKeyboardButton
					if err := elemElem.Decode(d); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				s.InlineKeyboard = append(s.InlineKeyboard, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes InlineQueryResult as json.
func (s InlineQueryResult) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes InlineQueryResult from json.
func (s *InlineQueryResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResult to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = InlineQueryResult(unwrapped)
	return nil
}

// Encode encodes InputMedia as json.
func (s InputMedia) Encode(e *jx.Encoder) {
	switch s.Type {
	case InputMediaAnimationInputMedia:
		s.InputMediaAnimation.Encode(e)
	case InputMediaDocumentInputMedia:
		s.InputMediaDocument.Encode(e)
	case InputMediaAudioInputMedia:
		s.InputMediaAudio.Encode(e)
	case InputMediaPhotoInputMedia:
		s.InputMediaPhoto.Encode(e)
	case InputMediaVideoInputMedia:
		s.InputMediaVideo.Encode(e)
	}
}

// Decode decodes InputMedia from json.
func (s *InputMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMedia to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "animation":
					s.Type = InputMediaAnimationInputMedia
					found = true
				case "audio":
					s.Type = InputMediaAudioInputMedia
					found = true
				case "document":
					s.Type = InputMediaDocumentInputMedia
					found = true
				case "photo":
					s.Type = InputMediaPhotoInputMedia
					found = true
				case "video":
					s.Type = InputMediaVideoInputMedia
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAnimationInputMedia:
		if err := s.InputMediaAnimation.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentInputMedia:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaAudioInputMedia:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoInputMedia:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoInputMedia:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s InputMediaAnimation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("media")
	e.Str(s.Media)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Width.Set {
		e.FieldStart("width")
		s.Width.Encode(e)
	}
	if s.Height.Set {
		e.FieldStart("height")
		s.Height.Encode(e)
	}
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes InputMediaAnimation from json.
func (s *InputMediaAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaAnimation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InputMediaAudio) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("media")
	e.Str(s.Media)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.Performer.Set {
		e.FieldStart("performer")
		s.Performer.Encode(e)
	}
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes InputMediaAudio from json.
func (s *InputMediaAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaAudio to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InputMediaDocument) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("media")
	e.Str(s.Media)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableContentTypeDetection.Set {
		e.FieldStart("disable_content_type_detection")
		s.DisableContentTypeDetection.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes InputMediaDocument from json.
func (s *InputMediaDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaDocument to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_content_type_detection":
			s.DisableContentTypeDetection.Reset()
			if err := s.DisableContentTypeDetection.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InputMediaPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("media")
	e.Str(s.Media)
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes InputMediaPhoto from json.
func (s *InputMediaPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaPhoto to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InputMediaVideo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("media")
	e.Str(s.Media)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Width.Set {
		e.FieldStart("width")
		s.Width.Encode(e)
	}
	if s.Height.Set {
		e.FieldStart("height")
		s.Height.Encode(e)
	}
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.SupportsStreaming.Set {
		e.FieldStart("supports_streaming")
		s.SupportsStreaming.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes InputMediaVideo from json.
func (s *InputMediaVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaVideo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "supports_streaming":
			s.SupportsStreaming.Reset()
			if err := s.SupportsStreaming.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Invoice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("start_parameter")
	e.Str(s.StartParameter)

	e.FieldStart("currency")
	e.Str(s.Currency)

	e.FieldStart("total_amount")
	e.Int(s.TotalAmount)
	e.ObjEnd()
}

// Decode decodes Invoice from json.
func (s *Invoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Invoice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "start_parameter":
			v, err := d.Str()
			s.StartParameter = string(v)
			if err != nil {
				return err
			}
		case "currency":
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "total_amount":
			v, err := d.Int()
			s.TotalAmount = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s KeyboardButton) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("text")
	e.Str(s.Text)
	if s.RequestContact.Set {
		e.FieldStart("request_contact")
		s.RequestContact.Encode(e)
	}
	if s.RequestLocation.Set {
		e.FieldStart("request_location")
		s.RequestLocation.Encode(e)
	}
	if s.RequestPoll.Set {
		e.FieldStart("request_poll")
		s.RequestPoll.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes KeyboardButton from json.
func (s *KeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeyboardButton to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "request_contact":
			s.RequestContact.Reset()
			if err := s.RequestContact.Decode(d); err != nil {
				return err
			}
		case "request_location":
			s.RequestLocation.Reset()
			if err := s.RequestLocation.Decode(d); err != nil {
				return err
			}
		case "request_poll":
			s.RequestPoll.Reset()
			if err := s.RequestPoll.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s KeyboardButtonPollType) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes KeyboardButtonPollType from json.
func (s *KeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeyboardButtonPollType to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LabeledPrice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("label")
	e.Str(s.Label)

	e.FieldStart("amount")
	e.Int(s.Amount)
	e.ObjEnd()
}

// Decode decodes LabeledPrice from json.
func (s *LabeledPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LabeledPrice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "amount":
			v, err := d.Int()
			s.Amount = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LeaveChat) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes LeaveChat from json.
func (s *LeaveChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LeaveChat to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Location) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("longitude")
	e.Float64(s.Longitude)

	e.FieldStart("latitude")
	e.Float64(s.Latitude)
	if s.HorizontalAccuracy.Set {
		e.FieldStart("horizontal_accuracy")
		s.HorizontalAccuracy.Encode(e)
	}
	if s.LivePeriod.Set {
		e.FieldStart("live_period")
		s.LivePeriod.Encode(e)
	}
	if s.Heading.Set {
		e.FieldStart("heading")
		s.Heading.Encode(e)
	}
	if s.ProximityAlertRadius.Set {
		e.FieldStart("proximity_alert_radius")
		s.ProximityAlertRadius.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Location from json.
func (s *Location) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Location to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "longitude":
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "latitude":
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "live_period":
			s.LivePeriod.Reset()
			if err := s.LivePeriod.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LoginUrl) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.ForwardText.Set {
		e.FieldStart("forward_text")
		s.ForwardText.Encode(e)
	}
	if s.BotUsername.Set {
		e.FieldStart("bot_username")
		s.BotUsername.Encode(e)
	}
	if s.RequestWriteAccess.Set {
		e.FieldStart("request_write_access")
		s.RequestWriteAccess.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes LoginUrl from json.
func (s *LoginUrl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LoginUrl to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "forward_text":
			s.ForwardText.Reset()
			if err := s.ForwardText.Decode(d); err != nil {
				return err
			}
		case "bot_username":
			s.BotUsername.Reset()
			if err := s.BotUsername.Decode(d); err != nil {
				return err
			}
		case "request_write_access":
			s.RequestWriteAccess.Reset()
			if err := s.RequestWriteAccess.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MaskPosition) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("point")
	e.Str(s.Point)

	e.FieldStart("x_shift")
	e.Float64(s.XShift)

	e.FieldStart("y_shift")
	e.Float64(s.YShift)

	e.FieldStart("scale")
	e.Float64(s.Scale)
	e.ObjEnd()
}

// Decode decodes MaskPosition from json.
func (s *MaskPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MaskPosition to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "point":
			v, err := d.Str()
			s.Point = string(v)
			if err != nil {
				return err
			}
		case "x_shift":
			v, err := d.Float64()
			s.XShift = float64(v)
			if err != nil {
				return err
			}
		case "y_shift":
			v, err := d.Float64()
			s.YShift = float64(v)
			if err != nil {
				return err
			}
		case "scale":
			v, err := d.Float64()
			s.Scale = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Message) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message_id")
	e.Int(s.MessageID)
	if s.From.Set {
		e.FieldStart("from")
		s.From.Encode(e)
	}
	if s.SenderChat.Set {
		e.FieldStart("sender_chat")
		s.SenderChat.Encode(e)
	}

	e.FieldStart("date")
	e.Int(s.Date)

	e.FieldStart("chat")
	s.Chat.Encode(e)
	if s.ForwardFrom.Set {
		e.FieldStart("forward_from")
		s.ForwardFrom.Encode(e)
	}
	if s.ForwardFromChat.Set {
		e.FieldStart("forward_from_chat")
		s.ForwardFromChat.Encode(e)
	}
	if s.ForwardFromMessageID.Set {
		e.FieldStart("forward_from_message_id")
		s.ForwardFromMessageID.Encode(e)
	}
	if s.ForwardSignature.Set {
		e.FieldStart("forward_signature")
		s.ForwardSignature.Encode(e)
	}
	if s.ForwardSenderName.Set {
		e.FieldStart("forward_sender_name")
		s.ForwardSenderName.Encode(e)
	}
	if s.ForwardDate.Set {
		e.FieldStart("forward_date")
		s.ForwardDate.Encode(e)
	}
	if s.ReplyToMessage != nil {
		e.FieldStart("reply_to_message")
		s.ReplyToMessage.Encode(e)
	}
	if s.ViaBot.Set {
		e.FieldStart("via_bot")
		s.ViaBot.Encode(e)
	}
	if s.EditDate.Set {
		e.FieldStart("edit_date")
		s.EditDate.Encode(e)
	}
	if s.MediaGroupID.Set {
		e.FieldStart("media_group_id")
		s.MediaGroupID.Encode(e)
	}
	if s.AuthorSignature.Set {
		e.FieldStart("author_signature")
		s.AuthorSignature.Encode(e)
	}
	if s.Text.Set {
		e.FieldStart("text")
		s.Text.Encode(e)
	}
	if s.Entities != nil {
		e.FieldStart("entities")
		e.ArrStart()
		for _, elem := range s.Entities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Animation.Set {
		e.FieldStart("animation")
		s.Animation.Encode(e)
	}
	if s.Audio.Set {
		e.FieldStart("audio")
		s.Audio.Encode(e)
	}
	if s.Document.Set {
		e.FieldStart("document")
		s.Document.Encode(e)
	}
	if s.Photo != nil {
		e.FieldStart("photo")
		e.ArrStart()
		for _, elem := range s.Photo {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Sticker.Set {
		e.FieldStart("sticker")
		s.Sticker.Encode(e)
	}
	if s.Video.Set {
		e.FieldStart("video")
		s.Video.Encode(e)
	}
	if s.VideoNote.Set {
		e.FieldStart("video_note")
		s.VideoNote.Encode(e)
	}
	if s.Voice.Set {
		e.FieldStart("voice")
		s.Voice.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Contact.Set {
		e.FieldStart("contact")
		s.Contact.Encode(e)
	}
	if s.Dice.Set {
		e.FieldStart("dice")
		s.Dice.Encode(e)
	}
	if s.Game.Set {
		e.FieldStart("game")
		s.Game.Encode(e)
	}
	if s.Poll.Set {
		e.FieldStart("poll")
		s.Poll.Encode(e)
	}
	if s.Venue.Set {
		e.FieldStart("venue")
		s.Venue.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	if s.NewChatMembers != nil {
		e.FieldStart("new_chat_members")
		e.ArrStart()
		for _, elem := range s.NewChatMembers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.LeftChatMember.Set {
		e.FieldStart("left_chat_member")
		s.LeftChatMember.Encode(e)
	}
	if s.NewChatTitle.Set {
		e.FieldStart("new_chat_title")
		s.NewChatTitle.Encode(e)
	}
	if s.NewChatPhoto != nil {
		e.FieldStart("new_chat_photo")
		e.ArrStart()
		for _, elem := range s.NewChatPhoto {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DeleteChatPhoto.Set {
		e.FieldStart("delete_chat_photo")
		s.DeleteChatPhoto.Encode(e)
	}
	if s.GroupChatCreated.Set {
		e.FieldStart("group_chat_created")
		s.GroupChatCreated.Encode(e)
	}
	if s.SupergroupChatCreated.Set {
		e.FieldStart("supergroup_chat_created")
		s.SupergroupChatCreated.Encode(e)
	}
	if s.ChannelChatCreated.Set {
		e.FieldStart("channel_chat_created")
		s.ChannelChatCreated.Encode(e)
	}
	if s.MessageAutoDeleteTimerChanged.Set {
		e.FieldStart("message_auto_delete_timer_changed")
		s.MessageAutoDeleteTimerChanged.Encode(e)
	}
	if s.MigrateToChatID.Set {
		e.FieldStart("migrate_to_chat_id")
		s.MigrateToChatID.Encode(e)
	}
	if s.MigrateFromChatID.Set {
		e.FieldStart("migrate_from_chat_id")
		s.MigrateFromChatID.Encode(e)
	}
	if s.PinnedMessage != nil {
		e.FieldStart("pinned_message")
		s.PinnedMessage.Encode(e)
	}
	if s.Invoice.Set {
		e.FieldStart("invoice")
		s.Invoice.Encode(e)
	}
	if s.SuccessfulPayment.Set {
		e.FieldStart("successful_payment")
		s.SuccessfulPayment.Encode(e)
	}
	if s.ConnectedWebsite.Set {
		e.FieldStart("connected_website")
		s.ConnectedWebsite.Encode(e)
	}
	if s.PassportData.Set {
		e.FieldStart("passport_data")
		s.PassportData.Encode(e)
	}
	if s.ProximityAlertTriggered.Set {
		e.FieldStart("proximity_alert_triggered")
		s.ProximityAlertTriggered.Encode(e)
	}
	if s.VoiceChatScheduled.Set {
		e.FieldStart("voice_chat_scheduled")
		s.VoiceChatScheduled.Encode(e)
	}
	if s.VoiceChatStarted != nil {
		e.FieldStart("voice_chat_started")
		s.VoiceChatStarted.Encode(e)
	}
	if s.VoiceChatEnded.Set {
		e.FieldStart("voice_chat_ended")
		s.VoiceChatEnded.Encode(e)
	}
	if s.VoiceChatParticipantsInvited.Set {
		e.FieldStart("voice_chat_participants_invited")
		s.VoiceChatParticipantsInvited.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Message to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "from":
			s.From.Reset()
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "sender_chat":
			s.SenderChat.Reset()
			if err := s.SenderChat.Decode(d); err != nil {
				return err
			}
		case "date":
			v, err := d.Int()
			s.Date = int(v)
			if err != nil {
				return err
			}
		case "chat":
			if err := s.Chat.Decode(d); err != nil {
				return err
			}
		case "forward_from":
			s.ForwardFrom.Reset()
			if err := s.ForwardFrom.Decode(d); err != nil {
				return err
			}
		case "forward_from_chat":
			s.ForwardFromChat.Reset()
			if err := s.ForwardFromChat.Decode(d); err != nil {
				return err
			}
		case "forward_from_message_id":
			s.ForwardFromMessageID.Reset()
			if err := s.ForwardFromMessageID.Decode(d); err != nil {
				return err
			}
		case "forward_signature":
			s.ForwardSignature.Reset()
			if err := s.ForwardSignature.Decode(d); err != nil {
				return err
			}
		case "forward_sender_name":
			s.ForwardSenderName.Reset()
			if err := s.ForwardSenderName.Decode(d); err != nil {
				return err
			}
		case "forward_date":
			s.ForwardDate.Reset()
			if err := s.ForwardDate.Decode(d); err != nil {
				return err
			}
		case "reply_to_message":
			s.ReplyToMessage = nil
			var elem Message
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyToMessage = &elem
		case "via_bot":
			s.ViaBot.Reset()
			if err := s.ViaBot.Decode(d); err != nil {
				return err
			}
		case "edit_date":
			s.EditDate.Reset()
			if err := s.EditDate.Decode(d); err != nil {
				return err
			}
		case "media_group_id":
			s.MediaGroupID.Reset()
			if err := s.MediaGroupID.Decode(d); err != nil {
				return err
			}
		case "author_signature":
			s.AuthorSignature.Reset()
			if err := s.AuthorSignature.Decode(d); err != nil {
				return err
			}
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "animation":
			s.Animation.Reset()
			if err := s.Animation.Decode(d); err != nil {
				return err
			}
		case "audio":
			s.Audio.Reset()
			if err := s.Audio.Decode(d); err != nil {
				return err
			}
		case "document":
			s.Document.Reset()
			if err := s.Document.Decode(d); err != nil {
				return err
			}
		case "photo":
			s.Photo = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PhotoSize
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Photo = append(s.Photo, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sticker":
			s.Sticker.Reset()
			if err := s.Sticker.Decode(d); err != nil {
				return err
			}
		case "video":
			s.Video.Reset()
			if err := s.Video.Decode(d); err != nil {
				return err
			}
		case "video_note":
			s.VideoNote.Reset()
			if err := s.VideoNote.Decode(d); err != nil {
				return err
			}
		case "voice":
			s.Voice.Reset()
			if err := s.Voice.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "contact":
			s.Contact.Reset()
			if err := s.Contact.Decode(d); err != nil {
				return err
			}
		case "dice":
			s.Dice.Reset()
			if err := s.Dice.Decode(d); err != nil {
				return err
			}
		case "game":
			s.Game.Reset()
			if err := s.Game.Decode(d); err != nil {
				return err
			}
		case "poll":
			s.Poll.Reset()
			if err := s.Poll.Decode(d); err != nil {
				return err
			}
		case "venue":
			s.Venue.Reset()
			if err := s.Venue.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "new_chat_members":
			s.NewChatMembers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem User
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NewChatMembers = append(s.NewChatMembers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "left_chat_member":
			s.LeftChatMember.Reset()
			if err := s.LeftChatMember.Decode(d); err != nil {
				return err
			}
		case "new_chat_title":
			s.NewChatTitle.Reset()
			if err := s.NewChatTitle.Decode(d); err != nil {
				return err
			}
		case "new_chat_photo":
			s.NewChatPhoto = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PhotoSize
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NewChatPhoto = append(s.NewChatPhoto, elem)
				return nil
			}); err != nil {
				return err
			}
		case "delete_chat_photo":
			s.DeleteChatPhoto.Reset()
			if err := s.DeleteChatPhoto.Decode(d); err != nil {
				return err
			}
		case "group_chat_created":
			s.GroupChatCreated.Reset()
			if err := s.GroupChatCreated.Decode(d); err != nil {
				return err
			}
		case "supergroup_chat_created":
			s.SupergroupChatCreated.Reset()
			if err := s.SupergroupChatCreated.Decode(d); err != nil {
				return err
			}
		case "channel_chat_created":
			s.ChannelChatCreated.Reset()
			if err := s.ChannelChatCreated.Decode(d); err != nil {
				return err
			}
		case "message_auto_delete_timer_changed":
			s.MessageAutoDeleteTimerChanged.Reset()
			if err := s.MessageAutoDeleteTimerChanged.Decode(d); err != nil {
				return err
			}
		case "migrate_to_chat_id":
			s.MigrateToChatID.Reset()
			if err := s.MigrateToChatID.Decode(d); err != nil {
				return err
			}
		case "migrate_from_chat_id":
			s.MigrateFromChatID.Reset()
			if err := s.MigrateFromChatID.Decode(d); err != nil {
				return err
			}
		case "pinned_message":
			s.PinnedMessage = nil
			var elem Message
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.PinnedMessage = &elem
		case "invoice":
			s.Invoice.Reset()
			if err := s.Invoice.Decode(d); err != nil {
				return err
			}
		case "successful_payment":
			s.SuccessfulPayment.Reset()
			if err := s.SuccessfulPayment.Decode(d); err != nil {
				return err
			}
		case "connected_website":
			s.ConnectedWebsite.Reset()
			if err := s.ConnectedWebsite.Decode(d); err != nil {
				return err
			}
		case "passport_data":
			s.PassportData.Reset()
			if err := s.PassportData.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_triggered":
			s.ProximityAlertTriggered.Reset()
			if err := s.ProximityAlertTriggered.Decode(d); err != nil {
				return err
			}
		case "voice_chat_scheduled":
			s.VoiceChatScheduled.Reset()
			if err := s.VoiceChatScheduled.Decode(d); err != nil {
				return err
			}
		case "voice_chat_started":
			s.VoiceChatStarted = nil
			var elem VoiceChatStarted
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.VoiceChatStarted = &elem
		case "voice_chat_ended":
			s.VoiceChatEnded.Reset()
			if err := s.VoiceChatEnded.Decode(d); err != nil {
				return err
			}
		case "voice_chat_participants_invited":
			s.VoiceChatParticipantsInvited.Reset()
			if err := s.VoiceChatParticipantsInvited.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MessageAutoDeleteTimerChanged) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message_auto_delete_time")
	e.Int(s.MessageAutoDeleteTime)
	e.ObjEnd()
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (s *MessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MessageAutoDeleteTimerChanged to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_auto_delete_time":
			v, err := d.Int()
			s.MessageAutoDeleteTime = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MessageEntity) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("offset")
	e.Int(s.Offset)

	e.FieldStart("length")
	e.Int(s.Length)
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	if s.Language.Set {
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MessageEntity from json.
func (s *MessageEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MessageEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "offset":
			v, err := d.Int()
			s.Offset = int(v)
			if err != nil {
				return err
			}
		case "length":
			v, err := d.Int()
			s.Length = int(v)
			if err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes Animation as json.
func (o OptAnimation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Animation from json.
func (o *OptAnimation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAnimation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAnimation`, d.Next())
	}
}

// Encode encodes Audio as json.
func (o OptAudio) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Audio from json.
func (o *OptAudio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAudio to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAudio`, d.Next())
	}
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBool`, d.Next())
	}
}

// Encode encodes Chat as json.
func (o OptChat) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Chat from json.
func (o *OptChat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChat to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChat`, d.Next())
	}
}

// Encode encodes ChatLocation as json.
func (o OptChatLocation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ChatLocation from json.
func (o *OptChatLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatLocation`, d.Next())
	}
}

// Encode encodes ChatPermissions as json.
func (o OptChatPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ChatPermissions from json.
func (o *OptChatPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatPermissions`, d.Next())
	}
}

// Encode encodes ChatPhoto as json.
func (o OptChatPhoto) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ChatPhoto from json.
func (o *OptChatPhoto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatPhoto to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatPhoto`, d.Next())
	}
}

// Encode encodes Contact as json.
func (o OptContact) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Contact from json.
func (o *OptContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptContact to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptContact`, d.Next())
	}
}

// Encode encodes Dice as json.
func (o OptDice) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Dice from json.
func (o *OptDice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDice to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDice`, d.Next())
	}
}

// Encode encodes Document as json.
func (o OptDocument) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Document from json.
func (o *OptDocument) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDocument to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDocument`, d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFloat64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFloat64`, d.Next())
	}
}

// Encode encodes Game as json.
func (o OptGame) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Game from json.
func (o *OptGame) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGame to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGame`, d.Next())
	}
}

// Encode encodes InlineKeyboardMarkup as json.
func (o OptInlineKeyboardMarkup) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes InlineKeyboardMarkup from json.
func (o *OptInlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInlineKeyboardMarkup to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInlineKeyboardMarkup`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt`, d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt64`, d.Next())
	}
}

// Encode encodes Invoice as json.
func (o OptInvoice) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Invoice from json.
func (o *OptInvoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInvoice to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInvoice`, d.Next())
	}
}

// Encode encodes KeyboardButtonPollType as json.
func (o OptKeyboardButtonPollType) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes KeyboardButtonPollType from json.
func (o *OptKeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptKeyboardButtonPollType to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptKeyboardButtonPollType`, d.Next())
	}
}

// Encode encodes Location as json.
func (o OptLocation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Location from json.
func (o *OptLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptLocation`, d.Next())
	}
}

// Encode encodes LoginUrl as json.
func (o OptLoginUrl) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes LoginUrl from json.
func (o *OptLoginUrl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptLoginUrl to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptLoginUrl`, d.Next())
	}
}

// Encode encodes MaskPosition as json.
func (o OptMaskPosition) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes MaskPosition from json.
func (o *OptMaskPosition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMaskPosition to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMaskPosition`, d.Next())
	}
}

// Encode encodes Message as json.
func (o OptMessage) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Message from json.
func (o *OptMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMessage to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMessage`, d.Next())
	}
}

// Encode encodes MessageAutoDeleteTimerChanged as json.
func (o OptMessageAutoDeleteTimerChanged) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (o *OptMessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMessageAutoDeleteTimerChanged to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMessageAutoDeleteTimerChanged`, d.Next())
	}
}

// Encode encodes OrderInfo as json.
func (o OptOrderInfo) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes OrderInfo from json.
func (o *OptOrderInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrderInfo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrderInfo`, d.Next())
	}
}

// Encode encodes PassportData as json.
func (o OptPassportData) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PassportData from json.
func (o *OptPassportData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPassportData to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPassportData`, d.Next())
	}
}

// Encode encodes PassportFile as json.
func (o OptPassportFile) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PassportFile from json.
func (o *OptPassportFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPassportFile to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPassportFile`, d.Next())
	}
}

// Encode encodes PhotoSize as json.
func (o OptPhotoSize) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PhotoSize from json.
func (o *OptPhotoSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPhotoSize to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPhotoSize`, d.Next())
	}
}

// Encode encodes Poll as json.
func (o OptPoll) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Poll from json.
func (o *OptPoll) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPoll to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPoll`, d.Next())
	}
}

// Encode encodes ProximityAlertTriggered as json.
func (o OptProximityAlertTriggered) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProximityAlertTriggered from json.
func (o *OptProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProximityAlertTriggered to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProximityAlertTriggered`, d.Next())
	}
}

// Encode encodes Response as json.
func (o OptResponse) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Response from json.
func (o *OptResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptResponse to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptResponse`, d.Next())
	}
}

// Encode encodes ShippingAddress as json.
func (o OptShippingAddress) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ShippingAddress from json.
func (o *OptShippingAddress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptShippingAddress to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptShippingAddress`, d.Next())
	}
}

// Encode encodes Sticker as json.
func (o OptSticker) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Sticker from json.
func (o *OptSticker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSticker to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSticker`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptString`, d.Next())
	}
}

// Encode encodes SuccessfulPayment as json.
func (o OptSuccessfulPayment) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes SuccessfulPayment from json.
func (o *OptSuccessfulPayment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSuccessfulPayment to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSuccessfulPayment`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptURL) Encode(e *jx.Encoder) {
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptURL`, d.Next())
	}
}

// Encode encodes User as json.
func (o OptUser) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes User from json.
func (o *OptUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUser`, d.Next())
	}
}

// Encode encodes Venue as json.
func (o OptVenue) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Venue from json.
func (o *OptVenue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVenue to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVenue`, d.Next())
	}
}

// Encode encodes Video as json.
func (o OptVideo) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Video from json.
func (o *OptVideo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVideo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVideo`, d.Next())
	}
}

// Encode encodes VideoNote as json.
func (o OptVideoNote) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes VideoNote from json.
func (o *OptVideoNote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVideoNote to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVideoNote`, d.Next())
	}
}

// Encode encodes Voice as json.
func (o OptVoice) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Voice from json.
func (o *OptVoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoice to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoice`, d.Next())
	}
}

// Encode encodes VoiceChatEnded as json.
func (o OptVoiceChatEnded) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes VoiceChatEnded from json.
func (o *OptVoiceChatEnded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoiceChatEnded to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoiceChatEnded`, d.Next())
	}
}

// Encode encodes VoiceChatParticipantsInvited as json.
func (o OptVoiceChatParticipantsInvited) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes VoiceChatParticipantsInvited from json.
func (o *OptVoiceChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoiceChatParticipantsInvited to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoiceChatParticipantsInvited`, d.Next())
	}
}

// Encode encodes VoiceChatScheduled as json.
func (o OptVoiceChatScheduled) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes VoiceChatScheduled from json.
func (o *OptVoiceChatScheduled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoiceChatScheduled to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoiceChatScheduled`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s OrderInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.PhoneNumber.Set {
		e.FieldStart("phone_number")
		s.PhoneNumber.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.ShippingAddress.Set {
		e.FieldStart("shipping_address")
		s.ShippingAddress.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrderInfo from json.
func (s *OrderInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrderInfo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "phone_number":
			s.PhoneNumber.Reset()
			if err := s.PhoneNumber.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "shipping_address":
			s.ShippingAddress.Reset()
			if err := s.ShippingAddress.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportData) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("data")
	e.ArrStart()
	for _, elem := range s.Data {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("credentials")
	s.Credentials.Encode(e)
	e.ObjEnd()
}

// Decode decodes PassportData from json.
func (s *PassportData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportData to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			s.Data = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EncryptedPassportElement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = append(s.Data, elem)
				return nil
			}); err != nil {
				return err
			}
		case "credentials":
			if err := s.Credentials.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PassportElementError as json.
func (s PassportElementError) Encode(e *jx.Encoder) {
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		s.PassportElementErrorDataField.Encode(e)
	case PassportElementErrorFrontSidePassportElementError:
		s.PassportElementErrorFrontSide.Encode(e)
	case PassportElementErrorReverseSidePassportElementError:
		s.PassportElementErrorReverseSide.Encode(e)
	case PassportElementErrorSelfiePassportElementError:
		s.PassportElementErrorSelfie.Encode(e)
	case PassportElementErrorFilePassportElementError:
		s.PassportElementErrorFile.Encode(e)
	case PassportElementErrorFilesPassportElementError:
		s.PassportElementErrorFiles.Encode(e)
	case PassportElementErrorTranslationFilePassportElementError:
		s.PassportElementErrorTranslationFile.Encode(e)
	case PassportElementErrorTranslationFilesPassportElementError:
		s.PassportElementErrorTranslationFiles.Encode(e)
	case PassportElementErrorUnspecifiedPassportElementError:
		s.PassportElementErrorUnspecified.Encode(e)
	}
}

// Decode decodes PassportElementError from json.
func (s *PassportElementError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementError to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "source":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "data":
					s.Type = PassportElementErrorDataFieldPassportElementError
					found = true
				case "file":
					s.Type = PassportElementErrorFilePassportElementError
					found = true
				case "files":
					s.Type = PassportElementErrorFilesPassportElementError
					found = true
				case "front_side":
					s.Type = PassportElementErrorFrontSidePassportElementError
					found = true
				case "reverse_side":
					s.Type = PassportElementErrorReverseSidePassportElementError
					found = true
				case "selfie":
					s.Type = PassportElementErrorSelfiePassportElementError
					found = true
				case "translation_file":
					s.Type = PassportElementErrorTranslationFilePassportElementError
					found = true
				case "translation_files":
					s.Type = PassportElementErrorTranslationFilesPassportElementError
					found = true
				case "unspecified":
					s.Type = PassportElementErrorUnspecifiedPassportElementError
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		if err := s.PassportElementErrorDataField.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFrontSidePassportElementError:
		if err := s.PassportElementErrorFrontSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorReverseSidePassportElementError:
		if err := s.PassportElementErrorReverseSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorSelfiePassportElementError:
		if err := s.PassportElementErrorSelfie.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilePassportElementError:
		if err := s.PassportElementErrorFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilesPassportElementError:
		if err := s.PassportElementErrorFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilePassportElementError:
		if err := s.PassportElementErrorTranslationFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilesPassportElementError:
		if err := s.PassportElementErrorTranslationFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorUnspecifiedPassportElementError:
		if err := s.PassportElementErrorUnspecified.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorDataField) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("field_name")
	e.Str(s.FieldName)

	e.FieldStart("data_hash")
	e.Str(s.DataHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorDataField from json.
func (s *PassportElementErrorDataField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorDataField to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "field_name":
			v, err := d.Str()
			s.FieldName = string(v)
			if err != nil {
				return err
			}
		case "data_hash":
			v, err := d.Str()
			s.DataHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hash")
	e.Str(s.FileHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorFile from json.
func (s *PassportElementErrorFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hash":
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorFiles) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hashes")
	e.ArrStart()
	for _, elem := range s.FileHashes {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorFiles from json.
func (s *PassportElementErrorFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hashes":
			s.FileHashes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.FileHashes = append(s.FileHashes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorFrontSide) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hash")
	e.Str(s.FileHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorFrontSide from json.
func (s *PassportElementErrorFrontSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFrontSide to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hash":
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorReverseSide) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hash")
	e.Str(s.FileHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorReverseSide from json.
func (s *PassportElementErrorReverseSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorReverseSide to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hash":
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorSelfie) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hash")
	e.Str(s.FileHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorSelfie from json.
func (s *PassportElementErrorSelfie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorSelfie to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hash":
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorTranslationFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hash")
	e.Str(s.FileHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorTranslationFile from json.
func (s *PassportElementErrorTranslationFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorTranslationFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hash":
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorTranslationFiles) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("file_hashes")
	e.ArrStart()
	for _, elem := range s.FileHashes {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorTranslationFiles from json.
func (s *PassportElementErrorTranslationFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorTranslationFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "file_hashes":
			s.FileHashes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.FileHashes = append(s.FileHashes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportElementErrorUnspecified) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	e.Str(s.Source)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("element_hash")
	e.Str(s.ElementHash)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PassportElementErrorUnspecified from json.
func (s *PassportElementErrorUnspecified) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorUnspecified to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "element_hash":
			v, err := d.Str()
			s.ElementHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PassportFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("file_size")
	e.Int(s.FileSize)

	e.FieldStart("file_date")
	e.Int(s.FileDate)
	e.ObjEnd()
}

// Decode decodes PassportFile from json.
func (s *PassportFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "file_size":
			v, err := d.Int()
			s.FileSize = int(v)
			if err != nil {
				return err
			}
		case "file_date":
			v, err := d.Int()
			s.FileDate = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PhotoSize) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("width")
	e.Int(s.Width)

	e.FieldStart("height")
	e.Int(s.Height)
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PhotoSize from json.
func (s *PhotoSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PhotoSize to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PinChatMessage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("message_id")
	e.Int(s.MessageID)
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PinChatMessage from json.
func (s *PinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PinChatMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Poll) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("question")
	e.Str(s.Question)

	e.FieldStart("options")
	e.ArrStart()
	for _, elem := range s.Options {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("total_voter_count")
	e.Int(s.TotalVoterCount)

	e.FieldStart("is_closed")
	e.Bool(s.IsClosed)

	e.FieldStart("is_anonymous")
	e.Bool(s.IsAnonymous)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("allows_multiple_answers")
	e.Bool(s.AllowsMultipleAnswers)
	if s.CorrectOptionID.Set {
		e.FieldStart("correct_option_id")
		s.CorrectOptionID.Encode(e)
	}
	if s.Explanation.Set {
		e.FieldStart("explanation")
		s.Explanation.Encode(e)
	}
	if s.ExplanationEntities != nil {
		e.FieldStart("explanation_entities")
		e.ArrStart()
		for _, elem := range s.ExplanationEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.OpenPeriod.Set {
		e.FieldStart("open_period")
		s.OpenPeriod.Encode(e)
	}
	if s.CloseDate.Set {
		e.FieldStart("close_date")
		s.CloseDate.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Poll from json.
func (s *Poll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Poll to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "question":
			v, err := d.Str()
			s.Question = string(v)
			if err != nil {
				return err
			}
		case "options":
			s.Options = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PollOption
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Options = append(s.Options, elem)
				return nil
			}); err != nil {
				return err
			}
		case "total_voter_count":
			v, err := d.Int()
			s.TotalVoterCount = int(v)
			if err != nil {
				return err
			}
		case "is_closed":
			v, err := d.Bool()
			s.IsClosed = bool(v)
			if err != nil {
				return err
			}
		case "is_anonymous":
			v, err := d.Bool()
			s.IsAnonymous = bool(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "allows_multiple_answers":
			v, err := d.Bool()
			s.AllowsMultipleAnswers = bool(v)
			if err != nil {
				return err
			}
		case "correct_option_id":
			s.CorrectOptionID.Reset()
			if err := s.CorrectOptionID.Decode(d); err != nil {
				return err
			}
		case "explanation":
			s.Explanation.Reset()
			if err := s.Explanation.Decode(d); err != nil {
				return err
			}
		case "explanation_entities":
			s.ExplanationEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ExplanationEntities = append(s.ExplanationEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "open_period":
			s.OpenPeriod.Reset()
			if err := s.OpenPeriod.Decode(d); err != nil {
				return err
			}
		case "close_date":
			s.CloseDate.Reset()
			if err := s.CloseDate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PollOption) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("text")
	e.Str(s.Text)

	e.FieldStart("voter_count")
	e.Int(s.VoterCount)
	e.ObjEnd()
}

// Decode decodes PollOption from json.
func (s *PollOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PollOption to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "voter_count":
			v, err := d.Int()
			s.VoterCount = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PromoteChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	if s.IsAnonymous.Set {
		e.FieldStart("is_anonymous")
		s.IsAnonymous.Encode(e)
	}
	if s.CanManageChat.Set {
		e.FieldStart("can_manage_chat")
		s.CanManageChat.Encode(e)
	}
	if s.CanPostMessages.Set {
		e.FieldStart("can_post_messages")
		s.CanPostMessages.Encode(e)
	}
	if s.CanEditMessages.Set {
		e.FieldStart("can_edit_messages")
		s.CanEditMessages.Encode(e)
	}
	if s.CanDeleteMessages.Set {
		e.FieldStart("can_delete_messages")
		s.CanDeleteMessages.Encode(e)
	}
	if s.CanManageVoiceChats.Set {
		e.FieldStart("can_manage_voice_chats")
		s.CanManageVoiceChats.Encode(e)
	}
	if s.CanRestrictMembers.Set {
		e.FieldStart("can_restrict_members")
		s.CanRestrictMembers.Encode(e)
	}
	if s.CanPromoteMembers.Set {
		e.FieldStart("can_promote_members")
		s.CanPromoteMembers.Encode(e)
	}
	if s.CanChangeInfo.Set {
		e.FieldStart("can_change_info")
		s.CanChangeInfo.Encode(e)
	}
	if s.CanInviteUsers.Set {
		e.FieldStart("can_invite_users")
		s.CanInviteUsers.Encode(e)
	}
	if s.CanPinMessages.Set {
		e.FieldStart("can_pin_messages")
		s.CanPinMessages.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PromoteChatMember from json.
func (s *PromoteChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PromoteChatMember to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "is_anonymous":
			s.IsAnonymous.Reset()
			if err := s.IsAnonymous.Decode(d); err != nil {
				return err
			}
		case "can_manage_chat":
			s.CanManageChat.Reset()
			if err := s.CanManageChat.Decode(d); err != nil {
				return err
			}
		case "can_post_messages":
			s.CanPostMessages.Reset()
			if err := s.CanPostMessages.Decode(d); err != nil {
				return err
			}
		case "can_edit_messages":
			s.CanEditMessages.Reset()
			if err := s.CanEditMessages.Decode(d); err != nil {
				return err
			}
		case "can_delete_messages":
			s.CanDeleteMessages.Reset()
			if err := s.CanDeleteMessages.Decode(d); err != nil {
				return err
			}
		case "can_manage_voice_chats":
			s.CanManageVoiceChats.Reset()
			if err := s.CanManageVoiceChats.Decode(d); err != nil {
				return err
			}
		case "can_restrict_members":
			s.CanRestrictMembers.Reset()
			if err := s.CanRestrictMembers.Decode(d); err != nil {
				return err
			}
		case "can_promote_members":
			s.CanPromoteMembers.Reset()
			if err := s.CanPromoteMembers.Decode(d); err != nil {
				return err
			}
		case "can_change_info":
			s.CanChangeInfo.Reset()
			if err := s.CanChangeInfo.Decode(d); err != nil {
				return err
			}
		case "can_invite_users":
			s.CanInviteUsers.Reset()
			if err := s.CanInviteUsers.Decode(d); err != nil {
				return err
			}
		case "can_pin_messages":
			s.CanPinMessages.Reset()
			if err := s.CanPinMessages.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProximityAlertTriggered) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("traveler")
	s.Traveler.Encode(e)

	e.FieldStart("watcher")
	s.Watcher.Encode(e)

	e.FieldStart("distance")
	e.Int(s.Distance)
	e.ObjEnd()
}

// Decode decodes ProximityAlertTriggered from json.
func (s *ProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProximityAlertTriggered to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "traveler":
			if err := s.Traveler.Decode(d); err != nil {
				return err
			}
		case "watcher":
			if err := s.Watcher.Decode(d); err != nil {
				return err
			}
		case "distance":
			v, err := d.Int()
			s.Distance = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReplyKeyboardMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("keyboard")
	e.ArrStart()
	for _, elem := range s.Keyboard {
		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ArrEnd()
	if s.ResizeKeyboard.Set {
		e.FieldStart("resize_keyboard")
		s.ResizeKeyboard.Encode(e)
	}
	if s.OneTimeKeyboard.Set {
		e.FieldStart("one_time_keyboard")
		s.OneTimeKeyboard.Encode(e)
	}
	if s.InputFieldPlaceholder.Set {
		e.FieldStart("input_field_placeholder")
		s.InputFieldPlaceholder.Encode(e)
	}
	if s.Selective.Set {
		e.FieldStart("selective")
		s.Selective.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReplyKeyboardMarkup from json.
func (s *ReplyKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReplyKeyboardMarkup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyboard":
			s.Keyboard = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []KeyboardButton
				elem = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem KeyboardButton
					if err := elemElem.Decode(d); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				s.Keyboard = append(s.Keyboard, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resize_keyboard":
			s.ResizeKeyboard.Reset()
			if err := s.ResizeKeyboard.Decode(d); err != nil {
				return err
			}
		case "one_time_keyboard":
			s.OneTimeKeyboard.Reset()
			if err := s.OneTimeKeyboard.Decode(d); err != nil {
				return err
			}
		case "input_field_placeholder":
			s.InputFieldPlaceholder.Reset()
			if err := s.InputFieldPlaceholder.Decode(d); err != nil {
				return err
			}
		case "selective":
			s.Selective.Reset()
			if err := s.Selective.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReplyKeyboardRemove) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("remove_keyboard")
	e.Bool(s.RemoveKeyboard)
	if s.Selective.Set {
		e.FieldStart("selective")
		s.Selective.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReplyKeyboardRemove from json.
func (s *ReplyKeyboardRemove) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReplyKeyboardRemove to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remove_keyboard":
			v, err := d.Bool()
			s.RemoveKeyboard = bool(v)
			if err != nil {
				return err
			}
		case "selective":
			s.Selective.Reset()
			if err := s.Selective.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Response) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.MigrateToChatID.Set {
		e.FieldStart("migrate_to_chat_id")
		s.MigrateToChatID.Encode(e)
	}
	if s.RetryAfter.Set {
		e.FieldStart("retry_after")
		s.RetryAfter.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Response from json.
func (s *Response) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Response to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "migrate_to_chat_id":
			s.MigrateToChatID.Reset()
			if err := s.MigrateToChatID.Decode(d); err != nil {
				return err
			}
		case "retry_after":
			s.RetryAfter.Reset()
			if err := s.RetryAfter.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RestrictChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("permissions")
	s.Permissions.Encode(e)
	if s.UntilDate.Set {
		e.FieldStart("until_date")
		s.UntilDate.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RestrictChatMember from json.
func (s *RestrictChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RestrictChatMember to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "until_date":
			s.UntilDate.Reset()
			if err := s.UntilDate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Result) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Result.Set {
		e.FieldStart("result")
		s.Result.Encode(e)
	}

	e.FieldStart("ok")
	e.Bool(s.Ok)
	e.ObjEnd()
}

// Decode decodes Result from json.
func (s *Result) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Result to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ResultMsg) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Result.Set {
		e.FieldStart("result")
		s.Result.Encode(e)
	}

	e.FieldStart("ok")
	e.Bool(s.Ok)
	e.ObjEnd()
}

// Decode decodes ResultMsg from json.
func (s *ResultMsg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultMsg to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ResultUsr) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Result.Set {
		e.FieldStart("result")
		s.Result.Encode(e)
	}

	e.FieldStart("ok")
	e.Bool(s.Ok)
	e.ObjEnd()
}

// Decode decodes ResultUsr from json.
func (s *ResultUsr) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultUsr to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RevokeChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("invite_link")
	e.Str(s.InviteLink)
	e.ObjEnd()
}

// Decode decodes RevokeChatInviteLink from json.
func (s *RevokeChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RevokeChatInviteLink to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			v, err := d.Str()
			s.InviteLink = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SendAnimation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("animation")
	e.Str(s.Animation)
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.Width.Set {
		e.FieldStart("width")
		s.Width.Encode(e)
	}
	if s.Height.Set {
		e.FieldStart("height")
		s.Height.Encode(e)
	}
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendAnimation from json.
func (s *SendAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendAnimation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "animation":
			v, err := d.Str()
			s.Animation = string(v)
			if err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendAnimationReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendAnimationReplyMarkup as json.
func (s SendAnimationReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendAnimationReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendAnimationReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendAnimationReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendAnimationReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendAnimationReplyMarkup from json.
func (s *SendAnimationReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendAnimationReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendAnimationReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendAnimationReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendAnimationReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendAnimationReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendAnimationReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendAnimationReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendAnimationReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendAnimationReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendAnimationReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendAnimationReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendAnimationReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendAnimationReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendAudio) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("audio")
	e.Str(s.Audio)
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.Performer.Set {
		e.FieldStart("performer")
		s.Performer.Encode(e)
	}
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendAudio from json.
func (s *SendAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendAudio to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "audio":
			v, err := d.Str()
			s.Audio = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendAudioReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendAudioReplyMarkup as json.
func (s SendAudioReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendAudioReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendAudioReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendAudioReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendAudioReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendAudioReplyMarkup from json.
func (s *SendAudioReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendAudioReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendAudioReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendAudioReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendAudioReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendAudioReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendAudioReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendAudioReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendAudioReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendAudioReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendAudioReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendAudioReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendAudioReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendAudioReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendChatAction) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("action")
	e.Str(s.Action)
	e.ObjEnd()
}

// Decode decodes SendChatAction from json.
func (s *SendChatAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendChatAction to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "action":
			v, err := d.Str()
			s.Action = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SendContact) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("phone_number")
	e.Str(s.PhoneNumber)

	e.FieldStart("first_name")
	e.Str(s.FirstName)
	if s.LastName.Set {
		e.FieldStart("last_name")
		s.LastName.Encode(e)
	}
	if s.Vcard.Set {
		e.FieldStart("vcard")
		s.Vcard.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendContact from json.
func (s *SendContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendContact to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "phone_number":
			v, err := d.Str()
			s.PhoneNumber = string(v)
			if err != nil {
				return err
			}
		case "first_name":
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "vcard":
			s.Vcard.Reset()
			if err := s.Vcard.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendContactReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendContactReplyMarkup as json.
func (s SendContactReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendContactReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendContactReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendContactReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendContactReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendContactReplyMarkup from json.
func (s *SendContactReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendContactReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendContactReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendContactReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendContactReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendContactReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendContactReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendContactReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendContactReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendContactReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendContactReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendContactReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendContactReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendContactReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendDice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	if s.Emoji.Set {
		e.FieldStart("emoji")
		s.Emoji.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendDice from json.
func (s *SendDice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendDice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "emoji":
			s.Emoji.Reset()
			if err := s.Emoji.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendDiceReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendDiceReplyMarkup as json.
func (s SendDiceReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendDiceReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendDiceReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendDiceReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendDiceReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendDiceReplyMarkup from json.
func (s *SendDiceReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendDiceReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendDiceReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendDiceReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendDiceReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendDiceReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendDiceReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendDiceReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendDiceReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendDiceReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendDiceReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendDiceReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendDiceReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendDiceReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendDocument) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("document")
	e.Str(s.Document)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableContentTypeDetection.Set {
		e.FieldStart("disable_content_type_detection")
		s.DisableContentTypeDetection.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendDocument from json.
func (s *SendDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendDocument to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "document":
			v, err := d.Str()
			s.Document = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_content_type_detection":
			s.DisableContentTypeDetection.Reset()
			if err := s.DisableContentTypeDetection.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendDocumentReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendDocumentReplyMarkup as json.
func (s SendDocumentReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendDocumentReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendDocumentReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendDocumentReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendDocumentReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendDocumentReplyMarkup from json.
func (s *SendDocumentReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendDocumentReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendDocumentReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendDocumentReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendDocumentReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendDocumentReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendDocumentReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendDocumentReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendDocumentReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendDocumentReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendDocumentReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendDocumentReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendDocumentReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendDocumentReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendGame) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	e.Int(s.ChatID)

	e.FieldStart("game_short_name")
	e.Str(s.GameShortName)
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendGame from json.
func (s *SendGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendGame to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			v, err := d.Int()
			s.ChatID = int(v)
			if err != nil {
				return err
			}
		case "game_short_name":
			v, err := d.Str()
			s.GameShortName = string(v)
			if err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SendInvoice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("payload")
	e.Str(s.Payload)

	e.FieldStart("provider_token")
	e.Str(s.ProviderToken)

	e.FieldStart("currency")
	e.Str(s.Currency)

	e.FieldStart("prices")
	e.ArrStart()
	for _, elem := range s.Prices {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.MaxTipAmount.Set {
		e.FieldStart("max_tip_amount")
		s.MaxTipAmount.Encode(e)
	}
	if s.SuggestedTipAmounts != nil {
		e.FieldStart("suggested_tip_amounts")
		e.ArrStart()
		for _, elem := range s.SuggestedTipAmounts {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	if s.StartParameter.Set {
		e.FieldStart("start_parameter")
		s.StartParameter.Encode(e)
	}
	if s.ProviderData.Set {
		e.FieldStart("provider_data")
		s.ProviderData.Encode(e)
	}
	if s.PhotoURL.Set {
		e.FieldStart("photo_url")
		s.PhotoURL.Encode(e)
	}
	if s.PhotoSize.Set {
		e.FieldStart("photo_size")
		s.PhotoSize.Encode(e)
	}
	if s.PhotoWidth.Set {
		e.FieldStart("photo_width")
		s.PhotoWidth.Encode(e)
	}
	if s.PhotoHeight.Set {
		e.FieldStart("photo_height")
		s.PhotoHeight.Encode(e)
	}
	if s.NeedName.Set {
		e.FieldStart("need_name")
		s.NeedName.Encode(e)
	}
	if s.NeedPhoneNumber.Set {
		e.FieldStart("need_phone_number")
		s.NeedPhoneNumber.Encode(e)
	}
	if s.NeedEmail.Set {
		e.FieldStart("need_email")
		s.NeedEmail.Encode(e)
	}
	if s.NeedShippingAddress.Set {
		e.FieldStart("need_shipping_address")
		s.NeedShippingAddress.Encode(e)
	}
	if s.SendPhoneNumberToProvider.Set {
		e.FieldStart("send_phone_number_to_provider")
		s.SendPhoneNumberToProvider.Encode(e)
	}
	if s.SendEmailToProvider.Set {
		e.FieldStart("send_email_to_provider")
		s.SendEmailToProvider.Encode(e)
	}
	if s.IsFlexible.Set {
		e.FieldStart("is_flexible")
		s.IsFlexible.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendInvoice from json.
func (s *SendInvoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendInvoice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "payload":
			v, err := d.Str()
			s.Payload = string(v)
			if err != nil {
				return err
			}
		case "provider_token":
			v, err := d.Str()
			s.ProviderToken = string(v)
			if err != nil {
				return err
			}
		case "currency":
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "prices":
			s.Prices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabeledPrice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Prices = append(s.Prices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "max_tip_amount":
			s.MaxTipAmount.Reset()
			if err := s.MaxTipAmount.Decode(d); err != nil {
				return err
			}
		case "suggested_tip_amounts":
			s.SuggestedTipAmounts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "start_parameter":
			s.StartParameter.Reset()
			if err := s.StartParameter.Decode(d); err != nil {
				return err
			}
		case "provider_data":
			s.ProviderData.Reset()
			if err := s.ProviderData.Decode(d); err != nil {
				return err
			}
		case "photo_url":
			s.PhotoURL.Reset()
			if err := s.PhotoURL.Decode(d); err != nil {
				return err
			}
		case "photo_size":
			s.PhotoSize.Reset()
			if err := s.PhotoSize.Decode(d); err != nil {
				return err
			}
		case "photo_width":
			s.PhotoWidth.Reset()
			if err := s.PhotoWidth.Decode(d); err != nil {
				return err
			}
		case "photo_height":
			s.PhotoHeight.Reset()
			if err := s.PhotoHeight.Decode(d); err != nil {
				return err
			}
		case "need_name":
			s.NeedName.Reset()
			if err := s.NeedName.Decode(d); err != nil {
				return err
			}
		case "need_phone_number":
			s.NeedPhoneNumber.Reset()
			if err := s.NeedPhoneNumber.Decode(d); err != nil {
				return err
			}
		case "need_email":
			s.NeedEmail.Reset()
			if err := s.NeedEmail.Decode(d); err != nil {
				return err
			}
		case "need_shipping_address":
			s.NeedShippingAddress.Reset()
			if err := s.NeedShippingAddress.Decode(d); err != nil {
				return err
			}
		case "send_phone_number_to_provider":
			s.SendPhoneNumberToProvider.Reset()
			if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
				return err
			}
		case "send_email_to_provider":
			s.SendEmailToProvider.Reset()
			if err := s.SendEmailToProvider.Decode(d); err != nil {
				return err
			}
		case "is_flexible":
			s.IsFlexible.Reset()
			if err := s.IsFlexible.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SendLocation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("latitude")
	e.Float64(s.Latitude)

	e.FieldStart("longitude")
	e.Float64(s.Longitude)
	if s.HorizontalAccuracy.Set {
		e.FieldStart("horizontal_accuracy")
		s.HorizontalAccuracy.Encode(e)
	}
	if s.LivePeriod.Set {
		e.FieldStart("live_period")
		s.LivePeriod.Encode(e)
	}
	if s.Heading.Set {
		e.FieldStart("heading")
		s.Heading.Encode(e)
	}
	if s.ProximityAlertRadius.Set {
		e.FieldStart("proximity_alert_radius")
		s.ProximityAlertRadius.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendLocation from json.
func (s *SendLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "latitude":
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "live_period":
			s.LivePeriod.Reset()
			if err := s.LivePeriod.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendLocationReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendLocationReplyMarkup as json.
func (s SendLocationReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendLocationReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendLocationReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendLocationReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendLocationReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendLocationReplyMarkup from json.
func (s *SendLocationReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendLocationReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendLocationReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendLocationReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendLocationReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendLocationReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendLocationReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendLocationReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendLocationReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendLocationReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendLocationReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendLocationReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendLocationReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendLocationReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendMediaGroup) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("media")
	e.ArrStart()
	for _, elem := range s.Media {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendMediaGroup from json.
func (s *SendMediaGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMediaGroup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "media":
			s.Media = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SendMediaGroupMediaItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Media = append(s.Media, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendMediaGroupMediaItem as json.
func (s SendMediaGroupMediaItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		s.InputMediaAudio.Encode(e)
	case InputMediaDocumentSendMediaGroupMediaItem:
		s.InputMediaDocument.Encode(e)
	case InputMediaPhotoSendMediaGroupMediaItem:
		s.InputMediaPhoto.Encode(e)
	case InputMediaVideoSendMediaGroupMediaItem:
		s.InputMediaVideo.Encode(e)
	}
}

// Decode decodes SendMediaGroupMediaItem from json.
func (s *SendMediaGroupMediaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMediaGroupMediaItem to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "audio":
					s.Type = InputMediaAudioSendMediaGroupMediaItem
					found = true
				case "document":
					s.Type = InputMediaDocumentSendMediaGroupMediaItem
					found = true
				case "photo":
					s.Type = InputMediaPhotoSendMediaGroupMediaItem
					found = true
				case "video":
					s.Type = InputMediaVideoSendMediaGroupMediaItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentSendMediaGroupMediaItem:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoSendMediaGroupMediaItem:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoSendMediaGroupMediaItem:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendMessage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("text")
	e.Str(s.Text)
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.Entities != nil {
		e.FieldStart("entities")
		e.ArrStart()
		for _, elem := range s.Entities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableWebPagePreview.Set {
		e.FieldStart("disable_web_page_preview")
		s.DisableWebPagePreview.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendMessage from json.
func (s *SendMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_web_page_preview":
			s.DisableWebPagePreview.Reset()
			if err := s.DisableWebPagePreview.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendMessageReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendMessageReplyMarkup as json.
func (s SendMessageReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendMessageReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendMessageReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendMessageReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendMessageReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendMessageReplyMarkup from json.
func (s *SendMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMessageReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendMessageReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendMessageReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendMessageReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendMessageReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendMessageReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendMessageReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendMessageReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendMessageReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendMessageReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendMessageReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendMessageReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendMessageReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("photo")
	e.Str(s.Photo)
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendPhoto from json.
func (s *SendPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendPhoto to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "photo":
			v, err := d.Str()
			s.Photo = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendPhotoReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendPhotoReplyMarkup as json.
func (s SendPhotoReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendPhotoReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendPhotoReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendPhotoReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendPhotoReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendPhotoReplyMarkup from json.
func (s *SendPhotoReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendPhotoReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendPhotoReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendPhotoReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendPhotoReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendPhotoReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendPhotoReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendPhotoReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendPhotoReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendPhotoReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendPhotoReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendPhotoReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendPhotoReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendPhotoReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendPoll) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("question")
	e.Str(s.Question)

	e.FieldStart("options")
	e.ArrStart()
	for _, elem := range s.Options {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.IsAnonymous.Set {
		e.FieldStart("is_anonymous")
		s.IsAnonymous.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.AllowsMultipleAnswers.Set {
		e.FieldStart("allows_multiple_answers")
		s.AllowsMultipleAnswers.Encode(e)
	}
	if s.CorrectOptionID.Set {
		e.FieldStart("correct_option_id")
		s.CorrectOptionID.Encode(e)
	}
	if s.Explanation.Set {
		e.FieldStart("explanation")
		s.Explanation.Encode(e)
	}
	if s.ExplanationParseMode.Set {
		e.FieldStart("explanation_parse_mode")
		s.ExplanationParseMode.Encode(e)
	}
	if s.ExplanationEntities != nil {
		e.FieldStart("explanation_entities")
		e.ArrStart()
		for _, elem := range s.ExplanationEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.OpenPeriod.Set {
		e.FieldStart("open_period")
		s.OpenPeriod.Encode(e)
	}
	if s.CloseDate.Set {
		e.FieldStart("close_date")
		s.CloseDate.Encode(e)
	}
	if s.IsClosed.Set {
		e.FieldStart("is_closed")
		s.IsClosed.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendPoll from json.
func (s *SendPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendPoll to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "question":
			v, err := d.Str()
			s.Question = string(v)
			if err != nil {
				return err
			}
		case "options":
			s.Options = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Options = append(s.Options, elem)
				return nil
			}); err != nil {
				return err
			}
		case "is_anonymous":
			s.IsAnonymous.Reset()
			if err := s.IsAnonymous.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "allows_multiple_answers":
			s.AllowsMultipleAnswers.Reset()
			if err := s.AllowsMultipleAnswers.Decode(d); err != nil {
				return err
			}
		case "correct_option_id":
			s.CorrectOptionID.Reset()
			if err := s.CorrectOptionID.Decode(d); err != nil {
				return err
			}
		case "explanation":
			s.Explanation.Reset()
			if err := s.Explanation.Decode(d); err != nil {
				return err
			}
		case "explanation_parse_mode":
			s.ExplanationParseMode.Reset()
			if err := s.ExplanationParseMode.Decode(d); err != nil {
				return err
			}
		case "explanation_entities":
			s.ExplanationEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ExplanationEntities = append(s.ExplanationEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "open_period":
			s.OpenPeriod.Reset()
			if err := s.OpenPeriod.Decode(d); err != nil {
				return err
			}
		case "close_date":
			s.CloseDate.Reset()
			if err := s.CloseDate.Decode(d); err != nil {
				return err
			}
		case "is_closed":
			s.IsClosed.Reset()
			if err := s.IsClosed.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendPollReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendPollReplyMarkup as json.
func (s SendPollReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendPollReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendPollReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendPollReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendPollReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendPollReplyMarkup from json.
func (s *SendPollReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendPollReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendPollReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendPollReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendPollReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendPollReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendPollReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendPollReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendPollReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendPollReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendPollReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendPollReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendPollReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendPollReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendSticker) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("sticker")
	e.Str(s.Sticker)
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendSticker from json.
func (s *SendSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendSticker to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "sticker":
			v, err := d.Str()
			s.Sticker = string(v)
			if err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendStickerReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendStickerReplyMarkup as json.
func (s SendStickerReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendStickerReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendStickerReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendStickerReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendStickerReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendStickerReplyMarkup from json.
func (s *SendStickerReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendStickerReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendStickerReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendStickerReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendStickerReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendStickerReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendStickerReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendStickerReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendStickerReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendStickerReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendStickerReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendStickerReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendStickerReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendStickerReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendVenue) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("latitude")
	e.Float64(s.Latitude)

	e.FieldStart("longitude")
	e.Float64(s.Longitude)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("address")
	e.Str(s.Address)
	if s.FoursquareID.Set {
		e.FieldStart("foursquare_id")
		s.FoursquareID.Encode(e)
	}
	if s.FoursquareType.Set {
		e.FieldStart("foursquare_type")
		s.FoursquareType.Encode(e)
	}
	if s.GooglePlaceID.Set {
		e.FieldStart("google_place_id")
		s.GooglePlaceID.Encode(e)
	}
	if s.GooglePlaceType.Set {
		e.FieldStart("google_place_type")
		s.GooglePlaceType.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendVenue from json.
func (s *SendVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVenue to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "latitude":
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "address":
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "foursquare_id":
			s.FoursquareID.Reset()
			if err := s.FoursquareID.Decode(d); err != nil {
				return err
			}
		case "foursquare_type":
			s.FoursquareType.Reset()
			if err := s.FoursquareType.Decode(d); err != nil {
				return err
			}
		case "google_place_id":
			s.GooglePlaceID.Reset()
			if err := s.GooglePlaceID.Decode(d); err != nil {
				return err
			}
		case "google_place_type":
			s.GooglePlaceType.Reset()
			if err := s.GooglePlaceType.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendVenueReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendVenueReplyMarkup as json.
func (s SendVenueReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVenueReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVenueReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVenueReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVenueReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendVenueReplyMarkup from json.
func (s *SendVenueReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVenueReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendVenueReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVenueReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVenueReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVenueReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendVenueReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendVenueReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendVenueReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendVenueReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVenueReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVenueReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVenueReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVenueReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendVideo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("video")
	e.Str(s.Video)
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.Width.Set {
		e.FieldStart("width")
		s.Width.Encode(e)
	}
	if s.Height.Set {
		e.FieldStart("height")
		s.Height.Encode(e)
	}
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.SupportsStreaming.Set {
		e.FieldStart("supports_streaming")
		s.SupportsStreaming.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendVideo from json.
func (s *SendVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVideo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "video":
			v, err := d.Str()
			s.Video = string(v)
			if err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "supports_streaming":
			s.SupportsStreaming.Reset()
			if err := s.SupportsStreaming.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendVideoReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SendVideoNote) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("video_note")
	e.Str(s.VideoNote)
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.Length.Set {
		e.FieldStart("length")
		s.Length.Encode(e)
	}
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendVideoNote from json.
func (s *SendVideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVideoNote to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "video_note":
			v, err := d.Str()
			s.VideoNote = string(v)
			if err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "length":
			s.Length.Reset()
			if err := s.Length.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendVideoNoteReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendVideoNoteReplyMarkup as json.
func (s SendVideoNoteReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVideoNoteReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVideoNoteReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVideoNoteReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVideoNoteReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendVideoNoteReplyMarkup from json.
func (s *SendVideoNoteReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVideoNoteReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendVideoNoteReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVideoNoteReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVideoNoteReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVideoNoteReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendVideoNoteReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendVideoNoteReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendVideoNoteReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendVideoNoteReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVideoNoteReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVideoNoteReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVideoNoteReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVideoNoteReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes SendVideoReplyMarkup as json.
func (s SendVideoReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVideoReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVideoReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVideoReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVideoReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendVideoReplyMarkup from json.
func (s *SendVideoReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVideoReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendVideoReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVideoReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVideoReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVideoReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendVideoReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendVideoReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendVideoReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendVideoReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVideoReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVideoReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVideoReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVideoReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendVoice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("voice")
	e.Str(s.Voice)
	if s.Caption.Set {
		e.FieldStart("caption")
		s.Caption.Encode(e)
	}
	if s.ParseMode.Set {
		e.FieldStart("parse_mode")
		s.ParseMode.Encode(e)
	}
	if s.CaptionEntities != nil {
		e.FieldStart("caption_entities")
		e.ArrStart()
		for _, elem := range s.CaptionEntities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Duration.Set {
		e.FieldStart("duration")
		s.Duration.Encode(e)
	}
	if s.DisableNotification.Set {
		e.FieldStart("disable_notification")
		s.DisableNotification.Encode(e)
	}
	if s.ReplyToMessageID.Set {
		e.FieldStart("reply_to_message_id")
		s.ReplyToMessageID.Encode(e)
	}
	if s.AllowSendingWithoutReply.Set {
		e.FieldStart("allow_sending_without_reply")
		s.AllowSendingWithoutReply.Encode(e)
	}
	if s.ReplyMarkup != nil {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SendVoice from json.
func (s *SendVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVoice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "voice":
			v, err := d.Str()
			s.Voice = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup = nil
			var elem SendVoiceReplyMarkup
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyMarkup = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SendVoiceReplyMarkup as json.
func (s SendVoiceReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVoiceReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVoiceReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVoiceReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVoiceReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendVoiceReplyMarkup from json.
func (s *SendVoiceReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVoiceReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendVoiceReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVoiceReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVoiceReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendVoiceReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendVoiceReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendVoiceReplyMarkup
			case "input_field_placeholder":
				found = true
				s.Type = ForceReplySendVoiceReplyMarkup
			case "selective":
				found = true
				s.Type = ForceReplySendVoiceReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVoiceReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVoiceReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVoiceReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVoiceReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SetChatAdministratorCustomTitle) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("custom_title")
	e.Str(s.CustomTitle)
	e.ObjEnd()
}

// Decode decodes SetChatAdministratorCustomTitle from json.
func (s *SetChatAdministratorCustomTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatAdministratorCustomTitle to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "custom_title":
			v, err := d.Str()
			s.CustomTitle = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetChatDescription) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SetChatDescription from json.
func (s *SetChatDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatDescription to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetChatPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("permissions")
	s.Permissions.Encode(e)
	e.ObjEnd()
}

// Decode decodes SetChatPermissions from json.
func (s *SetChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("photo")
	e.Str(s.Photo)
	e.ObjEnd()
}

// Decode decodes SetChatPhoto from json.
func (s *SetChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatPhoto to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "photo":
			v, err := d.Str()
			s.Photo = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetChatStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("sticker_set_name")
	e.Str(s.StickerSetName)
	e.ObjEnd()
}

// Decode decodes SetChatStickerSet from json.
func (s *SetChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatStickerSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "sticker_set_name":
			v, err := d.Str()
			s.StickerSetName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetChatTitle) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("title")
	e.Str(s.Title)
	e.ObjEnd()
}

// Decode decodes SetChatTitle from json.
func (s *SetChatTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatTitle to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetGameScore) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("score")
	e.Int(s.Score)
	if s.Force.Set {
		e.FieldStart("force")
		s.Force.Encode(e)
	}
	if s.DisableEditMessage.Set {
		e.FieldStart("disable_edit_message")
		s.DisableEditMessage.Encode(e)
	}
	if s.ChatID.Set {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SetGameScore from json.
func (s *SetGameScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetGameScore to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Int()
			s.Score = int(v)
			if err != nil {
				return err
			}
		case "force":
			s.Force.Reset()
			if err := s.Force.Decode(d); err != nil {
				return err
			}
		case "disable_edit_message":
			s.DisableEditMessage.Reset()
			if err := s.DisableEditMessage.Decode(d); err != nil {
				return err
			}
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("commands")
	e.ArrStart()
	for _, elem := range s.Commands {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Scope != nil {
		e.FieldStart("scope")
		s.Scope.Encode(e)
	}
	if s.LanguageCode.Set {
		e.FieldStart("language_code")
		s.LanguageCode.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SetMyCommands from json.
func (s *SetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetMyCommands to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commands":
			s.Commands = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BotCommand
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Commands = append(s.Commands, elem)
				return nil
			}); err != nil {
				return err
			}
		case "scope":
			s.Scope = nil
			var elem BotCommandScope
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Scope = &elem
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetPassportDataErrors) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("errors")
	e.ArrStart()
	for _, elem := range s.Errors {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SetPassportDataErrors from json.
func (s *SetPassportDataErrors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetPassportDataErrors to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PassportElementError
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetStickerPositionInSet) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sticker")
	e.Str(s.Sticker)

	e.FieldStart("position")
	e.Int(s.Position)
	e.ObjEnd()
}

// Decode decodes SetStickerPositionInSet from json.
func (s *SetStickerPositionInSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetStickerPositionInSet to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			v, err := d.Str()
			s.Sticker = string(v)
			if err != nil {
				return err
			}
		case "position":
			v, err := d.Int()
			s.Position = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetStickerSetThumb) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SetStickerSetThumb from json.
func (s *SetStickerSetThumb) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetStickerSetThumb to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SetWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.Certificate.Set {
		e.FieldStart("certificate")
		s.Certificate.Encode(e)
	}
	if s.IPAddress.Set {
		e.FieldStart("ip_address")
		s.IPAddress.Encode(e)
	}
	if s.MaxConnections.Set {
		e.FieldStart("max_connections")
		s.MaxConnections.Encode(e)
	}
	if s.AllowedUpdates != nil {
		e.FieldStart("allowed_updates")
		e.ArrStart()
		for _, elem := range s.AllowedUpdates {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.DropPendingUpdates.Set {
		e.FieldStart("drop_pending_updates")
		s.DropPendingUpdates.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SetWebhook from json.
func (s *SetWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetWebhook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "certificate":
			s.Certificate.Reset()
			if err := s.Certificate.Decode(d); err != nil {
				return err
			}
		case "ip_address":
			s.IPAddress.Reset()
			if err := s.IPAddress.Decode(d); err != nil {
				return err
			}
		case "max_connections":
			s.MaxConnections.Reset()
			if err := s.MaxConnections.Decode(d); err != nil {
				return err
			}
		case "allowed_updates":
			s.AllowedUpdates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedUpdates = append(s.AllowedUpdates, elem)
				return nil
			}); err != nil {
				return err
			}
		case "drop_pending_updates":
			s.DropPendingUpdates.Reset()
			if err := s.DropPendingUpdates.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShippingAddress) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("country_code")
	e.Str(s.CountryCode)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("city")
	e.Str(s.City)

	e.FieldStart("street_line1")
	e.Str(s.StreetLine1)

	e.FieldStart("street_line2")
	e.Str(s.StreetLine2)

	e.FieldStart("post_code")
	e.Str(s.PostCode)
	e.ObjEnd()
}

// Decode decodes ShippingAddress from json.
func (s *ShippingAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShippingAddress to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_code":
			v, err := d.Str()
			s.CountryCode = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "city":
			v, err := d.Str()
			s.City = string(v)
			if err != nil {
				return err
			}
		case "street_line1":
			v, err := d.Str()
			s.StreetLine1 = string(v)
			if err != nil {
				return err
			}
		case "street_line2":
			v, err := d.Str()
			s.StreetLine2 = string(v)
			if err != nil {
				return err
			}
		case "post_code":
			v, err := d.Str()
			s.PostCode = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShippingOption) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("prices")
	e.ArrStart()
	for _, elem := range s.Prices {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ShippingOption from json.
func (s *ShippingOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShippingOption to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "prices":
			s.Prices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabeledPrice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Prices = append(s.Prices, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Sticker) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("width")
	e.Int(s.Width)

	e.FieldStart("height")
	e.Int(s.Height)

	e.FieldStart("is_animated")
	e.Bool(s.IsAnimated)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.Emoji.Set {
		e.FieldStart("emoji")
		s.Emoji.Encode(e)
	}
	if s.SetName.Set {
		e.FieldStart("set_name")
		s.SetName.Encode(e)
	}
	if s.MaskPosition.Set {
		e.FieldStart("mask_position")
		s.MaskPosition.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Sticker from json.
func (s *Sticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Sticker to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "is_animated":
			v, err := d.Bool()
			s.IsAnimated = bool(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "emoji":
			s.Emoji.Reset()
			if err := s.Emoji.Decode(d); err != nil {
				return err
			}
		case "set_name":
			s.SetName.Reset()
			if err := s.SetName.Decode(d); err != nil {
				return err
			}
		case "mask_position":
			s.MaskPosition.Reset()
			if err := s.MaskPosition.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s StopMessageLiveLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ChatID != nil {
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	if s.InlineMessageID.Set {
		e.FieldStart("inline_message_id")
		s.InlineMessageID.Encode(e)
	}
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes StopMessageLiveLocation from json.
func (s *StopMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StopMessageLiveLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID = nil
			var elem ID
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ChatID = &elem
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s StopPoll) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("message_id")
	e.Int(s.MessageID)
	if s.ReplyMarkup.Set {
		e.FieldStart("reply_markup")
		s.ReplyMarkup.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes StopPoll from json.
func (s *StopPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StopPoll to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SuccessfulPayment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("currency")
	e.Str(s.Currency)

	e.FieldStart("total_amount")
	e.Int(s.TotalAmount)

	e.FieldStart("invoice_payload")
	e.Str(s.InvoicePayload)
	if s.ShippingOptionID.Set {
		e.FieldStart("shipping_option_id")
		s.ShippingOptionID.Encode(e)
	}
	if s.OrderInfo.Set {
		e.FieldStart("order_info")
		s.OrderInfo.Encode(e)
	}

	e.FieldStart("telegram_payment_charge_id")
	e.Str(s.TelegramPaymentChargeID)

	e.FieldStart("provider_payment_charge_id")
	e.Str(s.ProviderPaymentChargeID)
	e.ObjEnd()
}

// Decode decodes SuccessfulPayment from json.
func (s *SuccessfulPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SuccessfulPayment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "total_amount":
			v, err := d.Int()
			s.TotalAmount = int(v)
			if err != nil {
				return err
			}
		case "invoice_payload":
			v, err := d.Str()
			s.InvoicePayload = string(v)
			if err != nil {
				return err
			}
		case "shipping_option_id":
			s.ShippingOptionID.Reset()
			if err := s.ShippingOptionID.Decode(d); err != nil {
				return err
			}
		case "order_info":
			s.OrderInfo.Reset()
			if err := s.OrderInfo.Decode(d); err != nil {
				return err
			}
		case "telegram_payment_charge_id":
			v, err := d.Str()
			s.TelegramPaymentChargeID = string(v)
			if err != nil {
				return err
			}
		case "provider_payment_charge_id":
			v, err := d.Str()
			s.ProviderPaymentChargeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UnbanChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)

	e.FieldStart("user_id")
	e.Int(s.UserID)
	if s.OnlyIfBanned.Set {
		e.FieldStart("only_if_banned")
		s.OnlyIfBanned.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes UnbanChatMember from json.
func (s *UnbanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnbanChatMember to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "only_if_banned":
			s.OnlyIfBanned.Reset()
			if err := s.OnlyIfBanned.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UnpinAllChatMessages) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	e.ObjEnd()
}

// Decode decodes UnpinAllChatMessages from json.
func (s *UnpinAllChatMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnpinAllChatMessages to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UnpinChatMessage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("chat_id")
	s.ChatID.Encode(e)
	if s.MessageID.Set {
		e.FieldStart("message_id")
		s.MessageID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes UnpinChatMessage from json.
func (s *UnpinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnpinChatMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UploadStickerFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("user_id")
	e.Int(s.UserID)

	e.FieldStart("png_sticker")
	e.Str(s.PNGSticker)
	e.ObjEnd()
}

// Decode decodes UploadStickerFile from json.
func (s *UploadStickerFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UploadStickerFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			v, err := d.Int()
			s.UserID = int(v)
			if err != nil {
				return err
			}
		case "png_sticker":
			v, err := d.Str()
			s.PNGSticker = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s User) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("is_bot")
	e.Bool(s.IsBot)

	e.FieldStart("first_name")
	e.Str(s.FirstName)
	if s.LastName.Set {
		e.FieldStart("last_name")
		s.LastName.Encode(e)
	}
	if s.Username.Set {
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	if s.LanguageCode.Set {
		e.FieldStart("language_code")
		s.LanguageCode.Encode(e)
	}
	if s.CanJoinGroups.Set {
		e.FieldStart("can_join_groups")
		s.CanJoinGroups.Encode(e)
	}
	if s.CanReadAllGroupMessages.Set {
		e.FieldStart("can_read_all_group_messages")
		s.CanReadAllGroupMessages.Encode(e)
	}
	if s.SupportsInlineQueries.Set {
		e.FieldStart("supports_inline_queries")
		s.SupportsInlineQueries.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode User to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "is_bot":
			v, err := d.Bool()
			s.IsBot = bool(v)
			if err != nil {
				return err
			}
		case "first_name":
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		case "can_join_groups":
			s.CanJoinGroups.Reset()
			if err := s.CanJoinGroups.Decode(d); err != nil {
				return err
			}
		case "can_read_all_group_messages":
			s.CanReadAllGroupMessages.Reset()
			if err := s.CanReadAllGroupMessages.Decode(d); err != nil {
				return err
			}
		case "supports_inline_queries":
			s.SupportsInlineQueries.Reset()
			if err := s.SupportsInlineQueries.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Venue) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("location")
	s.Location.Encode(e)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("address")
	e.Str(s.Address)
	if s.FoursquareID.Set {
		e.FieldStart("foursquare_id")
		s.FoursquareID.Encode(e)
	}
	if s.FoursquareType.Set {
		e.FieldStart("foursquare_type")
		s.FoursquareType.Encode(e)
	}
	if s.GooglePlaceID.Set {
		e.FieldStart("google_place_id")
		s.GooglePlaceID.Encode(e)
	}
	if s.GooglePlaceType.Set {
		e.FieldStart("google_place_type")
		s.GooglePlaceType.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Venue from json.
func (s *Venue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Venue to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "address":
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "foursquare_id":
			s.FoursquareID.Reset()
			if err := s.FoursquareID.Decode(d); err != nil {
				return err
			}
		case "foursquare_type":
			s.FoursquareType.Reset()
			if err := s.FoursquareType.Decode(d); err != nil {
				return err
			}
		case "google_place_id":
			s.GooglePlaceID.Reset()
			if err := s.GooglePlaceID.Decode(d); err != nil {
				return err
			}
		case "google_place_type":
			s.GooglePlaceType.Reset()
			if err := s.GooglePlaceType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Video) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("width")
	e.Int(s.Width)

	e.FieldStart("height")
	e.Int(s.Height)

	e.FieldStart("duration")
	e.Int(s.Duration)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.FileName.Set {
		e.FieldStart("file_name")
		s.FileName.Encode(e)
	}
	if s.MimeType.Set {
		e.FieldStart("mime_type")
		s.MimeType.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Video from json.
func (s *Video) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Video to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s VideoNote) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("length")
	e.Int(s.Length)

	e.FieldStart("duration")
	e.Int(s.Duration)
	if s.Thumb.Set {
		e.FieldStart("thumb")
		s.Thumb.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes VideoNote from json.
func (s *VideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VideoNote to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "length":
			v, err := d.Int()
			s.Length = int(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Voice) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("file_id")
	e.Str(s.FileID)

	e.FieldStart("file_unique_id")
	e.Str(s.FileUniqueID)

	e.FieldStart("duration")
	e.Int(s.Duration)
	if s.MimeType.Set {
		e.FieldStart("mime_type")
		s.MimeType.Encode(e)
	}
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Voice from json.
func (s *Voice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Voice to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s VoiceChatEnded) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("duration")
	e.Int(s.Duration)
	e.ObjEnd()
}

// Decode decodes VoiceChatEnded from json.
func (s *VoiceChatEnded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatEnded to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s VoiceChatParticipantsInvited) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Users != nil {
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes VoiceChatParticipantsInvited from json.
func (s *VoiceChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatParticipantsInvited to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem User
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s VoiceChatScheduled) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("start_date")
	e.Int(s.StartDate)
	e.ObjEnd()
}

// Decode decodes VoiceChatScheduled from json.
func (s *VoiceChatScheduled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatScheduled to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_date":
			v, err := d.Int()
			s.StartDate = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s VoiceChatStarted) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes VoiceChatStarted from json.
func (s *VoiceChatStarted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatStarted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}
