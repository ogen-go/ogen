// Code generated by ogen, DO NOT EDIT.

package examples

import (
	"fmt"
	"math/bits"
	"regexp"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

var regexMap = map[string]*regexp.Regexp{
	"^":                     regexp.MustCompile("^"),
	"^([0-9X]{3})$":         regexp.MustCompile("^([0-9X]{3})$"),
	"^/":                    regexp.MustCompile("^/"),
	"^[a-zA-Z0-9\\.\\-_]+$": regexp.MustCompile("^[a-zA-Z0-9\\.\\-_]+$"),
	"^x-":                   regexp.MustCompile("^x-"),
}

// Ref: #/definitions/anysOrExpressions
type AnysOrExpressions map[string]jx.Raw

func (s *AnysOrExpressions) init() AnysOrExpressions {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A map of possible out-of band callbacks related to the parent operation. Each value in the map is
// a Path Item Object that describes a set of requests that may be initiated by the API provider and
// the expected responses. The key value used to identify the callback object is an expression,
// evaluated at runtime, that identifies a URL to use for the callback operation.
// Ref: #/definitions/callback
type Callback struct {
	// Pattern: "^".
	Pattern0Props CallbackPattern0
	// Pattern: "^x-".
	Pattern1Props CallbackPattern1
}

// Ref: #/definitions/callbackOrReference
// CallbackOrReference represents sum type.
type CallbackOrReference struct {
	Type      CallbackOrReferenceType // switch on this field
	Callback  Callback
	Reference Reference
}

// CallbackOrReferenceType is oneOf type of CallbackOrReference.
type CallbackOrReferenceType string

// Possible values for CallbackOrReferenceType.
const (
	CallbackCallbackOrReference  CallbackOrReferenceType = "Callback"
	ReferenceCallbackOrReference CallbackOrReferenceType = "Reference"
)

// IsCallback reports whether CallbackOrReference is Callback.
func (s CallbackOrReference) IsCallback() bool { return s.Type == CallbackCallbackOrReference }

// IsReference reports whether CallbackOrReference is Reference.
func (s CallbackOrReference) IsReference() bool { return s.Type == ReferenceCallbackOrReference }

// SetCallback sets CallbackOrReference to Callback.
func (s *CallbackOrReference) SetCallback(v Callback) {
	s.Type = CallbackCallbackOrReference
	s.Callback = v
}

// GetCallback returns Callback and true boolean if CallbackOrReference is Callback.
func (s CallbackOrReference) GetCallback() (v Callback, ok bool) {
	if !s.IsCallback() {
		return v, false
	}
	return s.Callback, true
}

// NewCallbackCallbackOrReference returns new CallbackOrReference from Callback.
func NewCallbackCallbackOrReference(v Callback) CallbackOrReference {
	var s CallbackOrReference
	s.SetCallback(v)
	return s
}

// SetReference sets CallbackOrReference to Reference.
func (s *CallbackOrReference) SetReference(v Reference) {
	s.Type = ReferenceCallbackOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if CallbackOrReference is Reference.
func (s CallbackOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceCallbackOrReference returns new CallbackOrReference from Reference.
func NewReferenceCallbackOrReference(v Reference) CallbackOrReference {
	var s CallbackOrReference
	s.SetReference(v)
	return s
}

type CallbackPattern0 map[string]PathItem

func (s *CallbackPattern0) init() CallbackPattern0 {
	m := *s
	if m == nil {
		m = map[string]PathItem{}
		*s = m
	}
	return m
}

type CallbackPattern1 map[string]jx.Raw

func (s *CallbackPattern1) init() CallbackPattern1 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/callbacksOrReferences
type CallbacksOrReferences map[string]CallbackOrReference

func (s *CallbacksOrReferences) init() CallbacksOrReferences {
	m := *s
	if m == nil {
		m = map[string]CallbackOrReference{}
		*s = m
	}
	return m
}

// Holds a set of reusable objects for different aspects of the OAS. All objects defined within the
// components object will have no effect on the API unless they are explicitly referenced from
// properties outside the components object.
// Ref: #/definitions/components
type Components struct {
	Schemas         OptSchemasOrReferences         "json:\"schemas\""
	Responses       OptResponsesOrReferences       "json:\"responses\""
	Parameters      OptParametersOrReferences      "json:\"parameters\""
	Examples        OptExamplesOrReferences        "json:\"examples\""
	RequestBodies   OptRequestBodiesOrReferences   "json:\"requestBodies\""
	Headers         OptHeadersOrReferences         "json:\"headers\""
	SecuritySchemes OptSecuritySchemesOrReferences "json:\"securitySchemes\""
	Links           OptLinksOrReferences           "json:\"links\""
	Callbacks       OptCallbacksOrReferences       "json:\"callbacks\""
	// Pattern: "^x-".
	Pattern0Props ComponentsPattern0
}

type ComponentsPattern0 map[string]jx.Raw

func (s *ComponentsPattern0) init() ComponentsPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Contact information for the exposed API.
// Ref: #/definitions/contact
type Contact struct {
	Name  OptString "json:\"name\""
	URL   OptString "json:\"url\""
	Email OptString "json:\"email\""
	// Pattern: "^x-".
	Pattern0Props ContactPattern0
}

type ContactPattern0 map[string]jx.Raw

func (s *ContactPattern0) init() ContactPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// When request bodies or response payloads may be one of a number of different schemas, a
// `discriminator` object can be used to aid in serialization, deserialization, and validation.  The
// discriminator is a specific object in a schema which is used to inform the consumer of the
// specification of an alternative schema based on the value associated with it.  When using the
// discriminator, _inline_ schemas will not be considered.
// Ref: #/definitions/discriminator
type Discriminator struct {
	PropertyName string     "json:\"propertyName\""
	Mapping      OptStrings "json:\"mapping\""
}

// A single encoding definition applied to a single schema property.
// Ref: #/definitions/encoding
type Encoding struct {
	ContentType   OptString              "json:\"contentType\""
	Headers       OptHeadersOrReferences "json:\"headers\""
	Style         OptString              "json:\"style\""
	Explode       OptBool                "json:\"explode\""
	AllowReserved OptBool                "json:\"allowReserved\""
	// Pattern: "^x-".
	Pattern0Props EncodingPattern0
}

type EncodingPattern0 map[string]jx.Raw

func (s *EncodingPattern0) init() EncodingPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/encodings
type Encodings map[string]Encoding

func (s *Encodings) init() Encodings {
	m := *s
	if m == nil {
		m = map[string]Encoding{}
		*s = m
	}
	return m
}

// Ref: #/definitions/example
type Example struct {
	Summary       OptString "json:\"summary\""
	Description   OptString "json:\"description\""
	Value         jx.Raw    "json:\"value\""
	ExternalValue OptString "json:\"externalValue\""
	// Pattern: "^x-".
	Pattern0Props ExamplePattern0
}

// Ref: #/definitions/exampleOrReference
// ExampleOrReference represents sum type.
type ExampleOrReference struct {
	Type      ExampleOrReferenceType // switch on this field
	Example   Example
	Reference Reference
}

// ExampleOrReferenceType is oneOf type of ExampleOrReference.
type ExampleOrReferenceType string

// Possible values for ExampleOrReferenceType.
const (
	ExampleExampleOrReference   ExampleOrReferenceType = "Example"
	ReferenceExampleOrReference ExampleOrReferenceType = "Reference"
)

// IsExample reports whether ExampleOrReference is Example.
func (s ExampleOrReference) IsExample() bool { return s.Type == ExampleExampleOrReference }

// IsReference reports whether ExampleOrReference is Reference.
func (s ExampleOrReference) IsReference() bool { return s.Type == ReferenceExampleOrReference }

// SetExample sets ExampleOrReference to Example.
func (s *ExampleOrReference) SetExample(v Example) {
	s.Type = ExampleExampleOrReference
	s.Example = v
}

// GetExample returns Example and true boolean if ExampleOrReference is Example.
func (s ExampleOrReference) GetExample() (v Example, ok bool) {
	if !s.IsExample() {
		return v, false
	}
	return s.Example, true
}

// NewExampleExampleOrReference returns new ExampleOrReference from Example.
func NewExampleExampleOrReference(v Example) ExampleOrReference {
	var s ExampleOrReference
	s.SetExample(v)
	return s
}

// SetReference sets ExampleOrReference to Reference.
func (s *ExampleOrReference) SetReference(v Reference) {
	s.Type = ReferenceExampleOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if ExampleOrReference is Reference.
func (s ExampleOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceExampleOrReference returns new ExampleOrReference from Reference.
func NewReferenceExampleOrReference(v Reference) ExampleOrReference {
	var s ExampleOrReference
	s.SetReference(v)
	return s
}

type ExamplePattern0 map[string]jx.Raw

func (s *ExamplePattern0) init() ExamplePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/examplesOrReferences
type ExamplesOrReferences map[string]ExampleOrReference

func (s *ExamplesOrReferences) init() ExamplesOrReferences {
	m := *s
	if m == nil {
		m = map[string]ExampleOrReference{}
		*s = m
	}
	return m
}

// Allows referencing an external resource for extended documentation.
// Ref: #/definitions/externalDocs
type ExternalDocs struct {
	Description OptString "json:\"description\""
	URL         string    "json:\"url\""
	// Pattern: "^x-".
	Pattern0Props ExternalDocsPattern0
}

type ExternalDocsPattern0 map[string]jx.Raw

func (s *ExternalDocsPattern0) init() ExternalDocsPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// The Header Object follows the structure of the Parameter Object with the following changes:  1.
// `name` MUST NOT be specified, it is given in the corresponding `headers` map. 1. `in` MUST NOT be
// specified, it is implicitly in `header`. 1. All traits that are affected by the location MUST be
// applicable to a location of `header` (for example, `style`).
// Ref: #/definitions/header
type Header struct {
	Description     OptString               "json:\"description\""
	Required        OptBool                 "json:\"required\""
	Deprecated      OptBool                 "json:\"deprecated\""
	AllowEmptyValue OptBool                 "json:\"allowEmptyValue\""
	Style           OptString               "json:\"style\""
	Explode         OptBool                 "json:\"explode\""
	AllowReserved   OptBool                 "json:\"allowReserved\""
	Schema          OptSchemaOrReference    "json:\"schema\""
	Example         jx.Raw                  "json:\"example\""
	Examples        OptExamplesOrReferences "json:\"examples\""
	Content         OptMediaTypes           "json:\"content\""
	// Pattern: "^x-".
	Pattern0Props HeaderPattern0
}

// Ref: #/definitions/headerOrReference
// HeaderOrReference represents sum type.
type HeaderOrReference struct {
	Type      HeaderOrReferenceType // switch on this field
	Header    Header
	Reference Reference
}

// HeaderOrReferenceType is oneOf type of HeaderOrReference.
type HeaderOrReferenceType string

// Possible values for HeaderOrReferenceType.
const (
	HeaderHeaderOrReference    HeaderOrReferenceType = "Header"
	ReferenceHeaderOrReference HeaderOrReferenceType = "Reference"
)

// IsHeader reports whether HeaderOrReference is Header.
func (s HeaderOrReference) IsHeader() bool { return s.Type == HeaderHeaderOrReference }

// IsReference reports whether HeaderOrReference is Reference.
func (s HeaderOrReference) IsReference() bool { return s.Type == ReferenceHeaderOrReference }

// SetHeader sets HeaderOrReference to Header.
func (s *HeaderOrReference) SetHeader(v Header) {
	s.Type = HeaderHeaderOrReference
	s.Header = v
}

// GetHeader returns Header and true boolean if HeaderOrReference is Header.
func (s HeaderOrReference) GetHeader() (v Header, ok bool) {
	if !s.IsHeader() {
		return v, false
	}
	return s.Header, true
}

// NewHeaderHeaderOrReference returns new HeaderOrReference from Header.
func NewHeaderHeaderOrReference(v Header) HeaderOrReference {
	var s HeaderOrReference
	s.SetHeader(v)
	return s
}

// SetReference sets HeaderOrReference to Reference.
func (s *HeaderOrReference) SetReference(v Reference) {
	s.Type = ReferenceHeaderOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if HeaderOrReference is Reference.
func (s HeaderOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceHeaderOrReference returns new HeaderOrReference from Reference.
func NewReferenceHeaderOrReference(v Reference) HeaderOrReference {
	var s HeaderOrReference
	s.SetReference(v)
	return s
}

type HeaderPattern0 map[string]jx.Raw

func (s *HeaderPattern0) init() HeaderPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/headersOrReferences
type HeadersOrReferences map[string]HeaderOrReference

func (s *HeadersOrReferences) init() HeadersOrReferences {
	m := *s
	if m == nil {
		m = map[string]HeaderOrReference{}
		*s = m
	}
	return m
}

// The object provides metadata about the API. The metadata MAY be used by the clients if needed, and
// MAY be presented in editing or documentation generation tools for convenience.
// Ref: #/definitions/info
type Info struct {
	Title          string     "json:\"title\""
	Description    OptString  "json:\"description\""
	TermsOfService OptString  "json:\"termsOfService\""
	Contact        OptContact "json:\"contact\""
	License        OptLicense "json:\"license\""
	Version        string     "json:\"version\""
	// Pattern: "^x-".
	Pattern0Props InfoPattern0
}

type InfoPattern0 map[string]jx.Raw

func (s *InfoPattern0) init() InfoPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type JsonschemaDraft4PropertiesEnum []jx.Raw

type JsonschemaDraft4PropertiesExclusiveMaximum bool

type JsonschemaDraft4PropertiesExclusiveMinimum bool

type JsonschemaDraft4PropertiesMaximum float64

type JsonschemaDraft4PropertiesMinimum float64

type JsonschemaDraft4PropertiesMultipleOf float64

type JsonschemaDraft4PropertiesPattern string

type JsonschemaDraft4PropertiesTitle string

type JsonschemaDraft4PropertiesUniqueItems bool

// License information for the exposed API.
// Ref: #/definitions/license
type License struct {
	Name string    "json:\"name\""
	URL  OptString "json:\"url\""
	// Pattern: "^x-".
	Pattern0Props LicensePattern0
}

type LicensePattern0 map[string]jx.Raw

func (s *LicensePattern0) init() LicensePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// The `Link object` represents a possible design-time link for a response. The presence of a link
// does not guarantee the caller's ability to successfully invoke it, rather it provides a known
// relationship and traversal mechanism between responses and other operations.  Unlike _dynamic_
// links (i.e. links provided **in** the response payload), the OAS linking mechanism does not
// require link information in the runtime response.  For computing links, and providing instructions
// to execute them, a runtime expression is used for accessing values in an operation and using them
// as parameters while invoking the linked operation.
// Ref: #/definitions/link
type Link struct {
	OperationRef OptString            "json:\"operationRef\""
	OperationId  OptString            "json:\"operationId\""
	Parameters   OptAnysOrExpressions "json:\"parameters\""
	RequestBody  jx.Raw               "json:\"requestBody\""
	Description  OptString            "json:\"description\""
	Server       OptServer            "json:\"server\""
	// Pattern: "^x-".
	Pattern0Props LinkPattern0
}

// Ref: #/definitions/linkOrReference
// LinkOrReference represents sum type.
type LinkOrReference struct {
	Type      LinkOrReferenceType // switch on this field
	Link      Link
	Reference Reference
}

// LinkOrReferenceType is oneOf type of LinkOrReference.
type LinkOrReferenceType string

// Possible values for LinkOrReferenceType.
const (
	LinkLinkOrReference      LinkOrReferenceType = "Link"
	ReferenceLinkOrReference LinkOrReferenceType = "Reference"
)

// IsLink reports whether LinkOrReference is Link.
func (s LinkOrReference) IsLink() bool { return s.Type == LinkLinkOrReference }

// IsReference reports whether LinkOrReference is Reference.
func (s LinkOrReference) IsReference() bool { return s.Type == ReferenceLinkOrReference }

// SetLink sets LinkOrReference to Link.
func (s *LinkOrReference) SetLink(v Link) {
	s.Type = LinkLinkOrReference
	s.Link = v
}

// GetLink returns Link and true boolean if LinkOrReference is Link.
func (s LinkOrReference) GetLink() (v Link, ok bool) {
	if !s.IsLink() {
		return v, false
	}
	return s.Link, true
}

// NewLinkLinkOrReference returns new LinkOrReference from Link.
func NewLinkLinkOrReference(v Link) LinkOrReference {
	var s LinkOrReference
	s.SetLink(v)
	return s
}

// SetReference sets LinkOrReference to Reference.
func (s *LinkOrReference) SetReference(v Reference) {
	s.Type = ReferenceLinkOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if LinkOrReference is Reference.
func (s LinkOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceLinkOrReference returns new LinkOrReference from Reference.
func NewReferenceLinkOrReference(v Reference) LinkOrReference {
	var s LinkOrReference
	s.SetReference(v)
	return s
}

type LinkPattern0 map[string]jx.Raw

func (s *LinkPattern0) init() LinkPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/linksOrReferences
type LinksOrReferences map[string]LinkOrReference

func (s *LinksOrReferences) init() LinksOrReferences {
	m := *s
	if m == nil {
		m = map[string]LinkOrReference{}
		*s = m
	}
	return m
}

// Each Media Type Object provides schema and examples for the media type identified by its key.
// Ref: #/definitions/mediaType
type MediaType struct {
	Schema   OptSchemaOrReference    "json:\"schema\""
	Example  jx.Raw                  "json:\"example\""
	Examples OptExamplesOrReferences "json:\"examples\""
	Encoding OptEncodings            "json:\"encoding\""
	// Pattern: "^x-".
	Pattern0Props MediaTypePattern0
}

type MediaTypePattern0 map[string]jx.Raw

func (s *MediaTypePattern0) init() MediaTypePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/mediaTypes
type MediaTypes map[string]MediaType

func (s *MediaTypes) init() MediaTypes {
	m := *s
	if m == nil {
		m = map[string]MediaType{}
		*s = m
	}
	return m
}

// Configuration details for a supported OAuth Flow.
// Ref: #/definitions/oauthFlow
type OauthFlow struct {
	AuthorizationUrl OptString  "json:\"authorizationUrl\""
	TokenUrl         OptString  "json:\"tokenUrl\""
	RefreshUrl       OptString  "json:\"refreshUrl\""
	Scopes           OptStrings "json:\"scopes\""
	// Pattern: "^x-".
	Pattern0Props OauthFlowPattern0
}

type OauthFlowPattern0 map[string]jx.Raw

func (s *OauthFlowPattern0) init() OauthFlowPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Allows configuration of the supported OAuth Flows.
// Ref: #/definitions/oauthFlows
type OauthFlows struct {
	Implicit          OptOauthFlow "json:\"implicit\""
	Password          OptOauthFlow "json:\"password\""
	ClientCredentials OptOauthFlow "json:\"clientCredentials\""
	AuthorizationCode OptOauthFlow "json:\"authorizationCode\""
	// Pattern: "^x-".
	Pattern0Props OauthFlowsPattern0
}

type OauthFlowsPattern0 map[string]jx.Raw

func (s *OauthFlowsPattern0) init() OauthFlowsPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Describes a single API operation on a path.
// Ref: #/definitions/operation
type Operation struct {
	Tags         []string                  "json:\"tags\""
	Summary      OptString                 "json:\"summary\""
	Description  OptString                 "json:\"description\""
	ExternalDocs OptExternalDocs           "json:\"externalDocs\""
	OperationId  OptString                 "json:\"operationId\""
	Parameters   []ParameterOrReference    "json:\"parameters\""
	RequestBody  OptRequestBodyOrReference "json:\"requestBody\""
	Responses    Responses                 "json:\"responses\""
	Callbacks    OptCallbacksOrReferences  "json:\"callbacks\""
	Deprecated   OptBool                   "json:\"deprecated\""
	Security     []SecurityRequirement     "json:\"security\""
	Servers      []Server                  "json:\"servers\""
	// Pattern: "^x-".
	Pattern0Props OperationPattern0
}

type OperationPattern0 map[string]jx.Raw

func (s *OperationPattern0) init() OperationPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// NewOptAnysOrExpressions returns new OptAnysOrExpressions with value set to v.
func NewOptAnysOrExpressions(v AnysOrExpressions) OptAnysOrExpressions {
	return OptAnysOrExpressions{
		Value: v,
		Set:   true,
	}
}

// OptAnysOrExpressions is optional AnysOrExpressions.
type OptAnysOrExpressions struct {
	Value AnysOrExpressions
	Set   bool
}

// IsSet returns true if OptAnysOrExpressions was set.
func (o OptAnysOrExpressions) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptAnysOrExpressions) Reset() {
	var v AnysOrExpressions
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptAnysOrExpressions) SetTo(v AnysOrExpressions) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptAnysOrExpressions) Get() (v AnysOrExpressions, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptAnysOrExpressions) Or(d AnysOrExpressions) AnysOrExpressions {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptBool returns new OptBool with value set to v.
func NewOptBool(v bool) OptBool {
	return OptBool{
		Value: v,
		Set:   true,
	}
}

// OptBool is optional bool.
type OptBool struct {
	Value bool
	Set   bool
}

// IsSet returns true if OptBool was set.
func (o OptBool) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptBool) Reset() {
	var v bool
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptBool) SetTo(v bool) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptBool) Get() (v bool, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptBool) Or(d bool) bool {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptCallbacksOrReferences returns new OptCallbacksOrReferences with value set to v.
func NewOptCallbacksOrReferences(v CallbacksOrReferences) OptCallbacksOrReferences {
	return OptCallbacksOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptCallbacksOrReferences is optional CallbacksOrReferences.
type OptCallbacksOrReferences struct {
	Value CallbacksOrReferences
	Set   bool
}

// IsSet returns true if OptCallbacksOrReferences was set.
func (o OptCallbacksOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptCallbacksOrReferences) Reset() {
	var v CallbacksOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptCallbacksOrReferences) SetTo(v CallbacksOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptCallbacksOrReferences) Get() (v CallbacksOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptCallbacksOrReferences) Or(d CallbacksOrReferences) CallbacksOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptComponents returns new OptComponents with value set to v.
func NewOptComponents(v Components) OptComponents {
	return OptComponents{
		Value: v,
		Set:   true,
	}
}

// OptComponents is optional Components.
type OptComponents struct {
	Value Components
	Set   bool
}

// IsSet returns true if OptComponents was set.
func (o OptComponents) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptComponents) Reset() {
	var v Components
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptComponents) SetTo(v Components) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptComponents) Get() (v Components, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptComponents) Or(d Components) Components {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptContact returns new OptContact with value set to v.
func NewOptContact(v Contact) OptContact {
	return OptContact{
		Value: v,
		Set:   true,
	}
}

// OptContact is optional Contact.
type OptContact struct {
	Value Contact
	Set   bool
}

// IsSet returns true if OptContact was set.
func (o OptContact) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptContact) Reset() {
	var v Contact
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptContact) SetTo(v Contact) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptContact) Get() (v Contact, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptContact) Or(d Contact) Contact {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDiscriminator returns new OptDiscriminator with value set to v.
func NewOptDiscriminator(v Discriminator) OptDiscriminator {
	return OptDiscriminator{
		Value: v,
		Set:   true,
	}
}

// OptDiscriminator is optional Discriminator.
type OptDiscriminator struct {
	Value Discriminator
	Set   bool
}

// IsSet returns true if OptDiscriminator was set.
func (o OptDiscriminator) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDiscriminator) Reset() {
	var v Discriminator
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDiscriminator) SetTo(v Discriminator) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDiscriminator) Get() (v Discriminator, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDiscriminator) Or(d Discriminator) Discriminator {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptEncodings returns new OptEncodings with value set to v.
func NewOptEncodings(v Encodings) OptEncodings {
	return OptEncodings{
		Value: v,
		Set:   true,
	}
}

// OptEncodings is optional Encodings.
type OptEncodings struct {
	Value Encodings
	Set   bool
}

// IsSet returns true if OptEncodings was set.
func (o OptEncodings) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptEncodings) Reset() {
	var v Encodings
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptEncodings) SetTo(v Encodings) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptEncodings) Get() (v Encodings, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptEncodings) Or(d Encodings) Encodings {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptExamplesOrReferences returns new OptExamplesOrReferences with value set to v.
func NewOptExamplesOrReferences(v ExamplesOrReferences) OptExamplesOrReferences {
	return OptExamplesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptExamplesOrReferences is optional ExamplesOrReferences.
type OptExamplesOrReferences struct {
	Value ExamplesOrReferences
	Set   bool
}

// IsSet returns true if OptExamplesOrReferences was set.
func (o OptExamplesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptExamplesOrReferences) Reset() {
	var v ExamplesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptExamplesOrReferences) SetTo(v ExamplesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptExamplesOrReferences) Get() (v ExamplesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptExamplesOrReferences) Or(d ExamplesOrReferences) ExamplesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptExternalDocs returns new OptExternalDocs with value set to v.
func NewOptExternalDocs(v ExternalDocs) OptExternalDocs {
	return OptExternalDocs{
		Value: v,
		Set:   true,
	}
}

// OptExternalDocs is optional ExternalDocs.
type OptExternalDocs struct {
	Value ExternalDocs
	Set   bool
}

// IsSet returns true if OptExternalDocs was set.
func (o OptExternalDocs) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptExternalDocs) Reset() {
	var v ExternalDocs
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptExternalDocs) SetTo(v ExternalDocs) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptExternalDocs) Get() (v ExternalDocs, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptExternalDocs) Or(d ExternalDocs) ExternalDocs {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptHeadersOrReferences returns new OptHeadersOrReferences with value set to v.
func NewOptHeadersOrReferences(v HeadersOrReferences) OptHeadersOrReferences {
	return OptHeadersOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptHeadersOrReferences is optional HeadersOrReferences.
type OptHeadersOrReferences struct {
	Value HeadersOrReferences
	Set   bool
}

// IsSet returns true if OptHeadersOrReferences was set.
func (o OptHeadersOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptHeadersOrReferences) Reset() {
	var v HeadersOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptHeadersOrReferences) SetTo(v HeadersOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptHeadersOrReferences) Get() (v HeadersOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptHeadersOrReferences) Or(d HeadersOrReferences) HeadersOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesExclusiveMaximum returns new OptJsonschemaDraft4PropertiesExclusiveMaximum with value set to v.
func NewOptJsonschemaDraft4PropertiesExclusiveMaximum(v JsonschemaDraft4PropertiesExclusiveMaximum) OptJsonschemaDraft4PropertiesExclusiveMaximum {
	return OptJsonschemaDraft4PropertiesExclusiveMaximum{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesExclusiveMaximum is optional JsonschemaDraft4PropertiesExclusiveMaximum.
type OptJsonschemaDraft4PropertiesExclusiveMaximum struct {
	Value JsonschemaDraft4PropertiesExclusiveMaximum
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesExclusiveMaximum was set.
func (o OptJsonschemaDraft4PropertiesExclusiveMaximum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesExclusiveMaximum) Reset() {
	var v JsonschemaDraft4PropertiesExclusiveMaximum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesExclusiveMaximum) SetTo(v JsonschemaDraft4PropertiesExclusiveMaximum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesExclusiveMaximum) Get() (v JsonschemaDraft4PropertiesExclusiveMaximum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesExclusiveMaximum) Or(d JsonschemaDraft4PropertiesExclusiveMaximum) JsonschemaDraft4PropertiesExclusiveMaximum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesExclusiveMinimum returns new OptJsonschemaDraft4PropertiesExclusiveMinimum with value set to v.
func NewOptJsonschemaDraft4PropertiesExclusiveMinimum(v JsonschemaDraft4PropertiesExclusiveMinimum) OptJsonschemaDraft4PropertiesExclusiveMinimum {
	return OptJsonschemaDraft4PropertiesExclusiveMinimum{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesExclusiveMinimum is optional JsonschemaDraft4PropertiesExclusiveMinimum.
type OptJsonschemaDraft4PropertiesExclusiveMinimum struct {
	Value JsonschemaDraft4PropertiesExclusiveMinimum
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesExclusiveMinimum was set.
func (o OptJsonschemaDraft4PropertiesExclusiveMinimum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesExclusiveMinimum) Reset() {
	var v JsonschemaDraft4PropertiesExclusiveMinimum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesExclusiveMinimum) SetTo(v JsonschemaDraft4PropertiesExclusiveMinimum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesExclusiveMinimum) Get() (v JsonschemaDraft4PropertiesExclusiveMinimum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesExclusiveMinimum) Or(d JsonschemaDraft4PropertiesExclusiveMinimum) JsonschemaDraft4PropertiesExclusiveMinimum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesMaximum returns new OptJsonschemaDraft4PropertiesMaximum with value set to v.
func NewOptJsonschemaDraft4PropertiesMaximum(v JsonschemaDraft4PropertiesMaximum) OptJsonschemaDraft4PropertiesMaximum {
	return OptJsonschemaDraft4PropertiesMaximum{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesMaximum is optional JsonschemaDraft4PropertiesMaximum.
type OptJsonschemaDraft4PropertiesMaximum struct {
	Value JsonschemaDraft4PropertiesMaximum
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesMaximum was set.
func (o OptJsonschemaDraft4PropertiesMaximum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesMaximum) Reset() {
	var v JsonschemaDraft4PropertiesMaximum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesMaximum) SetTo(v JsonschemaDraft4PropertiesMaximum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesMaximum) Get() (v JsonschemaDraft4PropertiesMaximum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesMaximum) Or(d JsonschemaDraft4PropertiesMaximum) JsonschemaDraft4PropertiesMaximum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesMinimum returns new OptJsonschemaDraft4PropertiesMinimum with value set to v.
func NewOptJsonschemaDraft4PropertiesMinimum(v JsonschemaDraft4PropertiesMinimum) OptJsonschemaDraft4PropertiesMinimum {
	return OptJsonschemaDraft4PropertiesMinimum{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesMinimum is optional JsonschemaDraft4PropertiesMinimum.
type OptJsonschemaDraft4PropertiesMinimum struct {
	Value JsonschemaDraft4PropertiesMinimum
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesMinimum was set.
func (o OptJsonschemaDraft4PropertiesMinimum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesMinimum) Reset() {
	var v JsonschemaDraft4PropertiesMinimum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesMinimum) SetTo(v JsonschemaDraft4PropertiesMinimum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesMinimum) Get() (v JsonschemaDraft4PropertiesMinimum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesMinimum) Or(d JsonschemaDraft4PropertiesMinimum) JsonschemaDraft4PropertiesMinimum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesMultipleOf returns new OptJsonschemaDraft4PropertiesMultipleOf with value set to v.
func NewOptJsonschemaDraft4PropertiesMultipleOf(v JsonschemaDraft4PropertiesMultipleOf) OptJsonschemaDraft4PropertiesMultipleOf {
	return OptJsonschemaDraft4PropertiesMultipleOf{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesMultipleOf is optional JsonschemaDraft4PropertiesMultipleOf.
type OptJsonschemaDraft4PropertiesMultipleOf struct {
	Value JsonschemaDraft4PropertiesMultipleOf
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesMultipleOf was set.
func (o OptJsonschemaDraft4PropertiesMultipleOf) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesMultipleOf) Reset() {
	var v JsonschemaDraft4PropertiesMultipleOf
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesMultipleOf) SetTo(v JsonschemaDraft4PropertiesMultipleOf) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesMultipleOf) Get() (v JsonschemaDraft4PropertiesMultipleOf, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesMultipleOf) Or(d JsonschemaDraft4PropertiesMultipleOf) JsonschemaDraft4PropertiesMultipleOf {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesPattern returns new OptJsonschemaDraft4PropertiesPattern with value set to v.
func NewOptJsonschemaDraft4PropertiesPattern(v JsonschemaDraft4PropertiesPattern) OptJsonschemaDraft4PropertiesPattern {
	return OptJsonschemaDraft4PropertiesPattern{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesPattern is optional JsonschemaDraft4PropertiesPattern.
type OptJsonschemaDraft4PropertiesPattern struct {
	Value JsonschemaDraft4PropertiesPattern
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesPattern was set.
func (o OptJsonschemaDraft4PropertiesPattern) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesPattern) Reset() {
	var v JsonschemaDraft4PropertiesPattern
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesPattern) SetTo(v JsonschemaDraft4PropertiesPattern) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesPattern) Get() (v JsonschemaDraft4PropertiesPattern, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesPattern) Or(d JsonschemaDraft4PropertiesPattern) JsonschemaDraft4PropertiesPattern {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesTitle returns new OptJsonschemaDraft4PropertiesTitle with value set to v.
func NewOptJsonschemaDraft4PropertiesTitle(v JsonschemaDraft4PropertiesTitle) OptJsonschemaDraft4PropertiesTitle {
	return OptJsonschemaDraft4PropertiesTitle{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesTitle is optional JsonschemaDraft4PropertiesTitle.
type OptJsonschemaDraft4PropertiesTitle struct {
	Value JsonschemaDraft4PropertiesTitle
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesTitle was set.
func (o OptJsonschemaDraft4PropertiesTitle) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesTitle) Reset() {
	var v JsonschemaDraft4PropertiesTitle
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesTitle) SetTo(v JsonschemaDraft4PropertiesTitle) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesTitle) Get() (v JsonschemaDraft4PropertiesTitle, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesTitle) Or(d JsonschemaDraft4PropertiesTitle) JsonschemaDraft4PropertiesTitle {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptJsonschemaDraft4PropertiesUniqueItems returns new OptJsonschemaDraft4PropertiesUniqueItems with value set to v.
func NewOptJsonschemaDraft4PropertiesUniqueItems(v JsonschemaDraft4PropertiesUniqueItems) OptJsonschemaDraft4PropertiesUniqueItems {
	return OptJsonschemaDraft4PropertiesUniqueItems{
		Value: v,
		Set:   true,
	}
}

// OptJsonschemaDraft4PropertiesUniqueItems is optional JsonschemaDraft4PropertiesUniqueItems.
type OptJsonschemaDraft4PropertiesUniqueItems struct {
	Value JsonschemaDraft4PropertiesUniqueItems
	Set   bool
}

// IsSet returns true if OptJsonschemaDraft4PropertiesUniqueItems was set.
func (o OptJsonschemaDraft4PropertiesUniqueItems) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptJsonschemaDraft4PropertiesUniqueItems) Reset() {
	var v JsonschemaDraft4PropertiesUniqueItems
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptJsonschemaDraft4PropertiesUniqueItems) SetTo(v JsonschemaDraft4PropertiesUniqueItems) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptJsonschemaDraft4PropertiesUniqueItems) Get() (v JsonschemaDraft4PropertiesUniqueItems, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptJsonschemaDraft4PropertiesUniqueItems) Or(d JsonschemaDraft4PropertiesUniqueItems) JsonschemaDraft4PropertiesUniqueItems {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptLicense returns new OptLicense with value set to v.
func NewOptLicense(v License) OptLicense {
	return OptLicense{
		Value: v,
		Set:   true,
	}
}

// OptLicense is optional License.
type OptLicense struct {
	Value License
	Set   bool
}

// IsSet returns true if OptLicense was set.
func (o OptLicense) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptLicense) Reset() {
	var v License
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptLicense) SetTo(v License) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptLicense) Get() (v License, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptLicense) Or(d License) License {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptLinksOrReferences returns new OptLinksOrReferences with value set to v.
func NewOptLinksOrReferences(v LinksOrReferences) OptLinksOrReferences {
	return OptLinksOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptLinksOrReferences is optional LinksOrReferences.
type OptLinksOrReferences struct {
	Value LinksOrReferences
	Set   bool
}

// IsSet returns true if OptLinksOrReferences was set.
func (o OptLinksOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptLinksOrReferences) Reset() {
	var v LinksOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptLinksOrReferences) SetTo(v LinksOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptLinksOrReferences) Get() (v LinksOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptLinksOrReferences) Or(d LinksOrReferences) LinksOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptMediaTypes returns new OptMediaTypes with value set to v.
func NewOptMediaTypes(v MediaTypes) OptMediaTypes {
	return OptMediaTypes{
		Value: v,
		Set:   true,
	}
}

// OptMediaTypes is optional MediaTypes.
type OptMediaTypes struct {
	Value MediaTypes
	Set   bool
}

// IsSet returns true if OptMediaTypes was set.
func (o OptMediaTypes) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptMediaTypes) Reset() {
	var v MediaTypes
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptMediaTypes) SetTo(v MediaTypes) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptMediaTypes) Get() (v MediaTypes, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptMediaTypes) Or(d MediaTypes) MediaTypes {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptOauthFlow returns new OptOauthFlow with value set to v.
func NewOptOauthFlow(v OauthFlow) OptOauthFlow {
	return OptOauthFlow{
		Value: v,
		Set:   true,
	}
}

// OptOauthFlow is optional OauthFlow.
type OptOauthFlow struct {
	Value OauthFlow
	Set   bool
}

// IsSet returns true if OptOauthFlow was set.
func (o OptOauthFlow) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptOauthFlow) Reset() {
	var v OauthFlow
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptOauthFlow) SetTo(v OauthFlow) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptOauthFlow) Get() (v OauthFlow, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptOauthFlow) Or(d OauthFlow) OauthFlow {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptOauthFlows returns new OptOauthFlows with value set to v.
func NewOptOauthFlows(v OauthFlows) OptOauthFlows {
	return OptOauthFlows{
		Value: v,
		Set:   true,
	}
}

// OptOauthFlows is optional OauthFlows.
type OptOauthFlows struct {
	Value OauthFlows
	Set   bool
}

// IsSet returns true if OptOauthFlows was set.
func (o OptOauthFlows) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptOauthFlows) Reset() {
	var v OauthFlows
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptOauthFlows) SetTo(v OauthFlows) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptOauthFlows) Get() (v OauthFlows, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptOauthFlows) Or(d OauthFlows) OauthFlows {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptOperation returns new OptOperation with value set to v.
func NewOptOperation(v Operation) OptOperation {
	return OptOperation{
		Value: v,
		Set:   true,
	}
}

// OptOperation is optional Operation.
type OptOperation struct {
	Value Operation
	Set   bool
}

// IsSet returns true if OptOperation was set.
func (o OptOperation) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptOperation) Reset() {
	var v Operation
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptOperation) SetTo(v Operation) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptOperation) Get() (v Operation, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptOperation) Or(d Operation) Operation {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptParameterStyle returns new OptParameterStyle with value set to v.
func NewOptParameterStyle(v ParameterStyle) OptParameterStyle {
	return OptParameterStyle{
		Value: v,
		Set:   true,
	}
}

// OptParameterStyle is optional ParameterStyle.
type OptParameterStyle struct {
	Value ParameterStyle
	Set   bool
}

// IsSet returns true if OptParameterStyle was set.
func (o OptParameterStyle) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptParameterStyle) Reset() {
	var v ParameterStyle
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptParameterStyle) SetTo(v ParameterStyle) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptParameterStyle) Get() (v ParameterStyle, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptParameterStyle) Or(d ParameterStyle) ParameterStyle {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptParametersOrReferences returns new OptParametersOrReferences with value set to v.
func NewOptParametersOrReferences(v ParametersOrReferences) OptParametersOrReferences {
	return OptParametersOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptParametersOrReferences is optional ParametersOrReferences.
type OptParametersOrReferences struct {
	Value ParametersOrReferences
	Set   bool
}

// IsSet returns true if OptParametersOrReferences was set.
func (o OptParametersOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptParametersOrReferences) Reset() {
	var v ParametersOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptParametersOrReferences) SetTo(v ParametersOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptParametersOrReferences) Get() (v ParametersOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptParametersOrReferences) Or(d ParametersOrReferences) ParametersOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptPositiveInteger returns new OptPositiveInteger with value set to v.
func NewOptPositiveInteger(v PositiveInteger) OptPositiveInteger {
	return OptPositiveInteger{
		Value: v,
		Set:   true,
	}
}

// OptPositiveInteger is optional PositiveInteger.
type OptPositiveInteger struct {
	Value PositiveInteger
	Set   bool
}

// IsSet returns true if OptPositiveInteger was set.
func (o OptPositiveInteger) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptPositiveInteger) Reset() {
	var v PositiveInteger
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptPositiveInteger) SetTo(v PositiveInteger) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptPositiveInteger) Get() (v PositiveInteger, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptPositiveInteger) Or(d PositiveInteger) PositiveInteger {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptRequestBodiesOrReferences returns new OptRequestBodiesOrReferences with value set to v.
func NewOptRequestBodiesOrReferences(v RequestBodiesOrReferences) OptRequestBodiesOrReferences {
	return OptRequestBodiesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptRequestBodiesOrReferences is optional RequestBodiesOrReferences.
type OptRequestBodiesOrReferences struct {
	Value RequestBodiesOrReferences
	Set   bool
}

// IsSet returns true if OptRequestBodiesOrReferences was set.
func (o OptRequestBodiesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptRequestBodiesOrReferences) Reset() {
	var v RequestBodiesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptRequestBodiesOrReferences) SetTo(v RequestBodiesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptRequestBodiesOrReferences) Get() (v RequestBodiesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptRequestBodiesOrReferences) Or(d RequestBodiesOrReferences) RequestBodiesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptRequestBodyOrReference returns new OptRequestBodyOrReference with value set to v.
func NewOptRequestBodyOrReference(v RequestBodyOrReference) OptRequestBodyOrReference {
	return OptRequestBodyOrReference{
		Value: v,
		Set:   true,
	}
}

// OptRequestBodyOrReference is optional RequestBodyOrReference.
type OptRequestBodyOrReference struct {
	Value RequestBodyOrReference
	Set   bool
}

// IsSet returns true if OptRequestBodyOrReference was set.
func (o OptRequestBodyOrReference) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptRequestBodyOrReference) Reset() {
	var v RequestBodyOrReference
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptRequestBodyOrReference) SetTo(v RequestBodyOrReference) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptRequestBodyOrReference) Get() (v RequestBodyOrReference, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptRequestBodyOrReference) Or(d RequestBodyOrReference) RequestBodyOrReference {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptResponseOrReference returns new OptResponseOrReference with value set to v.
func NewOptResponseOrReference(v ResponseOrReference) OptResponseOrReference {
	return OptResponseOrReference{
		Value: v,
		Set:   true,
	}
}

// OptResponseOrReference is optional ResponseOrReference.
type OptResponseOrReference struct {
	Value ResponseOrReference
	Set   bool
}

// IsSet returns true if OptResponseOrReference was set.
func (o OptResponseOrReference) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptResponseOrReference) Reset() {
	var v ResponseOrReference
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptResponseOrReference) SetTo(v ResponseOrReference) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptResponseOrReference) Get() (v ResponseOrReference, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptResponseOrReference) Or(d ResponseOrReference) ResponseOrReference {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptResponsesOrReferences returns new OptResponsesOrReferences with value set to v.
func NewOptResponsesOrReferences(v ResponsesOrReferences) OptResponsesOrReferences {
	return OptResponsesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptResponsesOrReferences is optional ResponsesOrReferences.
type OptResponsesOrReferences struct {
	Value ResponsesOrReferences
	Set   bool
}

// IsSet returns true if OptResponsesOrReferences was set.
func (o OptResponsesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptResponsesOrReferences) Reset() {
	var v ResponsesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptResponsesOrReferences) SetTo(v ResponsesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptResponsesOrReferences) Get() (v ResponsesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptResponsesOrReferences) Or(d ResponsesOrReferences) ResponsesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptSchemaOrReference returns new OptSchemaOrReference with value set to v.
func NewOptSchemaOrReference(v SchemaOrReference) OptSchemaOrReference {
	return OptSchemaOrReference{
		Value: v,
		Set:   true,
	}
}

// OptSchemaOrReference is optional SchemaOrReference.
type OptSchemaOrReference struct {
	Value SchemaOrReference
	Set   bool
}

// IsSet returns true if OptSchemaOrReference was set.
func (o OptSchemaOrReference) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptSchemaOrReference) Reset() {
	var v SchemaOrReference
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptSchemaOrReference) SetTo(v SchemaOrReference) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptSchemaOrReference) Get() (v SchemaOrReference, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptSchemaOrReference) Or(d SchemaOrReference) SchemaOrReference {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptSchemaProperties returns new OptSchemaProperties with value set to v.
func NewOptSchemaProperties(v SchemaProperties) OptSchemaProperties {
	return OptSchemaProperties{
		Value: v,
		Set:   true,
	}
}

// OptSchemaProperties is optional SchemaProperties.
type OptSchemaProperties struct {
	Value SchemaProperties
	Set   bool
}

// IsSet returns true if OptSchemaProperties was set.
func (o OptSchemaProperties) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptSchemaProperties) Reset() {
	var v SchemaProperties
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptSchemaProperties) SetTo(v SchemaProperties) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptSchemaProperties) Get() (v SchemaProperties, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptSchemaProperties) Or(d SchemaProperties) SchemaProperties {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptSchemaType returns new OptSchemaType with value set to v.
func NewOptSchemaType(v SchemaType) OptSchemaType {
	return OptSchemaType{
		Value: v,
		Set:   true,
	}
}

// OptSchemaType is optional SchemaType.
type OptSchemaType struct {
	Value SchemaType
	Set   bool
}

// IsSet returns true if OptSchemaType was set.
func (o OptSchemaType) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptSchemaType) Reset() {
	var v SchemaType
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptSchemaType) SetTo(v SchemaType) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptSchemaType) Get() (v SchemaType, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptSchemaType) Or(d SchemaType) SchemaType {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptSchemasOrReferences returns new OptSchemasOrReferences with value set to v.
func NewOptSchemasOrReferences(v SchemasOrReferences) OptSchemasOrReferences {
	return OptSchemasOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptSchemasOrReferences is optional SchemasOrReferences.
type OptSchemasOrReferences struct {
	Value SchemasOrReferences
	Set   bool
}

// IsSet returns true if OptSchemasOrReferences was set.
func (o OptSchemasOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptSchemasOrReferences) Reset() {
	var v SchemasOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptSchemasOrReferences) SetTo(v SchemasOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptSchemasOrReferences) Get() (v SchemasOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptSchemasOrReferences) Or(d SchemasOrReferences) SchemasOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptSecuritySchemesOrReferences returns new OptSecuritySchemesOrReferences with value set to v.
func NewOptSecuritySchemesOrReferences(v SecuritySchemesOrReferences) OptSecuritySchemesOrReferences {
	return OptSecuritySchemesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptSecuritySchemesOrReferences is optional SecuritySchemesOrReferences.
type OptSecuritySchemesOrReferences struct {
	Value SecuritySchemesOrReferences
	Set   bool
}

// IsSet returns true if OptSecuritySchemesOrReferences was set.
func (o OptSecuritySchemesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptSecuritySchemesOrReferences) Reset() {
	var v SecuritySchemesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptSecuritySchemesOrReferences) SetTo(v SecuritySchemesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptSecuritySchemesOrReferences) Get() (v SecuritySchemesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptSecuritySchemesOrReferences) Or(d SecuritySchemesOrReferences) SecuritySchemesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptServer returns new OptServer with value set to v.
func NewOptServer(v Server) OptServer {
	return OptServer{
		Value: v,
		Set:   true,
	}
}

// OptServer is optional Server.
type OptServer struct {
	Value Server
	Set   bool
}

// IsSet returns true if OptServer was set.
func (o OptServer) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptServer) Reset() {
	var v Server
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptServer) SetTo(v Server) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptServer) Get() (v Server, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptServer) Or(d Server) Server {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptServerVariables returns new OptServerVariables with value set to v.
func NewOptServerVariables(v ServerVariables) OptServerVariables {
	return OptServerVariables{
		Value: v,
		Set:   true,
	}
}

// OptServerVariables is optional ServerVariables.
type OptServerVariables struct {
	Value ServerVariables
	Set   bool
}

// IsSet returns true if OptServerVariables was set.
func (o OptServerVariables) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptServerVariables) Reset() {
	var v ServerVariables
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptServerVariables) SetTo(v ServerVariables) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptServerVariables) Get() (v ServerVariables, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptServerVariables) Or(d ServerVariables) ServerVariables {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptString returns new OptString with value set to v.
func NewOptString(v string) OptString {
	return OptString{
		Value: v,
		Set:   true,
	}
}

// OptString is optional string.
type OptString struct {
	Value string
	Set   bool
}

// IsSet returns true if OptString was set.
func (o OptString) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptString) Reset() {
	var v string
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptString) SetTo(v string) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptString) Get() (v string, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptString) Or(d string) string {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptStrings returns new OptStrings with value set to v.
func NewOptStrings(v Strings) OptStrings {
	return OptStrings{
		Value: v,
		Set:   true,
	}
}

// OptStrings is optional Strings.
type OptStrings struct {
	Value Strings
	Set   bool
}

// IsSet returns true if OptStrings was set.
func (o OptStrings) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptStrings) Reset() {
	var v Strings
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptStrings) SetTo(v Strings) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptStrings) Get() (v Strings, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptStrings) Or(d Strings) Strings {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptXML returns new OptXML with value set to v.
func NewOptXML(v XML) OptXML {
	return OptXML{
		Value: v,
		Set:   true,
	}
}

// OptXML is optional XML.
type OptXML struct {
	Value XML
	Set   bool
}

// IsSet returns true if OptXML was set.
func (o OptXML) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptXML) Reset() {
	var v XML
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptXML) SetTo(v XML) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptXML) Get() (v XML, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptXML) Or(d XML) XML {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// Describes a single operation parameter.  A unique parameter is defined by a combination of a name
// and location.
// Ref: #/definitions/parameter
type Parameter struct {
	Name            string                  "json:\"name\""
	In              ParameterIn             "json:\"in\""
	Description     OptString               "json:\"description\""
	Required        OptBool                 "json:\"required\""
	Deprecated      OptBool                 "json:\"deprecated\""
	AllowEmptyValue OptBool                 "json:\"allowEmptyValue\""
	Style           OptParameterStyle       "json:\"style\""
	Explode         OptBool                 "json:\"explode\""
	AllowReserved   OptBool                 "json:\"allowReserved\""
	Schema          OptSchemaOrReference    "json:\"schema\""
	Example         jx.Raw                  "json:\"example\""
	Examples        OptExamplesOrReferences "json:\"examples\""
	Content         OptMediaTypes           "json:\"content\""
	// Pattern: "^x-".
	Pattern0Props ParameterPattern0
}

type ParameterIn string

const (
	ParameterInPath   ParameterIn = "path"
	ParameterInQuery  ParameterIn = "query"
	ParameterInCookie ParameterIn = "cookie"
	ParameterInHeader ParameterIn = "header"
)

// Ref: #/definitions/parameterOrReference
// ParameterOrReference represents sum type.
type ParameterOrReference struct {
	Type      ParameterOrReferenceType // switch on this field
	Parameter Parameter
	Reference Reference
}

// ParameterOrReferenceType is oneOf type of ParameterOrReference.
type ParameterOrReferenceType string

// Possible values for ParameterOrReferenceType.
const (
	ParameterParameterOrReference ParameterOrReferenceType = "Parameter"
	ReferenceParameterOrReference ParameterOrReferenceType = "Reference"
)

// IsParameter reports whether ParameterOrReference is Parameter.
func (s ParameterOrReference) IsParameter() bool { return s.Type == ParameterParameterOrReference }

// IsReference reports whether ParameterOrReference is Reference.
func (s ParameterOrReference) IsReference() bool { return s.Type == ReferenceParameterOrReference }

// SetParameter sets ParameterOrReference to Parameter.
func (s *ParameterOrReference) SetParameter(v Parameter) {
	s.Type = ParameterParameterOrReference
	s.Parameter = v
}

// GetParameter returns Parameter and true boolean if ParameterOrReference is Parameter.
func (s ParameterOrReference) GetParameter() (v Parameter, ok bool) {
	if !s.IsParameter() {
		return v, false
	}
	return s.Parameter, true
}

// NewParameterParameterOrReference returns new ParameterOrReference from Parameter.
func NewParameterParameterOrReference(v Parameter) ParameterOrReference {
	var s ParameterOrReference
	s.SetParameter(v)
	return s
}

// SetReference sets ParameterOrReference to Reference.
func (s *ParameterOrReference) SetReference(v Reference) {
	s.Type = ReferenceParameterOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if ParameterOrReference is Reference.
func (s ParameterOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceParameterOrReference returns new ParameterOrReference from Reference.
func NewReferenceParameterOrReference(v Reference) ParameterOrReference {
	var s ParameterOrReference
	s.SetReference(v)
	return s
}

type ParameterPattern0 map[string]jx.Raw

func (s *ParameterPattern0) init() ParameterPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type ParameterStyle string

const (
	ParameterStyleMatrix         ParameterStyle = "matrix"
	ParameterStyleLabel          ParameterStyle = "label"
	ParameterStyleForm           ParameterStyle = "form"
	ParameterStyleSimple         ParameterStyle = "simple"
	ParameterStyleSpaceDelimited ParameterStyle = "spaceDelimited"
	ParameterStylePipeDelimited  ParameterStyle = "pipeDelimited"
	ParameterStyleDeepObject     ParameterStyle = "deepObject"
)

// Ref: #/definitions/parametersOrReferences
type ParametersOrReferences map[string]ParameterOrReference

func (s *ParametersOrReferences) init() ParametersOrReferences {
	m := *s
	if m == nil {
		m = map[string]ParameterOrReference{}
		*s = m
	}
	return m
}

// Describes the operations available on a single path. A Path Item MAY be empty, due to ACL
// constraints. The path itself is still exposed to the documentation viewer but they will not know
// which operations and parameters are available.
// Ref: #/definitions/pathItem
type PathItem struct {
	Ref         OptString              "json:\"$ref\""
	Summary     OptString              "json:\"summary\""
	Description OptString              "json:\"description\""
	Get         OptOperation           "json:\"get\""
	Put         OptOperation           "json:\"put\""
	Post        OptOperation           "json:\"post\""
	Delete      OptOperation           "json:\"delete\""
	Options     OptOperation           "json:\"options\""
	Head        OptOperation           "json:\"head\""
	Patch       OptOperation           "json:\"patch\""
	Trace       OptOperation           "json:\"trace\""
	Servers     []Server               "json:\"servers\""
	Parameters  []ParameterOrReference "json:\"parameters\""
	// Pattern: "^x-".
	Pattern0Props PathItemPattern0
}

type PathItemPattern0 map[string]jx.Raw

func (s *PathItemPattern0) init() PathItemPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Holds the relative paths to the individual endpoints and their operations. The path is appended to
// the URL from the `Server Object` in order to construct the full URL.  The Paths MAY be empty, due
// to ACL constraints.
// Ref: #/definitions/paths
type Paths struct {
	// Pattern: "^/".
	Pattern0Props PathsPattern0
	// Pattern: "^x-".
	Pattern1Props PathsPattern1
}

type PathsPattern0 map[string]PathItem

func (s *PathsPattern0) init() PathsPattern0 {
	m := *s
	if m == nil {
		m = map[string]PathItem{}
		*s = m
	}
	return m
}

type PathsPattern1 map[string]jx.Raw

func (s *PathsPattern1) init() PathsPattern1 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type PositiveInteger int

// A simple object to allow referencing other components in the specification, internally and
// externally.  The Reference Object is defined by JSON Reference and follows the same structure,
// behavior and rules.   For this specification, reference resolution is accomplished as defined by
// the JSON Reference specification and not by the JSON Schema specification.
// Ref: #/definitions/reference
type Reference struct {
	Ref string "json:\"$ref\""
}

// Ref: #/definitions/requestBodiesOrReferences
type RequestBodiesOrReferences map[string]RequestBodyOrReference

func (s *RequestBodiesOrReferences) init() RequestBodiesOrReferences {
	m := *s
	if m == nil {
		m = map[string]RequestBodyOrReference{}
		*s = m
	}
	return m
}

// Describes a single request body.
// Ref: #/definitions/requestBody
type RequestBody struct {
	Description OptString  "json:\"description\""
	Content     MediaTypes "json:\"content\""
	Required    OptBool    "json:\"required\""
	// Pattern: "^x-".
	Pattern0Props RequestBodyPattern0
}

// Ref: #/definitions/requestBodyOrReference
// RequestBodyOrReference represents sum type.
type RequestBodyOrReference struct {
	Type        RequestBodyOrReferenceType // switch on this field
	RequestBody RequestBody
	Reference   Reference
}

// RequestBodyOrReferenceType is oneOf type of RequestBodyOrReference.
type RequestBodyOrReferenceType string

// Possible values for RequestBodyOrReferenceType.
const (
	RequestBodyRequestBodyOrReference RequestBodyOrReferenceType = "RequestBody"
	ReferenceRequestBodyOrReference   RequestBodyOrReferenceType = "Reference"
)

// IsRequestBody reports whether RequestBodyOrReference is RequestBody.
func (s RequestBodyOrReference) IsRequestBody() bool {
	return s.Type == RequestBodyRequestBodyOrReference
}

// IsReference reports whether RequestBodyOrReference is Reference.
func (s RequestBodyOrReference) IsReference() bool { return s.Type == ReferenceRequestBodyOrReference }

// SetRequestBody sets RequestBodyOrReference to RequestBody.
func (s *RequestBodyOrReference) SetRequestBody(v RequestBody) {
	s.Type = RequestBodyRequestBodyOrReference
	s.RequestBody = v
}

// GetRequestBody returns RequestBody and true boolean if RequestBodyOrReference is RequestBody.
func (s RequestBodyOrReference) GetRequestBody() (v RequestBody, ok bool) {
	if !s.IsRequestBody() {
		return v, false
	}
	return s.RequestBody, true
}

// NewRequestBodyRequestBodyOrReference returns new RequestBodyOrReference from RequestBody.
func NewRequestBodyRequestBodyOrReference(v RequestBody) RequestBodyOrReference {
	var s RequestBodyOrReference
	s.SetRequestBody(v)
	return s
}

// SetReference sets RequestBodyOrReference to Reference.
func (s *RequestBodyOrReference) SetReference(v Reference) {
	s.Type = ReferenceRequestBodyOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if RequestBodyOrReference is Reference.
func (s RequestBodyOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceRequestBodyOrReference returns new RequestBodyOrReference from Reference.
func NewReferenceRequestBodyOrReference(v Reference) RequestBodyOrReference {
	var s RequestBodyOrReference
	s.SetReference(v)
	return s
}

type RequestBodyPattern0 map[string]jx.Raw

func (s *RequestBodyPattern0) init() RequestBodyPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Describes a single response from an API Operation, including design-time, static  `links` to
// operations based on the response.
// Ref: #/definitions/response
type Response struct {
	Description string                 "json:\"description\""
	Headers     OptHeadersOrReferences "json:\"headers\""
	Content     OptMediaTypes          "json:\"content\""
	Links       OptLinksOrReferences   "json:\"links\""
	// Pattern: "^x-".
	Pattern0Props ResponsePattern0
}

// Ref: #/definitions/responseOrReference
// ResponseOrReference represents sum type.
type ResponseOrReference struct {
	Type      ResponseOrReferenceType // switch on this field
	Response  Response
	Reference Reference
}

// ResponseOrReferenceType is oneOf type of ResponseOrReference.
type ResponseOrReferenceType string

// Possible values for ResponseOrReferenceType.
const (
	ResponseResponseOrReference  ResponseOrReferenceType = "Response"
	ReferenceResponseOrReference ResponseOrReferenceType = "Reference"
)

// IsResponse reports whether ResponseOrReference is Response.
func (s ResponseOrReference) IsResponse() bool { return s.Type == ResponseResponseOrReference }

// IsReference reports whether ResponseOrReference is Reference.
func (s ResponseOrReference) IsReference() bool { return s.Type == ReferenceResponseOrReference }

// SetResponse sets ResponseOrReference to Response.
func (s *ResponseOrReference) SetResponse(v Response) {
	s.Type = ResponseResponseOrReference
	s.Response = v
}

// GetResponse returns Response and true boolean if ResponseOrReference is Response.
func (s ResponseOrReference) GetResponse() (v Response, ok bool) {
	if !s.IsResponse() {
		return v, false
	}
	return s.Response, true
}

// NewResponseResponseOrReference returns new ResponseOrReference from Response.
func NewResponseResponseOrReference(v Response) ResponseOrReference {
	var s ResponseOrReference
	s.SetResponse(v)
	return s
}

// SetReference sets ResponseOrReference to Reference.
func (s *ResponseOrReference) SetReference(v Reference) {
	s.Type = ReferenceResponseOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if ResponseOrReference is Reference.
func (s ResponseOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceResponseOrReference returns new ResponseOrReference from Reference.
func NewReferenceResponseOrReference(v Reference) ResponseOrReference {
	var s ResponseOrReference
	s.SetReference(v)
	return s
}

type ResponsePattern0 map[string]jx.Raw

func (s *ResponsePattern0) init() ResponsePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A container for the expected responses of an operation. The container maps a HTTP response code to
// the expected response.  The documentation is not necessarily expected to cover all possible HTTP
// response codes because they may not be known in advance. However, documentation is expected to
// cover a successful operation response and any known errors.  The `default` MAY be used as a
// default response object for all HTTP codes  that are not covered individually by the specification.
//   The `Responses Object` MUST contain at least one response code, and it  SHOULD be the response
// for a successful operation call.
// Ref: #/definitions/responses
type Responses struct {
	Default OptResponseOrReference "json:\"default\""
	// Pattern: "^([0-9X]{3})$".
	Pattern0Props ResponsesPattern0
	// Pattern: "^x-".
	Pattern1Props ResponsesPattern1
}

// Ref: #/definitions/responsesOrReferences
type ResponsesOrReferences map[string]ResponseOrReference

func (s *ResponsesOrReferences) init() ResponsesOrReferences {
	m := *s
	if m == nil {
		m = map[string]ResponseOrReference{}
		*s = m
	}
	return m
}

type ResponsesPattern0 map[string]ResponseOrReference

func (s *ResponsesPattern0) init() ResponsesPattern0 {
	m := *s
	if m == nil {
		m = map[string]ResponseOrReference{}
		*s = m
	}
	return m
}

type ResponsesPattern1 map[string]jx.Raw

func (s *ResponsesPattern1) init() ResponsesPattern1 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// The Schema Object allows the definition of input and output data types. These types can be objects,
//  but also primitives and arrays. This object is an extended subset of the JSON Schema
// Specification Wright Draft 00.  For more information about the properties, see JSON Schema Core
// and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON
// Schema.
// Ref: #/definitions/schema
type Schema struct {
	Nullable             OptBool                                       "json:\"nullable\""
	Discriminator        OptDiscriminator                              "json:\"discriminator\""
	ReadOnly             OptBool                                       "json:\"readOnly\""
	WriteOnly            OptBool                                       "json:\"writeOnly\""
	XML                  OptXML                                        "json:\"xml\""
	ExternalDocs         OptExternalDocs                               "json:\"externalDocs\""
	Example              jx.Raw                                        "json:\"example\""
	Deprecated           OptBool                                       "json:\"deprecated\""
	Title                OptJsonschemaDraft4PropertiesTitle            "json:\"title\""
	MultipleOf           OptJsonschemaDraft4PropertiesMultipleOf       "json:\"multipleOf\""
	Maximum              OptJsonschemaDraft4PropertiesMaximum          "json:\"maximum\""
	ExclusiveMaximum     OptJsonschemaDraft4PropertiesExclusiveMaximum "json:\"exclusiveMaximum\""
	Minimum              OptJsonschemaDraft4PropertiesMinimum          "json:\"minimum\""
	ExclusiveMinimum     OptJsonschemaDraft4PropertiesExclusiveMinimum "json:\"exclusiveMinimum\""
	MaxLength            OptPositiveInteger                            "json:\"maxLength\""
	MinLength            OptPositiveInteger                            "json:\"minLength\""
	Pattern              OptJsonschemaDraft4PropertiesPattern          "json:\"pattern\""
	MaxItems             OptPositiveInteger                            "json:\"maxItems\""
	MinItems             OptPositiveInteger                            "json:\"minItems\""
	UniqueItems          OptJsonschemaDraft4PropertiesUniqueItems      "json:\"uniqueItems\""
	MaxProperties        OptPositiveInteger                            "json:\"maxProperties\""
	MinProperties        OptPositiveInteger                            "json:\"minProperties\""
	Required             *StringArray                                  "json:\"required\""
	Enum                 *JsonschemaDraft4PropertiesEnum               "json:\"enum\""
	Type                 OptSchemaType                                 "json:\"type\""
	AllOf                []SchemaOrReference                           "json:\"allOf\""
	OneOf                []SchemaOrReference                           "json:\"oneOf\""
	AnyOf                []SchemaOrReference                           "json:\"anyOf\""
	Not                  *Schema                                       "json:\"not\""
	Items                *SchemaOrReference                            "json:\"items\""
	Properties           OptSchemaProperties                           "json:\"properties\""
	AdditionalProperties *SchemaAdditionalProperties                   "json:\"additionalProperties\""
	Default              jx.Raw                                        "json:\"default\""
	Description          OptString                                     "json:\"description\""
	Format               OptString                                     "json:\"format\""
	// Pattern: "^x-".
	Pattern0Props SchemaPattern0
}

// SchemaAdditionalProperties represents sum type.
type SchemaAdditionalProperties struct {
	Type              SchemaAdditionalPropertiesType // switch on this field
	SchemaOrReference SchemaOrReference
	Bool              bool
}

// SchemaAdditionalPropertiesType is oneOf type of SchemaAdditionalProperties.
type SchemaAdditionalPropertiesType string

// Possible values for SchemaAdditionalPropertiesType.
const (
	SchemaOrReferenceSchemaAdditionalProperties SchemaAdditionalPropertiesType = "SchemaOrReference"
	BoolSchemaAdditionalProperties              SchemaAdditionalPropertiesType = "bool"
)

// IsSchemaOrReference reports whether SchemaAdditionalProperties is SchemaOrReference.
func (s SchemaAdditionalProperties) IsSchemaOrReference() bool {
	return s.Type == SchemaOrReferenceSchemaAdditionalProperties
}

// IsBool reports whether SchemaAdditionalProperties is bool.
func (s SchemaAdditionalProperties) IsBool() bool { return s.Type == BoolSchemaAdditionalProperties }

// SetSchemaOrReference sets SchemaAdditionalProperties to SchemaOrReference.
func (s *SchemaAdditionalProperties) SetSchemaOrReference(v SchemaOrReference) {
	s.Type = SchemaOrReferenceSchemaAdditionalProperties
	s.SchemaOrReference = v
}

// GetSchemaOrReference returns SchemaOrReference and true boolean if SchemaAdditionalProperties is SchemaOrReference.
func (s SchemaAdditionalProperties) GetSchemaOrReference() (v SchemaOrReference, ok bool) {
	if !s.IsSchemaOrReference() {
		return v, false
	}
	return s.SchemaOrReference, true
}

// NewSchemaOrReferenceSchemaAdditionalProperties returns new SchemaAdditionalProperties from SchemaOrReference.
func NewSchemaOrReferenceSchemaAdditionalProperties(v SchemaOrReference) SchemaAdditionalProperties {
	var s SchemaAdditionalProperties
	s.SetSchemaOrReference(v)
	return s
}

// SetBool sets SchemaAdditionalProperties to bool.
func (s *SchemaAdditionalProperties) SetBool(v bool) {
	s.Type = BoolSchemaAdditionalProperties
	s.Bool = v
}

// GetBool returns bool and true boolean if SchemaAdditionalProperties is bool.
func (s SchemaAdditionalProperties) GetBool() (v bool, ok bool) {
	if !s.IsBool() {
		return v, false
	}
	return s.Bool, true
}

// NewBoolSchemaAdditionalProperties returns new SchemaAdditionalProperties from bool.
func NewBoolSchemaAdditionalProperties(v bool) SchemaAdditionalProperties {
	var s SchemaAdditionalProperties
	s.SetBool(v)
	return s
}

// Ref: #/definitions/schemaOrReference
// SchemaOrReference represents sum type.
type SchemaOrReference struct {
	Type      SchemaOrReferenceType // switch on this field
	Schema    Schema
	Reference Reference
}

// SchemaOrReferenceType is oneOf type of SchemaOrReference.
type SchemaOrReferenceType string

// Possible values for SchemaOrReferenceType.
const (
	SchemaSchemaOrReference    SchemaOrReferenceType = "Schema"
	ReferenceSchemaOrReference SchemaOrReferenceType = "Reference"
)

// IsSchema reports whether SchemaOrReference is Schema.
func (s SchemaOrReference) IsSchema() bool { return s.Type == SchemaSchemaOrReference }

// IsReference reports whether SchemaOrReference is Reference.
func (s SchemaOrReference) IsReference() bool { return s.Type == ReferenceSchemaOrReference }

// SetSchema sets SchemaOrReference to Schema.
func (s *SchemaOrReference) SetSchema(v Schema) {
	s.Type = SchemaSchemaOrReference
	s.Schema = v
}

// GetSchema returns Schema and true boolean if SchemaOrReference is Schema.
func (s SchemaOrReference) GetSchema() (v Schema, ok bool) {
	if !s.IsSchema() {
		return v, false
	}
	return s.Schema, true
}

// NewSchemaSchemaOrReference returns new SchemaOrReference from Schema.
func NewSchemaSchemaOrReference(v Schema) SchemaOrReference {
	var s SchemaOrReference
	s.SetSchema(v)
	return s
}

// SetReference sets SchemaOrReference to Reference.
func (s *SchemaOrReference) SetReference(v Reference) {
	s.Type = ReferenceSchemaOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if SchemaOrReference is Reference.
func (s SchemaOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceSchemaOrReference returns new SchemaOrReference from Reference.
func NewReferenceSchemaOrReference(v Reference) SchemaOrReference {
	var s SchemaOrReference
	s.SetReference(v)
	return s
}

type SchemaPattern0 map[string]jx.Raw

func (s *SchemaPattern0) init() SchemaPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type SchemaProperties map[string]SchemaOrReference

func (s *SchemaProperties) init() SchemaProperties {
	m := *s
	if m == nil {
		m = map[string]SchemaOrReference{}
		*s = m
	}
	return m
}

type SchemaType string

const (
	SchemaTypeArray   SchemaType = "array"
	SchemaTypeBoolean SchemaType = "boolean"
	SchemaTypeInteger SchemaType = "integer"
	SchemaTypeNull    SchemaType = "null"
	SchemaTypeNumber  SchemaType = "number"
	SchemaTypeObject  SchemaType = "object"
	SchemaTypeString  SchemaType = "string"
)

// Ref: #/definitions/schemasOrReferences
type SchemasOrReferences map[string]SchemaOrReference

func (s *SchemasOrReferences) init() SchemasOrReferences {
	m := *s
	if m == nil {
		m = map[string]SchemaOrReference{}
		*s = m
	}
	return m
}

// Lists the required security schemes to execute this operation. The name used for each property
// MUST correspond to a security scheme declared in the Security Schemes under the Components Object.
//  Security Requirement Objects that contain multiple schemes require that all schemes MUST be
// satisfied for a request to be authorized. This enables support for scenarios where multiple query
// parameters or HTTP headers are required to convey security information.  When a list of Security
// Requirement Objects is defined on the Open API object or Operation Object, only one of Security
// Requirement Objects in the list needs to be satisfied to authorize the request.
// Ref: #/definitions/securityRequirement
type SecurityRequirement map[string][]string

func (s *SecurityRequirement) init() SecurityRequirement {
	m := *s
	if m == nil {
		m = map[string][]string{}
		*s = m
	}
	return m
}

// Defines a security scheme that can be used by the operations. Supported schemes are HTTP
// authentication, an API key (either as a header or as a query parameter), OAuth2's common flows
// (implicit, password, application and access code) as defined in RFC6749, and OpenID Connect
// Discovery.
// Ref: #/definitions/securityScheme
type SecurityScheme struct {
	Type             string        "json:\"type\""
	Description      OptString     "json:\"description\""
	Name             OptString     "json:\"name\""
	In               OptString     "json:\"in\""
	Scheme           OptString     "json:\"scheme\""
	BearerFormat     OptString     "json:\"bearerFormat\""
	Flows            OptOauthFlows "json:\"flows\""
	OpenIdConnectUrl OptString     "json:\"openIdConnectUrl\""
	// Pattern: "^x-".
	Pattern0Props SecuritySchemePattern0
}

// Ref: #/definitions/securitySchemeOrReference
// SecuritySchemeOrReference represents sum type.
type SecuritySchemeOrReference struct {
	Type           SecuritySchemeOrReferenceType // switch on this field
	SecurityScheme SecurityScheme
	Reference      Reference
}

// SecuritySchemeOrReferenceType is oneOf type of SecuritySchemeOrReference.
type SecuritySchemeOrReferenceType string

// Possible values for SecuritySchemeOrReferenceType.
const (
	SecuritySchemeSecuritySchemeOrReference SecuritySchemeOrReferenceType = "SecurityScheme"
	ReferenceSecuritySchemeOrReference      SecuritySchemeOrReferenceType = "Reference"
)

// IsSecurityScheme reports whether SecuritySchemeOrReference is SecurityScheme.
func (s SecuritySchemeOrReference) IsSecurityScheme() bool {
	return s.Type == SecuritySchemeSecuritySchemeOrReference
}

// IsReference reports whether SecuritySchemeOrReference is Reference.
func (s SecuritySchemeOrReference) IsReference() bool {
	return s.Type == ReferenceSecuritySchemeOrReference
}

// SetSecurityScheme sets SecuritySchemeOrReference to SecurityScheme.
func (s *SecuritySchemeOrReference) SetSecurityScheme(v SecurityScheme) {
	s.Type = SecuritySchemeSecuritySchemeOrReference
	s.SecurityScheme = v
}

// GetSecurityScheme returns SecurityScheme and true boolean if SecuritySchemeOrReference is SecurityScheme.
func (s SecuritySchemeOrReference) GetSecurityScheme() (v SecurityScheme, ok bool) {
	if !s.IsSecurityScheme() {
		return v, false
	}
	return s.SecurityScheme, true
}

// NewSecuritySchemeSecuritySchemeOrReference returns new SecuritySchemeOrReference from SecurityScheme.
func NewSecuritySchemeSecuritySchemeOrReference(v SecurityScheme) SecuritySchemeOrReference {
	var s SecuritySchemeOrReference
	s.SetSecurityScheme(v)
	return s
}

// SetReference sets SecuritySchemeOrReference to Reference.
func (s *SecuritySchemeOrReference) SetReference(v Reference) {
	s.Type = ReferenceSecuritySchemeOrReference
	s.Reference = v
}

// GetReference returns Reference and true boolean if SecuritySchemeOrReference is Reference.
func (s SecuritySchemeOrReference) GetReference() (v Reference, ok bool) {
	if !s.IsReference() {
		return v, false
	}
	return s.Reference, true
}

// NewReferenceSecuritySchemeOrReference returns new SecuritySchemeOrReference from Reference.
func NewReferenceSecuritySchemeOrReference(v Reference) SecuritySchemeOrReference {
	var s SecuritySchemeOrReference
	s.SetReference(v)
	return s
}

type SecuritySchemePattern0 map[string]jx.Raw

func (s *SecuritySchemePattern0) init() SecuritySchemePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/securitySchemesOrReferences
type SecuritySchemesOrReferences map[string]SecuritySchemeOrReference

func (s *SecuritySchemesOrReferences) init() SecuritySchemesOrReferences {
	m := *s
	if m == nil {
		m = map[string]SecuritySchemeOrReference{}
		*s = m
	}
	return m
}

// An object representing a Server.
// Ref: #/definitions/server
type Server struct {
	URL         string             "json:\"url\""
	Description OptString          "json:\"description\""
	Variables   OptServerVariables "json:\"variables\""
	// Pattern: "^x-".
	Pattern0Props ServerPattern0
}

type ServerPattern0 map[string]jx.Raw

func (s *ServerPattern0) init() ServerPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// An object representing a Server Variable for server URL template substitution.
// Ref: #/definitions/serverVariable
type ServerVariable struct {
	Enum        []string  "json:\"enum\""
	Default     string    "json:\"default\""
	Description OptString "json:\"description\""
	// Pattern: "^x-".
	Pattern0Props ServerVariablePattern0
}

type ServerVariablePattern0 map[string]jx.Raw

func (s *ServerVariablePattern0) init() ServerVariablePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/serverVariables
type ServerVariables map[string]ServerVariable

func (s *ServerVariables) init() ServerVariables {
	m := *s
	if m == nil {
		m = map[string]ServerVariable{}
		*s = m
	}
	return m
}

// This is the root document object of the OpenAPI document.
type Spec struct {
	Openapi      string                "json:\"openapi\""
	Info         Info                  "json:\"info\""
	Servers      []Server              "json:\"servers\""
	Paths        Paths                 "json:\"paths\""
	Components   OptComponents         "json:\"components\""
	Security     []SecurityRequirement "json:\"security\""
	Tags         []Tag                 "json:\"tags\""
	ExternalDocs OptExternalDocs       "json:\"externalDocs\""
	// Pattern: "^x-".
	Pattern0Props SpecPattern0
}

type SpecPattern0 map[string]jx.Raw

func (s *SpecPattern0) init() SpecPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type StringArray []string

// Ref: #/definitions/strings
type Strings map[string]string

func (s *Strings) init() Strings {
	m := *s
	if m == nil {
		m = map[string]string{}
		*s = m
	}
	return m
}

// Adds metadata to a single tag that is used by the Operation Object. It is not mandatory to have a
// Tag Object per tag defined in the Operation Object instances.
// Ref: #/definitions/tag
type Tag struct {
	Name         string          "json:\"name\""
	Description  OptString       "json:\"description\""
	ExternalDocs OptExternalDocs "json:\"externalDocs\""
	// Pattern: "^x-".
	Pattern0Props TagPattern0
}

type TagPattern0 map[string]jx.Raw

func (s *TagPattern0) init() TagPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A metadata object that allows for more fine-tuned XML model definitions.  When using arrays, XML
// element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be
// used to add that information. See examples for expected behavior.
// Ref: #/definitions/xml
type XML struct {
	Name      OptString "json:\"name\""
	Namespace OptString "json:\"namespace\""
	Prefix    OptString "json:\"prefix\""
	Attribute OptBool   "json:\"attribute\""
	Wrapped   OptBool   "json:\"wrapped\""
	// Pattern: "^x-".
	Pattern0Props XMLPattern0
}

type XMLPattern0 map[string]jx.Raw

func (s *XMLPattern0) init() XMLPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// setDefaults set default value of fields.
func (s *Schema) setDefaults() {
	{
		val := JsonschemaDraft4PropertiesExclusiveMaximum(false)

		s.ExclusiveMaximum.SetTo(val)
	}
	{
		val := JsonschemaDraft4PropertiesExclusiveMinimum(false)

		s.ExclusiveMinimum.SetTo(val)
	}
	{
		val := JsonschemaDraft4PropertiesUniqueItems(false)

		s.UniqueItems.SetTo(val)
	}
}

// Encode implements json.Marshaler.
func (s AnysOrExpressions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AnysOrExpressions) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AnysOrExpressions from json.
func (s *AnysOrExpressions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnysOrExpressions to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnysOrExpressions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnysOrExpressions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnysOrExpressions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Callback) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Callback) encodeFields(e *jx.Encoder) {
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		elem.Encode(e)
	}
	for k, elem := range s.Pattern1Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfCallback = [0]string{}

// Decode decodes Callback from json.
func (s *Callback) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Callback to nil")
	}
	s.Pattern0Props = map[string]PathItem{}
	s.Pattern1Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var handled bool
			if pattern := regexMap["^"]; pattern.Match(k) {
				handled = true
				var elem PathItem
				if err := func() error {
					if err := elem.Decode(d); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern1Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Callback")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Callback) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Callback) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallbackOrReference as json.
func (s CallbackOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case CallbackCallbackOrReference:
		s.Callback.Encode(e)
	case ReferenceCallbackOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes CallbackOrReference from json.
func (s *CallbackOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "$ref":
				found = true
				s.Type = ReferenceCallbackOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = CallbackCallbackOrReference
	}
	switch s.Type {
	case CallbackCallbackOrReference:
		if err := s.Callback.Decode(d); err != nil {
			return err
		}
	case ReferenceCallbackOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallbackOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CallbackPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CallbackPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes CallbackPattern0 from json.
func (s *CallbackPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem PathItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallbackPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallbackPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CallbackPattern1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CallbackPattern1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CallbackPattern1 from json.
func (s *CallbackPattern1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackPattern1 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallbackPattern1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallbackPattern1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackPattern1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CallbacksOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CallbacksOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes CallbacksOrReferences from json.
func (s *CallbacksOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbacksOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem CallbackOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallbacksOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallbacksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbacksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Components) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Components) encodeFields(e *jx.Encoder) {
	{
		if s.Schemas.Set {
			e.FieldStart("schemas")
			s.Schemas.Encode(e)
		}
	}
	{
		if s.Responses.Set {
			e.FieldStart("responses")
			s.Responses.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.RequestBodies.Set {
			e.FieldStart("requestBodies")
			s.RequestBodies.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.SecuritySchemes.Set {
			e.FieldStart("securitySchemes")
			s.SecuritySchemes.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.Callbacks.Set {
			e.FieldStart("callbacks")
			s.Callbacks.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfComponents = [9]string{
	0: "schemas",
	1: "responses",
	2: "parameters",
	3: "examples",
	4: "requestBodies",
	5: "headers",
	6: "securitySchemes",
	7: "links",
	8: "callbacks",
}

// Decode decodes Components from json.
func (s *Components) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Components to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			if err := func() error {
				s.Schemas.Reset()
				if err := s.Schemas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "responses":
			if err := func() error {
				s.Responses.Reset()
				if err := s.Responses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responses\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "requestBodies":
			if err := func() error {
				s.RequestBodies.Reset()
				if err := s.RequestBodies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBodies\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "securitySchemes":
			if err := func() error {
				s.SecuritySchemes.Reset()
				if err := s.SecuritySchemes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securitySchemes\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "callbacks":
			if err := func() error {
				s.Callbacks.Reset()
				if err := s.Callbacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callbacks\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Components")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Components) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Components) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ComponentsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ComponentsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ComponentsPattern0 from json.
func (s *ComponentsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComponentsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComponentsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ComponentsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComponentsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Contact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Contact) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfContact = [3]string{
	0: "name",
	1: "url",
	2: "email",
}

// Decode decodes Contact from json.
func (s *Contact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contact to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Contact")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Contact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Contact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ContactPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ContactPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ContactPattern0 from json.
func (s *ContactPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContactPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContactPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContactPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContactPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Discriminator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Discriminator) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("propertyName")
		e.Str(s.PropertyName)
	}
	{
		if s.Mapping.Set {
			e.FieldStart("mapping")
			s.Mapping.Encode(e)
		}
	}
}

var jsonFieldsNameOfDiscriminator = [2]string{
	0: "propertyName",
	1: "mapping",
}

// Decode decodes Discriminator from json.
func (s *Discriminator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Discriminator to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "propertyName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PropertyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"propertyName\"")
			}
		case "mapping":
			if err := func() error {
				s.Mapping.Reset()
				if err := s.Mapping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapping\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Discriminator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDiscriminator) {
					name = jsonFieldsNameOfDiscriminator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Discriminator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Discriminator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Encoding) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Encoding) encodeFields(e *jx.Encoder) {
	{
		if s.ContentType.Set {
			e.FieldStart("contentType")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.Explode.Set {
			e.FieldStart("explode")
			s.Explode.Encode(e)
		}
	}
	{
		if s.AllowReserved.Set {
			e.FieldStart("allowReserved")
			s.AllowReserved.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfEncoding = [5]string{
	0: "contentType",
	1: "headers",
	2: "style",
	3: "explode",
	4: "allowReserved",
}

// Decode decodes Encoding from json.
func (s *Encoding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Encoding to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contentType":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentType\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "explode":
			if err := func() error {
				s.Explode.Reset()
				if err := s.Explode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explode\"")
			}
		case "allowReserved":
			if err := func() error {
				s.AllowReserved.Reset()
				if err := s.AllowReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowReserved\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Encoding")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Encoding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Encoding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EncodingPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EncodingPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes EncodingPattern0 from json.
func (s *EncodingPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncodingPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncodingPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EncodingPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncodingPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Encodings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s Encodings) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes Encodings from json.
func (s *Encodings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Encodings to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem Encoding
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Encodings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Encodings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Encodings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Example) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Example) encodeFields(e *jx.Encoder) {
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{

		if len(s.Value) != 0 {
			e.FieldStart("value")
			e.Raw(s.Value)
		}
	}
	{
		if s.ExternalValue.Set {
			e.FieldStart("externalValue")
			s.ExternalValue.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfExample = [4]string{
	0: "summary",
	1: "description",
	2: "value",
	3: "externalValue",
}

// Decode decodes Example from json.
func (s *Example) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Example to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "value":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Value = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "externalValue":
			if err := func() error {
				s.ExternalValue.Reset()
				if err := s.ExternalValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalValue\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Example")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Example) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Example) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExampleOrReference as json.
func (s ExampleOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case ExampleExampleOrReference:
		s.Example.Encode(e)
	case ReferenceExampleOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes ExampleOrReference from json.
func (s *ExampleOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "summary":
				found = true
				s.Type = ExampleExampleOrReference
			case "description":
				found = true
				s.Type = ExampleExampleOrReference
			case "value":
				found = true
				s.Type = ExampleExampleOrReference
			case "externalValue":
				found = true
				s.Type = ExampleExampleOrReference
			case "$ref":
				found = true
				s.Type = ReferenceExampleOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ExampleExampleOrReference:
		if err := s.Example.Decode(d); err != nil {
			return err
		}
	case ReferenceExampleOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExampleOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExamplePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExamplePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ExamplePattern0 from json.
func (s *ExamplePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExamplePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExamplePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExamplePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExamplePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExamplesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExamplesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ExamplesOrReferences from json.
func (s *ExamplesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExamplesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ExampleOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExamplesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExamplesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExamplesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExternalDocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s ExternalDocs) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{

		e.FieldStart("url")
		e.Str(s.URL)
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfExternalDocs = [2]string{
	0: "description",
	1: "url",
}

// Decode decodes ExternalDocs from json.
func (s *ExternalDocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalDocs to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalDocs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExternalDocs) {
					name = jsonFieldsNameOfExternalDocs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExternalDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExternalDocsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExternalDocsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ExternalDocsPattern0 from json.
func (s *ExternalDocsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalDocsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalDocsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExternalDocsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalDocsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Header) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Header) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.AllowEmptyValue.Set {
			e.FieldStart("allowEmptyValue")
			s.AllowEmptyValue.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.Explode.Set {
			e.FieldStart("explode")
			s.Explode.Encode(e)
		}
	}
	{
		if s.AllowReserved.Set {
			e.FieldStart("allowReserved")
			s.AllowReserved.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfHeader = [11]string{
	0:  "description",
	1:  "required",
	2:  "deprecated",
	3:  "allowEmptyValue",
	4:  "style",
	5:  "explode",
	6:  "allowReserved",
	7:  "schema",
	8:  "example",
	9:  "examples",
	10: "content",
}

// Decode decodes Header from json.
func (s *Header) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Header to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "allowEmptyValue":
			if err := func() error {
				s.AllowEmptyValue.Reset()
				if err := s.AllowEmptyValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowEmptyValue\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "explode":
			if err := func() error {
				s.Explode.Reset()
				if err := s.Explode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explode\"")
			}
		case "allowReserved":
			if err := func() error {
				s.AllowReserved.Reset()
				if err := s.AllowReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowReserved\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Header")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Header) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Header) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HeaderOrReference as json.
func (s HeaderOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case HeaderHeaderOrReference:
		s.Header.Encode(e)
	case ReferenceHeaderOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes HeaderOrReference from json.
func (s *HeaderOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HeaderOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "description":
				found = true
				s.Type = HeaderHeaderOrReference
			case "required":
				found = true
				s.Type = HeaderHeaderOrReference
			case "deprecated":
				found = true
				s.Type = HeaderHeaderOrReference
			case "allowEmptyValue":
				found = true
				s.Type = HeaderHeaderOrReference
			case "style":
				found = true
				s.Type = HeaderHeaderOrReference
			case "explode":
				found = true
				s.Type = HeaderHeaderOrReference
			case "allowReserved":
				found = true
				s.Type = HeaderHeaderOrReference
			case "schema":
				found = true
				s.Type = HeaderHeaderOrReference
			case "example":
				found = true
				s.Type = HeaderHeaderOrReference
			case "examples":
				found = true
				s.Type = HeaderHeaderOrReference
			case "content":
				found = true
				s.Type = HeaderHeaderOrReference
			case "$ref":
				found = true
				s.Type = ReferenceHeaderOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case HeaderHeaderOrReference:
		if err := s.Header.Decode(d); err != nil {
			return err
		}
	case ReferenceHeaderOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HeaderOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HeaderOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HeaderPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HeaderPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HeaderPattern0 from json.
func (s *HeaderPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HeaderPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HeaderPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HeaderPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HeaderPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HeadersOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HeadersOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes HeadersOrReferences from json.
func (s *HeadersOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HeadersOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem HeaderOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HeadersOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HeadersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HeadersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Info) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Info) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TermsOfService.Set {
			e.FieldStart("termsOfService")
			s.TermsOfService.Encode(e)
		}
	}
	{
		if s.Contact.Set {
			e.FieldStart("contact")
			s.Contact.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
	{

		e.FieldStart("version")
		e.Str(s.Version)
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfInfo = [6]string{
	0: "title",
	1: "description",
	2: "termsOfService",
	3: "contact",
	4: "license",
	5: "version",
}

// Decode decodes Info from json.
func (s *Info) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Info to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "termsOfService":
			if err := func() error {
				s.TermsOfService.Reset()
				if err := s.TermsOfService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termsOfService\"")
			}
		case "contact":
			if err := func() error {
				s.Contact.Reset()
				if err := s.Contact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contact\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Info")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInfo) {
					name = jsonFieldsNameOfInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Info) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Info) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s InfoPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s InfoPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes InfoPattern0 from json.
func (s *InfoPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfoPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfoPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InfoPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfoPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesEnum as json.
func (s JsonschemaDraft4PropertiesEnum) Encode(e *jx.Encoder) {
	unwrapped := []jx.Raw(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes JsonschemaDraft4PropertiesEnum from json.
func (s *JsonschemaDraft4PropertiesEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesEnum to nil")
	}
	var unwrapped []jx.Raw
	if err := func() error {
		unwrapped = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesEnum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesExclusiveMaximum as json.
func (s JsonschemaDraft4PropertiesExclusiveMaximum) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesExclusiveMaximum from json.
func (s *JsonschemaDraft4PropertiesExclusiveMaximum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesExclusiveMaximum to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesExclusiveMaximum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesExclusiveMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesExclusiveMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesExclusiveMinimum as json.
func (s JsonschemaDraft4PropertiesExclusiveMinimum) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesExclusiveMinimum from json.
func (s *JsonschemaDraft4PropertiesExclusiveMinimum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesExclusiveMinimum to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesExclusiveMinimum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesExclusiveMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesExclusiveMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesMaximum as json.
func (s JsonschemaDraft4PropertiesMaximum) Encode(e *jx.Encoder) {
	unwrapped := float64(s)
	e.Float64(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesMaximum from json.
func (s *JsonschemaDraft4PropertiesMaximum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesMaximum to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesMaximum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesMinimum as json.
func (s JsonschemaDraft4PropertiesMinimum) Encode(e *jx.Encoder) {
	unwrapped := float64(s)
	e.Float64(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesMinimum from json.
func (s *JsonschemaDraft4PropertiesMinimum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesMinimum to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesMinimum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesMultipleOf as json.
func (s JsonschemaDraft4PropertiesMultipleOf) Encode(e *jx.Encoder) {
	unwrapped := float64(s)
	e.Float64(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesMultipleOf from json.
func (s *JsonschemaDraft4PropertiesMultipleOf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesMultipleOf to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesMultipleOf(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesMultipleOf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesMultipleOf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesPattern as json.
func (s JsonschemaDraft4PropertiesPattern) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesPattern from json.
func (s *JsonschemaDraft4PropertiesPattern) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesPattern to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesPattern(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesPattern) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesPattern) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesTitle as json.
func (s JsonschemaDraft4PropertiesTitle) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesTitle from json.
func (s *JsonschemaDraft4PropertiesTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesTitle to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesTitle(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesUniqueItems as json.
func (s JsonschemaDraft4PropertiesUniqueItems) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes JsonschemaDraft4PropertiesUniqueItems from json.
func (s *JsonschemaDraft4PropertiesUniqueItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonschemaDraft4PropertiesUniqueItems to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonschemaDraft4PropertiesUniqueItems(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonschemaDraft4PropertiesUniqueItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonschemaDraft4PropertiesUniqueItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s License) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s License) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfLicense = [2]string{
	0: "name",
	1: "url",
}

// Decode decodes License from json.
func (s *License) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode License to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode License")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicense) {
					name = jsonFieldsNameOfLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s License) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *License) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LicensePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LicensePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes LicensePattern0 from json.
func (s *LicensePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicensePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LicensePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicensePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Link) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Link) encodeFields(e *jx.Encoder) {
	{
		if s.OperationRef.Set {
			e.FieldStart("operationRef")
			s.OperationRef.Encode(e)
		}
	}
	{
		if s.OperationId.Set {
			e.FieldStart("operationId")
			s.OperationId.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{

		if len(s.RequestBody) != 0 {
			e.FieldStart("requestBody")
			e.Raw(s.RequestBody)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Server.Set {
			e.FieldStart("server")
			s.Server.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfLink = [6]string{
	0: "operationRef",
	1: "operationId",
	2: "parameters",
	3: "requestBody",
	4: "description",
	5: "server",
}

// Decode decodes Link from json.
func (s *Link) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Link to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operationRef":
			if err := func() error {
				s.OperationRef.Reset()
				if err := s.OperationRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationRef\"")
			}
		case "operationId":
			if err := func() error {
				s.OperationId.Reset()
				if err := s.OperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "requestBody":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RequestBody = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBody\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "server":
			if err := func() error {
				s.Server.Reset()
				if err := s.Server.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Link")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Link) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Link) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkOrReference as json.
func (s LinkOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case LinkLinkOrReference:
		s.Link.Encode(e)
	case ReferenceLinkOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes LinkOrReference from json.
func (s *LinkOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "operationRef":
				found = true
				s.Type = LinkLinkOrReference
			case "operationId":
				found = true
				s.Type = LinkLinkOrReference
			case "parameters":
				found = true
				s.Type = LinkLinkOrReference
			case "requestBody":
				found = true
				s.Type = LinkLinkOrReference
			case "description":
				found = true
				s.Type = LinkLinkOrReference
			case "server":
				found = true
				s.Type = LinkLinkOrReference
			case "$ref":
				found = true
				s.Type = ReferenceLinkOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case LinkLinkOrReference:
		if err := s.Link.Decode(d); err != nil {
			return err
		}
	case ReferenceLinkOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LinkOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LinkPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LinkPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes LinkPattern0 from json.
func (s *LinkPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LinkPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LinksOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LinksOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes LinksOrReferences from json.
func (s *LinksOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinksOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem LinkOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinksOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LinksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MediaType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s MediaType) encodeFields(e *jx.Encoder) {
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.Encoding.Set {
			e.FieldStart("encoding")
			s.Encoding.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfMediaType = [4]string{
	0: "schema",
	1: "example",
	2: "examples",
	3: "encoding",
}

// Decode decodes MediaType from json.
func (s *MediaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MediaType to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "encoding":
			if err := func() error {
				s.Encoding.Reset()
				if err := s.Encoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MediaType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MediaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MediaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MediaTypePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s MediaTypePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes MediaTypePattern0 from json.
func (s *MediaTypePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MediaTypePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MediaTypePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MediaTypePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MediaTypePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MediaTypes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s MediaTypes) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes MediaTypes from json.
func (s *MediaTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MediaTypes to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem MediaType
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MediaTypes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MediaTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MediaTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OauthFlow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s OauthFlow) encodeFields(e *jx.Encoder) {
	{
		if s.AuthorizationUrl.Set {
			e.FieldStart("authorizationUrl")
			s.AuthorizationUrl.Encode(e)
		}
	}
	{
		if s.TokenUrl.Set {
			e.FieldStart("tokenUrl")
			s.TokenUrl.Encode(e)
		}
	}
	{
		if s.RefreshUrl.Set {
			e.FieldStart("refreshUrl")
			s.RefreshUrl.Encode(e)
		}
	}
	{
		if s.Scopes.Set {
			e.FieldStart("scopes")
			s.Scopes.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfOauthFlow = [4]string{
	0: "authorizationUrl",
	1: "tokenUrl",
	2: "refreshUrl",
	3: "scopes",
}

// Decode decodes OauthFlow from json.
func (s *OauthFlow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OauthFlow to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authorizationUrl":
			if err := func() error {
				s.AuthorizationUrl.Reset()
				if err := s.AuthorizationUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationUrl\"")
			}
		case "tokenUrl":
			if err := func() error {
				s.TokenUrl.Reset()
				if err := s.TokenUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenUrl\"")
			}
		case "refreshUrl":
			if err := func() error {
				s.RefreshUrl.Reset()
				if err := s.RefreshUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshUrl\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OauthFlow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OauthFlow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OauthFlow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OauthFlowPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s OauthFlowPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes OauthFlowPattern0 from json.
func (s *OauthFlowPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OauthFlowPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OauthFlowPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OauthFlowPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OauthFlowPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OauthFlows) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s OauthFlows) encodeFields(e *jx.Encoder) {
	{
		if s.Implicit.Set {
			e.FieldStart("implicit")
			s.Implicit.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.ClientCredentials.Set {
			e.FieldStart("clientCredentials")
			s.ClientCredentials.Encode(e)
		}
	}
	{
		if s.AuthorizationCode.Set {
			e.FieldStart("authorizationCode")
			s.AuthorizationCode.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfOauthFlows = [4]string{
	0: "implicit",
	1: "password",
	2: "clientCredentials",
	3: "authorizationCode",
}

// Decode decodes OauthFlows from json.
func (s *OauthFlows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OauthFlows to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "implicit":
			if err := func() error {
				s.Implicit.Reset()
				if err := s.Implicit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implicit\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "clientCredentials":
			if err := func() error {
				s.ClientCredentials.Reset()
				if err := s.ClientCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientCredentials\"")
			}
		case "authorizationCode":
			if err := func() error {
				s.AuthorizationCode.Reset()
				if err := s.AuthorizationCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationCode\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OauthFlows")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OauthFlows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OauthFlows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OauthFlowsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s OauthFlowsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes OauthFlowsPattern0 from json.
func (s *OauthFlowsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OauthFlowsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OauthFlowsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OauthFlowsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OauthFlowsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Operation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Operation) encodeFields(e *jx.Encoder) {
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	{
		if s.OperationId.Set {
			e.FieldStart("operationId")
			s.OperationId.Encode(e)
		}
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequestBody.Set {
			e.FieldStart("requestBody")
			s.RequestBody.Encode(e)
		}
	}
	{

		e.FieldStart("responses")
		s.Responses.Encode(e)
	}
	{
		if s.Callbacks.Set {
			e.FieldStart("callbacks")
			s.Callbacks.Encode(e)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.Security != nil {
			e.FieldStart("security")
			e.ArrStart()
			for _, elem := range s.Security {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfOperation = [12]string{
	0:  "tags",
	1:  "summary",
	2:  "description",
	3:  "externalDocs",
	4:  "operationId",
	5:  "parameters",
	6:  "requestBody",
	7:  "responses",
	8:  "callbacks",
	9:  "deprecated",
	10: "security",
	11: "servers",
}

// Decode decodes Operation from json.
func (s *Operation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Operation to nil")
	}
	var requiredBitSet [2]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		case "operationId":
			if err := func() error {
				s.OperationId.Reset()
				if err := s.OperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = make([]ParameterOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParameterOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "requestBody":
			if err := func() error {
				s.RequestBody.Reset()
				if err := s.RequestBody.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBody\"")
			}
		case "responses":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Responses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responses\"")
			}
		case "callbacks":
			if err := func() error {
				s.Callbacks.Reset()
				if err := s.Callbacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callbacks\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "security":
			if err := func() error {
				s.Security = make([]SecurityRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SecurityRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Security = append(s.Security, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]Server, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Server
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Operation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOperation) {
					name = jsonFieldsNameOfOperation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Operation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Operation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OperationPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s OperationPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes OperationPattern0 from json.
func (s *OperationPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OperationPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OperationPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OperationPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnysOrExpressions as json.
func (o OptAnysOrExpressions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnysOrExpressions from json.
func (o *OptAnysOrExpressions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnysOrExpressions to nil")
	}
	o.Set = true
	o.Value = make(AnysOrExpressions)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnysOrExpressions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnysOrExpressions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallbacksOrReferences as json.
func (o OptCallbacksOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallbacksOrReferences from json.
func (o *OptCallbacksOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallbacksOrReferences to nil")
	}
	o.Set = true
	o.Value = make(CallbacksOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallbacksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallbacksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Components as json.
func (o OptComponents) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Components from json.
func (o *OptComponents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComponents to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComponents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComponents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Contact as json.
func (o OptContact) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Contact from json.
func (o *OptContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContact to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Discriminator as json.
func (o OptDiscriminator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Discriminator from json.
func (o *OptDiscriminator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDiscriminator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDiscriminator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDiscriminator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Encodings as json.
func (o OptEncodings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Encodings from json.
func (o *OptEncodings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEncodings to nil")
	}
	o.Set = true
	o.Value = make(Encodings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEncodings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEncodings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExamplesOrReferences as json.
func (o OptExamplesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExamplesOrReferences from json.
func (o *OptExamplesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExamplesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(ExamplesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExamplesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExamplesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExternalDocs as json.
func (o OptExternalDocs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExternalDocs from json.
func (o *OptExternalDocs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExternalDocs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExternalDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExternalDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HeadersOrReferences as json.
func (o OptHeadersOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HeadersOrReferences from json.
func (o *OptHeadersOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHeadersOrReferences to nil")
	}
	o.Set = true
	o.Value = make(HeadersOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHeadersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHeadersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesExclusiveMaximum as json.
func (o OptJsonschemaDraft4PropertiesExclusiveMaximum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesExclusiveMaximum from json.
func (o *OptJsonschemaDraft4PropertiesExclusiveMaximum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesExclusiveMaximum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesExclusiveMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesExclusiveMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesExclusiveMinimum as json.
func (o OptJsonschemaDraft4PropertiesExclusiveMinimum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesExclusiveMinimum from json.
func (o *OptJsonschemaDraft4PropertiesExclusiveMinimum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesExclusiveMinimum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesExclusiveMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesExclusiveMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesMaximum as json.
func (o OptJsonschemaDraft4PropertiesMaximum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesMaximum from json.
func (o *OptJsonschemaDraft4PropertiesMaximum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesMaximum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesMinimum as json.
func (o OptJsonschemaDraft4PropertiesMinimum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesMinimum from json.
func (o *OptJsonschemaDraft4PropertiesMinimum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesMinimum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesMultipleOf as json.
func (o OptJsonschemaDraft4PropertiesMultipleOf) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesMultipleOf from json.
func (o *OptJsonschemaDraft4PropertiesMultipleOf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesMultipleOf to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesMultipleOf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesMultipleOf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesPattern as json.
func (o OptJsonschemaDraft4PropertiesPattern) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesPattern from json.
func (o *OptJsonschemaDraft4PropertiesPattern) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesPattern to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesPattern) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesPattern) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesTitle as json.
func (o OptJsonschemaDraft4PropertiesTitle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesTitle from json.
func (o *OptJsonschemaDraft4PropertiesTitle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesTitle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonschemaDraft4PropertiesUniqueItems as json.
func (o OptJsonschemaDraft4PropertiesUniqueItems) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonschemaDraft4PropertiesUniqueItems from json.
func (o *OptJsonschemaDraft4PropertiesUniqueItems) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonschemaDraft4PropertiesUniqueItems to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonschemaDraft4PropertiesUniqueItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonschemaDraft4PropertiesUniqueItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes License as json.
func (o OptLicense) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes License from json.
func (o *OptLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLicense to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinksOrReferences as json.
func (o OptLinksOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinksOrReferences from json.
func (o *OptLinksOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinksOrReferences to nil")
	}
	o.Set = true
	o.Value = make(LinksOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MediaTypes as json.
func (o OptMediaTypes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MediaTypes from json.
func (o *OptMediaTypes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMediaTypes to nil")
	}
	o.Set = true
	o.Value = make(MediaTypes)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMediaTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMediaTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OauthFlow as json.
func (o OptOauthFlow) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OauthFlow from json.
func (o *OptOauthFlow) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOauthFlow to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOauthFlow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOauthFlow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OauthFlows as json.
func (o OptOauthFlows) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OauthFlows from json.
func (o *OptOauthFlows) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOauthFlows to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOauthFlows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOauthFlows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Operation as json.
func (o OptOperation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Operation from json.
func (o *OptOperation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOperation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParameterStyle as json.
func (o OptParameterStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ParameterStyle from json.
func (o *OptParameterStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParameterStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParameterStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParameterStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParametersOrReferences as json.
func (o OptParametersOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ParametersOrReferences from json.
func (o *OptParametersOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParametersOrReferences to nil")
	}
	o.Set = true
	o.Value = make(ParametersOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParametersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParametersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PositiveInteger as json.
func (o OptPositiveInteger) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PositiveInteger from json.
func (o *OptPositiveInteger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPositiveInteger to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPositiveInteger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPositiveInteger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestBodiesOrReferences as json.
func (o OptRequestBodiesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestBodiesOrReferences from json.
func (o *OptRequestBodiesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestBodiesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(RequestBodiesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestBodiesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestBodiesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestBodyOrReference as json.
func (o OptRequestBodyOrReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestBodyOrReference from json.
func (o *OptRequestBodyOrReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestBodyOrReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestBodyOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestBodyOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseOrReference as json.
func (o OptResponseOrReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseOrReference from json.
func (o *OptResponseOrReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseOrReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponsesOrReferences as json.
func (o OptResponsesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponsesOrReferences from json.
func (o *OptResponsesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponsesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(ResponsesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponsesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponsesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaOrReference as json.
func (o OptSchemaOrReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SchemaOrReference from json.
func (o *OptSchemaOrReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemaOrReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemaOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemaOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaProperties as json.
func (o OptSchemaProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SchemaProperties from json.
func (o *OptSchemaProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemaProperties to nil")
	}
	o.Set = true
	o.Value = make(SchemaProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemaProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemaProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaType as json.
func (o OptSchemaType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SchemaType from json.
func (o *OptSchemaType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemaType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemasOrReferences as json.
func (o OptSchemasOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SchemasOrReferences from json.
func (o *OptSchemasOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemasOrReferences to nil")
	}
	o.Set = true
	o.Value = make(SchemasOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemasOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemasOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySchemesOrReferences as json.
func (o OptSecuritySchemesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SecuritySchemesOrReferences from json.
func (o *OptSecuritySchemesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecuritySchemesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(SecuritySchemesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecuritySchemesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecuritySchemesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Server as json.
func (o OptServer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Server from json.
func (o *OptServer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServerVariables as json.
func (o OptServerVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ServerVariables from json.
func (o *OptServerVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServerVariables to nil")
	}
	o.Set = true
	o.Value = make(ServerVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServerVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServerVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Strings as json.
func (o OptStrings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Strings from json.
func (o *OptStrings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStrings to nil")
	}
	o.Set = true
	o.Value = make(Strings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStrings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStrings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes XML as json.
func (o OptXML) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes XML from json.
func (o *OptXML) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptXML to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptXML) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptXML) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Parameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Parameter) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("in")
		s.In.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.AllowEmptyValue.Set {
			e.FieldStart("allowEmptyValue")
			s.AllowEmptyValue.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.Explode.Set {
			e.FieldStart("explode")
			s.Explode.Encode(e)
		}
	}
	{
		if s.AllowReserved.Set {
			e.FieldStart("allowReserved")
			s.AllowReserved.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfParameter = [13]string{
	0:  "name",
	1:  "in",
	2:  "description",
	3:  "required",
	4:  "deprecated",
	5:  "allowEmptyValue",
	6:  "style",
	7:  "explode",
	8:  "allowReserved",
	9:  "schema",
	10: "example",
	11: "examples",
	12: "content",
}

// Decode decodes Parameter from json.
func (s *Parameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Parameter to nil")
	}
	var requiredBitSet [2]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "in":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.In.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "allowEmptyValue":
			if err := func() error {
				s.AllowEmptyValue.Reset()
				if err := s.AllowEmptyValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowEmptyValue\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "explode":
			if err := func() error {
				s.Explode.Reset()
				if err := s.Explode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explode\"")
			}
		case "allowReserved":
			if err := func() error {
				s.AllowReserved.Reset()
				if err := s.AllowReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowReserved\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Parameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParameter) {
					name = jsonFieldsNameOfParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Parameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Parameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParameterIn as json.
func (s ParameterIn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParameterIn from json.
func (s *ParameterIn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParameterIn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParameterIn(v) {
	case ParameterInPath:
		*s = ParameterInPath
	case ParameterInQuery:
		*s = ParameterInQuery
	case ParameterInCookie:
		*s = ParameterInCookie
	case ParameterInHeader:
		*s = ParameterInHeader
	default:
		*s = ParameterIn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParameterIn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParameterIn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParameterOrReference as json.
func (s ParameterOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case ParameterParameterOrReference:
		s.Parameter.Encode(e)
	case ReferenceParameterOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes ParameterOrReference from json.
func (s *ParameterOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParameterOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "name":
				found = true
				s.Type = ParameterParameterOrReference
			case "in":
				found = true
				s.Type = ParameterParameterOrReference
			case "description":
				found = true
				s.Type = ParameterParameterOrReference
			case "required":
				found = true
				s.Type = ParameterParameterOrReference
			case "deprecated":
				found = true
				s.Type = ParameterParameterOrReference
			case "allowEmptyValue":
				found = true
				s.Type = ParameterParameterOrReference
			case "style":
				found = true
				s.Type = ParameterParameterOrReference
			case "explode":
				found = true
				s.Type = ParameterParameterOrReference
			case "allowReserved":
				found = true
				s.Type = ParameterParameterOrReference
			case "schema":
				found = true
				s.Type = ParameterParameterOrReference
			case "example":
				found = true
				s.Type = ParameterParameterOrReference
			case "examples":
				found = true
				s.Type = ParameterParameterOrReference
			case "content":
				found = true
				s.Type = ParameterParameterOrReference
			case "$ref":
				found = true
				s.Type = ReferenceParameterOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ParameterParameterOrReference:
		if err := s.Parameter.Decode(d); err != nil {
			return err
		}
	case ReferenceParameterOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParameterOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParameterOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ParameterPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ParameterPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ParameterPattern0 from json.
func (s *ParameterPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParameterPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParameterPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParameterPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParameterPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParameterStyle as json.
func (s ParameterStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParameterStyle from json.
func (s *ParameterStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParameterStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParameterStyle(v) {
	case ParameterStyleMatrix:
		*s = ParameterStyleMatrix
	case ParameterStyleLabel:
		*s = ParameterStyleLabel
	case ParameterStyleForm:
		*s = ParameterStyleForm
	case ParameterStyleSimple:
		*s = ParameterStyleSimple
	case ParameterStyleSpaceDelimited:
		*s = ParameterStyleSpaceDelimited
	case ParameterStylePipeDelimited:
		*s = ParameterStylePipeDelimited
	case ParameterStyleDeepObject:
		*s = ParameterStyleDeepObject
	default:
		*s = ParameterStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParameterStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParameterStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ParametersOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ParametersOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ParametersOrReferences from json.
func (s *ParametersOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParametersOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ParameterOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParametersOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParametersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParametersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PathItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s PathItem) encodeFields(e *jx.Encoder) {
	{
		if s.Ref.Set {
			e.FieldStart("$ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Get.Set {
			e.FieldStart("get")
			s.Get.Encode(e)
		}
	}
	{
		if s.Put.Set {
			e.FieldStart("put")
			s.Put.Encode(e)
		}
	}
	{
		if s.Post.Set {
			e.FieldStart("post")
			s.Post.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
	{
		if s.Head.Set {
			e.FieldStart("head")
			s.Head.Encode(e)
		}
	}
	{
		if s.Patch.Set {
			e.FieldStart("patch")
			s.Patch.Encode(e)
		}
	}
	{
		if s.Trace.Set {
			e.FieldStart("trace")
			s.Trace.Encode(e)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfPathItem = [13]string{
	0:  "$ref",
	1:  "summary",
	2:  "description",
	3:  "get",
	4:  "put",
	5:  "post",
	6:  "delete",
	7:  "options",
	8:  "head",
	9:  "patch",
	10: "trace",
	11: "servers",
	12: "parameters",
}

// Decode decodes PathItem from json.
func (s *PathItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PathItem to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "get":
			if err := func() error {
				s.Get.Reset()
				if err := s.Get.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"get\"")
			}
		case "put":
			if err := func() error {
				s.Put.Reset()
				if err := s.Put.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"put\"")
			}
		case "post":
			if err := func() error {
				s.Post.Reset()
				if err := s.Post.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "head":
			if err := func() error {
				s.Head.Reset()
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "patch":
			if err := func() error {
				s.Patch.Reset()
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		case "trace":
			if err := func() error {
				s.Trace.Reset()
				if err := s.Trace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]Server, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Server
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = make([]ParameterOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParameterOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PathItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PathItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PathItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PathItemPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PathItemPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PathItemPattern0 from json.
func (s *PathItemPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PathItemPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PathItemPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PathItemPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PathItemPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Paths) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Paths) encodeFields(e *jx.Encoder) {
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		elem.Encode(e)
	}
	for k, elem := range s.Pattern1Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfPaths = [0]string{}

// Decode decodes Paths from json.
func (s *Paths) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Paths to nil")
	}
	s.Pattern0Props = map[string]PathItem{}
	s.Pattern1Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var handled bool
			if pattern := regexMap["^/"]; pattern.Match(k) {
				handled = true
				var elem PathItem
				if err := func() error {
					if err := elem.Decode(d); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern1Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Paths")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Paths) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Paths) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PathsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PathsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes PathsPattern0 from json.
func (s *PathsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PathsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^/"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem PathItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PathsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PathsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PathsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PathsPattern1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PathsPattern1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PathsPattern1 from json.
func (s *PathsPattern1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PathsPattern1 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PathsPattern1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PathsPattern1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PathsPattern1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PositiveInteger as json.
func (s PositiveInteger) Encode(e *jx.Encoder) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes PositiveInteger from json.
func (s *PositiveInteger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PositiveInteger to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PositiveInteger(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PositiveInteger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PositiveInteger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Reference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Reference) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("$ref")
		e.Str(s.Ref)
	}
}

var jsonFieldsNameOfReference = [1]string{
	0: "$ref",
}

// Decode decodes Reference from json.
func (s *Reference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Reference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Reference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReference) {
					name = jsonFieldsNameOfReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Reference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Reference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RequestBodiesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RequestBodiesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes RequestBodiesOrReferences from json.
func (s *RequestBodiesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestBodiesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem RequestBodyOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestBodiesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestBodiesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestBodiesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s RequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{

		e.FieldStart("content")
		s.Content.Encode(e)
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfRequestBody = [3]string{
	0: "description",
	1: "content",
	2: "required",
}

// Decode decodes RequestBody from json.
func (s *RequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestBody to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRequestBody) {
					name = jsonFieldsNameOfRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestBodyOrReference as json.
func (s RequestBodyOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case RequestBodyRequestBodyOrReference:
		s.RequestBody.Encode(e)
	case ReferenceRequestBodyOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes RequestBodyOrReference from json.
func (s *RequestBodyOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestBodyOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "description":
				found = true
				s.Type = RequestBodyRequestBodyOrReference
			case "content":
				found = true
				s.Type = RequestBodyRequestBodyOrReference
			case "required":
				found = true
				s.Type = RequestBodyRequestBodyOrReference
			case "$ref":
				found = true
				s.Type = ReferenceRequestBodyOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RequestBodyRequestBodyOrReference:
		if err := s.RequestBody.Decode(d); err != nil {
			return err
		}
	case ReferenceRequestBodyOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestBodyOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestBodyOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RequestBodyPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RequestBodyPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RequestBodyPattern0 from json.
func (s *RequestBodyPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestBodyPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestBodyPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestBodyPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestBodyPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Response) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Response) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfResponse = [4]string{
	0: "description",
	1: "headers",
	2: "content",
	3: "links",
}

// Decode decodes Response from json.
func (s *Response) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Response to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Response")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResponse) {
					name = jsonFieldsNameOfResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Response) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Response) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseOrReference as json.
func (s ResponseOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case ResponseResponseOrReference:
		s.Response.Encode(e)
	case ReferenceResponseOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes ResponseOrReference from json.
func (s *ResponseOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "description":
				found = true
				s.Type = ResponseResponseOrReference
			case "headers":
				found = true
				s.Type = ResponseResponseOrReference
			case "content":
				found = true
				s.Type = ResponseResponseOrReference
			case "links":
				found = true
				s.Type = ResponseResponseOrReference
			case "$ref":
				found = true
				s.Type = ReferenceResponseOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ResponseResponseOrReference:
		if err := s.Response.Decode(d); err != nil {
			return err
		}
	case ReferenceResponseOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponseOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResponsePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResponsePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ResponsePattern0 from json.
func (s *ResponsePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponsePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponsePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponsePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponsePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Responses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Responses) encodeFields(e *jx.Encoder) {
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		elem.Encode(e)
	}
	for k, elem := range s.Pattern1Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfResponses = [1]string{
	0: "default",
}

// Decode decodes Responses from json.
func (s *Responses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Responses to nil")
	}
	s.Pattern0Props = map[string]ResponseOrReference{}
	s.Pattern1Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^([0-9X]{3})$"]; pattern.Match(k) {
				handled = true
				var elem ResponseOrReference
				if err := func() error {
					if err := elem.Decode(d); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern1Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Responses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Responses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Responses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResponsesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResponsesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ResponsesOrReferences from json.
func (s *ResponsesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponsesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ResponseOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponsesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponsesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponsesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResponsesPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResponsesPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ResponsesPattern0 from json.
func (s *ResponsesPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponsesPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^([0-9X]{3})$"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem ResponseOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponsesPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponsesPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponsesPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResponsesPattern1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResponsesPattern1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ResponsesPattern1 from json.
func (s *ResponsesPattern1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponsesPattern1 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponsesPattern1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponsesPattern1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponsesPattern1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Schema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Schema) encodeFields(e *jx.Encoder) {
	{
		if s.Nullable.Set {
			e.FieldStart("nullable")
			s.Nullable.Encode(e)
		}
	}
	{
		if s.Discriminator.Set {
			e.FieldStart("discriminator")
			s.Discriminator.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.WriteOnly.Set {
			e.FieldStart("writeOnly")
			s.WriteOnly.Encode(e)
		}
	}
	{
		if s.XML.Set {
			e.FieldStart("xml")
			s.XML.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.MultipleOf.Set {
			e.FieldStart("multipleOf")
			s.MultipleOf.Encode(e)
		}
	}
	{
		if s.Maximum.Set {
			e.FieldStart("maximum")
			s.Maximum.Encode(e)
		}
	}
	{
		if s.ExclusiveMaximum.Set {
			e.FieldStart("exclusiveMaximum")
			s.ExclusiveMaximum.Encode(e)
		}
	}
	{
		if s.Minimum.Set {
			e.FieldStart("minimum")
			s.Minimum.Encode(e)
		}
	}
	{
		if s.ExclusiveMinimum.Set {
			e.FieldStart("exclusiveMinimum")
			s.ExclusiveMinimum.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			e.FieldStart("maxLength")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.MinLength.Set {
			e.FieldStart("minLength")
			s.MinLength.Encode(e)
		}
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.MaxItems.Set {
			e.FieldStart("maxItems")
			s.MaxItems.Encode(e)
		}
	}
	{
		if s.MinItems.Set {
			e.FieldStart("minItems")
			s.MinItems.Encode(e)
		}
	}
	{
		if s.UniqueItems.Set {
			e.FieldStart("uniqueItems")
			s.UniqueItems.Encode(e)
		}
	}
	{
		if s.MaxProperties.Set {
			e.FieldStart("maxProperties")
			s.MaxProperties.Encode(e)
		}
	}
	{
		if s.MinProperties.Set {
			e.FieldStart("minProperties")
			s.MinProperties.Encode(e)
		}
	}
	{
		if s.Required != nil {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Enum != nil {
			e.FieldStart("enum")
			s.Enum.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.AllOf != nil {
			e.FieldStart("allOf")
			e.ArrStart()
			for _, elem := range s.AllOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OneOf != nil {
			e.FieldStart("oneOf")
			e.ArrStart()
			for _, elem := range s.OneOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnyOf != nil {
			e.FieldStart("anyOf")
			e.ArrStart()
			for _, elem := range s.AnyOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Not != nil {
			e.FieldStart("not")
			s.Not.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			s.Items.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties != nil {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{

		if len(s.Default) != 0 {
			e.FieldStart("default")
			e.Raw(s.Default)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfSchema = [35]string{
	0:  "nullable",
	1:  "discriminator",
	2:  "readOnly",
	3:  "writeOnly",
	4:  "xml",
	5:  "externalDocs",
	6:  "example",
	7:  "deprecated",
	8:  "title",
	9:  "multipleOf",
	10: "maximum",
	11: "exclusiveMaximum",
	12: "minimum",
	13: "exclusiveMinimum",
	14: "maxLength",
	15: "minLength",
	16: "pattern",
	17: "maxItems",
	18: "minItems",
	19: "uniqueItems",
	20: "maxProperties",
	21: "minProperties",
	22: "required",
	23: "enum",
	24: "type",
	25: "allOf",
	26: "oneOf",
	27: "anyOf",
	28: "not",
	29: "items",
	30: "properties",
	31: "additionalProperties",
	32: "default",
	33: "description",
	34: "format",
}

// Decode decodes Schema from json.
func (s *Schema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Schema to nil")
	}
	s.setDefaults()
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nullable":
			if err := func() error {
				s.Nullable.Reset()
				if err := s.Nullable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nullable\"")
			}
		case "discriminator":
			if err := func() error {
				s.Discriminator.Reset()
				if err := s.Discriminator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discriminator\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "writeOnly":
			if err := func() error {
				s.WriteOnly.Reset()
				if err := s.WriteOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeOnly\"")
			}
		case "xml":
			if err := func() error {
				s.XML.Reset()
				if err := s.XML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xml\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "multipleOf":
			if err := func() error {
				s.MultipleOf.Reset()
				if err := s.MultipleOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multipleOf\"")
			}
		case "maximum":
			if err := func() error {
				s.Maximum.Reset()
				if err := s.Maximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum\"")
			}
		case "exclusiveMaximum":
			if err := func() error {
				s.ExclusiveMaximum.Reset()
				if err := s.ExclusiveMaximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMaximum\"")
			}
		case "minimum":
			if err := func() error {
				s.Minimum.Reset()
				if err := s.Minimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum\"")
			}
		case "exclusiveMinimum":
			if err := func() error {
				s.ExclusiveMinimum.Reset()
				if err := s.ExclusiveMinimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMinimum\"")
			}
		case "maxLength":
			if err := func() error {
				s.MaxLength.Reset()
				if err := s.MaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLength\"")
			}
		case "minLength":
			if err := func() error {
				s.MinLength.Reset()
				if err := s.MinLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minLength\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "maxItems":
			if err := func() error {
				s.MaxItems.Reset()
				if err := s.MaxItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxItems\"")
			}
		case "minItems":
			if err := func() error {
				s.MinItems.Reset()
				if err := s.MinItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minItems\"")
			}
		case "uniqueItems":
			if err := func() error {
				s.UniqueItems.Reset()
				if err := s.UniqueItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniqueItems\"")
			}
		case "maxProperties":
			if err := func() error {
				s.MaxProperties.Reset()
				if err := s.MaxProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxProperties\"")
			}
		case "minProperties":
			if err := func() error {
				s.MinProperties.Reset()
				if err := s.MinProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minProperties\"")
			}
		case "required":
			if err := func() error {
				s.Required = nil
				var elem StringArray
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Required = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "enum":
			if err := func() error {
				s.Enum = nil
				var elem JsonschemaDraft4PropertiesEnum
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Enum = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "allOf":
			if err := func() error {
				s.AllOf = make([]SchemaOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SchemaOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllOf = append(s.AllOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allOf\"")
			}
		case "oneOf":
			if err := func() error {
				s.OneOf = make([]SchemaOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SchemaOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OneOf = append(s.OneOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oneOf\"")
			}
		case "anyOf":
			if err := func() error {
				s.AnyOf = make([]SchemaOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SchemaOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AnyOf = append(s.AnyOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anyOf\"")
			}
		case "not":
			if err := func() error {
				s.Not = nil
				var elem Schema
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Not = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"not\"")
			}
		case "items":
			if err := func() error {
				s.Items = nil
				var elem SchemaOrReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties = nil
				var elem SchemaAdditionalProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalProperties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "default":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Default = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Schema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Schema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Schema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaAdditionalProperties as json.
func (s SchemaAdditionalProperties) Encode(e *jx.Encoder) {
	switch s.Type {
	case SchemaOrReferenceSchemaAdditionalProperties:
		s.SchemaOrReference.Encode(e)
	case BoolSchemaAdditionalProperties:
		e.Bool(s.Bool)
	}
}

// Decode decodes SchemaAdditionalProperties from json.
func (s *SchemaAdditionalProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaAdditionalProperties to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.SchemaOrReference.Decode(d); err != nil {
			return err
		}
		s.Type = SchemaOrReferenceSchemaAdditionalProperties
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolSchemaAdditionalProperties
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaAdditionalProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaAdditionalProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaOrReference as json.
func (s SchemaOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case SchemaSchemaOrReference:
		s.Schema.Encode(e)
	case ReferenceSchemaOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes SchemaOrReference from json.
func (s *SchemaOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "nullable":
				found = true
				s.Type = SchemaSchemaOrReference
			case "discriminator":
				found = true
				s.Type = SchemaSchemaOrReference
			case "readOnly":
				found = true
				s.Type = SchemaSchemaOrReference
			case "writeOnly":
				found = true
				s.Type = SchemaSchemaOrReference
			case "xml":
				found = true
				s.Type = SchemaSchemaOrReference
			case "externalDocs":
				found = true
				s.Type = SchemaSchemaOrReference
			case "example":
				found = true
				s.Type = SchemaSchemaOrReference
			case "deprecated":
				found = true
				s.Type = SchemaSchemaOrReference
			case "title":
				found = true
				s.Type = SchemaSchemaOrReference
			case "multipleOf":
				found = true
				s.Type = SchemaSchemaOrReference
			case "maximum":
				found = true
				s.Type = SchemaSchemaOrReference
			case "exclusiveMaximum":
				found = true
				s.Type = SchemaSchemaOrReference
			case "minimum":
				found = true
				s.Type = SchemaSchemaOrReference
			case "exclusiveMinimum":
				found = true
				s.Type = SchemaSchemaOrReference
			case "maxLength":
				found = true
				s.Type = SchemaSchemaOrReference
			case "minLength":
				found = true
				s.Type = SchemaSchemaOrReference
			case "pattern":
				found = true
				s.Type = SchemaSchemaOrReference
			case "maxItems":
				found = true
				s.Type = SchemaSchemaOrReference
			case "minItems":
				found = true
				s.Type = SchemaSchemaOrReference
			case "uniqueItems":
				found = true
				s.Type = SchemaSchemaOrReference
			case "maxProperties":
				found = true
				s.Type = SchemaSchemaOrReference
			case "minProperties":
				found = true
				s.Type = SchemaSchemaOrReference
			case "required":
				found = true
				s.Type = SchemaSchemaOrReference
			case "enum":
				found = true
				s.Type = SchemaSchemaOrReference
			case "type":
				found = true
				s.Type = SchemaSchemaOrReference
			case "allOf":
				found = true
				s.Type = SchemaSchemaOrReference
			case "oneOf":
				found = true
				s.Type = SchemaSchemaOrReference
			case "anyOf":
				found = true
				s.Type = SchemaSchemaOrReference
			case "not":
				found = true
				s.Type = SchemaSchemaOrReference
			case "items":
				found = true
				s.Type = SchemaSchemaOrReference
			case "properties":
				found = true
				s.Type = SchemaSchemaOrReference
			case "additionalProperties":
				found = true
				s.Type = SchemaSchemaOrReference
			case "default":
				found = true
				s.Type = SchemaSchemaOrReference
			case "description":
				found = true
				s.Type = SchemaSchemaOrReference
			case "format":
				found = true
				s.Type = SchemaSchemaOrReference
			case "$ref":
				found = true
				s.Type = ReferenceSchemaOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SchemaSchemaOrReference:
		if err := s.Schema.Decode(d); err != nil {
			return err
		}
	case ReferenceSchemaOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SchemaPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SchemaPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SchemaPattern0 from json.
func (s *SchemaPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SchemaPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SchemaProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SchemaProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SchemaProperties from json.
func (s *SchemaProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SchemaOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SchemaProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaType as json.
func (s SchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SchemaType from json.
func (s *SchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SchemaType(v) {
	case SchemaTypeArray:
		*s = SchemaTypeArray
	case SchemaTypeBoolean:
		*s = SchemaTypeBoolean
	case SchemaTypeInteger:
		*s = SchemaTypeInteger
	case SchemaTypeNull:
		*s = SchemaTypeNull
	case SchemaTypeNumber:
		*s = SchemaTypeNumber
	case SchemaTypeObject:
		*s = SchemaTypeObject
	case SchemaTypeString:
		*s = SchemaTypeString
	default:
		*s = SchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SchemasOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SchemasOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SchemasOrReferences from json.
func (s *SchemasOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemasOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SchemaOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SchemasOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemasOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemasOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecurityRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecurityRequirement) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes SecurityRequirement from json.
func (s *SecurityRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecurityRequirement to nil")
	}
	m := s.init()
	pattern := regexMap["^[a-zA-Z0-9\\.\\-_]+$"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return errors.Errorf("unexpected field %q", k)
		}
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecurityRequirement")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecurityRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecurityRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecurityScheme) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s SecurityScheme) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.In.Set {
			e.FieldStart("in")
			s.In.Encode(e)
		}
	}
	{
		if s.Scheme.Set {
			e.FieldStart("scheme")
			s.Scheme.Encode(e)
		}
	}
	{
		if s.BearerFormat.Set {
			e.FieldStart("bearerFormat")
			s.BearerFormat.Encode(e)
		}
	}
	{
		if s.Flows.Set {
			e.FieldStart("flows")
			s.Flows.Encode(e)
		}
	}
	{
		if s.OpenIdConnectUrl.Set {
			e.FieldStart("openIdConnectUrl")
			s.OpenIdConnectUrl.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfSecurityScheme = [8]string{
	0: "type",
	1: "description",
	2: "name",
	3: "in",
	4: "scheme",
	5: "bearerFormat",
	6: "flows",
	7: "openIdConnectUrl",
}

// Decode decodes SecurityScheme from json.
func (s *SecurityScheme) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecurityScheme to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "in":
			if err := func() error {
				s.In.Reset()
				if err := s.In.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in\"")
			}
		case "scheme":
			if err := func() error {
				s.Scheme.Reset()
				if err := s.Scheme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheme\"")
			}
		case "bearerFormat":
			if err := func() error {
				s.BearerFormat.Reset()
				if err := s.BearerFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bearerFormat\"")
			}
		case "flows":
			if err := func() error {
				s.Flows.Reset()
				if err := s.Flows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flows\"")
			}
		case "openIdConnectUrl":
			if err := func() error {
				s.OpenIdConnectUrl.Reset()
				if err := s.OpenIdConnectUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openIdConnectUrl\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecurityScheme")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecurityScheme) {
					name = jsonFieldsNameOfSecurityScheme[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecurityScheme) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecurityScheme) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySchemeOrReference as json.
func (s SecuritySchemeOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case SecuritySchemeSecuritySchemeOrReference:
		s.SecurityScheme.Encode(e)
	case ReferenceSecuritySchemeOrReference:
		s.Reference.Encode(e)
	}
}

// Decode decodes SecuritySchemeOrReference from json.
func (s *SecuritySchemeOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySchemeOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "description":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "name":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "in":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "scheme":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "bearerFormat":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "flows":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "openIdConnectUrl":
				found = true
				s.Type = SecuritySchemeSecuritySchemeOrReference
			case "$ref":
				found = true
				s.Type = ReferenceSecuritySchemeOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SecuritySchemeSecuritySchemeOrReference:
		if err := s.SecurityScheme.Decode(d); err != nil {
			return err
		}
	case ReferenceSecuritySchemeOrReference:
		if err := s.Reference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecuritySchemeOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySchemeOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecuritySchemePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecuritySchemePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecuritySchemePattern0 from json.
func (s *SecuritySchemePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySchemePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecuritySchemePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecuritySchemePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySchemePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecuritySchemesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecuritySchemesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SecuritySchemesOrReferences from json.
func (s *SecuritySchemesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySchemesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SecuritySchemeOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecuritySchemesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecuritySchemesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySchemesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Server) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Server) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Variables.Set {
			e.FieldStart("variables")
			s.Variables.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfServer = [3]string{
	0: "url",
	1: "description",
	2: "variables",
}

// Decode decodes Server from json.
func (s *Server) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Server to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "variables":
			if err := func() error {
				s.Variables.Reset()
				if err := s.Variables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Server")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServer) {
					name = jsonFieldsNameOfServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Server) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Server) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ServerPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ServerPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ServerPattern0 from json.
func (s *ServerPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServerPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ServerVariable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s ServerVariable) encodeFields(e *jx.Encoder) {
	{
		if s.Enum != nil {
			e.FieldStart("enum")
			e.ArrStart()
			for _, elem := range s.Enum {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("default")
		e.Str(s.Default)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfServerVariable = [3]string{
	0: "enum",
	1: "default",
	2: "description",
}

// Decode decodes ServerVariable from json.
func (s *ServerVariable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerVariable to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enum":
			if err := func() error {
				s.Enum = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Enum = append(s.Enum, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Default = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerVariable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerVariable) {
					name = jsonFieldsNameOfServerVariable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServerVariable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerVariable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ServerVariablePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ServerVariablePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ServerVariablePattern0 from json.
func (s *ServerVariablePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerVariablePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerVariablePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServerVariablePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerVariablePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ServerVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ServerVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ServerVariables from json.
func (s *ServerVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ServerVariable
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServerVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Spec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Spec) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("openapi")
		e.Str(s.Openapi)
	}
	{

		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("paths")
		s.Paths.Encode(e)
	}
	{
		if s.Components.Set {
			e.FieldStart("components")
			s.Components.Encode(e)
		}
	}
	{
		if s.Security != nil {
			e.FieldStart("security")
			e.ArrStart()
			for _, elem := range s.Security {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfSpec = [8]string{
	0: "openapi",
	1: "info",
	2: "servers",
	3: "paths",
	4: "components",
	5: "security",
	6: "tags",
	7: "externalDocs",
}

// Decode decodes Spec from json.
func (s *Spec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Spec to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openapi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Openapi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openapi\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]Server, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Server
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "paths":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Paths.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paths\"")
			}
		case "components":
			if err := func() error {
				s.Components.Reset()
				if err := s.Components.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "security":
			if err := func() error {
				s.Security = make([]SecurityRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SecurityRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Security = append(s.Security, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Spec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpec) {
					name = jsonFieldsNameOfSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Spec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Spec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpecPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpecPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpecPattern0 from json.
func (s *SpecPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpecPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpecPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpecPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpecPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StringArray as json.
func (s StringArray) Encode(e *jx.Encoder) {
	unwrapped := []string(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes StringArray from json.
func (s *StringArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StringArray to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StringArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Strings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s Strings) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes Strings from json.
func (s *Strings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Strings to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Strings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Strings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Strings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Tag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Tag) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfTag = [3]string{
	0: "name",
	1: "description",
	2: "externalDocs",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}
	var requiredBitSet [1]uint8
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTag) {
					name = jsonFieldsNameOfTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TagPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TagPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes TagPattern0 from json.
func (s *TagPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TagPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s XML) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s XML) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.Attribute.Set {
			e.FieldStart("attribute")
			s.Attribute.Encode(e)
		}
	}
	{
		if s.Wrapped.Set {
			e.FieldStart("wrapped")
			s.Wrapped.Encode(e)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfXML = [5]string{
	0: "name",
	1: "namespace",
	2: "prefix",
	3: "attribute",
	4: "wrapped",
}

// Decode decodes XML from json.
func (s *XML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode XML to nil")
	}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "attribute":
			if err := func() error {
				s.Attribute.Reset()
				if err := s.Attribute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attribute\"")
			}
		case "wrapped":
			if err := func() error {
				s.Wrapped.Reset()
				if err := s.Wrapped.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wrapped\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode XML")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s XML) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *XML) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s XMLPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s XMLPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes XMLPattern0 from json.
func (s *XMLPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode XMLPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode XMLPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s XMLPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *XMLPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

func (s Callback) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s CallbackOrReference) Validate() error {
	switch s.Type {
	case CallbackCallbackOrReference:
		if err := s.Callback.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case ReferenceCallbackOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s CallbackPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s CallbacksOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Components) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Schemas.Set {
			if err := func() error {
				if err := s.Schemas.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schemas",
			Error: err,
		})
	}
	if err := func() error {
		if s.Responses.Set {
			if err := func() error {
				if err := s.Responses.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "responses",
			Error: err,
		})
	}
	if err := func() error {
		if s.Parameters.Set {
			if err := func() error {
				if err := s.Parameters.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "parameters",
			Error: err,
		})
	}
	if err := func() error {
		if s.RequestBodies.Set {
			if err := func() error {
				if err := s.RequestBodies.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "requestBodies",
			Error: err,
		})
	}
	if err := func() error {
		if s.Headers.Set {
			if err := func() error {
				if err := s.Headers.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "headers",
			Error: err,
		})
	}
	if err := func() error {
		if s.Callbacks.Set {
			if err := func() error {
				if err := s.Callbacks.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "callbacks",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Encoding) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Headers.Set {
			if err := func() error {
				if err := s.Headers.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "headers",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Encodings) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Header) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Schema.Set {
			if err := func() error {
				if err := s.Schema.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schema",
			Error: err,
		})
	}
	if err := func() error {
		if s.Content.Set {
			if err := func() error {
				if err := s.Content.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s HeaderOrReference) Validate() error {
	switch s.Type {
	case HeaderHeaderOrReference:
		if err := s.Header.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case ReferenceHeaderOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s HeadersOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s JsonschemaDraft4PropertiesEnum) Validate() error {
	if s == nil {
		return errors.New("nil is invalid value")
	}
	if err := (validate.Array{
		MinLength:    1,
		MinLengthSet: true,
		MaxLength:    0,
		MaxLengthSet: false,
	}).ValidateLength(len(s)); err != nil {
		return errors.Wrap(err, "array")
	}
	return nil // return 1
}
func (s JsonschemaDraft4PropertiesMaximum) Validate() error {
	if err := (validate.Float{}).Validate(float64(s)); err != nil {
		return errors.Wrap(err, "float")
	}
	return nil // return 1
}
func (s JsonschemaDraft4PropertiesMinimum) Validate() error {
	if err := (validate.Float{}).Validate(float64(s)); err != nil {
		return errors.Wrap(err, "float")
	}
	return nil // return 1
}
func (s JsonschemaDraft4PropertiesMultipleOf) Validate() error {
	if err := (validate.Float{
		MinSet:        true,
		Min:           0,
		MaxSet:        false,
		Max:           0,
		MinExclusive:  true,
		MaxExclusive:  false,
		MultipleOfSet: false,
		MultipleOf:    nil,
	}).Validate(float64(s)); err != nil {
		return errors.Wrap(err, "float")
	}
	return nil // return 1
}
func (s MediaType) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Schema.Set {
			if err := func() error {
				if err := s.Schema.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schema",
			Error: err,
		})
	}
	if err := func() error {
		if s.Encoding.Set {
			if err := func() error {
				if err := s.Encoding.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "encoding",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MediaTypes) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Operation) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Parameters {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "parameters",
			Error: err,
		})
	}
	if err := func() error {
		if s.RequestBody.Set {
			if err := func() error {
				if err := s.RequestBody.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "requestBody",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Responses.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "responses",
			Error: err,
		})
	}
	if err := func() error {
		if s.Callbacks.Set {
			if err := func() error {
				if err := s.Callbacks.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "callbacks",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Security {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "security",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s Parameter) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.In.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "in",
			Error: err,
		})
	}
	if err := func() error {
		if s.Style.Set {
			if err := func() error {
				if err := s.Style.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "style",
			Error: err,
		})
	}
	if err := func() error {
		if s.Schema.Set {
			if err := func() error {
				if err := s.Schema.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schema",
			Error: err,
		})
	}
	if err := func() error {
		if s.Content.Set {
			if err := func() error {
				if err := s.Content.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s ParameterIn) Validate() error {
	switch s {
	case "path":
		return nil
	case "query":
		return nil
	case "cookie":
		return nil
	case "header":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s ParameterOrReference) Validate() error {
	switch s.Type {
	case ParameterParameterOrReference:
		if err := s.Parameter.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case ReferenceParameterOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s ParameterStyle) Validate() error {
	switch s {
	case "matrix":
		return nil
	case "label":
		return nil
	case "form":
		return nil
	case "simple":
		return nil
	case "spaceDelimited":
		return nil
	case "pipeDelimited":
		return nil
	case "deepObject":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s ParametersOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PathItem) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Get.Set {
			if err := func() error {
				if err := s.Get.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "get",
			Error: err,
		})
	}
	if err := func() error {
		if s.Put.Set {
			if err := func() error {
				if err := s.Put.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "put",
			Error: err,
		})
	}
	if err := func() error {
		if s.Post.Set {
			if err := func() error {
				if err := s.Post.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "post",
			Error: err,
		})
	}
	if err := func() error {
		if s.Delete.Set {
			if err := func() error {
				if err := s.Delete.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "delete",
			Error: err,
		})
	}
	if err := func() error {
		if s.Options.Set {
			if err := func() error {
				if err := s.Options.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "options",
			Error: err,
		})
	}
	if err := func() error {
		if s.Head.Set {
			if err := func() error {
				if err := s.Head.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "head",
			Error: err,
		})
	}
	if err := func() error {
		if s.Patch.Set {
			if err := func() error {
				if err := s.Patch.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "patch",
			Error: err,
		})
	}
	if err := func() error {
		if s.Trace.Set {
			if err := func() error {
				if err := s.Trace.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "trace",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Parameters {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "parameters",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Paths) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PathsPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PositiveInteger) Validate() error {
	if err := (validate.Int{
		MinSet:        true,
		Min:           0,
		MaxSet:        false,
		Max:           0,
		MinExclusive:  false,
		MaxExclusive:  false,
		MultipleOfSet: false,
		MultipleOf:    0,
	}).Validate(int64(s)); err != nil {
		return errors.Wrap(err, "int")
	}
	return nil // return 1
}
func (s RequestBodiesOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s RequestBody) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Content.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s RequestBodyOrReference) Validate() error {
	switch s.Type {
	case RequestBodyRequestBodyOrReference:
		if err := s.RequestBody.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case ReferenceRequestBodyOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s Response) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Headers.Set {
			if err := func() error {
				if err := s.Headers.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "headers",
			Error: err,
		})
	}
	if err := func() error {
		if s.Content.Set {
			if err := func() error {
				if err := s.Content.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s ResponseOrReference) Validate() error {
	switch s.Type {
	case ResponseResponseOrReference:
		if err := s.Response.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case ReferenceResponseOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s Responses) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Default.Set {
			if err := func() error {
				if err := s.Default.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "default",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s ResponsesOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s ResponsesPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Schema) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.MultipleOf.Set {
			if err := func() error {
				if err := s.MultipleOf.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "multipleOf",
			Error: err,
		})
	}
	if err := func() error {
		if s.Maximum.Set {
			if err := func() error {
				if err := s.Maximum.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maximum",
			Error: err,
		})
	}
	if err := func() error {
		if s.Minimum.Set {
			if err := func() error {
				if err := s.Minimum.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minimum",
			Error: err,
		})
	}
	if err := func() error {
		if s.MaxLength.Set {
			if err := func() error {
				if err := s.MaxLength.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maxLength",
			Error: err,
		})
	}
	if err := func() error {
		if s.MinLength.Set {
			if err := func() error {
				if err := s.MinLength.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minLength",
			Error: err,
		})
	}
	if err := func() error {
		if s.MaxItems.Set {
			if err := func() error {
				if err := s.MaxItems.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maxItems",
			Error: err,
		})
	}
	if err := func() error {
		if s.MinItems.Set {
			if err := func() error {
				if err := s.MinItems.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minItems",
			Error: err,
		})
	}
	if err := func() error {
		if s.MaxProperties.Set {
			if err := func() error {
				if err := s.MaxProperties.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maxProperties",
			Error: err,
		})
	}
	if err := func() error {
		if s.MinProperties.Set {
			if err := func() error {
				if err := s.MinProperties.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minProperties",
			Error: err,
		})
	}
	if err := func() error {
		if s.Required == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Required.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "required",
			Error: err,
		})
	}
	if err := func() error {
		if s.Enum == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Enum.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "enum",
			Error: err,
		})
	}
	if err := func() error {
		if s.Type.Set {
			if err := func() error {
				if err := s.Type.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.AllOf)); err != nil {
			return errors.Wrap(err, "array")
		}
		var failures []validate.FieldError
		for i, elem := range s.AllOf {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "allOf",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.OneOf)); err != nil {
			return errors.Wrap(err, "array")
		}
		var failures []validate.FieldError
		for i, elem := range s.OneOf {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "oneOf",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.AnyOf)); err != nil {
			return errors.Wrap(err, "array")
		}
		var failures []validate.FieldError
		for i, elem := range s.AnyOf {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "anyOf",
			Error: err,
		})
	}
	if err := func() error {
		if s.Not == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Not.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "not",
			Error: err,
		})
	}
	if err := func() error {
		if s.Items == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Items.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if err := func() error {
		if s.Properties.Set {
			if err := func() error {
				if err := s.Properties.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "properties",
			Error: err,
		})
	}
	if err := func() error {
		if s.AdditionalProperties == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.AdditionalProperties.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "additionalProperties",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SchemaAdditionalProperties) Validate() error {
	switch s.Type {
	case SchemaOrReferenceSchemaAdditionalProperties:
		if err := s.SchemaOrReference.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case BoolSchemaAdditionalProperties:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s SchemaOrReference) Validate() error {
	switch s.Type {
	case SchemaSchemaOrReference:
		if err := s.Schema.Validate(); err != nil {
			return err
		}
		return nil // return 1
	case ReferenceSchemaOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s SchemaProperties) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SchemaType) Validate() error {
	switch s {
	case "array":
		return nil
	case "boolean":
		return nil
	case "integer":
		return nil
	case "null":
		return nil
	case "number":
		return nil
	case "object":
		return nil
	case "string":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s SchemasOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SecurityRequirement) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if elem == nil {
				return errors.New("nil is invalid value")
			}
			return nil // return 1
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Spec) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Paths.Validate(); err != nil {
			return err
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "paths",
			Error: err,
		})
	}
	if err := func() error {
		if s.Components.Set {
			if err := func() error {
				if err := s.Components.Value.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				return err
			}
		}
		return nil // return 2
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "components",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Security {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil // return 1
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil // return 1
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "security",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s StringArray) Validate() error {
	if s == nil {
		return errors.New("nil is invalid value")
	}
	if err := (validate.Array{
		MinLength:    1,
		MinLengthSet: true,
		MaxLength:    0,
		MaxLengthSet: false,
	}).ValidateLength(len(s)); err != nil {
		return errors.Wrap(err, "array")
	}
	return nil // return 1
}
