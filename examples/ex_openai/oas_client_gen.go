// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CancelFineTune invokes cancelFineTune operation.
	//
	// Immediately cancel a fine-tune job.
	//
	// POST /fine-tunes/{fine_tune_id}/cancel
	CancelFineTune(ctx context.Context, params CancelFineTuneParams) (FineTune, error)
	// CreateAnswer invokes createAnswer operation.
	//
	// Answers the specified question using the provided documents and examples.
	// The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to
	// find relevant context. The relevant context is combined with the provided examples and question to
	// create the prompt for [completion](/docs/api-reference/completions).
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /answers
	CreateAnswer(ctx context.Context, request *CreateAnswerRequest) (*CreateAnswerResponse, error)
	// CreateChatCompletion invokes createChatCompletion operation.
	//
	// Creates a completion for the chat message.
	//
	// POST /chat/completions
	CreateChatCompletion(ctx context.Context, request *CreateChatCompletionRequest) (*CreateChatCompletionResponse, error)
	// CreateClassification invokes createClassification operation.
	//
	// Classifies the specified `query` using provided examples.
	// The endpoint first [searches](/docs/api-reference/searches) over the labeled examples
	// to select the ones most relevant for the particular query. Then, the relevant examples
	// are combined with the query to construct a prompt to produce the final label via the
	// [completions](/docs/api-reference/completions) endpoint.
	// Labeled examples can be provided via an uploaded `file`, or explicitly listed in the
	// request using the `examples` parameter for quick tests and small scale use cases.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /classifications
	CreateClassification(ctx context.Context, request *CreateClassificationRequest) (*CreateClassificationResponse, error)
	// CreateCompletion invokes createCompletion operation.
	//
	// Creates a completion for the provided prompt and parameters.
	//
	// POST /completions
	CreateCompletion(ctx context.Context, request *CreateCompletionRequest) (*CreateCompletionResponse, error)
	// CreateEdit invokes createEdit operation.
	//
	// Creates a new edit for the provided input, instruction, and parameters.
	//
	// POST /edits
	CreateEdit(ctx context.Context, request *CreateEditRequest) (*CreateEditResponse, error)
	// CreateEmbedding invokes createEmbedding operation.
	//
	// Creates an embedding vector representing the input text.
	//
	// POST /embeddings
	CreateEmbedding(ctx context.Context, request *CreateEmbeddingRequest) (*CreateEmbeddingResponse, error)
	// CreateFile invokes createFile operation.
	//
	// Upload a file that contains document(s) to be used across various endpoints/features. Currently,
	// the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you
	// need to increase the storage limit.
	//
	// POST /files
	CreateFile(ctx context.Context, request *CreateFileRequestMultipart) (OpenAIFile, error)
	// CreateFineTune invokes createFineTune operation.
	//
	// Creates a job that fine-tunes a specified model from a given dataset.
	// Response includes details of the enqueued job including job status and the name of the fine-tuned
	// models once complete.
	// [Learn more about Fine-tuning](/docs/guides/fine-tuning).
	//
	// POST /fine-tunes
	CreateFineTune(ctx context.Context, request *CreateFineTuneRequest) (FineTune, error)
	// CreateImage invokes createImage operation.
	//
	// Creates an image given a prompt.
	//
	// POST /images/generations
	CreateImage(ctx context.Context, request *CreateImageRequest) (ImagesResponse, error)
	// CreateImageEdit invokes createImageEdit operation.
	//
	// Creates an edited or extended image given an original image and a prompt.
	//
	// POST /images/edits
	CreateImageEdit(ctx context.Context, request *CreateImageEditRequestMultipart) (ImagesResponse, error)
	// CreateImageVariation invokes createImageVariation operation.
	//
	// Creates a variation of a given image.
	//
	// POST /images/variations
	CreateImageVariation(ctx context.Context, request *CreateImageVariationRequestMultipart) (ImagesResponse, error)
	// CreateModeration invokes createModeration operation.
	//
	// Classifies if text violates OpenAI's Content Policy.
	//
	// POST /moderations
	CreateModeration(ctx context.Context, request *CreateModerationRequest) (*CreateModerationResponse, error)
	// CreateSearch invokes createSearch operation.
	//
	// The search endpoint computes similarity scores between provided query and documents. Documents can
	// be passed directly to the API if there are no more than 200 of them.
	// To go beyond the 200 document limit, documents can be processed offline and then used for
	// efficient retrieval at query time. When `file` is set, the search endpoint searches over all the
	// documents in the given file and returns up to the `max_rerank` number of documents. These
	// documents will be returned along with their search scores.
	// The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go
	// higher), where a score above 200 usually means the document is semantically similar to the query.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /engines/{engine_id}/search
	CreateSearch(ctx context.Context, request *CreateSearchRequest, params CreateSearchParams) (*CreateSearchResponse, error)
	// CreateTranscription invokes createTranscription operation.
	//
	// Transcribes audio into the input language.
	//
	// POST /audio/transcriptions
	CreateTranscription(ctx context.Context, request *CreateTranscriptionRequestMultipart) (*CreateTranscriptionResponse, error)
	// CreateTranslation invokes createTranslation operation.
	//
	// Translates audio into into English.
	//
	// POST /audio/translations
	CreateTranslation(ctx context.Context, request *CreateTranslationRequestMultipart) (*CreateTranslationResponse, error)
	// DeleteFile invokes deleteFile operation.
	//
	// Delete a file.
	//
	// DELETE /files/{file_id}
	DeleteFile(ctx context.Context, params DeleteFileParams) (*DeleteFileResponse, error)
	// DeleteModel invokes deleteModel operation.
	//
	// Delete a fine-tuned model. You must have the Owner role in your organization.
	//
	// DELETE /models/{model}
	DeleteModel(ctx context.Context, params DeleteModelParams) (*DeleteModelResponse, error)
	// DownloadFile invokes downloadFile operation.
	//
	// Returns the contents of the specified file.
	//
	// GET /files/{file_id}/content
	DownloadFile(ctx context.Context, params DownloadFileParams) (string, error)
	// ListEngines invokes listEngines operation.
	//
	// Lists the currently available (non-finetuned) models, and provides basic information about each
	// one such as the owner and availability.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /engines
	ListEngines(ctx context.Context) (*ListEnginesResponse, error)
	// ListFiles invokes listFiles operation.
	//
	// Returns a list of files that belong to the user's organization.
	//
	// GET /files
	ListFiles(ctx context.Context) (*ListFilesResponse, error)
	// ListFineTuneEvents invokes listFineTuneEvents operation.
	//
	// Get fine-grained status updates for a fine-tune job.
	//
	// GET /fine-tunes/{fine_tune_id}/events
	ListFineTuneEvents(ctx context.Context, params ListFineTuneEventsParams) (*ListFineTuneEventsResponse, error)
	// ListFineTunes invokes listFineTunes operation.
	//
	// List your organization's fine-tuning jobs.
	//
	// GET /fine-tunes
	ListFineTunes(ctx context.Context) (*ListFineTunesResponse, error)
	// ListModels invokes listModels operation.
	//
	// Lists the currently available models, and provides basic information about each one such as the
	// owner and availability.
	//
	// GET /models
	ListModels(ctx context.Context) (*ListModelsResponse, error)
	// RetrieveEngine invokes retrieveEngine operation.
	//
	// Retrieves a model instance, providing basic information about it such as the owner and
	// availability.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /engines/{engine_id}
	RetrieveEngine(ctx context.Context, params RetrieveEngineParams) (Engine, error)
	// RetrieveFile invokes retrieveFile operation.
	//
	// Returns information about a specific file.
	//
	// GET /files/{file_id}
	RetrieveFile(ctx context.Context, params RetrieveFileParams) (OpenAIFile, error)
	// RetrieveFineTune invokes retrieveFineTune operation.
	//
	// Gets info about the fine-tune job.
	// [Learn more about Fine-tuning](/docs/guides/fine-tuning).
	//
	// GET /fine-tunes/{fine_tune_id}
	RetrieveFineTune(ctx context.Context, params RetrieveFineTuneParams) (FineTune, error)
	// RetrieveModel invokes retrieveModel operation.
	//
	// Retrieves a model instance, providing basic information about the model such as the owner and
	// permissioning.
	//
	// GET /models/{model}
	RetrieveModel(ctx context.Context, params RetrieveModelParams) (Model, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CancelFineTune invokes cancelFineTune operation.
//
// Immediately cancel a fine-tune job.
//
// POST /fine-tunes/{fine_tune_id}/cancel
func (c *Client) CancelFineTune(ctx context.Context, params CancelFineTuneParams) (FineTune, error) {
	res, err := c.sendCancelFineTune(ctx, params)
	return res, err
}

func (c *Client) sendCancelFineTune(ctx context.Context, params CancelFineTuneParams) (res FineTune, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cancelFineTune"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/fine-tunes/{fine_tune_id}/cancel"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CancelFineTune",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/fine-tunes/"
	{
		// Encode "fine_tune_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fine_tune_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FineTuneID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCancelFineTuneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAnswer invokes createAnswer operation.
//
// Answers the specified question using the provided documents and examples.
// The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to
// find relevant context. The relevant context is combined with the provided examples and question to
// create the prompt for [completion](/docs/api-reference/completions).
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /answers
func (c *Client) CreateAnswer(ctx context.Context, request *CreateAnswerRequest) (*CreateAnswerResponse, error) {
	res, err := c.sendCreateAnswer(ctx, request)
	return res, err
}

func (c *Client) sendCreateAnswer(ctx context.Context, request *CreateAnswerRequest) (res *CreateAnswerResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAnswer"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/answers"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateAnswer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/answers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAnswerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAnswerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatCompletion invokes createChatCompletion operation.
//
// Creates a completion for the chat message.
//
// POST /chat/completions
func (c *Client) CreateChatCompletion(ctx context.Context, request *CreateChatCompletionRequest) (*CreateChatCompletionResponse, error) {
	res, err := c.sendCreateChatCompletion(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatCompletion(ctx context.Context, request *CreateChatCompletionRequest) (res *CreateChatCompletionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createChatCompletion"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/chat/completions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateChatCompletion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/chat/completions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatCompletionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatCompletionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateClassification invokes createClassification operation.
//
// Classifies the specified `query` using provided examples.
// The endpoint first [searches](/docs/api-reference/searches) over the labeled examples
// to select the ones most relevant for the particular query. Then, the relevant examples
// are combined with the query to construct a prompt to produce the final label via the
// [completions](/docs/api-reference/completions) endpoint.
// Labeled examples can be provided via an uploaded `file`, or explicitly listed in the
// request using the `examples` parameter for quick tests and small scale use cases.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /classifications
func (c *Client) CreateClassification(ctx context.Context, request *CreateClassificationRequest) (*CreateClassificationResponse, error) {
	res, err := c.sendCreateClassification(ctx, request)
	return res, err
}

func (c *Client) sendCreateClassification(ctx context.Context, request *CreateClassificationRequest) (res *CreateClassificationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createClassification"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/classifications"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateClassification",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/classifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClassificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateClassificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCompletion invokes createCompletion operation.
//
// Creates a completion for the provided prompt and parameters.
//
// POST /completions
func (c *Client) CreateCompletion(ctx context.Context, request *CreateCompletionRequest) (*CreateCompletionResponse, error) {
	res, err := c.sendCreateCompletion(ctx, request)
	return res, err
}

func (c *Client) sendCreateCompletion(ctx context.Context, request *CreateCompletionRequest) (res *CreateCompletionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createCompletion"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/completions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateCompletion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/completions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCompletionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCompletionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEdit invokes createEdit operation.
//
// Creates a new edit for the provided input, instruction, and parameters.
//
// POST /edits
func (c *Client) CreateEdit(ctx context.Context, request *CreateEditRequest) (*CreateEditResponse, error) {
	res, err := c.sendCreateEdit(ctx, request)
	return res, err
}

func (c *Client) sendCreateEdit(ctx context.Context, request *CreateEditRequest) (res *CreateEditResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createEdit"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/edits"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateEdit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/edits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEditRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEmbedding invokes createEmbedding operation.
//
// Creates an embedding vector representing the input text.
//
// POST /embeddings
func (c *Client) CreateEmbedding(ctx context.Context, request *CreateEmbeddingRequest) (*CreateEmbeddingResponse, error) {
	res, err := c.sendCreateEmbedding(ctx, request)
	return res, err
}

func (c *Client) sendCreateEmbedding(ctx context.Context, request *CreateEmbeddingRequest) (res *CreateEmbeddingResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createEmbedding"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/embeddings"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateEmbedding",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/embeddings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEmbeddingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEmbeddingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFile invokes createFile operation.
//
// Upload a file that contains document(s) to be used across various endpoints/features. Currently,
// the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you
// need to increase the storage limit.
//
// POST /files
func (c *Client) CreateFile(ctx context.Context, request *CreateFileRequestMultipart) (OpenAIFile, error) {
	res, err := c.sendCreateFile(ctx, request)
	return res, err
}

func (c *Client) sendCreateFile(ctx context.Context, request *CreateFileRequestMultipart) (res OpenAIFile, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createFile"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/files"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateFile",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFineTune invokes createFineTune operation.
//
// Creates a job that fine-tunes a specified model from a given dataset.
// Response includes details of the enqueued job including job status and the name of the fine-tuned
// models once complete.
// [Learn more about Fine-tuning](/docs/guides/fine-tuning).
//
// POST /fine-tunes
func (c *Client) CreateFineTune(ctx context.Context, request *CreateFineTuneRequest) (FineTune, error) {
	res, err := c.sendCreateFineTune(ctx, request)
	return res, err
}

func (c *Client) sendCreateFineTune(ctx context.Context, request *CreateFineTuneRequest) (res FineTune, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createFineTune"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/fine-tunes"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateFineTune",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/fine-tunes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFineTuneRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateFineTuneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImage invokes createImage operation.
//
// Creates an image given a prompt.
//
// POST /images/generations
func (c *Client) CreateImage(ctx context.Context, request *CreateImageRequest) (ImagesResponse, error) {
	res, err := c.sendCreateImage(ctx, request)
	return res, err
}

func (c *Client) sendCreateImage(ctx context.Context, request *CreateImageRequest) (res ImagesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createImage"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/images/generations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateImage",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/images/generations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImageEdit invokes createImageEdit operation.
//
// Creates an edited or extended image given an original image and a prompt.
//
// POST /images/edits
func (c *Client) CreateImageEdit(ctx context.Context, request *CreateImageEditRequestMultipart) (ImagesResponse, error) {
	res, err := c.sendCreateImageEdit(ctx, request)
	return res, err
}

func (c *Client) sendCreateImageEdit(ctx context.Context, request *CreateImageEditRequestMultipart) (res ImagesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createImageEdit"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/images/edits"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateImageEdit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/images/edits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImageEditRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateImageEditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImageVariation invokes createImageVariation operation.
//
// Creates a variation of a given image.
//
// POST /images/variations
func (c *Client) CreateImageVariation(ctx context.Context, request *CreateImageVariationRequestMultipart) (ImagesResponse, error) {
	res, err := c.sendCreateImageVariation(ctx, request)
	return res, err
}

func (c *Client) sendCreateImageVariation(ctx context.Context, request *CreateImageVariationRequestMultipart) (res ImagesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createImageVariation"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/images/variations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateImageVariation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/images/variations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImageVariationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateImageVariationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateModeration invokes createModeration operation.
//
// Classifies if text violates OpenAI's Content Policy.
//
// POST /moderations
func (c *Client) CreateModeration(ctx context.Context, request *CreateModerationRequest) (*CreateModerationResponse, error) {
	res, err := c.sendCreateModeration(ctx, request)
	return res, err
}

func (c *Client) sendCreateModeration(ctx context.Context, request *CreateModerationRequest) (res *CreateModerationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createModeration"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/moderations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateModeration",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/moderations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateModerationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateModerationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSearch invokes createSearch operation.
//
// The search endpoint computes similarity scores between provided query and documents. Documents can
// be passed directly to the API if there are no more than 200 of them.
// To go beyond the 200 document limit, documents can be processed offline and then used for
// efficient retrieval at query time. When `file` is set, the search endpoint searches over all the
// documents in the given file and returns up to the `max_rerank` number of documents. These
// documents will be returned along with their search scores.
// The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go
// higher), where a score above 200 usually means the document is semantically similar to the query.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /engines/{engine_id}/search
func (c *Client) CreateSearch(ctx context.Context, request *CreateSearchRequest, params CreateSearchParams) (*CreateSearchResponse, error) {
	res, err := c.sendCreateSearch(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateSearch(ctx context.Context, request *CreateSearchRequest, params CreateSearchParams) (res *CreateSearchResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createSearch"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/engines/{engine_id}/search"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateSearch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/engines/"
	{
		// Encode "engine_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "engine_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EngineID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/search"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSearchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSearchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTranscription invokes createTranscription operation.
//
// Transcribes audio into the input language.
//
// POST /audio/transcriptions
func (c *Client) CreateTranscription(ctx context.Context, request *CreateTranscriptionRequestMultipart) (*CreateTranscriptionResponse, error) {
	res, err := c.sendCreateTranscription(ctx, request)
	return res, err
}

func (c *Client) sendCreateTranscription(ctx context.Context, request *CreateTranscriptionRequestMultipart) (res *CreateTranscriptionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createTranscription"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/audio/transcriptions"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateTranscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/audio/transcriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTranscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTranslation invokes createTranslation operation.
//
// Translates audio into into English.
//
// POST /audio/translations
func (c *Client) CreateTranslation(ctx context.Context, request *CreateTranslationRequestMultipart) (*CreateTranslationResponse, error) {
	res, err := c.sendCreateTranslation(ctx, request)
	return res, err
}

func (c *Client) sendCreateTranslation(ctx context.Context, request *CreateTranslationRequestMultipart) (res *CreateTranslationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createTranslation"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/audio/translations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateTranslation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/audio/translations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTranslationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTranslationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFile invokes deleteFile operation.
//
// Delete a file.
//
// DELETE /files/{file_id}
func (c *Client) DeleteFile(ctx context.Context, params DeleteFileParams) (*DeleteFileResponse, error) {
	res, err := c.sendDeleteFile(ctx, params)
	return res, err
}

func (c *Client) sendDeleteFile(ctx context.Context, params DeleteFileParams) (res *DeleteFileResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteFile"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/files/{file_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteFile",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/files/"
	{
		// Encode "file_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "file_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteModel invokes deleteModel operation.
//
// Delete a fine-tuned model. You must have the Owner role in your organization.
//
// DELETE /models/{model}
func (c *Client) DeleteModel(ctx context.Context, params DeleteModelParams) (*DeleteModelResponse, error) {
	res, err := c.sendDeleteModel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteModel(ctx context.Context, params DeleteModelParams) (res *DeleteModelResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteModel"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/models/{model}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteModel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/models/"
	{
		// Encode "model" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Model))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DownloadFile invokes downloadFile operation.
//
// Returns the contents of the specified file.
//
// GET /files/{file_id}/content
func (c *Client) DownloadFile(ctx context.Context, params DownloadFileParams) (string, error) {
	res, err := c.sendDownloadFile(ctx, params)
	return res, err
}

func (c *Client) sendDownloadFile(ctx context.Context, params DownloadFileParams) (res string, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("downloadFile"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/files/{file_id}/content"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DownloadFile",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/files/"
	{
		// Encode "file_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "file_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/content"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDownloadFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListEngines invokes listEngines operation.
//
// Lists the currently available (non-finetuned) models, and provides basic information about each
// one such as the owner and availability.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /engines
func (c *Client) ListEngines(ctx context.Context) (*ListEnginesResponse, error) {
	res, err := c.sendListEngines(ctx)
	return res, err
}

func (c *Client) sendListEngines(ctx context.Context) (res *ListEnginesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEngines"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/engines"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListEngines",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/engines"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListEnginesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListFiles invokes listFiles operation.
//
// Returns a list of files that belong to the user's organization.
//
// GET /files
func (c *Client) ListFiles(ctx context.Context) (*ListFilesResponse, error) {
	res, err := c.sendListFiles(ctx)
	return res, err
}

func (c *Client) sendListFiles(ctx context.Context) (res *ListFilesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFiles"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/files"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListFiles",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListFilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListFineTuneEvents invokes listFineTuneEvents operation.
//
// Get fine-grained status updates for a fine-tune job.
//
// GET /fine-tunes/{fine_tune_id}/events
func (c *Client) ListFineTuneEvents(ctx context.Context, params ListFineTuneEventsParams) (*ListFineTuneEventsResponse, error) {
	res, err := c.sendListFineTuneEvents(ctx, params)
	return res, err
}

func (c *Client) sendListFineTuneEvents(ctx context.Context, params ListFineTuneEventsParams) (res *ListFineTuneEventsResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFineTuneEvents"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/fine-tunes/{fine_tune_id}/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListFineTuneEvents",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/fine-tunes/"
	{
		// Encode "fine_tune_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fine_tune_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FineTuneID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "stream" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "stream",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Stream.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListFineTuneEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListFineTunes invokes listFineTunes operation.
//
// List your organization's fine-tuning jobs.
//
// GET /fine-tunes
func (c *Client) ListFineTunes(ctx context.Context) (*ListFineTunesResponse, error) {
	res, err := c.sendListFineTunes(ctx)
	return res, err
}

func (c *Client) sendListFineTunes(ctx context.Context) (res *ListFineTunesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFineTunes"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/fine-tunes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListFineTunes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/fine-tunes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListFineTunesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListModels invokes listModels operation.
//
// Lists the currently available models, and provides basic information about each one such as the
// owner and availability.
//
// GET /models
func (c *Client) ListModels(ctx context.Context) (*ListModelsResponse, error) {
	res, err := c.sendListModels(ctx)
	return res, err
}

func (c *Client) sendListModels(ctx context.Context) (res *ListModelsResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listModels"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/models"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListModels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/models"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveEngine invokes retrieveEngine operation.
//
// Retrieves a model instance, providing basic information about it such as the owner and
// availability.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /engines/{engine_id}
func (c *Client) RetrieveEngine(ctx context.Context, params RetrieveEngineParams) (Engine, error) {
	res, err := c.sendRetrieveEngine(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveEngine(ctx context.Context, params RetrieveEngineParams) (res Engine, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retrieveEngine"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/engines/{engine_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RetrieveEngine",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/engines/"
	{
		// Encode "engine_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "engine_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EngineID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetrieveEngineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveFile invokes retrieveFile operation.
//
// Returns information about a specific file.
//
// GET /files/{file_id}
func (c *Client) RetrieveFile(ctx context.Context, params RetrieveFileParams) (OpenAIFile, error) {
	res, err := c.sendRetrieveFile(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveFile(ctx context.Context, params RetrieveFileParams) (res OpenAIFile, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retrieveFile"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/files/{file_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RetrieveFile",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/files/"
	{
		// Encode "file_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "file_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetrieveFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveFineTune invokes retrieveFineTune operation.
//
// Gets info about the fine-tune job.
// [Learn more about Fine-tuning](/docs/guides/fine-tuning).
//
// GET /fine-tunes/{fine_tune_id}
func (c *Client) RetrieveFineTune(ctx context.Context, params RetrieveFineTuneParams) (FineTune, error) {
	res, err := c.sendRetrieveFineTune(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveFineTune(ctx context.Context, params RetrieveFineTuneParams) (res FineTune, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retrieveFineTune"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/fine-tunes/{fine_tune_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RetrieveFineTune",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/fine-tunes/"
	{
		// Encode "fine_tune_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fine_tune_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FineTuneID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetrieveFineTuneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveModel invokes retrieveModel operation.
//
// Retrieves a model instance, providing basic information about the model such as the owner and
// permissioning.
//
// GET /models/{model}
func (c *Client) RetrieveModel(ctx context.Context, params RetrieveModelParams) (Model, error) {
	res, err := c.sendRetrieveModel(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveModel(ctx context.Context, params RetrieveModelParams) (res Model, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retrieveModel"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/models/{model}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RetrieveModel",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/models/"
	{
		// Encode "model" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Model))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetrieveModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
