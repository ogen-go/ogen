// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AddStickerToSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddStickerToSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PNGSticker.Set {
			e.FieldStart("png_sticker")
			s.PNGSticker.Encode(e)
		}
	}
	{
		if s.TgsSticker.Set {
			e.FieldStart("tgs_sticker")
			s.TgsSticker.Encode(e)
		}
	}
	{
		e.FieldStart("emojis")
		e.Str(s.Emojis)
	}
	{
		if s.MaskPosition.Set {
			e.FieldStart("mask_position")
			s.MaskPosition.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddStickerToSet = [6]string{
	0: "user_id",
	1: "name",
	2: "png_sticker",
	3: "tgs_sticker",
	4: "emojis",
	5: "mask_position",
}

// Decode decodes AddStickerToSet from json.
func (s *AddStickerToSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddStickerToSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "png_sticker":
			if err := func() error {
				s.PNGSticker.Reset()
				if err := s.PNGSticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"png_sticker\"")
			}
		case "tgs_sticker":
			if err := func() error {
				s.TgsSticker.Reset()
				if err := s.TgsSticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgs_sticker\"")
			}
		case "emojis":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Emojis = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emojis\"")
			}
		case "mask_position":
			if err := func() error {
				s.MaskPosition.Reset()
				if err := s.MaskPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddStickerToSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddStickerToSet) {
					name = jsonFieldsNameOfAddStickerToSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddStickerToSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddStickerToSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Animation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Animation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnimation = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "duration",
	5: "thumb",
	6: "file_name",
	7: "mime_type",
	8: "file_size",
}

// Decode decodes Animation from json.
func (s *Animation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Animation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Animation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnimation) {
					name = jsonFieldsNameOfAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Animation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Animation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerCallbackQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerCallbackQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("callback_query_id")
		e.Str(s.CallbackQueryID)
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.ShowAlert.Set {
			e.FieldStart("show_alert")
			s.ShowAlert.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.CacheTime.Set {
			e.FieldStart("cache_time")
			s.CacheTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerCallbackQuery = [5]string{
	0: "callback_query_id",
	1: "text",
	2: "show_alert",
	3: "url",
	4: "cache_time",
}

// Decode decodes AnswerCallbackQuery from json.
func (s *AnswerCallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerCallbackQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "callback_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CallbackQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_query_id\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "show_alert":
			if err := func() error {
				s.ShowAlert.Reset()
				if err := s.ShowAlert.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_alert\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "cache_time":
			if err := func() error {
				s.CacheTime.Reset()
				if err := s.CacheTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerCallbackQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerCallbackQuery) {
					name = jsonFieldsNameOfAnswerCallbackQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerCallbackQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerCallbackQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerInlineQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerInlineQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inline_query_id")
		e.Str(s.InlineQueryID)
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.CacheTime.Set {
			e.FieldStart("cache_time")
			s.CacheTime.Encode(e)
		}
	}
	{
		if s.IsPersonal.Set {
			e.FieldStart("is_personal")
			s.IsPersonal.Encode(e)
		}
	}
	{
		if s.NextOffset.Set {
			e.FieldStart("next_offset")
			s.NextOffset.Encode(e)
		}
	}
	{
		if s.SwitchPmText.Set {
			e.FieldStart("switch_pm_text")
			s.SwitchPmText.Encode(e)
		}
	}
	{
		if s.SwitchPmParameter.Set {
			e.FieldStart("switch_pm_parameter")
			s.SwitchPmParameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerInlineQuery = [7]string{
	0: "inline_query_id",
	1: "results",
	2: "cache_time",
	3: "is_personal",
	4: "next_offset",
	5: "switch_pm_text",
	6: "switch_pm_parameter",
}

// Decode decodes AnswerInlineQuery from json.
func (s *AnswerInlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerInlineQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InlineQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_query_id\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Results = make([]InlineQueryResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InlineQueryResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "cache_time":
			if err := func() error {
				s.CacheTime.Reset()
				if err := s.CacheTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_time\"")
			}
		case "is_personal":
			if err := func() error {
				s.IsPersonal.Reset()
				if err := s.IsPersonal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_personal\"")
			}
		case "next_offset":
			if err := func() error {
				s.NextOffset.Reset()
				if err := s.NextOffset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_offset\"")
			}
		case "switch_pm_text":
			if err := func() error {
				s.SwitchPmText.Reset()
				if err := s.SwitchPmText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_pm_text\"")
			}
		case "switch_pm_parameter":
			if err := func() error {
				s.SwitchPmParameter.Reset()
				if err := s.SwitchPmParameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_pm_parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerInlineQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerInlineQuery) {
					name = jsonFieldsNameOfAnswerInlineQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerInlineQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerInlineQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerPreCheckoutQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerPreCheckoutQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pre_checkout_query_id")
		e.Str(s.PreCheckoutQueryID)
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerPreCheckoutQuery = [3]string{
	0: "pre_checkout_query_id",
	1: "ok",
	2: "error_message",
}

// Decode decodes AnswerPreCheckoutQuery from json.
func (s *AnswerPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerPreCheckoutQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pre_checkout_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PreCheckoutQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_checkout_query_id\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerPreCheckoutQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerPreCheckoutQuery) {
					name = jsonFieldsNameOfAnswerPreCheckoutQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerPreCheckoutQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerShippingQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerShippingQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shipping_query_id")
		e.Str(s.ShippingQueryID)
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
	{
		if s.ShippingOptions != nil {
			e.FieldStart("shipping_options")
			e.ArrStart()
			for _, elem := range s.ShippingOptions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerShippingQuery = [4]string{
	0: "shipping_query_id",
	1: "ok",
	2: "shipping_options",
	3: "error_message",
}

// Decode decodes AnswerShippingQuery from json.
func (s *AnswerShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerShippingQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shipping_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShippingQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_query_id\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		case "shipping_options":
			if err := func() error {
				s.ShippingOptions = make([]ShippingOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ShippingOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ShippingOptions = append(s.ShippingOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_options\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerShippingQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerShippingQuery) {
					name = jsonFieldsNameOfAnswerShippingQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerShippingQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerShippingQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApproveChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApproveChatJoinRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfApproveChatJoinRequest = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes ApproveChatJoinRequest from json.
func (s *ApproveChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApproveChatJoinRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApproveChatJoinRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApproveChatJoinRequest) {
					name = jsonFieldsNameOfApproveChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApproveChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApproveChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Audio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Audio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
}

var jsonFieldsNameOfAudio = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "duration",
	3: "performer",
	4: "title",
	5: "file_name",
	6: "mime_type",
	7: "file_size",
	8: "thumb",
}

// Decode decodes Audio from json.
func (s *Audio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Audio to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Audio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudio) {
					name = jsonFieldsNameOfAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Audio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Audio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BanChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BanChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.UntilDate.Set {
			e.FieldStart("until_date")
			s.UntilDate.Encode(e)
		}
	}
	{
		if s.RevokeMessages.Set {
			e.FieldStart("revoke_messages")
			s.RevokeMessages.Encode(e)
		}
	}
}

var jsonFieldsNameOfBanChatMember = [4]string{
	0: "chat_id",
	1: "user_id",
	2: "until_date",
	3: "revoke_messages",
}

// Decode decodes BanChatMember from json.
func (s *BanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BanChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "until_date":
			if err := func() error {
				s.UntilDate.Reset()
				if err := s.UntilDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		case "revoke_messages":
			if err := func() error {
				s.RevokeMessages.Reset()
				if err := s.RevokeMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revoke_messages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BanChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanChatMember) {
					name = jsonFieldsNameOfBanChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BanChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BanChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BanChatSenderChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BanChatSenderChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sender_chat_id")
		e.Int64(s.SenderChatID)
	}
}

var jsonFieldsNameOfBanChatSenderChat = [2]string{
	0: "chat_id",
	1: "sender_chat_id",
}

// Decode decodes BanChatSenderChat from json.
func (s *BanChatSenderChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BanChatSenderChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sender_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.SenderChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BanChatSenderChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanChatSenderChat) {
					name = jsonFieldsNameOfBanChatSenderChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BanChatSenderChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BanChatSenderChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommand) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommand) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("command")
		e.Str(s.Command)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfBotCommand = [2]string{
	0: "command",
	1: "description",
}

// Decode decodes BotCommand from json.
func (s *BotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommand to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Command = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommand")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommand) {
					name = jsonFieldsNameOfBotCommand[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotCommandScope as json.
func (s BotCommandScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s BotCommandScope) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		e.FieldStart("type")
		e.Str("default")
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		e.FieldStart("type")
		e.Str("all_private_chats")
	case BotCommandScopeAllGroupChatsBotCommandScope:
		e.FieldStart("type")
		e.Str("all_group_chats")
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		e.FieldStart("type")
		e.Str("all_chat_administrators")
	case BotCommandScopeChatBotCommandScope:
		e.FieldStart("type")
		e.Str("chat")
		{
			s := s.BotCommandScopeChat
			{
				e.FieldStart("chat_id")
				s.ChatID.Encode(e)
			}
		}
	case BotCommandScopeChatAdministratorsBotCommandScope:
		e.FieldStart("type")
		e.Str("chat_administrators")
		{
			s := s.BotCommandScopeChatAdministrators
			{
				e.FieldStart("chat_id")
				s.ChatID.Encode(e)
			}
		}
	case BotCommandScopeChatMemberBotCommandScope:
		e.FieldStart("type")
		e.Str("chat_member")
		{
			s := s.BotCommandScopeChatMember
			{
				e.FieldStart("chat_id")
				s.ChatID.Encode(e)
			}
			{
				e.FieldStart("user_id")
				e.Int64(s.UserID)
			}
		}
	}
}

// Decode decodes BotCommandScope from json.
func (s *BotCommandScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScope to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "default":
					s.Type = BotCommandScopeDefaultBotCommandScope
					found = true
				case "all_private_chats":
					s.Type = BotCommandScopeAllPrivateChatsBotCommandScope
					found = true
				case "all_group_chats":
					s.Type = BotCommandScopeAllGroupChatsBotCommandScope
					found = true
				case "all_chat_administrators":
					s.Type = BotCommandScopeAllChatAdministratorsBotCommandScope
					found = true
				case "chat":
					s.Type = BotCommandScopeChatBotCommandScope
					found = true
				case "chat_administrators":
					s.Type = BotCommandScopeChatAdministratorsBotCommandScope
					found = true
				case "chat_member":
					s.Type = BotCommandScopeChatMemberBotCommandScope
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		if err := s.BotCommandScopeDefault.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		if err := s.BotCommandScopeAllPrivateChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllGroupChatsBotCommandScope:
		if err := s.BotCommandScopeAllGroupChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeAllChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatBotCommandScope:
		if err := s.BotCommandScopeChat.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatMemberBotCommandScope:
		if err := s.BotCommandScopeChatMember.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BotCommandScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeAllChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeAllChatAdministrators) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeAllChatAdministrators = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllChatAdministrators from json.
func (s *BotCommandScopeAllChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeAllChatAdministrators to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeAllChatAdministrators")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllChatAdministrators) {
					name = jsonFieldsNameOfBotCommandScopeAllChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeAllChatAdministrators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeAllChatAdministrators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeAllGroupChats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeAllGroupChats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeAllGroupChats = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllGroupChats from json.
func (s *BotCommandScopeAllGroupChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeAllGroupChats to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeAllGroupChats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllGroupChats) {
					name = jsonFieldsNameOfBotCommandScopeAllGroupChats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeAllGroupChats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeAllGroupChats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeAllPrivateChats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeAllPrivateChats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeAllPrivateChats = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllPrivateChats from json.
func (s *BotCommandScopeAllPrivateChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeAllPrivateChats to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeAllPrivateChats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllPrivateChats) {
					name = jsonFieldsNameOfBotCommandScopeAllPrivateChats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeAllPrivateChats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeAllPrivateChats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfBotCommandScopeChat = [2]string{
	0: "type",
	1: "chat_id",
}

// Decode decodes BotCommandScopeChat from json.
func (s *BotCommandScopeChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeChat to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChat) {
					name = jsonFieldsNameOfBotCommandScopeChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeChatAdministrators) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfBotCommandScopeChatAdministrators = [2]string{
	0: "type",
	1: "chat_id",
}

// Decode decodes BotCommandScopeChatAdministrators from json.
func (s *BotCommandScopeChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeChatAdministrators to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeChatAdministrators")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChatAdministrators) {
					name = jsonFieldsNameOfBotCommandScopeChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeChatAdministrators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeChatAdministrators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfBotCommandScopeChatMember = [3]string{
	0: "type",
	1: "chat_id",
	2: "user_id",
}

// Decode decodes BotCommandScopeChatMember from json.
func (s *BotCommandScopeChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeChatMember to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChatMember) {
					name = jsonFieldsNameOfBotCommandScopeChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeDefault) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeDefault) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeDefault = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeDefault from json.
func (s *BotCommandScopeDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeDefault to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeDefault")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeDefault) {
					name = jsonFieldsNameOfBotCommandScopeDefault[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallbackGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallbackGame) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCallbackGame = [0]string{}

// Decode decodes CallbackGame from json.
func (s *CallbackGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackGame to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CallbackGame")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallbackGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallbackQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallbackQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		if s.Message != nil {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_instance")
		e.Str(s.ChatInstance)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.GameShortName.Set {
			e.FieldStart("game_short_name")
			s.GameShortName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallbackQuery = [7]string{
	0: "id",
	1: "from",
	2: "message",
	3: "inline_message_id",
	4: "chat_instance",
	5: "data",
	6: "game_short_name",
}

// Decode decodes CallbackQuery from json.
func (s *CallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "message":
			if err := func() error {
				s.Message = nil
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Message = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "chat_instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ChatInstance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_instance\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "game_short_name":
			if err := func() error {
				s.GameShortName.Reset()
				if err := s.GameShortName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_short_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallbackQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCallbackQuery) {
					name = jsonFieldsNameOfCallbackQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallbackQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Chat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Chat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.FirstName.Set {
			e.FieldStart("first_name")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Photo.Set {
			e.FieldStart("photo")
			s.Photo.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.HasPrivateForwards.Set {
			e.FieldStart("has_private_forwards")
			s.HasPrivateForwards.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.InviteLink.Set {
			e.FieldStart("invite_link")
			s.InviteLink.Encode(e)
		}
	}
	{
		if s.PinnedMessage != nil {
			e.FieldStart("pinned_message")
			s.PinnedMessage.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.SlowModeDelay.Set {
			e.FieldStart("slow_mode_delay")
			s.SlowModeDelay.Encode(e)
		}
	}
	{
		if s.MessageAutoDeleteTime.Set {
			e.FieldStart("message_auto_delete_time")
			s.MessageAutoDeleteTime.Encode(e)
		}
	}
	{
		if s.HasProtectedContent.Set {
			e.FieldStart("has_protected_content")
			s.HasProtectedContent.Encode(e)
		}
	}
	{
		if s.StickerSetName.Set {
			e.FieldStart("sticker_set_name")
			s.StickerSetName.Encode(e)
		}
	}
	{
		if s.CanSetStickerSet.Set {
			e.FieldStart("can_set_sticker_set")
			s.CanSetStickerSet.Encode(e)
		}
	}
	{
		if s.LinkedChatID.Set {
			e.FieldStart("linked_chat_id")
			s.LinkedChatID.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfChat = [20]string{
	0:  "id",
	1:  "type",
	2:  "title",
	3:  "username",
	4:  "first_name",
	5:  "last_name",
	6:  "photo",
	7:  "bio",
	8:  "has_private_forwards",
	9:  "description",
	10: "invite_link",
	11: "pinned_message",
	12: "permissions",
	13: "slow_mode_delay",
	14: "message_auto_delete_time",
	15: "has_protected_content",
	16: "sticker_set_name",
	17: "can_set_sticker_set",
	18: "linked_chat_id",
	19: "location",
}

// Decode decodes Chat from json.
func (s *Chat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Chat to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "first_name":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "photo":
			if err := func() error {
				s.Photo.Reset()
				if err := s.Photo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "has_private_forwards":
			if err := func() error {
				s.HasPrivateForwards.Reset()
				if err := s.HasPrivateForwards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_private_forwards\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "invite_link":
			if err := func() error {
				s.InviteLink.Reset()
				if err := s.InviteLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "pinned_message":
			if err := func() error {
				s.PinnedMessage = nil
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PinnedMessage = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned_message\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "slow_mode_delay":
			if err := func() error {
				s.SlowModeDelay.Reset()
				if err := s.SlowModeDelay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slow_mode_delay\"")
			}
		case "message_auto_delete_time":
			if err := func() error {
				s.MessageAutoDeleteTime.Reset()
				if err := s.MessageAutoDeleteTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_auto_delete_time\"")
			}
		case "has_protected_content":
			if err := func() error {
				s.HasProtectedContent.Reset()
				if err := s.HasProtectedContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_protected_content\"")
			}
		case "sticker_set_name":
			if err := func() error {
				s.StickerSetName.Reset()
				if err := s.StickerSetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_set_name\"")
			}
		case "can_set_sticker_set":
			if err := func() error {
				s.CanSetStickerSet.Reset()
				if err := s.CanSetStickerSet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_set_sticker_set\"")
			}
		case "linked_chat_id":
			if err := func() error {
				s.LinkedChatID.Reset()
				if err := s.LinkedChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linked_chat_id\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Chat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChat) {
					name = jsonFieldsNameOfChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Chat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Chat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("creates_join_request")
		e.Bool(s.CreatesJoinRequest)
	}
	{
		e.FieldStart("is_primary")
		e.Bool(s.IsPrimary)
	}
	{
		e.FieldStart("is_revoked")
		e.Bool(s.IsRevoked)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expire_date")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.FieldStart("member_limit")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.PendingJoinRequestCount.Set {
			e.FieldStart("pending_join_request_count")
			s.PendingJoinRequestCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatInviteLink = [9]string{
	0: "invite_link",
	1: "creator",
	2: "creates_join_request",
	3: "is_primary",
	4: "is_revoked",
	5: "name",
	6: "expire_date",
	7: "member_limit",
	8: "pending_join_request_count",
}

// Decode decodes ChatInviteLink from json.
func (s *ChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatInviteLink to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invite_link":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "creator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "creates_join_request":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CreatesJoinRequest = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creates_join_request\"")
			}
		case "is_primary":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsPrimary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_primary\"")
			}
		case "is_revoked":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsRevoked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_revoked\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "expire_date":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_date\"")
			}
		case "member_limit":
			if err := func() error {
				s.MemberLimit.Reset()
				if err := s.MemberLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"member_limit\"")
			}
		case "pending_join_request_count":
			if err := func() error {
				s.PendingJoinRequestCount.Reset()
				if err := s.PendingJoinRequestCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_join_request_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatInviteLink) {
					name = jsonFieldsNameOfChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatJoinRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.InviteLink.Set {
			e.FieldStart("invite_link")
			s.InviteLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatJoinRequest = [5]string{
	0: "chat",
	1: "from",
	2: "date",
	3: "bio",
	4: "invite_link",
}

// Decode decodes ChatJoinRequest from json.
func (s *ChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatJoinRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "invite_link":
			if err := func() error {
				s.InviteLink.Reset()
				if err := s.InviteLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatJoinRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatJoinRequest) {
					name = jsonFieldsNameOfChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatLocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
}

var jsonFieldsNameOfChatLocation = [2]string{
	0: "location",
	1: "address",
}

// Decode decodes ChatLocation from json.
func (s *ChatLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatLocation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatLocation) {
					name = jsonFieldsNameOfChatLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatMember as json.
func (s ChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ChatMember) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ChatMemberOwnerChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberOwner")
		{
			s := s.ChatMemberOwner
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("is_anonymous")
				e.Bool(s.IsAnonymous)
			}
			{
				if s.CustomTitle.Set {
					e.FieldStart("custom_title")
					s.CustomTitle.Encode(e)
				}
			}
		}
	case ChatMemberAdministratorChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberAdministrator")
		{
			s := s.ChatMemberAdministrator
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("can_be_edited")
				e.Bool(s.CanBeEdited)
			}
			{
				e.FieldStart("is_anonymous")
				e.Bool(s.IsAnonymous)
			}
			{
				e.FieldStart("can_manage_chat")
				e.Bool(s.CanManageChat)
			}
			{
				e.FieldStart("can_delete_messages")
				e.Bool(s.CanDeleteMessages)
			}
			{
				e.FieldStart("can_manage_voice_chats")
				e.Bool(s.CanManageVoiceChats)
			}
			{
				e.FieldStart("can_restrict_members")
				e.Bool(s.CanRestrictMembers)
			}
			{
				e.FieldStart("can_promote_members")
				e.Bool(s.CanPromoteMembers)
			}
			{
				e.FieldStart("can_change_info")
				e.Bool(s.CanChangeInfo)
			}
			{
				e.FieldStart("can_invite_users")
				e.Bool(s.CanInviteUsers)
			}
			{
				if s.CanPostMessages.Set {
					e.FieldStart("can_post_messages")
					s.CanPostMessages.Encode(e)
				}
			}
			{
				if s.CanEditMessages.Set {
					e.FieldStart("can_edit_messages")
					s.CanEditMessages.Encode(e)
				}
			}
			{
				if s.CanPinMessages.Set {
					e.FieldStart("can_pin_messages")
					s.CanPinMessages.Encode(e)
				}
			}
			{
				if s.CustomTitle.Set {
					e.FieldStart("custom_title")
					s.CustomTitle.Encode(e)
				}
			}
		}
	case ChatMemberMemberChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberMember")
		{
			s := s.ChatMemberMember
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
		}
	case ChatMemberRestrictedChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberRestricted")
		{
			s := s.ChatMemberRestricted
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("is_member")
				e.Bool(s.IsMember)
			}
			{
				e.FieldStart("can_change_info")
				e.Bool(s.CanChangeInfo)
			}
			{
				e.FieldStart("can_invite_users")
				e.Bool(s.CanInviteUsers)
			}
			{
				e.FieldStart("can_pin_messages")
				e.Bool(s.CanPinMessages)
			}
			{
				e.FieldStart("can_send_messages")
				e.Bool(s.CanSendMessages)
			}
			{
				e.FieldStart("can_send_media_messages")
				e.Bool(s.CanSendMediaMessages)
			}
			{
				e.FieldStart("can_send_polls")
				e.Bool(s.CanSendPolls)
			}
			{
				e.FieldStart("can_send_other_messages")
				e.Bool(s.CanSendOtherMessages)
			}
			{
				e.FieldStart("can_add_web_page_previews")
				e.Bool(s.CanAddWebPagePreviews)
			}
			{
				e.FieldStart("until_date")
				e.Int(s.UntilDate)
			}
		}
	case ChatMemberLeftChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberLeft")
		{
			s := s.ChatMemberLeft
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
		}
	case ChatMemberBannedChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberBanned")
		{
			s := s.ChatMemberBanned
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("until_date")
				e.Int(s.UntilDate)
			}
		}
	}
}

// Decode decodes ChatMember from json.
func (s *ChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMember to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "status":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "ChatMemberOwner":
					s.Type = ChatMemberOwnerChatMember
					found = true
				case "ChatMemberAdministrator":
					s.Type = ChatMemberAdministratorChatMember
					found = true
				case "ChatMemberMember":
					s.Type = ChatMemberMemberChatMember
					found = true
				case "ChatMemberRestricted":
					s.Type = ChatMemberRestrictedChatMember
					found = true
				case "ChatMemberLeft":
					s.Type = ChatMemberLeftChatMember
					found = true
				case "ChatMemberBanned":
					s.Type = ChatMemberBannedChatMember
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ChatMemberOwnerChatMember:
		if err := s.ChatMemberOwner.Decode(d); err != nil {
			return err
		}
	case ChatMemberAdministratorChatMember:
		if err := s.ChatMemberAdministrator.Decode(d); err != nil {
			return err
		}
	case ChatMemberMemberChatMember:
		if err := s.ChatMemberMember.Decode(d); err != nil {
			return err
		}
	case ChatMemberRestrictedChatMember:
		if err := s.ChatMemberRestricted.Decode(d); err != nil {
			return err
		}
	case ChatMemberLeftChatMember:
		if err := s.ChatMemberLeft.Decode(d); err != nil {
			return err
		}
	case ChatMemberBannedChatMember:
		if err := s.ChatMemberBanned.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberAdministrator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberAdministrator) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("can_be_edited")
		e.Bool(s.CanBeEdited)
	}
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		e.FieldStart("can_manage_chat")
		e.Bool(s.CanManageChat)
	}
	{
		e.FieldStart("can_delete_messages")
		e.Bool(s.CanDeleteMessages)
	}
	{
		e.FieldStart("can_manage_voice_chats")
		e.Bool(s.CanManageVoiceChats)
	}
	{
		e.FieldStart("can_restrict_members")
		e.Bool(s.CanRestrictMembers)
	}
	{
		e.FieldStart("can_promote_members")
		e.Bool(s.CanPromoteMembers)
	}
	{
		e.FieldStart("can_change_info")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.FieldStart("can_invite_users")
		e.Bool(s.CanInviteUsers)
	}
	{
		if s.CanPostMessages.Set {
			e.FieldStart("can_post_messages")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.FieldStart("can_edit_messages")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
	{
		if s.CustomTitle.Set {
			e.FieldStart("custom_title")
			s.CustomTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberAdministrator = [15]string{
	0:  "status",
	1:  "user",
	2:  "can_be_edited",
	3:  "is_anonymous",
	4:  "can_manage_chat",
	5:  "can_delete_messages",
	6:  "can_manage_voice_chats",
	7:  "can_restrict_members",
	8:  "can_promote_members",
	9:  "can_change_info",
	10: "can_invite_users",
	11: "can_post_messages",
	12: "can_edit_messages",
	13: "can_pin_messages",
	14: "custom_title",
}

// Decode decodes ChatMemberAdministrator from json.
func (s *ChatMemberAdministrator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberAdministrator to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "can_be_edited":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanBeEdited = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_be_edited\"")
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "can_manage_chat":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanManageChat = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_chat\"")
			}
		case "can_delete_messages":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanDeleteMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_messages\"")
			}
		case "can_manage_voice_chats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanManageVoiceChats = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_voice_chats\"")
			}
		case "can_restrict_members":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanRestrictMembers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_restrict_members\"")
			}
		case "can_promote_members":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanPromoteMembers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_promote_members\"")
			}
		case "can_change_info":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanChangeInfo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanInviteUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_post_messages":
			if err := func() error {
				s.CanPostMessages.Reset()
				if err := s.CanPostMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_messages\"")
			}
		case "can_edit_messages":
			if err := func() error {
				s.CanEditMessages.Reset()
				if err := s.CanEditMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_messages\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "custom_title":
			if err := func() error {
				s.CustomTitle.Reset()
				if err := s.CustomTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberAdministrator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberAdministrator) {
					name = jsonFieldsNameOfChatMemberAdministrator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberAdministrator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberAdministrator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberBanned) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberBanned) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("until_date")
		e.Int(s.UntilDate)
	}
}

var jsonFieldsNameOfChatMemberBanned = [3]string{
	0: "status",
	1: "user",
	2: "until_date",
}

// Decode decodes ChatMemberBanned from json.
func (s *ChatMemberBanned) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberBanned to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "until_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.UntilDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberBanned")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberBanned) {
					name = jsonFieldsNameOfChatMemberBanned[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberBanned) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberBanned) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberLeft) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberLeft) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfChatMemberLeft = [2]string{
	0: "status",
	1: "user",
}

// Decode decodes ChatMemberLeft from json.
func (s *ChatMemberLeft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberLeft to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberLeft")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberLeft) {
					name = jsonFieldsNameOfChatMemberLeft[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberLeft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberLeft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfChatMemberMember = [2]string{
	0: "status",
	1: "user",
}

// Decode decodes ChatMemberMember from json.
func (s *ChatMemberMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberMember) {
					name = jsonFieldsNameOfChatMemberMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberOwner) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		if s.CustomTitle.Set {
			e.FieldStart("custom_title")
			s.CustomTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberOwner = [4]string{
	0: "status",
	1: "user",
	2: "is_anonymous",
	3: "custom_title",
}

// Decode decodes ChatMemberOwner from json.
func (s *ChatMemberOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberOwner to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "custom_title":
			if err := func() error {
				s.CustomTitle.Reset()
				if err := s.CustomTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberOwner) {
					name = jsonFieldsNameOfChatMemberOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberRestricted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberRestricted) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("is_member")
		e.Bool(s.IsMember)
	}
	{
		e.FieldStart("can_change_info")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.FieldStart("can_invite_users")
		e.Bool(s.CanInviteUsers)
	}
	{
		e.FieldStart("can_pin_messages")
		e.Bool(s.CanPinMessages)
	}
	{
		e.FieldStart("can_send_messages")
		e.Bool(s.CanSendMessages)
	}
	{
		e.FieldStart("can_send_media_messages")
		e.Bool(s.CanSendMediaMessages)
	}
	{
		e.FieldStart("can_send_polls")
		e.Bool(s.CanSendPolls)
	}
	{
		e.FieldStart("can_send_other_messages")
		e.Bool(s.CanSendOtherMessages)
	}
	{
		e.FieldStart("can_add_web_page_previews")
		e.Bool(s.CanAddWebPagePreviews)
	}
	{
		e.FieldStart("until_date")
		e.Int(s.UntilDate)
	}
}

var jsonFieldsNameOfChatMemberRestricted = [12]string{
	0:  "status",
	1:  "user",
	2:  "is_member",
	3:  "can_change_info",
	4:  "can_invite_users",
	5:  "can_pin_messages",
	6:  "can_send_messages",
	7:  "can_send_media_messages",
	8:  "can_send_polls",
	9:  "can_send_other_messages",
	10: "can_add_web_page_previews",
	11: "until_date",
}

// Decode decodes ChatMemberRestricted from json.
func (s *ChatMemberRestricted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberRestricted to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "is_member":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsMember = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_member\"")
			}
		case "can_change_info":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanChangeInfo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanInviteUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_pin_messages":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanPinMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "can_send_messages":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanSendMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_messages\"")
			}
		case "can_send_media_messages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanSendMediaMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_media_messages\"")
			}
		case "can_send_polls":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanSendPolls = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_polls\"")
			}
		case "can_send_other_messages":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanSendOtherMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_other_messages\"")
			}
		case "can_add_web_page_previews":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanAddWebPagePreviews = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_add_web_page_previews\"")
			}
		case "until_date":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.UntilDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberRestricted")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberRestricted) {
					name = jsonFieldsNameOfChatMemberRestricted[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberRestricted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberRestricted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberUpdated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberUpdated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("old_chat_member")
		s.OldChatMember.Encode(e)
	}
	{
		e.FieldStart("new_chat_member")
		s.NewChatMember.Encode(e)
	}
	{
		if s.InviteLink.Set {
			e.FieldStart("invite_link")
			s.InviteLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberUpdated = [6]string{
	0: "chat",
	1: "from",
	2: "date",
	3: "old_chat_member",
	4: "new_chat_member",
	5: "invite_link",
}

// Decode decodes ChatMemberUpdated from json.
func (s *ChatMemberUpdated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberUpdated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "old_chat_member":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OldChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_chat_member\"")
			}
		case "new_chat_member":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.NewChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_member\"")
			}
		case "invite_link":
			if err := func() error {
				s.InviteLink.Reset()
				if err := s.InviteLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberUpdated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberUpdated) {
					name = jsonFieldsNameOfChatMemberUpdated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.CanSendMessages.Set {
			e.FieldStart("can_send_messages")
			s.CanSendMessages.Encode(e)
		}
	}
	{
		if s.CanSendMediaMessages.Set {
			e.FieldStart("can_send_media_messages")
			s.CanSendMediaMessages.Encode(e)
		}
	}
	{
		if s.CanSendPolls.Set {
			e.FieldStart("can_send_polls")
			s.CanSendPolls.Encode(e)
		}
	}
	{
		if s.CanSendOtherMessages.Set {
			e.FieldStart("can_send_other_messages")
			s.CanSendOtherMessages.Encode(e)
		}
	}
	{
		if s.CanAddWebPagePreviews.Set {
			e.FieldStart("can_add_web_page_previews")
			s.CanAddWebPagePreviews.Encode(e)
		}
	}
	{
		if s.CanChangeInfo.Set {
			e.FieldStart("can_change_info")
			s.CanChangeInfo.Encode(e)
		}
	}
	{
		if s.CanInviteUsers.Set {
			e.FieldStart("can_invite_users")
			s.CanInviteUsers.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatPermissions = [8]string{
	0: "can_send_messages",
	1: "can_send_media_messages",
	2: "can_send_polls",
	3: "can_send_other_messages",
	4: "can_add_web_page_previews",
	5: "can_change_info",
	6: "can_invite_users",
	7: "can_pin_messages",
}

// Decode decodes ChatPermissions from json.
func (s *ChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_send_messages":
			if err := func() error {
				s.CanSendMessages.Reset()
				if err := s.CanSendMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_messages\"")
			}
		case "can_send_media_messages":
			if err := func() error {
				s.CanSendMediaMessages.Reset()
				if err := s.CanSendMediaMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_media_messages\"")
			}
		case "can_send_polls":
			if err := func() error {
				s.CanSendPolls.Reset()
				if err := s.CanSendPolls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_polls\"")
			}
		case "can_send_other_messages":
			if err := func() error {
				s.CanSendOtherMessages.Reset()
				if err := s.CanSendOtherMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_other_messages\"")
			}
		case "can_add_web_page_previews":
			if err := func() error {
				s.CanAddWebPagePreviews.Reset()
				if err := s.CanAddWebPagePreviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_add_web_page_previews\"")
			}
		case "can_change_info":
			if err := func() error {
				s.CanChangeInfo.Reset()
				if err := s.CanChangeInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			if err := func() error {
				s.CanInviteUsers.Reset()
				if err := s.CanInviteUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("small_file_id")
		e.Str(s.SmallFileID)
	}
	{
		e.FieldStart("small_file_unique_id")
		e.Str(s.SmallFileUniqueID)
	}
	{
		e.FieldStart("big_file_id")
		e.Str(s.BigFileID)
	}
	{
		e.FieldStart("big_file_unique_id")
		e.Str(s.BigFileUniqueID)
	}
}

var jsonFieldsNameOfChatPhoto = [4]string{
	0: "small_file_id",
	1: "small_file_unique_id",
	2: "big_file_id",
	3: "big_file_unique_id",
}

// Decode decodes ChatPhoto from json.
func (s *ChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatPhoto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "small_file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SmallFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"small_file_id\"")
			}
		case "small_file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SmallFileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"small_file_unique_id\"")
			}
		case "big_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BigFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"big_file_id\"")
			}
		case "big_file_unique_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BigFileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"big_file_unique_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatPhoto) {
					name = jsonFieldsNameOfChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatType as json.
func (s ChatType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatType from json.
func (s *ChatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatType(v) {
	case ChatTypePrivate:
		*s = ChatTypePrivate
	case ChatTypeGroup:
		*s = ChatTypeGroup
	case ChatTypeSupergroup:
		*s = ChatTypeSupergroup
	case ChatTypeChannel:
		*s = ChatTypeChannel
	default:
		*s = ChatType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChosenInlineResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChosenInlineResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("result_id")
		e.Str(s.ResultID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
}

var jsonFieldsNameOfChosenInlineResult = [5]string{
	0: "result_id",
	1: "from",
	2: "location",
	3: "inline_message_id",
	4: "query",
}

// Decode decodes ChosenInlineResult from json.
func (s *ChosenInlineResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChosenInlineResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResultID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChosenInlineResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChosenInlineResult) {
					name = jsonFieldsNameOfChosenInlineResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChosenInlineResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChosenInlineResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Contact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Contact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
}

var jsonFieldsNameOfContact = [5]string{
	0: "phone_number",
	1: "first_name",
	2: "last_name",
	3: "user_id",
	4: "vcard",
}

// Decode decodes Contact from json.
func (s *Contact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contact to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Contact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContact) {
					name = jsonFieldsNameOfContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Contact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Contact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopyMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopyMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("from_chat_id")
		s.FromChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCopyMessage = [10]string{
	0: "chat_id",
	1: "from_chat_id",
	2: "message_id",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "disable_notification",
	7: "reply_to_message_id",
	8: "allow_sending_without_reply",
	9: "reply_markup",
}

// Decode decodes CopyMessage from json.
func (s *CopyMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyMessage to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.FromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopyMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCopyMessage) {
					name = jsonFieldsNameOfCopyMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopyMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CopyMessageReplyMarkup as json.
func (s CopyMessageReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupCopyMessageReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupCopyMessageReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveCopyMessageReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplyCopyMessageReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s CopyMessageReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupCopyMessageReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupCopyMessageReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveCopyMessageReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplyCopyMessageReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes CopyMessageReplyMarkup from json.
func (s *CopyMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyMessageReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupCopyMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupCopyMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupCopyMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupCopyMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveCopyMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplyCopyMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupCopyMessageReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupCopyMessageReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveCopyMessageReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplyCopyMessageReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CopyMessageReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyMessageReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expire_date")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.FieldStart("member_limit")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.CreatesJoinRequest.Set {
			e.FieldStart("creates_join_request")
			s.CreatesJoinRequest.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateChatInviteLink = [5]string{
	0: "chat_id",
	1: "name",
	2: "expire_date",
	3: "member_limit",
	4: "creates_join_request",
}

// Decode decodes CreateChatInviteLink from json.
func (s *CreateChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "expire_date":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_date\"")
			}
		case "member_limit":
			if err := func() error {
				s.MemberLimit.Reset()
				if err := s.MemberLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"member_limit\"")
			}
		case "creates_join_request":
			if err := func() error {
				s.CreatesJoinRequest.Reset()
				if err := s.CreatesJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creates_join_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatInviteLink) {
					name = jsonFieldsNameOfCreateChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNewStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNewStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.PNGSticker.Set {
			e.FieldStart("png_sticker")
			s.PNGSticker.Encode(e)
		}
	}
	{
		if s.TgsSticker.Set {
			e.FieldStart("tgs_sticker")
			s.TgsSticker.Encode(e)
		}
	}
	{
		e.FieldStart("emojis")
		e.Str(s.Emojis)
	}
	{
		if s.ContainsMasks.Set {
			e.FieldStart("contains_masks")
			s.ContainsMasks.Encode(e)
		}
	}
	{
		if s.MaskPosition.Set {
			e.FieldStart("mask_position")
			s.MaskPosition.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateNewStickerSet = [8]string{
	0: "user_id",
	1: "name",
	2: "title",
	3: "png_sticker",
	4: "tgs_sticker",
	5: "emojis",
	6: "contains_masks",
	7: "mask_position",
}

// Decode decodes CreateNewStickerSet from json.
func (s *CreateNewStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNewStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "png_sticker":
			if err := func() error {
				s.PNGSticker.Reset()
				if err := s.PNGSticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"png_sticker\"")
			}
		case "tgs_sticker":
			if err := func() error {
				s.TgsSticker.Reset()
				if err := s.TgsSticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgs_sticker\"")
			}
		case "emojis":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Emojis = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emojis\"")
			}
		case "contains_masks":
			if err := func() error {
				s.ContainsMasks.Reset()
				if err := s.ContainsMasks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contains_masks\"")
			}
		case "mask_position":
			if err := func() error {
				s.MaskPosition.Reset()
				if err := s.MaskPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNewStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNewStickerSet) {
					name = jsonFieldsNameOfCreateNewStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNewStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNewStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeclineChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeclineChatJoinRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfDeclineChatJoinRequest = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes DeclineChatJoinRequest from json.
func (s *DeclineChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclineChatJoinRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeclineChatJoinRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeclineChatJoinRequest) {
					name = jsonFieldsNameOfDeclineChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeclineChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclineChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteChatPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfDeleteChatPhoto = [1]string{
	0: "chat_id",
}

// Decode decodes DeleteChatPhoto from json.
func (s *DeleteChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteChatPhoto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteChatPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChatPhoto) {
					name = jsonFieldsNameOfDeleteChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteChatPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteChatPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteChatStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteChatStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfDeleteChatStickerSet = [1]string{
	0: "chat_id",
}

// Decode decodes DeleteChatStickerSet from json.
func (s *DeleteChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteChatStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteChatStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChatStickerSet) {
					name = jsonFieldsNameOfDeleteChatStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteChatStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteChatStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
}

var jsonFieldsNameOfDeleteMessage = [2]string{
	0: "chat_id",
	1: "message_id",
}

// Decode decodes DeleteMessage from json.
func (s *DeleteMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteMessage) {
					name = jsonFieldsNameOfDeleteMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteMyCommands) encodeFields(e *jx.Encoder) {
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteMyCommands = [2]string{
	0: "scope",
	1: "language_code",
}

// Decode decodes DeleteMyCommands from json.
func (s *DeleteMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteMyCommands to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteMyCommands")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteStickerFromSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteStickerFromSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
}

var jsonFieldsNameOfDeleteStickerFromSet = [1]string{
	0: "sticker",
}

// Decode decodes DeleteStickerFromSet from json.
func (s *DeleteStickerFromSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStickerFromSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteStickerFromSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteStickerFromSet) {
					name = jsonFieldsNameOfDeleteStickerFromSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStickerFromSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStickerFromSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteWebhook) encodeFields(e *jx.Encoder) {
	{
		if s.DropPendingUpdates.Set {
			e.FieldStart("drop_pending_updates")
			s.DropPendingUpdates.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteWebhook = [1]string{
	0: "drop_pending_updates",
}

// Decode decodes DeleteWebhook from json.
func (s *DeleteWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteWebhook to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drop_pending_updates":
			if err := func() error {
				s.DropPendingUpdates.Reset()
				if err := s.DropPendingUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_pending_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteWebhook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Dice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Dice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("emoji")
		e.Str(s.Emoji)
	}
	{
		e.FieldStart("value")
		e.Int(s.Value)
	}
}

var jsonFieldsNameOfDice = [2]string{
	0: "emoji",
	1: "value",
}

// Decode decodes Dice from json.
func (s *Dice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Dice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emoji":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Emoji = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Value = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Dice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDice) {
					name = jsonFieldsNameOfDice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Dice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Dice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Document) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Document) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfDocument = [6]string{
	0: "file_id",
	1: "file_unique_id",
	2: "thumb",
	3: "file_name",
	4: "mime_type",
	5: "file_size",
}

// Decode decodes Document from json.
func (s *Document) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Document to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Document")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDocument) {
					name = jsonFieldsNameOfDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Document) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Document) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expire_date")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.FieldStart("member_limit")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.CreatesJoinRequest.Set {
			e.FieldStart("creates_join_request")
			s.CreatesJoinRequest.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditChatInviteLink = [6]string{
	0: "chat_id",
	1: "invite_link",
	2: "name",
	3: "expire_date",
	4: "member_limit",
	5: "creates_join_request",
}

// Decode decodes EditChatInviteLink from json.
func (s *EditChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "expire_date":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_date\"")
			}
		case "member_limit":
			if err := func() error {
				s.MemberLimit.Reset()
				if err := s.MemberLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"member_limit\"")
			}
		case "creates_join_request":
			if err := func() error {
				s.CreatesJoinRequest.Reset()
				if err := s.CreatesJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creates_join_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditChatInviteLink) {
					name = jsonFieldsNameOfEditChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageCaption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageCaption) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageCaption = [7]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "reply_markup",
}

// Decode decodes EditMessageCaption from json.
func (s *EditMessageCaption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageCaption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageCaption")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageCaption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageCaption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageLiveLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageLiveLocation) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageLiveLocation = [9]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "latitude",
	4: "longitude",
	5: "horizontal_accuracy",
	6: "heading",
	7: "proximity_alert_radius",
	8: "reply_markup",
}

// Decode decodes EditMessageLiveLocation from json.
func (s *EditMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageLiveLocation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageLiveLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageLiveLocation) {
					name = jsonFieldsNameOfEditMessageLiveLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageLiveLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageLiveLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageMedia) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("media")
		s.Media.Encode(e)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageMedia = [5]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "media",
	4: "reply_markup",
}

// Decode decodes EditMessageMedia from json.
func (s *EditMessageMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageMedia to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Media.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageMedia")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageMedia) {
					name = jsonFieldsNameOfEditMessageMedia[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageReplyMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageReplyMarkup) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageReplyMarkup = [4]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "reply_markup",
}

// Decode decodes EditMessageReplyMarkup from json.
func (s *EditMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageReplyMarkup to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageReplyMarkup")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageText) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageText) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableWebPagePreview.Set {
			e.FieldStart("disable_web_page_preview")
			s.DisableWebPagePreview.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageText = [8]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "text",
	4: "parse_mode",
	5: "entities",
	6: "disable_web_page_preview",
	7: "reply_markup",
}

// Decode decodes EditMessageText from json.
func (s *EditMessageText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageText to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "disable_web_page_preview":
			if err := func() error {
				s.DisableWebPagePreview.Reset()
				if err := s.DisableWebPagePreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_web_page_preview\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageText")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageText) {
					name = jsonFieldsNameOfEditMessageText[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptedCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptedCredentials) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.Str(s.Data)
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
	{
		e.FieldStart("secret")
		e.Str(s.Secret)
	}
}

var jsonFieldsNameOfEncryptedCredentials = [3]string{
	0: "data",
	1: "hash",
	2: "secret",
}

// Decode decodes EncryptedCredentials from json.
func (s *EncryptedCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptedCredentials to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Data = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		case "secret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Secret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptedCredentials")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptedCredentials) {
					name = jsonFieldsNameOfEncryptedCredentials[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptedCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptedPassportElement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptedPassportElement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FrontSide.Set {
			e.FieldStart("front_side")
			s.FrontSide.Encode(e)
		}
	}
	{
		if s.ReverseSide.Set {
			e.FieldStart("reverse_side")
			s.ReverseSide.Encode(e)
		}
	}
	{
		if s.Selfie.Set {
			e.FieldStart("selfie")
			s.Selfie.Encode(e)
		}
	}
	{
		if s.Translation != nil {
			e.FieldStart("translation")
			e.ArrStart()
			for _, elem := range s.Translation {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
}

var jsonFieldsNameOfEncryptedPassportElement = [10]string{
	0: "type",
	1: "data",
	2: "phone_number",
	3: "email",
	4: "files",
	5: "front_side",
	6: "reverse_side",
	7: "selfie",
	8: "translation",
	9: "hash",
}

// Decode decodes EncryptedPassportElement from json.
func (s *EncryptedPassportElement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptedPassportElement to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "files":
			if err := func() error {
				s.Files = make([]PassportFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PassportFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "front_side":
			if err := func() error {
				s.FrontSide.Reset()
				if err := s.FrontSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"front_side\"")
			}
		case "reverse_side":
			if err := func() error {
				s.ReverseSide.Reset()
				if err := s.ReverseSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reverse_side\"")
			}
		case "selfie":
			if err := func() error {
				s.Selfie.Reset()
				if err := s.Selfie.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selfie\"")
			}
		case "translation":
			if err := func() error {
				s.Translation = make([]PassportFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PassportFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Translation = append(s.Translation, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translation\"")
			}
		case "hash":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptedPassportElement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptedPassportElement) {
					name = jsonFieldsNameOfEncryptedPassportElement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptedPassportElement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EncryptedPassportElementType as json.
func (s EncryptedPassportElementType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EncryptedPassportElementType from json.
func (s *EncryptedPassportElementType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptedPassportElementType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EncryptedPassportElementType(v) {
	case EncryptedPassportElementTypePersonalDetails:
		*s = EncryptedPassportElementTypePersonalDetails
	case EncryptedPassportElementTypePassport:
		*s = EncryptedPassportElementTypePassport
	case EncryptedPassportElementTypeDriverLicense:
		*s = EncryptedPassportElementTypeDriverLicense
	case EncryptedPassportElementTypeIdentityCard:
		*s = EncryptedPassportElementTypeIdentityCard
	case EncryptedPassportElementTypeInternalPassport:
		*s = EncryptedPassportElementTypeInternalPassport
	case EncryptedPassportElementTypeAddress:
		*s = EncryptedPassportElementTypeAddress
	case EncryptedPassportElementTypeUtilityBill:
		*s = EncryptedPassportElementTypeUtilityBill
	case EncryptedPassportElementTypeBankStatement:
		*s = EncryptedPassportElementTypeBankStatement
	case EncryptedPassportElementTypeRentalAgreement:
		*s = EncryptedPassportElementTypeRentalAgreement
	case EncryptedPassportElementTypePassportRegistration:
		*s = EncryptedPassportElementTypePassportRegistration
	case EncryptedPassportElementTypeTemporaryRegistration:
		*s = EncryptedPassportElementTypeTemporaryRegistration
	case EncryptedPassportElementTypePhoneNumber:
		*s = EncryptedPassportElementTypePhoneNumber
	case EncryptedPassportElementTypeEmail:
		*s = EncryptedPassportElementTypeEmail
	default:
		*s = EncryptedPassportElementType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EncryptedPassportElementType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptedPassportElementType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
	{
		e.FieldStart("error_code")
		e.Int(s.ErrorCode)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "ok",
	1: "error_code",
	2: "description",
	3: "parameters",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		case "error_code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ErrorCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExportChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExportChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfExportChatInviteLink = [1]string{
	0: "chat_id",
}

// Decode decodes ExportChatInviteLink from json.
func (s *ExportChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExportChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExportChatInviteLink) {
					name = jsonFieldsNameOfExportChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExportChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *File) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *File) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.FilePath.Set {
			e.FieldStart("file_path")
			s.FilePath.Encode(e)
		}
	}
}

var jsonFieldsNameOfFile = [4]string{
	0: "file_id",
	1: "file_unique_id",
	2: "file_size",
	3: "file_path",
}

// Decode decodes File from json.
func (s *File) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode File to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "file_path":
			if err := func() error {
				s.FilePath.Reset()
				if err := s.FilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode File")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFile) {
					name = jsonFieldsNameOfFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *File) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *File) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForceReply) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForceReply) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("force_reply")
		e.Bool(s.ForceReply)
	}
	{
		if s.InputFieldPlaceholder.Set {
			e.FieldStart("input_field_placeholder")
			s.InputFieldPlaceholder.Encode(e)
		}
	}
	{
		if s.Selective.Set {
			e.FieldStart("selective")
			s.Selective.Encode(e)
		}
	}
}

var jsonFieldsNameOfForceReply = [3]string{
	0: "force_reply",
	1: "input_field_placeholder",
	2: "selective",
}

// Decode decodes ForceReply from json.
func (s *ForceReply) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForceReply to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force_reply":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ForceReply = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_reply\"")
			}
		case "input_field_placeholder":
			if err := func() error {
				s.InputFieldPlaceholder.Reset()
				if err := s.InputFieldPlaceholder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_field_placeholder\"")
			}
		case "selective":
			if err := func() error {
				s.Selective.Reset()
				if err := s.Selective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selective\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForceReply")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForceReply) {
					name = jsonFieldsNameOfForceReply[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForceReply) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForceReply) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForwardMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForwardMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("from_chat_id")
		s.FromChatID.Encode(e)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
}

var jsonFieldsNameOfForwardMessage = [4]string{
	0: "chat_id",
	1: "from_chat_id",
	2: "disable_notification",
	3: "message_id",
}

// Decode decodes ForwardMessage from json.
func (s *ForwardMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForwardMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.FromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_chat_id\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForwardMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForwardMessage) {
					name = jsonFieldsNameOfForwardMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForwardMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForwardMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Game) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Game) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("photo")
		e.ArrStart()
		for _, elem := range s.Photo {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.TextEntities != nil {
			e.FieldStart("text_entities")
			e.ArrStart()
			for _, elem := range s.TextEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Animation.Set {
			e.FieldStart("animation")
			s.Animation.Encode(e)
		}
	}
}

var jsonFieldsNameOfGame = [6]string{
	0: "title",
	1: "description",
	2: "photo",
	3: "text",
	4: "text_entities",
	5: "animation",
}

// Decode decodes Game from json.
func (s *Game) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Game to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "text_entities":
			if err := func() error {
				s.TextEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TextEntities = append(s.TextEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_entities\"")
			}
		case "animation":
			if err := func() error {
				s.Animation.Reset()
				if err := s.Animation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Game")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGame) {
					name = jsonFieldsNameOfGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Game) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Game) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GameHighScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GameHighScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
}

var jsonFieldsNameOfGameHighScore = [3]string{
	0: "position",
	1: "user",
	2: "score",
}

// Decode decodes GameHighScore from json.
func (s *GameHighScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GameHighScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GameHighScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGameHighScore) {
					name = jsonFieldsNameOfGameHighScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GameHighScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GameHighScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfGetChat = [1]string{
	0: "chat_id",
}

// Decode decodes GetChat from json.
func (s *GetChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChat) {
					name = jsonFieldsNameOfGetChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatAdministrators) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfGetChatAdministrators = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatAdministrators from json.
func (s *GetChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatAdministrators to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatAdministrators")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatAdministrators) {
					name = jsonFieldsNameOfGetChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatAdministrators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatAdministrators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfGetChatMember = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes GetChatMember from json.
func (s *GetChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatMember) {
					name = jsonFieldsNameOfGetChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatMemberCount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatMemberCount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfGetChatMemberCount = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatMemberCount from json.
func (s *GetChatMemberCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatMemberCount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatMemberCount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatMemberCount) {
					name = jsonFieldsNameOfGetChatMemberCount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatMemberCount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatMemberCount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
}

var jsonFieldsNameOfGetFile = [1]string{
	0: "file_id",
}

// Decode decodes GetFile from json.
func (s *GetFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFile) {
					name = jsonFieldsNameOfGetFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetGameHighScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetGameHighScores) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetGameHighScores = [4]string{
	0: "user_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
}

// Decode decodes GetGameHighScores from json.
func (s *GetGameHighScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGameHighScores to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetGameHighScores")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetGameHighScores) {
					name = jsonFieldsNameOfGetGameHighScores[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGameHighScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGameHighScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMyCommands) encodeFields(e *jx.Encoder) {
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMyCommands = [2]string{
	0: "scope",
	1: "language_code",
}

// Decode decodes GetMyCommands from json.
func (s *GetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMyCommands to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMyCommands")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetStickerSet = [1]string{
	0: "name",
}

// Decode decodes GetStickerSet from json.
func (s *GetStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStickerSet) {
					name = jsonFieldsNameOfGetStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUpdates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUpdates) encodeFields(e *jx.Encoder) {
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			e.FieldStart("timeout")
			s.Timeout.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.FieldStart("allowed_updates")
			e.ArrStart()
			for _, elem := range s.AllowedUpdates {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetUpdates = [4]string{
	0: "offset",
	1: "limit",
	2: "timeout",
	3: "allowed_updates",
}

// Decode decodes GetUpdates from json.
func (s *GetUpdates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpdates to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "timeout":
			if err := func() error {
				s.Timeout.Reset()
				if err := s.Timeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "allowed_updates":
			if err := func() error {
				s.AllowedUpdates = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUpdates = append(s.AllowedUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUpdates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserProfilePhotos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserProfilePhotos = [3]string{
	0: "user_id",
	1: "offset",
	2: "limit",
}

// Decode decodes GetUserProfilePhotos from json.
func (s *GetUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserProfilePhotos to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserProfilePhotos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserProfilePhotos) {
					name = jsonFieldsNameOfGetUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ID as json.
func (s ID) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringID:
		e.Str(s.String)
	case Int64ID:
		e.Int64(s.Int64)
	}
}

// Decode decodes ID from json.
func (s *ID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ID to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int64()
		s.Int64 = int64(v)
		if err != nil {
			return err
		}
		s.Type = Int64ID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineKeyboardButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineKeyboardButton) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.LoginURL.Set {
			e.FieldStart("login_url")
			s.LoginURL.Encode(e)
		}
	}
	{
		if s.CallbackData.Set {
			e.FieldStart("callback_data")
			s.CallbackData.Encode(e)
		}
	}
	{
		if s.SwitchInlineQuery.Set {
			e.FieldStart("switch_inline_query")
			s.SwitchInlineQuery.Encode(e)
		}
	}
	{
		if s.SwitchInlineQueryCurrentChat.Set {
			e.FieldStart("switch_inline_query_current_chat")
			s.SwitchInlineQueryCurrentChat.Encode(e)
		}
	}
	{
		if s.CallbackGame != nil {
			e.FieldStart("callback_game")
			s.CallbackGame.Encode(e)
		}
	}
	{
		if s.Pay.Set {
			e.FieldStart("pay")
			s.Pay.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineKeyboardButton = [8]string{
	0: "text",
	1: "url",
	2: "login_url",
	3: "callback_data",
	4: "switch_inline_query",
	5: "switch_inline_query_current_chat",
	6: "callback_game",
	7: "pay",
}

// Decode decodes InlineKeyboardButton from json.
func (s *InlineKeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineKeyboardButton to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "login_url":
			if err := func() error {
				s.LoginURL.Reset()
				if err := s.LoginURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login_url\"")
			}
		case "callback_data":
			if err := func() error {
				s.CallbackData.Reset()
				if err := s.CallbackData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_data\"")
			}
		case "switch_inline_query":
			if err := func() error {
				s.SwitchInlineQuery.Reset()
				if err := s.SwitchInlineQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_inline_query\"")
			}
		case "switch_inline_query_current_chat":
			if err := func() error {
				s.SwitchInlineQueryCurrentChat.Reset()
				if err := s.SwitchInlineQueryCurrentChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_inline_query_current_chat\"")
			}
		case "callback_game":
			if err := func() error {
				s.CallbackGame = nil
				var elem CallbackGame
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CallbackGame = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_game\"")
			}
		case "pay":
			if err := func() error {
				s.Pay.Reset()
				if err := s.Pay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineKeyboardButton")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineKeyboardButton) {
					name = jsonFieldsNameOfInlineKeyboardButton[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineKeyboardButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineKeyboardMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineKeyboardMarkup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inline_keyboard")
		e.ArrStart()
		for _, elem := range s.InlineKeyboard {
			e.ArrStart()
			for _, elem := range elem {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfInlineKeyboardMarkup = [1]string{
	0: "inline_keyboard",
}

// Decode decodes InlineKeyboardMarkup from json.
func (s *InlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineKeyboardMarkup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_keyboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.InlineKeyboard = make([][]InlineKeyboardButton, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []InlineKeyboardButton
					elem = make([]InlineKeyboardButton, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem InlineKeyboardButton
						if err := elemElem.Decode(d); err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.InlineKeyboard = append(s.InlineKeyboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_keyboard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineKeyboardMarkup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineKeyboardMarkup) {
					name = jsonFieldsNameOfInlineKeyboardMarkup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineKeyboardMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		e.FieldStart("offset")
		e.Str(s.Offset)
	}
	{
		if s.ChatType.Set {
			e.FieldStart("chat_type")
			s.ChatType.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQuery = [6]string{
	0: "id",
	1: "from",
	2: "query",
	3: "offset",
	4: "chat_type",
	5: "location",
}

// Decode decodes InlineQuery from json.
func (s *InlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Offset = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "chat_type":
			if err := func() error {
				s.ChatType.Reset()
				if err := s.ChatType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_type\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQuery) {
					name = jsonFieldsNameOfInlineQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryChatType as json.
func (s InlineQueryChatType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InlineQueryChatType from json.
func (s *InlineQueryChatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryChatType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InlineQueryChatType(v) {
	case InlineQueryChatTypeSender:
		*s = InlineQueryChatTypeSender
	case InlineQueryChatTypePrivate:
		*s = InlineQueryChatTypePrivate
	case InlineQueryChatTypeGroup:
		*s = InlineQueryChatTypeGroup
	case InlineQueryChatTypeSupergroup:
		*s = InlineQueryChatTypeSupergroup
	case InlineQueryChatTypeChannel:
		*s = InlineQueryChatTypeChannel
	default:
		*s = InlineQueryChatType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InlineQueryChatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryChatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryResult as json.
func (s InlineQueryResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s InlineQueryResult) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineQueryResultCachedAudioInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedAudio")
		{
			s := s.InlineQueryResultCachedAudio
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("audio_file_id")
				e.Str(s.AudioFileID)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedDocumentInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedDocument")
		{
			s := s.InlineQueryResultCachedDocument
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				e.FieldStart("document_file_id")
				e.Str(s.DocumentFileID)
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedGifInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedGif")
		{
			s := s.InlineQueryResultCachedGif
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("gif_file_id")
				e.Str(s.GIFFileID)
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedMpeg4GifInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedMpeg4Gif")
		{
			s := s.InlineQueryResultCachedMpeg4Gif
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("mpeg4_file_id")
				e.Str(s.Mpeg4FileID)
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedPhotoInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedPhoto")
		{
			s := s.InlineQueryResultCachedPhoto
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("photo_file_id")
				e.Str(s.PhotoFileID)
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedStickerInlineQueryResult:
		e.FieldStart("type")
		e.Str("sticker")
		{
			s := s.InlineQueryResultCachedSticker
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("sticker_file_id")
				e.Str(s.StickerFileID)
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedVideoInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedVideo")
		{
			s := s.InlineQueryResultCachedVideo
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("video_file_id")
				e.Str(s.VideoFileID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedVoiceInlineQueryResult:
		e.FieldStart("type")
		e.Str("InlineQueryResultCachedVoice")
		{
			s := s.InlineQueryResultCachedVoice
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("voice_file_id")
				e.Str(s.VoiceFileID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultArticleInlineQueryResult:
		e.FieldStart("type")
		e.Str("article")
		{
			s := s.InlineQueryResultArticle
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				e.FieldStart("input_message_content")
				s.InputMessageContent.Encode(e)
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.URL.Set {
					e.FieldStart("url")
					s.URL.Encode(e)
				}
			}
			{
				if s.HideURL.Set {
					e.FieldStart("hide_url")
					s.HideURL.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.ThumbURL.Set {
					e.FieldStart("thumb_url")
					s.ThumbURL.Encode(e)
				}
			}
			{
				if s.ThumbWidth.Set {
					e.FieldStart("thumb_width")
					s.ThumbWidth.Encode(e)
				}
			}
			{
				if s.ThumbHeight.Set {
					e.FieldStart("thumb_height")
					s.ThumbHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultAudioInlineQueryResult:
		e.FieldStart("type")
		e.Str("audio")
		{
			s := s.InlineQueryResultAudio
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("audio_url")
				json.EncodeURI(e, s.AudioURL)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Performer.Set {
					e.FieldStart("performer")
					s.Performer.Encode(e)
				}
			}
			{
				if s.AudioDuration.Set {
					e.FieldStart("audio_duration")
					s.AudioDuration.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultContactInlineQueryResult:
		e.FieldStart("type")
		e.Str("contact")
		{
			s := s.InlineQueryResultContact
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("first_name")
				e.Str(s.FirstName)
			}
			{
				if s.LastName.Set {
					e.FieldStart("last_name")
					s.LastName.Encode(e)
				}
			}
			{
				if s.Vcard.Set {
					e.FieldStart("vcard")
					s.Vcard.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbURL.Set {
					e.FieldStart("thumb_url")
					s.ThumbURL.Encode(e)
				}
			}
			{
				if s.ThumbWidth.Set {
					e.FieldStart("thumb_width")
					s.ThumbWidth.Encode(e)
				}
			}
			{
				if s.ThumbHeight.Set {
					e.FieldStart("thumb_height")
					s.ThumbHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultGameInlineQueryResult:
		e.FieldStart("type")
		e.Str("game")
		{
			s := s.InlineQueryResultGame
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("game_short_name")
				e.Str(s.GameShortName)
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
		}
	case InlineQueryResultDocumentInlineQueryResult:
		e.FieldStart("type")
		e.Str("document")
		{
			s := s.InlineQueryResultDocument
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("document_url")
				json.EncodeURI(e, s.DocumentURL)
			}
			{
				e.FieldStart("mime_type")
				e.Str(s.MimeType)
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbURL.Set {
					e.FieldStart("thumb_url")
					s.ThumbURL.Encode(e)
				}
			}
			{
				if s.ThumbWidth.Set {
					e.FieldStart("thumb_width")
					s.ThumbWidth.Encode(e)
				}
			}
			{
				if s.ThumbHeight.Set {
					e.FieldStart("thumb_height")
					s.ThumbHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultGifInlineQueryResult:
		e.FieldStart("type")
		e.Str("gif")
		{
			s := s.InlineQueryResultGif
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("gif_url")
				json.EncodeURI(e, s.GIFURL)
			}
			{
				if s.GIFWidth.Set {
					e.FieldStart("gif_width")
					s.GIFWidth.Encode(e)
				}
			}
			{
				if s.GIFHeight.Set {
					e.FieldStart("gif_height")
					s.GIFHeight.Encode(e)
				}
			}
			{
				if s.GIFDuration.Set {
					e.FieldStart("gif_duration")
					s.GIFDuration.Encode(e)
				}
			}
			{
				e.FieldStart("thumb_url")
				json.EncodeURI(e, s.ThumbURL)
			}
			{
				if s.ThumbMimeType.Set {
					e.FieldStart("thumb_mime_type")
					s.ThumbMimeType.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultLocationInlineQueryResult:
		e.FieldStart("type")
		e.Str("location")
		{
			s := s.InlineQueryResultLocation
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("latitude")
				e.Float64(s.Latitude)
			}
			{
				e.FieldStart("longitude")
				e.Float64(s.Longitude)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.HorizontalAccuracy.Set {
					e.FieldStart("horizontal_accuracy")
					s.HorizontalAccuracy.Encode(e)
				}
			}
			{
				if s.LivePeriod.Set {
					e.FieldStart("live_period")
					s.LivePeriod.Encode(e)
				}
			}
			{
				if s.Heading.Set {
					e.FieldStart("heading")
					s.Heading.Encode(e)
				}
			}
			{
				if s.ProximityAlertRadius.Set {
					e.FieldStart("proximity_alert_radius")
					s.ProximityAlertRadius.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbURL.Set {
					e.FieldStart("thumb_url")
					s.ThumbURL.Encode(e)
				}
			}
			{
				if s.ThumbWidth.Set {
					e.FieldStart("thumb_width")
					s.ThumbWidth.Encode(e)
				}
			}
			{
				if s.ThumbHeight.Set {
					e.FieldStart("thumb_height")
					s.ThumbHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultMpeg4GifInlineQueryResult:
		e.FieldStart("type")
		e.Str("mpeg4_gif")
		{
			s := s.InlineQueryResultMpeg4Gif
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("mpeg4_url")
				json.EncodeURI(e, s.Mpeg4URL)
			}
			{
				if s.Mpeg4Width.Set {
					e.FieldStart("mpeg4_width")
					s.Mpeg4Width.Encode(e)
				}
			}
			{
				if s.Mpeg4Height.Set {
					e.FieldStart("mpeg4_height")
					s.Mpeg4Height.Encode(e)
				}
			}
			{
				if s.Mpeg4Duration.Set {
					e.FieldStart("mpeg4_duration")
					s.Mpeg4Duration.Encode(e)
				}
			}
			{
				e.FieldStart("thumb_url")
				json.EncodeURI(e, s.ThumbURL)
			}
			{
				if s.ThumbMimeType.Set {
					e.FieldStart("thumb_mime_type")
					s.ThumbMimeType.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultPhotoInlineQueryResult:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InlineQueryResultPhoto
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("photo_url")
				json.EncodeURI(e, s.PhotoURL)
			}
			{
				e.FieldStart("thumb_url")
				json.EncodeURI(e, s.ThumbURL)
			}
			{
				if s.PhotoWidth.Set {
					e.FieldStart("photo_width")
					s.PhotoWidth.Encode(e)
				}
			}
			{
				if s.PhotoHeight.Set {
					e.FieldStart("photo_height")
					s.PhotoHeight.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultVenueInlineQueryResult:
		e.FieldStart("type")
		e.Str("venue")
		{
			s := s.InlineQueryResultVenue
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("latitude")
				e.Float64(s.Latitude)
			}
			{
				e.FieldStart("longitude")
				e.Float64(s.Longitude)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				e.FieldStart("address")
				e.Str(s.Address)
			}
			{
				if s.FoursquareID.Set {
					e.FieldStart("foursquare_id")
					s.FoursquareID.Encode(e)
				}
			}
			{
				if s.FoursquareType.Set {
					e.FieldStart("foursquare_type")
					s.FoursquareType.Encode(e)
				}
			}
			{
				if s.GooglePlaceID.Set {
					e.FieldStart("google_place_id")
					s.GooglePlaceID.Encode(e)
				}
			}
			{
				if s.GooglePlaceType.Set {
					e.FieldStart("google_place_type")
					s.GooglePlaceType.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbURL.Set {
					e.FieldStart("thumb_url")
					s.ThumbURL.Encode(e)
				}
			}
			{
				if s.ThumbWidth.Set {
					e.FieldStart("thumb_width")
					s.ThumbWidth.Encode(e)
				}
			}
			{
				if s.ThumbHeight.Set {
					e.FieldStart("thumb_height")
					s.ThumbHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultVideoInlineQueryResult:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InlineQueryResultVideo
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("video_url")
				json.EncodeURI(e, s.VideoURL)
			}
			{
				e.FieldStart("mime_type")
				e.Str(s.MimeType)
			}
			{
				e.FieldStart("thumb_url")
				json.EncodeURI(e, s.ThumbURL)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.VideoWidth.Set {
					e.FieldStart("video_width")
					s.VideoWidth.Encode(e)
				}
			}
			{
				if s.VideoHeight.Set {
					e.FieldStart("video_height")
					s.VideoHeight.Encode(e)
				}
			}
			{
				if s.VideoDuration.Set {
					e.FieldStart("video_duration")
					s.VideoDuration.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultVoiceInlineQueryResult:
		e.FieldStart("type")
		e.Str("voice")
		{
			s := s.InlineQueryResultVoice
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("voice_url")
				json.EncodeURI(e, s.VoiceURL)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.VoiceDuration.Set {
					e.FieldStart("voice_duration")
					s.VoiceDuration.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	}
}

// Decode decodes InlineQueryResult from json.
func (s *InlineQueryResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResult to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "InlineQueryResultCachedAudio":
					s.Type = InlineQueryResultCachedAudioInlineQueryResult
					found = true
				case "InlineQueryResultCachedDocument":
					s.Type = InlineQueryResultCachedDocumentInlineQueryResult
					found = true
				case "InlineQueryResultCachedGif":
					s.Type = InlineQueryResultCachedGifInlineQueryResult
					found = true
				case "InlineQueryResultCachedMpeg4Gif":
					s.Type = InlineQueryResultCachedMpeg4GifInlineQueryResult
					found = true
				case "InlineQueryResultCachedPhoto":
					s.Type = InlineQueryResultCachedPhotoInlineQueryResult
					found = true
				case "sticker":
					s.Type = InlineQueryResultCachedStickerInlineQueryResult
					found = true
				case "InlineQueryResultCachedVideo":
					s.Type = InlineQueryResultCachedVideoInlineQueryResult
					found = true
				case "InlineQueryResultCachedVoice":
					s.Type = InlineQueryResultCachedVoiceInlineQueryResult
					found = true
				case "article":
					s.Type = InlineQueryResultArticleInlineQueryResult
					found = true
				case "audio":
					s.Type = InlineQueryResultAudioInlineQueryResult
					found = true
				case "contact":
					s.Type = InlineQueryResultContactInlineQueryResult
					found = true
				case "game":
					s.Type = InlineQueryResultGameInlineQueryResult
					found = true
				case "document":
					s.Type = InlineQueryResultDocumentInlineQueryResult
					found = true
				case "gif":
					s.Type = InlineQueryResultGifInlineQueryResult
					found = true
				case "location":
					s.Type = InlineQueryResultLocationInlineQueryResult
					found = true
				case "mpeg4_gif":
					s.Type = InlineQueryResultMpeg4GifInlineQueryResult
					found = true
				case "photo":
					s.Type = InlineQueryResultPhotoInlineQueryResult
					found = true
				case "venue":
					s.Type = InlineQueryResultVenueInlineQueryResult
					found = true
				case "video":
					s.Type = InlineQueryResultVideoInlineQueryResult
					found = true
				case "voice":
					s.Type = InlineQueryResultVoiceInlineQueryResult
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineQueryResultCachedAudioInlineQueryResult:
		if err := s.InlineQueryResultCachedAudio.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedDocumentInlineQueryResult:
		if err := s.InlineQueryResultCachedDocument.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedGifInlineQueryResult:
		if err := s.InlineQueryResultCachedGif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedMpeg4GifInlineQueryResult:
		if err := s.InlineQueryResultCachedMpeg4Gif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedPhotoInlineQueryResult:
		if err := s.InlineQueryResultCachedPhoto.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedStickerInlineQueryResult:
		if err := s.InlineQueryResultCachedSticker.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedVideoInlineQueryResult:
		if err := s.InlineQueryResultCachedVideo.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedVoiceInlineQueryResult:
		if err := s.InlineQueryResultCachedVoice.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultArticleInlineQueryResult:
		if err := s.InlineQueryResultArticle.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultAudioInlineQueryResult:
		if err := s.InlineQueryResultAudio.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultContactInlineQueryResult:
		if err := s.InlineQueryResultContact.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultGameInlineQueryResult:
		if err := s.InlineQueryResultGame.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultDocumentInlineQueryResult:
		if err := s.InlineQueryResultDocument.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultGifInlineQueryResult:
		if err := s.InlineQueryResultGif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultLocationInlineQueryResult:
		if err := s.InlineQueryResultLocation.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultMpeg4GifInlineQueryResult:
		if err := s.InlineQueryResultMpeg4Gif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultPhotoInlineQueryResult:
		if err := s.InlineQueryResultPhoto.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVenueInlineQueryResult:
		if err := s.InlineQueryResultVenue.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVideoInlineQueryResult:
		if err := s.InlineQueryResultVideo.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVoiceInlineQueryResult:
		if err := s.InlineQueryResultVoice.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InlineQueryResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultArticle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultArticle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("input_message_content")
		s.InputMessageContent.Encode(e)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HideURL.Set {
			e.FieldStart("hide_url")
			s.HideURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.FieldStart("thumb_url")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.FieldStart("thumb_width")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.FieldStart("thumb_height")
			s.ThumbHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultArticle = [11]string{
	0:  "type",
	1:  "id",
	2:  "title",
	3:  "input_message_content",
	4:  "reply_markup",
	5:  "url",
	6:  "hide_url",
	7:  "description",
	8:  "thumb_url",
	9:  "thumb_width",
	10: "thumb_height",
}

// Decode decodes InlineQueryResultArticle from json.
func (s *InlineQueryResultArticle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultArticle to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "input_message_content":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "hide_url":
			if err := func() error {
				s.HideURL.Reset()
				if err := s.HideURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hide_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "thumb_url":
			if err := func() error {
				s.ThumbURL.Reset()
				if err := s.ThumbURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_width":
			if err := func() error {
				s.ThumbWidth.Reset()
				if err := s.ThumbWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_width\"")
			}
		case "thumb_height":
			if err := func() error {
				s.ThumbHeight.Reset()
				if err := s.ThumbHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultArticle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultArticle) {
					name = jsonFieldsNameOfInlineQueryResultArticle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultArticle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("audio_url")
		json.EncodeURI(e, s.AudioURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.AudioDuration.Set {
			e.FieldStart("audio_duration")
			s.AudioDuration.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultAudio = [11]string{
	0:  "type",
	1:  "id",
	2:  "audio_url",
	3:  "title",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "performer",
	8:  "audio_duration",
	9:  "reply_markup",
	10: "input_message_content",
}

// Decode decodes InlineQueryResultAudio from json.
func (s *InlineQueryResultAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultAudio to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "audio_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AudioURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "audio_duration":
			if err := func() error {
				s.AudioDuration.Reset()
				if err := s.AudioDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_duration\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultAudio) {
					name = jsonFieldsNameOfInlineQueryResultAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("audio_file_id")
		e.Str(s.AudioFileID)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedAudio = [8]string{
	0: "type",
	1: "id",
	2: "audio_file_id",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "reply_markup",
	7: "input_message_content",
}

// Decode decodes InlineQueryResultCachedAudio from json.
func (s *InlineQueryResultCachedAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedAudio to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "audio_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AudioFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_file_id\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedAudio) {
					name = jsonFieldsNameOfInlineQueryResultCachedAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("document_file_id")
		e.Str(s.DocumentFileID)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedDocument = [10]string{
	0: "type",
	1: "id",
	2: "title",
	3: "document_file_id",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedDocument from json.
func (s *InlineQueryResultCachedDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedDocument to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "document_file_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DocumentFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_file_id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedDocument) {
					name = jsonFieldsNameOfInlineQueryResultCachedDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedGif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedGif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("gif_file_id")
		e.Str(s.GIFFileID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedGif = [9]string{
	0: "type",
	1: "id",
	2: "gif_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedGif from json.
func (s *InlineQueryResultCachedGif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedGif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "gif_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GIFFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_file_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedGif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedGif) {
					name = jsonFieldsNameOfInlineQueryResultCachedGif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedGif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedGif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedMpeg4Gif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedMpeg4Gif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("mpeg4_file_id")
		e.Str(s.Mpeg4FileID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif = [9]string{
	0: "type",
	1: "id",
	2: "mpeg4_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedMpeg4Gif from json.
func (s *InlineQueryResultCachedMpeg4Gif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedMpeg4Gif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "mpeg4_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Mpeg4FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_file_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedMpeg4Gif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif) {
					name = jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedMpeg4Gif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedMpeg4Gif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("photo_file_id")
		e.Str(s.PhotoFileID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedPhoto = [10]string{
	0: "type",
	1: "id",
	2: "photo_file_id",
	3: "title",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedPhoto from json.
func (s *InlineQueryResultCachedPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedPhoto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "photo_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhotoFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_file_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedPhoto) {
					name = jsonFieldsNameOfInlineQueryResultCachedPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedSticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedSticker) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("sticker_file_id")
		e.Str(s.StickerFileID)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedSticker = [5]string{
	0: "type",
	1: "id",
	2: "sticker_file_id",
	3: "reply_markup",
	4: "input_message_content",
}

// Decode decodes InlineQueryResultCachedSticker from json.
func (s *InlineQueryResultCachedSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedSticker to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "sticker_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StickerFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_file_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedSticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedSticker) {
					name = jsonFieldsNameOfInlineQueryResultCachedSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("video_file_id")
		e.Str(s.VideoFileID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedVideo = [10]string{
	0: "type",
	1: "id",
	2: "video_file_id",
	3: "title",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedVideo from json.
func (s *InlineQueryResultCachedVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedVideo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "video_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VideoFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_file_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedVideo) {
					name = jsonFieldsNameOfInlineQueryResultCachedVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("voice_file_id")
		e.Str(s.VoiceFileID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedVoice = [9]string{
	0: "type",
	1: "id",
	2: "voice_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedVoice from json.
func (s *InlineQueryResultCachedVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedVoice to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "voice_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VoiceFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_file_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedVoice) {
					name = jsonFieldsNameOfInlineQueryResultCachedVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultContact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultContact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.FieldStart("thumb_url")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.FieldStart("thumb_width")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.FieldStart("thumb_height")
			s.ThumbHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultContact = [11]string{
	0:  "type",
	1:  "id",
	2:  "phone_number",
	3:  "first_name",
	4:  "last_name",
	5:  "vcard",
	6:  "reply_markup",
	7:  "input_message_content",
	8:  "thumb_url",
	9:  "thumb_width",
	10: "thumb_height",
}

// Decode decodes InlineQueryResultContact from json.
func (s *InlineQueryResultContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultContact to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumb_url":
			if err := func() error {
				s.ThumbURL.Reset()
				if err := s.ThumbURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_width":
			if err := func() error {
				s.ThumbWidth.Reset()
				if err := s.ThumbWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_width\"")
			}
		case "thumb_height":
			if err := func() error {
				s.ThumbHeight.Reset()
				if err := s.ThumbHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultContact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultContact) {
					name = jsonFieldsNameOfInlineQueryResultContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("document_url")
		json.EncodeURI(e, s.DocumentURL)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.FieldStart("thumb_url")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.FieldStart("thumb_width")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.FieldStart("thumb_height")
			s.ThumbHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultDocument = [14]string{
	0:  "type",
	1:  "id",
	2:  "title",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "document_url",
	7:  "mime_type",
	8:  "description",
	9:  "reply_markup",
	10: "input_message_content",
	11: "thumb_url",
	12: "thumb_width",
	13: "thumb_height",
}

// Decode decodes InlineQueryResultDocument from json.
func (s *InlineQueryResultDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultDocument to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "document_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DocumentURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_url\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumb_url":
			if err := func() error {
				s.ThumbURL.Reset()
				if err := s.ThumbURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_width":
			if err := func() error {
				s.ThumbWidth.Reset()
				if err := s.ThumbWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_width\"")
			}
		case "thumb_height":
			if err := func() error {
				s.ThumbHeight.Reset()
				if err := s.ThumbHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultDocument) {
					name = jsonFieldsNameOfInlineQueryResultDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultGame) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("game_short_name")
		e.Str(s.GameShortName)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultGame = [4]string{
	0: "type",
	1: "id",
	2: "game_short_name",
	3: "reply_markup",
}

// Decode decodes InlineQueryResultGame from json.
func (s *InlineQueryResultGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultGame to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "game_short_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GameShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_short_name\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultGame")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultGame) {
					name = jsonFieldsNameOfInlineQueryResultGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultGif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultGif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("gif_url")
		json.EncodeURI(e, s.GIFURL)
	}
	{
		if s.GIFWidth.Set {
			e.FieldStart("gif_width")
			s.GIFWidth.Encode(e)
		}
	}
	{
		if s.GIFHeight.Set {
			e.FieldStart("gif_height")
			s.GIFHeight.Encode(e)
		}
	}
	{
		if s.GIFDuration.Set {
			e.FieldStart("gif_duration")
			s.GIFDuration.Encode(e)
		}
	}
	{
		e.FieldStart("thumb_url")
		json.EncodeURI(e, s.ThumbURL)
	}
	{
		if s.ThumbMimeType.Set {
			e.FieldStart("thumb_mime_type")
			s.ThumbMimeType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultGif = [14]string{
	0:  "type",
	1:  "id",
	2:  "gif_url",
	3:  "gif_width",
	4:  "gif_height",
	5:  "gif_duration",
	6:  "thumb_url",
	7:  "thumb_mime_type",
	8:  "title",
	9:  "caption",
	10: "parse_mode",
	11: "caption_entities",
	12: "reply_markup",
	13: "input_message_content",
}

// Decode decodes InlineQueryResultGif from json.
func (s *InlineQueryResultGif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultGif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "gif_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GIFURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_url\"")
			}
		case "gif_width":
			if err := func() error {
				s.GIFWidth.Reset()
				if err := s.GIFWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_width\"")
			}
		case "gif_height":
			if err := func() error {
				s.GIFHeight.Reset()
				if err := s.GIFHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_height\"")
			}
		case "gif_duration":
			if err := func() error {
				s.GIFDuration.Reset()
				if err := s.GIFDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_duration\"")
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ThumbURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_mime_type":
			if err := func() error {
				s.ThumbMimeType.Reset()
				if err := s.ThumbMimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_mime_type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultGif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultGif) {
					name = jsonFieldsNameOfInlineQueryResultGif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultGif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultGif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultLocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.FieldStart("thumb_url")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.FieldStart("thumb_width")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.FieldStart("thumb_height")
			s.ThumbHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultLocation = [14]string{
	0:  "type",
	1:  "id",
	2:  "latitude",
	3:  "longitude",
	4:  "title",
	5:  "horizontal_accuracy",
	6:  "live_period",
	7:  "heading",
	8:  "proximity_alert_radius",
	9:  "reply_markup",
	10: "input_message_content",
	11: "thumb_url",
	12: "thumb_width",
	13: "thumb_height",
}

// Decode decodes InlineQueryResultLocation from json.
func (s *InlineQueryResultLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultLocation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumb_url":
			if err := func() error {
				s.ThumbURL.Reset()
				if err := s.ThumbURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_width":
			if err := func() error {
				s.ThumbWidth.Reset()
				if err := s.ThumbWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_width\"")
			}
		case "thumb_height":
			if err := func() error {
				s.ThumbHeight.Reset()
				if err := s.ThumbHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultLocation) {
					name = jsonFieldsNameOfInlineQueryResultLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultMpeg4Gif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultMpeg4Gif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("mpeg4_url")
		json.EncodeURI(e, s.Mpeg4URL)
	}
	{
		if s.Mpeg4Width.Set {
			e.FieldStart("mpeg4_width")
			s.Mpeg4Width.Encode(e)
		}
	}
	{
		if s.Mpeg4Height.Set {
			e.FieldStart("mpeg4_height")
			s.Mpeg4Height.Encode(e)
		}
	}
	{
		if s.Mpeg4Duration.Set {
			e.FieldStart("mpeg4_duration")
			s.Mpeg4Duration.Encode(e)
		}
	}
	{
		e.FieldStart("thumb_url")
		json.EncodeURI(e, s.ThumbURL)
	}
	{
		if s.ThumbMimeType.Set {
			e.FieldStart("thumb_mime_type")
			s.ThumbMimeType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultMpeg4Gif = [14]string{
	0:  "type",
	1:  "id",
	2:  "mpeg4_url",
	3:  "mpeg4_width",
	4:  "mpeg4_height",
	5:  "mpeg4_duration",
	6:  "thumb_url",
	7:  "thumb_mime_type",
	8:  "title",
	9:  "caption",
	10: "parse_mode",
	11: "caption_entities",
	12: "reply_markup",
	13: "input_message_content",
}

// Decode decodes InlineQueryResultMpeg4Gif from json.
func (s *InlineQueryResultMpeg4Gif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultMpeg4Gif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "mpeg4_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Mpeg4URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_url\"")
			}
		case "mpeg4_width":
			if err := func() error {
				s.Mpeg4Width.Reset()
				if err := s.Mpeg4Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_width\"")
			}
		case "mpeg4_height":
			if err := func() error {
				s.Mpeg4Height.Reset()
				if err := s.Mpeg4Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_height\"")
			}
		case "mpeg4_duration":
			if err := func() error {
				s.Mpeg4Duration.Reset()
				if err := s.Mpeg4Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_duration\"")
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ThumbURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_mime_type":
			if err := func() error {
				s.ThumbMimeType.Reset()
				if err := s.ThumbMimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_mime_type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultMpeg4Gif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultMpeg4Gif) {
					name = jsonFieldsNameOfInlineQueryResultMpeg4Gif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultMpeg4Gif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultMpeg4Gif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("photo_url")
		json.EncodeURI(e, s.PhotoURL)
	}
	{
		e.FieldStart("thumb_url")
		json.EncodeURI(e, s.ThumbURL)
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultPhoto = [13]string{
	0:  "type",
	1:  "id",
	2:  "photo_url",
	3:  "thumb_url",
	4:  "photo_width",
	5:  "photo_height",
	6:  "title",
	7:  "description",
	8:  "caption",
	9:  "parse_mode",
	10: "caption_entities",
	11: "reply_markup",
	12: "input_message_content",
}

// Decode decodes InlineQueryResultPhoto from json.
func (s *InlineQueryResultPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultPhoto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "photo_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PhotoURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ThumbURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultPhoto) {
					name = jsonFieldsNameOfInlineQueryResultPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultVenue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultVenue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.FieldStart("thumb_url")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.FieldStart("thumb_width")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.FieldStart("thumb_height")
			s.ThumbHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultVenue = [15]string{
	0:  "type",
	1:  "id",
	2:  "latitude",
	3:  "longitude",
	4:  "title",
	5:  "address",
	6:  "foursquare_id",
	7:  "foursquare_type",
	8:  "google_place_id",
	9:  "google_place_type",
	10: "reply_markup",
	11: "input_message_content",
	12: "thumb_url",
	13: "thumb_width",
	14: "thumb_height",
}

// Decode decodes InlineQueryResultVenue from json.
func (s *InlineQueryResultVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultVenue to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumb_url":
			if err := func() error {
				s.ThumbURL.Reset()
				if err := s.ThumbURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "thumb_width":
			if err := func() error {
				s.ThumbWidth.Reset()
				if err := s.ThumbWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_width\"")
			}
		case "thumb_height":
			if err := func() error {
				s.ThumbHeight.Reset()
				if err := s.ThumbHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultVenue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVenue) {
					name = jsonFieldsNameOfInlineQueryResultVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultVenue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("video_url")
		json.EncodeURI(e, s.VideoURL)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		e.FieldStart("thumb_url")
		json.EncodeURI(e, s.ThumbURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VideoWidth.Set {
			e.FieldStart("video_width")
			s.VideoWidth.Encode(e)
		}
	}
	{
		if s.VideoHeight.Set {
			e.FieldStart("video_height")
			s.VideoHeight.Encode(e)
		}
	}
	{
		if s.VideoDuration.Set {
			e.FieldStart("video_duration")
			s.VideoDuration.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultVideo = [15]string{
	0:  "type",
	1:  "id",
	2:  "video_url",
	3:  "mime_type",
	4:  "thumb_url",
	5:  "title",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "video_width",
	10: "video_height",
	11: "video_duration",
	12: "description",
	13: "reply_markup",
	14: "input_message_content",
}

// Decode decodes InlineQueryResultVideo from json.
func (s *InlineQueryResultVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultVideo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "video_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.VideoURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_url\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ThumbURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "video_width":
			if err := func() error {
				s.VideoWidth.Reset()
				if err := s.VideoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_width\"")
			}
		case "video_height":
			if err := func() error {
				s.VideoHeight.Reset()
				if err := s.VideoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_height\"")
			}
		case "video_duration":
			if err := func() error {
				s.VideoDuration.Reset()
				if err := s.VideoDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_duration\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVideo) {
					name = jsonFieldsNameOfInlineQueryResultVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("voice_url")
		json.EncodeURI(e, s.VoiceURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VoiceDuration.Set {
			e.FieldStart("voice_duration")
			s.VoiceDuration.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultVoice = [10]string{
	0: "type",
	1: "id",
	2: "voice_url",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "voice_duration",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultVoice from json.
func (s *InlineQueryResultVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultVoice to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "voice_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.VoiceURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "voice_duration":
			if err := func() error {
				s.VoiceDuration.Reset()
				if err := s.VoiceDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_duration\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVoice) {
					name = jsonFieldsNameOfInlineQueryResultVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputContactMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputContactMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputContactMessageContent = [4]string{
	0: "phone_number",
	1: "first_name",
	2: "last_name",
	3: "vcard",
}

// Decode decodes InputContactMessageContent from json.
func (s *InputContactMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputContactMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputContactMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputContactMessageContent) {
					name = jsonFieldsNameOfInputContactMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputContactMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputContactMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputInvoiceMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputInvoiceMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		e.FieldStart("provider_token")
		e.Str(s.ProviderToken)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.MaxTipAmount.Set {
			e.FieldStart("max_tip_amount")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.FieldStart("suggested_tip_amounts")
			e.ArrStart()
			for _, elem := range s.SuggestedTipAmounts {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderData.Set {
			e.FieldStart("provider_data")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.FieldStart("photo_size")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.FieldStart("need_name")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.FieldStart("need_phone_number")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.FieldStart("need_email")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.FieldStart("need_shipping_address")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.FieldStart("send_phone_number_to_provider")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.FieldStart("send_email_to_provider")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.FieldStart("is_flexible")
			s.IsFlexible.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputInvoiceMessageContent = [20]string{
	0:  "title",
	1:  "description",
	2:  "payload",
	3:  "provider_token",
	4:  "currency",
	5:  "prices",
	6:  "max_tip_amount",
	7:  "suggested_tip_amounts",
	8:  "provider_data",
	9:  "photo_url",
	10: "photo_size",
	11: "photo_width",
	12: "photo_height",
	13: "need_name",
	14: "need_phone_number",
	15: "need_email",
	16: "need_shipping_address",
	17: "send_phone_number_to_provider",
	18: "send_email_to_provider",
	19: "is_flexible",
}

// Decode decodes InputInvoiceMessageContent from json.
func (s *InputInvoiceMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputInvoiceMessageContent to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "provider_token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ProviderToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_token\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		case "max_tip_amount":
			if err := func() error {
				s.MaxTipAmount.Reset()
				if err := s.MaxTipAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tip_amount\"")
			}
		case "suggested_tip_amounts":
			if err := func() error {
				s.SuggestedTipAmounts = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suggested_tip_amounts\"")
			}
		case "provider_data":
			if err := func() error {
				s.ProviderData.Reset()
				if err := s.ProviderData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_data\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "photo_size":
			if err := func() error {
				s.PhotoSize.Reset()
				if err := s.PhotoSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_size\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "need_name":
			if err := func() error {
				s.NeedName.Reset()
				if err := s.NeedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_name\"")
			}
		case "need_phone_number":
			if err := func() error {
				s.NeedPhoneNumber.Reset()
				if err := s.NeedPhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_phone_number\"")
			}
		case "need_email":
			if err := func() error {
				s.NeedEmail.Reset()
				if err := s.NeedEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_email\"")
			}
		case "need_shipping_address":
			if err := func() error {
				s.NeedShippingAddress.Reset()
				if err := s.NeedShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_shipping_address\"")
			}
		case "send_phone_number_to_provider":
			if err := func() error {
				s.SendPhoneNumberToProvider.Reset()
				if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_phone_number_to_provider\"")
			}
		case "send_email_to_provider":
			if err := func() error {
				s.SendEmailToProvider.Reset()
				if err := s.SendEmailToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_email_to_provider\"")
			}
		case "is_flexible":
			if err := func() error {
				s.IsFlexible.Reset()
				if err := s.IsFlexible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_flexible\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputInvoiceMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputInvoiceMessageContent) {
					name = jsonFieldsNameOfInputInvoiceMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputInvoiceMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputInvoiceMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputLocationMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputLocationMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputLocationMessageContent = [6]string{
	0: "latitude",
	1: "longitude",
	2: "horizontal_accuracy",
	3: "live_period",
	4: "heading",
	5: "proximity_alert_radius",
}

// Decode decodes InputLocationMessageContent from json.
func (s *InputLocationMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputLocationMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputLocationMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputLocationMessageContent) {
					name = jsonFieldsNameOfInputLocationMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputLocationMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputLocationMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputMedia as json.
func (s InputMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s InputMedia) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputMediaAnimationInputMedia:
		e.FieldStart("type")
		e.Str("animation")
		{
			s := s.InputMediaAnimation
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
		}
	case InputMediaDocumentInputMedia:
		e.FieldStart("type")
		e.Str("document")
		{
			s := s.InputMediaDocument
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.DisableContentTypeDetection.Set {
					e.FieldStart("disable_content_type_detection")
					s.DisableContentTypeDetection.Encode(e)
				}
			}
		}
	case InputMediaAudioInputMedia:
		e.FieldStart("type")
		e.Str("audio")
		{
			s := s.InputMediaAudio
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.Performer.Set {
					e.FieldStart("performer")
					s.Performer.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
		}
	case InputMediaPhotoInputMedia:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InputMediaPhoto
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
		}
	case InputMediaVideoInputMedia:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InputMediaVideo
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.SupportsStreaming.Set {
					e.FieldStart("supports_streaming")
					s.SupportsStreaming.Encode(e)
				}
			}
		}
	}
}

// Decode decodes InputMedia from json.
func (s *InputMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMedia to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "animation":
					s.Type = InputMediaAnimationInputMedia
					found = true
				case "document":
					s.Type = InputMediaDocumentInputMedia
					found = true
				case "audio":
					s.Type = InputMediaAudioInputMedia
					found = true
				case "photo":
					s.Type = InputMediaPhotoInputMedia
					found = true
				case "video":
					s.Type = InputMediaVideoInputMedia
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAnimationInputMedia:
		if err := s.InputMediaAnimation.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentInputMedia:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaAudioInputMedia:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoInputMedia:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoInputMedia:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InputMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaAnimation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaAnimation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaAnimation = [9]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "width",
	7: "height",
	8: "duration",
}

// Decode decodes InputMediaAnimation from json.
func (s *InputMediaAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaAnimation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaAnimation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaAnimation) {
					name = jsonFieldsNameOfInputMediaAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaAnimation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaAnimation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaAudio = [9]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "duration",
	7: "performer",
	8: "title",
}

// Decode decodes InputMediaAudio from json.
func (s *InputMediaAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaAudio to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaAudio) {
					name = jsonFieldsNameOfInputMediaAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableContentTypeDetection.Set {
			e.FieldStart("disable_content_type_detection")
			s.DisableContentTypeDetection.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaDocument = [7]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "disable_content_type_detection",
}

// Decode decodes InputMediaDocument from json.
func (s *InputMediaDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaDocument to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_content_type_detection":
			if err := func() error {
				s.DisableContentTypeDetection.Reset()
				if err := s.DisableContentTypeDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_content_type_detection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaDocument) {
					name = jsonFieldsNameOfInputMediaDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInputMediaPhoto = [5]string{
	0: "type",
	1: "media",
	2: "caption",
	3: "parse_mode",
	4: "caption_entities",
}

// Decode decodes InputMediaPhoto from json.
func (s *InputMediaPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaPhoto to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaPhoto) {
					name = jsonFieldsNameOfInputMediaPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.FieldStart("supports_streaming")
			s.SupportsStreaming.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaVideo = [10]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "width",
	7: "height",
	8: "duration",
	9: "supports_streaming",
}

// Decode decodes InputMediaVideo from json.
func (s *InputMediaVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaVideo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "supports_streaming":
			if err := func() error {
				s.SupportsStreaming.Reset()
				if err := s.SupportsStreaming.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_streaming\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaVideo) {
					name = jsonFieldsNameOfInputMediaVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputMessageContent as json.
func (s InputMessageContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		s.InputTextMessageContent.Encode(e)
	case InputLocationMessageContentInputMessageContent:
		s.InputLocationMessageContent.Encode(e)
	case InputVenueMessageContentInputMessageContent:
		s.InputVenueMessageContent.Encode(e)
	case InputContactMessageContentInputMessageContent:
		s.InputContactMessageContent.Encode(e)
	case InputInvoiceMessageContentInputMessageContent:
		s.InputInvoiceMessageContent.Encode(e)
	}
}

func (s InputMessageContent) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		s.InputTextMessageContent.encodeFields(e)
	case InputLocationMessageContentInputMessageContent:
		s.InputLocationMessageContent.encodeFields(e)
	case InputVenueMessageContentInputMessageContent:
		s.InputVenueMessageContent.encodeFields(e)
	case InputContactMessageContentInputMessageContent:
		s.InputContactMessageContent.encodeFields(e)
	case InputInvoiceMessageContentInputMessageContent:
		s.InputInvoiceMessageContent.encodeFields(e)
	}
}

// Decode decodes InputMessageContent from json.
func (s *InputMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMessageContent to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "message_text":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "parse_mode":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "entities":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "disable_web_page_preview":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "horizontal_accuracy":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "live_period":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "heading":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "proximity_alert_radius":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "foursquare_id":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "foursquare_type":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "google_place_id":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "google_place_type":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "phone_number":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "first_name":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "last_name":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "vcard":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "description":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "payload":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "provider_token":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "currency":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prices":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_tip_amount":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "suggested_tip_amounts":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "provider_data":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_url":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_size":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_width":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_height":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_name":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_phone_number":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_email":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_shipping_address":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "send_phone_number_to_provider":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "send_email_to_provider":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_flexible":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		if err := s.InputTextMessageContent.Decode(d); err != nil {
			return err
		}
	case InputLocationMessageContentInputMessageContent:
		if err := s.InputLocationMessageContent.Decode(d); err != nil {
			return err
		}
	case InputVenueMessageContentInputMessageContent:
		if err := s.InputVenueMessageContent.Decode(d); err != nil {
			return err
		}
	case InputContactMessageContentInputMessageContent:
		if err := s.InputContactMessageContent.Decode(d); err != nil {
			return err
		}
	case InputInvoiceMessageContentInputMessageContent:
		if err := s.InputInvoiceMessageContent.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InputMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputTextMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputTextMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_text")
		e.Str(s.MessageText)
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableWebPagePreview.Set {
			e.FieldStart("disable_web_page_preview")
			s.DisableWebPagePreview.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputTextMessageContent = [4]string{
	0: "message_text",
	1: "parse_mode",
	2: "entities",
	3: "disable_web_page_preview",
}

// Decode decodes InputTextMessageContent from json.
func (s *InputTextMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputTextMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MessageText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_text\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "disable_web_page_preview":
			if err := func() error {
				s.DisableWebPagePreview.Reset()
				if err := s.DisableWebPagePreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_web_page_preview\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputTextMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputTextMessageContent) {
					name = jsonFieldsNameOfInputTextMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputTextMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputTextMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputVenueMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputVenueMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputVenueMessageContent = [8]string{
	0: "latitude",
	1: "longitude",
	2: "title",
	3: "address",
	4: "foursquare_id",
	5: "foursquare_type",
	6: "google_place_id",
	7: "google_place_type",
}

// Decode decodes InputVenueMessageContent from json.
func (s *InputVenueMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputVenueMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputVenueMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputVenueMessageContent) {
					name = jsonFieldsNameOfInputVenueMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputVenueMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputVenueMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Invoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Invoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("start_parameter")
		e.Str(s.StartParameter)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
}

var jsonFieldsNameOfInvoice = [5]string{
	0: "title",
	1: "description",
	2: "start_parameter",
	3: "currency",
	4: "total_amount",
}

// Decode decodes Invoice from json.
func (s *Invoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Invoice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "start_parameter":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StartParameter = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_parameter\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Invoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoice) {
					name = jsonFieldsNameOfInvoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Invoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Invoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyboardButton as json.
func (s KeyboardButton) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringKeyboardButton:
		e.Str(s.String)
	case KeyboardButtonObjectKeyboardButton:
		s.KeyboardButtonObject.Encode(e)
	}
}

// Decode decodes KeyboardButton from json.
func (s *KeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButton to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.KeyboardButtonObject.Decode(d); err != nil {
			return err
		}
		s.Type = KeyboardButtonObjectKeyboardButton
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringKeyboardButton
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KeyboardButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyboardButtonObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyboardButtonObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.RequestContact.Set {
			e.FieldStart("request_contact")
			s.RequestContact.Encode(e)
		}
	}
	{
		if s.RequestLocation.Set {
			e.FieldStart("request_location")
			s.RequestLocation.Encode(e)
		}
	}
	{
		if s.RequestPoll.Set {
			e.FieldStart("request_poll")
			s.RequestPoll.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyboardButtonObject = [4]string{
	0: "text",
	1: "request_contact",
	2: "request_location",
	3: "request_poll",
}

// Decode decodes KeyboardButtonObject from json.
func (s *KeyboardButtonObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButtonObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "request_contact":
			if err := func() error {
				s.RequestContact.Reset()
				if err := s.RequestContact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_contact\"")
			}
		case "request_location":
			if err := func() error {
				s.RequestLocation.Reset()
				if err := s.RequestLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_location\"")
			}
		case "request_poll":
			if err := func() error {
				s.RequestPoll.Reset()
				if err := s.RequestPoll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_poll\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyboardButtonObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeyboardButtonObject) {
					name = jsonFieldsNameOfKeyboardButtonObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyboardButtonObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButtonObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyboardButtonPollType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyboardButtonPollType) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyboardButtonPollType = [1]string{
	0: "type",
}

// Decode decodes KeyboardButtonPollType from json.
func (s *KeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButtonPollType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyboardButtonPollType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyboardButtonPollType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButtonPollType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LabeledPrice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LabeledPrice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("amount")
		e.Int(s.Amount)
	}
}

var jsonFieldsNameOfLabeledPrice = [2]string{
	0: "label",
	1: "amount",
}

// Decode decodes LabeledPrice from json.
func (s *LabeledPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabeledPrice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Amount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabeledPrice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabeledPrice) {
					name = jsonFieldsNameOfLabeledPrice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LabeledPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabeledPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaveChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaveChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfLeaveChat = [1]string{
	0: "chat_id",
}

// Decode decodes LeaveChat from json.
func (s *LeaveChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaveChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaveChat) {
					name = jsonFieldsNameOfLeaveChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Location) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Location) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
}

var jsonFieldsNameOfLocation = [6]string{
	0: "longitude",
	1: "latitude",
	2: "horizontal_accuracy",
	3: "live_period",
	4: "heading",
	5: "proximity_alert_radius",
}

// Decode decodes Location from json.
func (s *Location) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Location to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "longitude":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Location")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocation) {
					name = jsonFieldsNameOfLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Location) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Location) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginUrl) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginUrl) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.ForwardText.Set {
			e.FieldStart("forward_text")
			s.ForwardText.Encode(e)
		}
	}
	{
		if s.BotUsername.Set {
			e.FieldStart("bot_username")
			s.BotUsername.Encode(e)
		}
	}
	{
		if s.RequestWriteAccess.Set {
			e.FieldStart("request_write_access")
			s.RequestWriteAccess.Encode(e)
		}
	}
}

var jsonFieldsNameOfLoginUrl = [4]string{
	0: "url",
	1: "forward_text",
	2: "bot_username",
	3: "request_write_access",
}

// Decode decodes LoginUrl from json.
func (s *LoginUrl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginUrl to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forward_text":
			if err := func() error {
				s.ForwardText.Reset()
				if err := s.ForwardText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_text\"")
			}
		case "bot_username":
			if err := func() error {
				s.BotUsername.Reset()
				if err := s.BotUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot_username\"")
			}
		case "request_write_access":
			if err := func() error {
				s.RequestWriteAccess.Reset()
				if err := s.RequestWriteAccess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_write_access\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginUrl")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginUrl) {
					name = jsonFieldsNameOfLoginUrl[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaskPosition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaskPosition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("point")
		e.Str(s.Point)
	}
	{
		e.FieldStart("x_shift")
		e.Float64(s.XShift)
	}
	{
		e.FieldStart("y_shift")
		e.Float64(s.YShift)
	}
	{
		e.FieldStart("scale")
		e.Float64(s.Scale)
	}
}

var jsonFieldsNameOfMaskPosition = [4]string{
	0: "point",
	1: "x_shift",
	2: "y_shift",
	3: "scale",
}

// Decode decodes MaskPosition from json.
func (s *MaskPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaskPosition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "point":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Point = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point\"")
			}
		case "x_shift":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.XShift = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x_shift\"")
			}
		case "y_shift":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.YShift = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y_shift\"")
			}
		case "scale":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Scale = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaskPosition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMaskPosition) {
					name = jsonFieldsNameOfMaskPosition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaskPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaskPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Message) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Message) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.SenderChat.Set {
			e.FieldStart("sender_chat")
			s.SenderChat.Encode(e)
		}
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		if s.ForwardFrom.Set {
			e.FieldStart("forward_from")
			s.ForwardFrom.Encode(e)
		}
	}
	{
		if s.ForwardFromChat.Set {
			e.FieldStart("forward_from_chat")
			s.ForwardFromChat.Encode(e)
		}
	}
	{
		if s.ForwardFromMessageID.Set {
			e.FieldStart("forward_from_message_id")
			s.ForwardFromMessageID.Encode(e)
		}
	}
	{
		if s.ForwardSignature.Set {
			e.FieldStart("forward_signature")
			s.ForwardSignature.Encode(e)
		}
	}
	{
		if s.ForwardSenderName.Set {
			e.FieldStart("forward_sender_name")
			s.ForwardSenderName.Encode(e)
		}
	}
	{
		if s.ForwardDate.Set {
			e.FieldStart("forward_date")
			s.ForwardDate.Encode(e)
		}
	}
	{
		if s.IsAutomaticForward.Set {
			e.FieldStart("is_automatic_forward")
			s.IsAutomaticForward.Encode(e)
		}
	}
	{
		if s.ReplyToMessage != nil {
			e.FieldStart("reply_to_message")
			s.ReplyToMessage.Encode(e)
		}
	}
	{
		if s.ViaBot.Set {
			e.FieldStart("via_bot")
			s.ViaBot.Encode(e)
		}
	}
	{
		if s.EditDate.Set {
			e.FieldStart("edit_date")
			s.EditDate.Encode(e)
		}
	}
	{
		if s.HasProtectedContent.Set {
			e.FieldStart("has_protected_content")
			s.HasProtectedContent.Encode(e)
		}
	}
	{
		if s.MediaGroupID.Set {
			e.FieldStart("media_group_id")
			s.MediaGroupID.Encode(e)
		}
	}
	{
		if s.AuthorSignature.Set {
			e.FieldStart("author_signature")
			s.AuthorSignature.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Animation.Set {
			e.FieldStart("animation")
			s.Animation.Encode(e)
		}
	}
	{
		if s.Audio.Set {
			e.FieldStart("audio")
			s.Audio.Encode(e)
		}
	}
	{
		if s.Document.Set {
			e.FieldStart("document")
			s.Document.Encode(e)
		}
	}
	{
		if s.Photo != nil {
			e.FieldStart("photo")
			e.ArrStart()
			for _, elem := range s.Photo {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sticker.Set {
			e.FieldStart("sticker")
			s.Sticker.Encode(e)
		}
	}
	{
		if s.Video.Set {
			e.FieldStart("video")
			s.Video.Encode(e)
		}
	}
	{
		if s.VideoNote.Set {
			e.FieldStart("video_note")
			s.VideoNote.Encode(e)
		}
	}
	{
		if s.Voice.Set {
			e.FieldStart("voice")
			s.Voice.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Contact.Set {
			e.FieldStart("contact")
			s.Contact.Encode(e)
		}
	}
	{
		if s.Dice.Set {
			e.FieldStart("dice")
			s.Dice.Encode(e)
		}
	}
	{
		if s.Game.Set {
			e.FieldStart("game")
			s.Game.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.FieldStart("poll")
			s.Poll.Encode(e)
		}
	}
	{
		if s.Venue.Set {
			e.FieldStart("venue")
			s.Venue.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.NewChatMembers != nil {
			e.FieldStart("new_chat_members")
			e.ArrStart()
			for _, elem := range s.NewChatMembers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LeftChatMember.Set {
			e.FieldStart("left_chat_member")
			s.LeftChatMember.Encode(e)
		}
	}
	{
		if s.NewChatTitle.Set {
			e.FieldStart("new_chat_title")
			s.NewChatTitle.Encode(e)
		}
	}
	{
		if s.NewChatPhoto != nil {
			e.FieldStart("new_chat_photo")
			e.ArrStart()
			for _, elem := range s.NewChatPhoto {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DeleteChatPhoto.Set {
			e.FieldStart("delete_chat_photo")
			s.DeleteChatPhoto.Encode(e)
		}
	}
	{
		if s.GroupChatCreated.Set {
			e.FieldStart("group_chat_created")
			s.GroupChatCreated.Encode(e)
		}
	}
	{
		if s.SupergroupChatCreated.Set {
			e.FieldStart("supergroup_chat_created")
			s.SupergroupChatCreated.Encode(e)
		}
	}
	{
		if s.ChannelChatCreated.Set {
			e.FieldStart("channel_chat_created")
			s.ChannelChatCreated.Encode(e)
		}
	}
	{
		if s.MessageAutoDeleteTimerChanged.Set {
			e.FieldStart("message_auto_delete_timer_changed")
			s.MessageAutoDeleteTimerChanged.Encode(e)
		}
	}
	{
		if s.MigrateToChatID.Set {
			e.FieldStart("migrate_to_chat_id")
			s.MigrateToChatID.Encode(e)
		}
	}
	{
		if s.MigrateFromChatID.Set {
			e.FieldStart("migrate_from_chat_id")
			s.MigrateFromChatID.Encode(e)
		}
	}
	{
		if s.PinnedMessage != nil {
			e.FieldStart("pinned_message")
			s.PinnedMessage.Encode(e)
		}
	}
	{
		if s.Invoice.Set {
			e.FieldStart("invoice")
			s.Invoice.Encode(e)
		}
	}
	{
		if s.SuccessfulPayment.Set {
			e.FieldStart("successful_payment")
			s.SuccessfulPayment.Encode(e)
		}
	}
	{
		if s.ConnectedWebsite.Set {
			e.FieldStart("connected_website")
			s.ConnectedWebsite.Encode(e)
		}
	}
	{
		if s.PassportData.Set {
			e.FieldStart("passport_data")
			s.PassportData.Encode(e)
		}
	}
	{
		if s.ProximityAlertTriggered.Set {
			e.FieldStart("proximity_alert_triggered")
			s.ProximityAlertTriggered.Encode(e)
		}
	}
	{
		if s.VoiceChatScheduled.Set {
			e.FieldStart("voice_chat_scheduled")
			s.VoiceChatScheduled.Encode(e)
		}
	}
	{
		if s.VoiceChatStarted != nil {
			e.FieldStart("voice_chat_started")
			s.VoiceChatStarted.Encode(e)
		}
	}
	{
		if s.VoiceChatEnded.Set {
			e.FieldStart("voice_chat_ended")
			s.VoiceChatEnded.Encode(e)
		}
	}
	{
		if s.VoiceChatParticipantsInvited.Set {
			e.FieldStart("voice_chat_participants_invited")
			s.VoiceChatParticipantsInvited.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessage = [58]string{
	0:  "message_id",
	1:  "from",
	2:  "sender_chat",
	3:  "date",
	4:  "chat",
	5:  "forward_from",
	6:  "forward_from_chat",
	7:  "forward_from_message_id",
	8:  "forward_signature",
	9:  "forward_sender_name",
	10: "forward_date",
	11: "is_automatic_forward",
	12: "reply_to_message",
	13: "via_bot",
	14: "edit_date",
	15: "has_protected_content",
	16: "media_group_id",
	17: "author_signature",
	18: "text",
	19: "entities",
	20: "animation",
	21: "audio",
	22: "document",
	23: "photo",
	24: "sticker",
	25: "video",
	26: "video_note",
	27: "voice",
	28: "caption",
	29: "caption_entities",
	30: "contact",
	31: "dice",
	32: "game",
	33: "poll",
	34: "venue",
	35: "location",
	36: "new_chat_members",
	37: "left_chat_member",
	38: "new_chat_title",
	39: "new_chat_photo",
	40: "delete_chat_photo",
	41: "group_chat_created",
	42: "supergroup_chat_created",
	43: "channel_chat_created",
	44: "message_auto_delete_timer_changed",
	45: "migrate_to_chat_id",
	46: "migrate_from_chat_id",
	47: "pinned_message",
	48: "invoice",
	49: "successful_payment",
	50: "connected_website",
	51: "passport_data",
	52: "proximity_alert_triggered",
	53: "voice_chat_scheduled",
	54: "voice_chat_started",
	55: "voice_chat_ended",
	56: "voice_chat_participants_invited",
	57: "reply_markup",
}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Message to nil")
	}
	var requiredBitSet [8]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "sender_chat":
			if err := func() error {
				s.SenderChat.Reset()
				if err := s.SenderChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "chat":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "forward_from":
			if err := func() error {
				s.ForwardFrom.Reset()
				if err := s.ForwardFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_from\"")
			}
		case "forward_from_chat":
			if err := func() error {
				s.ForwardFromChat.Reset()
				if err := s.ForwardFromChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_from_chat\"")
			}
		case "forward_from_message_id":
			if err := func() error {
				s.ForwardFromMessageID.Reset()
				if err := s.ForwardFromMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_from_message_id\"")
			}
		case "forward_signature":
			if err := func() error {
				s.ForwardSignature.Reset()
				if err := s.ForwardSignature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_signature\"")
			}
		case "forward_sender_name":
			if err := func() error {
				s.ForwardSenderName.Reset()
				if err := s.ForwardSenderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_sender_name\"")
			}
		case "forward_date":
			if err := func() error {
				s.ForwardDate.Reset()
				if err := s.ForwardDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_date\"")
			}
		case "is_automatic_forward":
			if err := func() error {
				s.IsAutomaticForward.Reset()
				if err := s.IsAutomaticForward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_automatic_forward\"")
			}
		case "reply_to_message":
			if err := func() error {
				s.ReplyToMessage = nil
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ReplyToMessage = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message\"")
			}
		case "via_bot":
			if err := func() error {
				s.ViaBot.Reset()
				if err := s.ViaBot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"via_bot\"")
			}
		case "edit_date":
			if err := func() error {
				s.EditDate.Reset()
				if err := s.EditDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edit_date\"")
			}
		case "has_protected_content":
			if err := func() error {
				s.HasProtectedContent.Reset()
				if err := s.HasProtectedContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_protected_content\"")
			}
		case "media_group_id":
			if err := func() error {
				s.MediaGroupID.Reset()
				if err := s.MediaGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_group_id\"")
			}
		case "author_signature":
			if err := func() error {
				s.AuthorSignature.Reset()
				if err := s.AuthorSignature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_signature\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "animation":
			if err := func() error {
				s.Animation.Reset()
				if err := s.Animation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		case "audio":
			if err := func() error {
				s.Audio.Reset()
				if err := s.Audio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio\"")
			}
		case "document":
			if err := func() error {
				s.Document.Reset()
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "photo":
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "sticker":
			if err := func() error {
				s.Sticker.Reset()
				if err := s.Sticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "video":
			if err := func() error {
				s.Video.Reset()
				if err := s.Video.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		case "video_note":
			if err := func() error {
				s.VideoNote.Reset()
				if err := s.VideoNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_note\"")
			}
		case "voice":
			if err := func() error {
				s.Voice.Reset()
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "contact":
			if err := func() error {
				s.Contact.Reset()
				if err := s.Contact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contact\"")
			}
		case "dice":
			if err := func() error {
				s.Dice.Reset()
				if err := s.Dice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dice\"")
			}
		case "game":
			if err := func() error {
				s.Game.Reset()
				if err := s.Game.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game\"")
			}
		case "poll":
			if err := func() error {
				s.Poll.Reset()
				if err := s.Poll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll\"")
			}
		case "venue":
			if err := func() error {
				s.Venue.Reset()
				if err := s.Venue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"venue\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "new_chat_members":
			if err := func() error {
				s.NewChatMembers = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewChatMembers = append(s.NewChatMembers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_members\"")
			}
		case "left_chat_member":
			if err := func() error {
				s.LeftChatMember.Reset()
				if err := s.LeftChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_chat_member\"")
			}
		case "new_chat_title":
			if err := func() error {
				s.NewChatTitle.Reset()
				if err := s.NewChatTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_title\"")
			}
		case "new_chat_photo":
			if err := func() error {
				s.NewChatPhoto = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewChatPhoto = append(s.NewChatPhoto, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_photo\"")
			}
		case "delete_chat_photo":
			if err := func() error {
				s.DeleteChatPhoto.Reset()
				if err := s.DeleteChatPhoto.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_chat_photo\"")
			}
		case "group_chat_created":
			if err := func() error {
				s.GroupChatCreated.Reset()
				if err := s.GroupChatCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_chat_created\"")
			}
		case "supergroup_chat_created":
			if err := func() error {
				s.SupergroupChatCreated.Reset()
				if err := s.SupergroupChatCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supergroup_chat_created\"")
			}
		case "channel_chat_created":
			if err := func() error {
				s.ChannelChatCreated.Reset()
				if err := s.ChannelChatCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_chat_created\"")
			}
		case "message_auto_delete_timer_changed":
			if err := func() error {
				s.MessageAutoDeleteTimerChanged.Reset()
				if err := s.MessageAutoDeleteTimerChanged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_auto_delete_timer_changed\"")
			}
		case "migrate_to_chat_id":
			if err := func() error {
				s.MigrateToChatID.Reset()
				if err := s.MigrateToChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migrate_to_chat_id\"")
			}
		case "migrate_from_chat_id":
			if err := func() error {
				s.MigrateFromChatID.Reset()
				if err := s.MigrateFromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migrate_from_chat_id\"")
			}
		case "pinned_message":
			if err := func() error {
				s.PinnedMessage = nil
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PinnedMessage = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned_message\"")
			}
		case "invoice":
			if err := func() error {
				s.Invoice.Reset()
				if err := s.Invoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice\"")
			}
		case "successful_payment":
			if err := func() error {
				s.SuccessfulPayment.Reset()
				if err := s.SuccessfulPayment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful_payment\"")
			}
		case "connected_website":
			if err := func() error {
				s.ConnectedWebsite.Reset()
				if err := s.ConnectedWebsite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connected_website\"")
			}
		case "passport_data":
			if err := func() error {
				s.PassportData.Reset()
				if err := s.PassportData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passport_data\"")
			}
		case "proximity_alert_triggered":
			if err := func() error {
				s.ProximityAlertTriggered.Reset()
				if err := s.ProximityAlertTriggered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_triggered\"")
			}
		case "voice_chat_scheduled":
			if err := func() error {
				s.VoiceChatScheduled.Reset()
				if err := s.VoiceChatScheduled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_chat_scheduled\"")
			}
		case "voice_chat_started":
			if err := func() error {
				s.VoiceChatStarted = nil
				var elem VoiceChatStarted
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VoiceChatStarted = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_chat_started\"")
			}
		case "voice_chat_ended":
			if err := func() error {
				s.VoiceChatEnded.Reset()
				if err := s.VoiceChatEnded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_chat_ended\"")
			}
		case "voice_chat_participants_invited":
			if err := func() error {
				s.VoiceChatParticipantsInvited.Reset()
				if err := s.VoiceChatParticipantsInvited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_chat_participants_invited\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Message")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [8]uint8{
		0b00011001,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessage) {
					name = jsonFieldsNameOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Message) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Message) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageAutoDeleteTimerChanged) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageAutoDeleteTimerChanged) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_auto_delete_time")
		e.Int(s.MessageAutoDeleteTime)
	}
}

var jsonFieldsNameOfMessageAutoDeleteTimerChanged = [1]string{
	0: "message_auto_delete_time",
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (s *MessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageAutoDeleteTimerChanged to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_auto_delete_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageAutoDeleteTime = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_auto_delete_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageAutoDeleteTimerChanged")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageAutoDeleteTimerChanged) {
					name = jsonFieldsNameOfMessageAutoDeleteTimerChanged[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageAutoDeleteTimerChanged) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageAutoDeleteTimerChanged) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		e.FieldStart("length")
		e.Int(s.Length)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessageEntity = [6]string{
	0: "type",
	1: "offset",
	2: "length",
	3: "url",
	4: "user",
	5: "language",
}

// Decode decodes MessageEntity from json.
func (s *MessageEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageEntity to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "length":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Length = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageEntity) {
					name = jsonFieldsNameOfMessageEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageEntityType as json.
func (s MessageEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageEntityType from json.
func (s *MessageEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageEntityType(v) {
	case MessageEntityTypeMention:
		*s = MessageEntityTypeMention
	case MessageEntityTypeHashtag:
		*s = MessageEntityTypeHashtag
	case MessageEntityTypeCashtag:
		*s = MessageEntityTypeCashtag
	case MessageEntityTypeBotCommand:
		*s = MessageEntityTypeBotCommand
	case MessageEntityTypeURL:
		*s = MessageEntityTypeURL
	case MessageEntityTypeEmail:
		*s = MessageEntityTypeEmail
	case MessageEntityTypePhoneNumber:
		*s = MessageEntityTypePhoneNumber
	case MessageEntityTypeBold:
		*s = MessageEntityTypeBold
	case MessageEntityTypeItalic:
		*s = MessageEntityTypeItalic
	case MessageEntityTypeUnderline:
		*s = MessageEntityTypeUnderline
	case MessageEntityTypeStrikethrough:
		*s = MessageEntityTypeStrikethrough
	case MessageEntityTypeCode:
		*s = MessageEntityTypeCode
	case MessageEntityTypePre:
		*s = MessageEntityTypePre
	case MessageEntityTypeTextLink:
		*s = MessageEntityTypeTextLink
	case MessageEntityTypeTextMention:
		*s = MessageEntityTypeTextMention
	default:
		*s = MessageEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageId) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageId) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
}

var jsonFieldsNameOfMessageId = [1]string{
	0: "message_id",
}

// Decode decodes MessageId from json.
func (s *MessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageId to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageId")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageId) {
					name = jsonFieldsNameOfMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Animation as json.
func (o OptAnimation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Animation from json.
func (o *OptAnimation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnimation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnimation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnimation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Audio as json.
func (o OptAudio) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Audio from json.
func (o *OptAudio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAudio to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotCommandScope as json.
func (o OptBotCommandScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BotCommandScope from json.
func (o *OptBotCommandScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBotCommandScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBotCommandScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBotCommandScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallbackQuery as json.
func (o OptCallbackQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallbackQuery from json.
func (o *OptCallbackQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallbackQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallbackQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallbackQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Chat as json.
func (o OptChat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Chat from json.
func (o *OptChat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatInviteLink as json.
func (o OptChatInviteLink) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatInviteLink from json.
func (o *OptChatInviteLink) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatInviteLink to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatJoinRequest as json.
func (o OptChatJoinRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatJoinRequest from json.
func (o *OptChatJoinRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatJoinRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatLocation as json.
func (o OptChatLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatLocation from json.
func (o *OptChatLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatMember as json.
func (o OptChatMember) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatMember from json.
func (o *OptChatMember) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatMember to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatMemberUpdated as json.
func (o OptChatMemberUpdated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatMemberUpdated from json.
func (o *OptChatMemberUpdated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatMemberUpdated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatMemberUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatMemberUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatPermissions as json.
func (o OptChatPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatPermissions from json.
func (o *OptChatPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatPhoto as json.
func (o OptChatPhoto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatPhoto from json.
func (o *OptChatPhoto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatPhoto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChosenInlineResult as json.
func (o OptChosenInlineResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChosenInlineResult from json.
func (o *OptChosenInlineResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChosenInlineResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChosenInlineResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChosenInlineResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Contact as json.
func (o OptContact) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Contact from json.
func (o *OptContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContact to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CopyMessageReplyMarkup as json.
func (o OptCopyMessageReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CopyMessageReplyMarkup from json.
func (o *OptCopyMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCopyMessageReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCopyMessageReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCopyMessageReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteMyCommands as json.
func (o OptDeleteMyCommands) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteMyCommands from json.
func (o *OptDeleteMyCommands) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteMyCommands to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteWebhook as json.
func (o OptDeleteWebhook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteWebhook from json.
func (o *OptDeleteWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteWebhook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Dice as json.
func (o OptDice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Dice from json.
func (o *OptDice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Document as json.
func (o OptDocument) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Document from json.
func (o *OptDocument) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDocument to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes File as json.
func (o OptFile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes File from json.
func (o *OptFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Game as json.
func (o OptGame) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Game from json.
func (o *OptGame) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGame to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetMyCommands as json.
func (o OptGetMyCommands) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyCommands from json.
func (o *OptGetMyCommands) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetMyCommands to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpdates as json.
func (o OptGetUpdates) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUpdates from json.
func (o *OptGetUpdates) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUpdates to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ID as json.
func (o OptID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ID from json.
func (o *OptID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineKeyboardMarkup as json.
func (o OptInlineKeyboardMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineKeyboardMarkup from json.
func (o *OptInlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineKeyboardMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineKeyboardMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQuery as json.
func (o OptInlineQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineQuery from json.
func (o *OptInlineQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryChatType as json.
func (o OptInlineQueryChatType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InlineQueryChatType from json.
func (o *OptInlineQueryChatType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineQueryChatType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineQueryChatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineQueryChatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputMessageContent as json.
func (o OptInputMessageContent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InputMessageContent from json.
func (o *OptInputMessageContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInputMessageContent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInputMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInputMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Invoice as json.
func (o OptInvoice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Invoice from json.
func (o *OptInvoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInvoice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInvoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInvoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyboardButtonPollType as json.
func (o OptKeyboardButtonPollType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes KeyboardButtonPollType from json.
func (o *OptKeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptKeyboardButtonPollType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptKeyboardButtonPollType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptKeyboardButtonPollType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Location as json.
func (o OptLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Location from json.
func (o *OptLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoginUrl as json.
func (o OptLoginUrl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LoginUrl from json.
func (o *OptLoginUrl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoginUrl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoginUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoginUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaskPosition as json.
func (o OptMaskPosition) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaskPosition from json.
func (o *OptMaskPosition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaskPosition to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaskPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaskPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Message as json.
func (o OptMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Message from json.
func (o *OptMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageAutoDeleteTimerChanged as json.
func (o OptMessageAutoDeleteTimerChanged) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (o *OptMessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageAutoDeleteTimerChanged to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageAutoDeleteTimerChanged) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageAutoDeleteTimerChanged) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageId as json.
func (o OptMessageId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageId from json.
func (o *OptMessageId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderInfo as json.
func (o OptOrderInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderInfo from json.
func (o *OptOrderInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrderInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportData as json.
func (o OptPassportData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PassportData from json.
func (o *OptPassportData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPassportData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPassportData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPassportData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportFile as json.
func (o OptPassportFile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PassportFile from json.
func (o *OptPassportFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPassportFile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPassportFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPassportFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhotoSize as json.
func (o OptPhotoSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PhotoSize from json.
func (o *OptPhotoSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPhotoSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPhotoSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPhotoSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Poll as json.
func (o OptPoll) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Poll from json.
func (o *OptPoll) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoll to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PollAnswer as json.
func (o OptPollAnswer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PollAnswer from json.
func (o *OptPollAnswer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPollAnswer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPollAnswer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPollAnswer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PreCheckoutQuery as json.
func (o OptPreCheckoutQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PreCheckoutQuery from json.
func (o *OptPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPreCheckoutQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPreCheckoutQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProximityAlertTriggered as json.
func (o OptProximityAlertTriggered) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProximityAlertTriggered from json.
func (o *OptProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProximityAlertTriggered to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProximityAlertTriggered) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Response as json.
func (o OptResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Response from json.
func (o *OptResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendAnimationReplyMarkup as json.
func (o OptSendAnimationReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendAnimationReplyMarkup from json.
func (o *OptSendAnimationReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendAnimationReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendAnimationReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendAnimationReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendAudioReplyMarkup as json.
func (o OptSendAudioReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendAudioReplyMarkup from json.
func (o *OptSendAudioReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendAudioReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendAudioReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendAudioReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendContactReplyMarkup as json.
func (o OptSendContactReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendContactReplyMarkup from json.
func (o *OptSendContactReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendContactReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendContactReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendContactReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendDiceReplyMarkup as json.
func (o OptSendDiceReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendDiceReplyMarkup from json.
func (o *OptSendDiceReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendDiceReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendDiceReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendDiceReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendDocumentReplyMarkup as json.
func (o OptSendDocumentReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendDocumentReplyMarkup from json.
func (o *OptSendDocumentReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendDocumentReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendDocumentReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendDocumentReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendLocationReplyMarkup as json.
func (o OptSendLocationReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendLocationReplyMarkup from json.
func (o *OptSendLocationReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendLocationReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendLocationReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendLocationReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendMessageReplyMarkup as json.
func (o OptSendMessageReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendMessageReplyMarkup from json.
func (o *OptSendMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendMessageReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendMessageReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendMessageReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendPhotoReplyMarkup as json.
func (o OptSendPhotoReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendPhotoReplyMarkup from json.
func (o *OptSendPhotoReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendPhotoReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendPhotoReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendPhotoReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendPollReplyMarkup as json.
func (o OptSendPollReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendPollReplyMarkup from json.
func (o *OptSendPollReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendPollReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendPollReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendPollReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendStickerReplyMarkup as json.
func (o OptSendStickerReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendStickerReplyMarkup from json.
func (o *OptSendStickerReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendStickerReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendStickerReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendStickerReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVenueReplyMarkup as json.
func (o OptSendVenueReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendVenueReplyMarkup from json.
func (o *OptSendVenueReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendVenueReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendVenueReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendVenueReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVideoNoteReplyMarkup as json.
func (o OptSendVideoNoteReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendVideoNoteReplyMarkup from json.
func (o *OptSendVideoNoteReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendVideoNoteReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendVideoNoteReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendVideoNoteReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVideoReplyMarkup as json.
func (o OptSendVideoReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendVideoReplyMarkup from json.
func (o *OptSendVideoReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendVideoReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendVideoReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendVideoReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVoiceReplyMarkup as json.
func (o OptSendVoiceReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendVoiceReplyMarkup from json.
func (o *OptSendVoiceReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendVoiceReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendVoiceReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendVoiceReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShippingAddress as json.
func (o OptShippingAddress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ShippingAddress from json.
func (o *OptShippingAddress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptShippingAddress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptShippingAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptShippingAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShippingQuery as json.
func (o OptShippingQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ShippingQuery from json.
func (o *OptShippingQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptShippingQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptShippingQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptShippingQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Sticker as json.
func (o OptSticker) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Sticker from json.
func (o *OptSticker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSticker to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessfulPayment as json.
func (o OptSuccessfulPayment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessfulPayment from json.
func (o *OptSuccessfulPayment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessfulPayment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessfulPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessfulPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes User as json.
func (o OptUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes User from json.
func (o *OptUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserProfilePhotos as json.
func (o OptUserProfilePhotos) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserProfilePhotos from json.
func (o *OptUserProfilePhotos) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserProfilePhotos to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Venue as json.
func (o OptVenue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Venue from json.
func (o *OptVenue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVenue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVenue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVenue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Video as json.
func (o OptVideo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Video from json.
func (o *OptVideo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoNote as json.
func (o OptVideoNote) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VideoNote from json.
func (o *OptVideoNote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideoNote to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideoNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideoNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Voice as json.
func (o OptVoice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Voice from json.
func (o *OptVoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceChatEnded as json.
func (o OptVoiceChatEnded) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceChatEnded from json.
func (o *OptVoiceChatEnded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceChatEnded to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceChatEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceChatEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceChatParticipantsInvited as json.
func (o OptVoiceChatParticipantsInvited) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceChatParticipantsInvited from json.
func (o *OptVoiceChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceChatParticipantsInvited to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceChatParticipantsInvited) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceChatParticipantsInvited) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceChatScheduled as json.
func (o OptVoiceChatScheduled) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceChatScheduled from json.
func (o *OptVoiceChatScheduled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceChatScheduled to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceChatScheduled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceChatScheduled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookInfo as json.
func (o OptWebhookInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookInfo from json.
func (o *OptWebhookInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.ShippingAddress.Set {
			e.FieldStart("shipping_address")
			s.ShippingAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrderInfo = [4]string{
	0: "name",
	1: "phone_number",
	2: "email",
	3: "shipping_address",
}

// Decode decodes OrderInfo from json.
func (s *OrderInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "shipping_address":
			if err := func() error {
				s.ShippingAddress.Reset()
				if err := s.ShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("credentials")
		s.Credentials.Encode(e)
	}
}

var jsonFieldsNameOfPassportData = [2]string{
	0: "data",
	1: "credentials",
}

// Decode decodes PassportData from json.
func (s *PassportData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]EncryptedPassportElement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EncryptedPassportElement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "credentials":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportData) {
					name = jsonFieldsNameOfPassportData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementError as json.
func (s PassportElementError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PassportElementError) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		e.FieldStart("type")
		e.Str("data")
		{
			s := s.PassportElementErrorDataField
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("field_name")
				e.Str(s.FieldName)
			}
			{
				e.FieldStart("data_hash")
				e.Str(s.DataHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorFrontSidePassportElementError:
		e.FieldStart("type")
		e.Str("front_side")
		{
			s := s.PassportElementErrorFrontSide
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorReverseSidePassportElementError:
		e.FieldStart("type")
		e.Str("reverse_side")
		{
			s := s.PassportElementErrorReverseSide
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorSelfiePassportElementError:
		e.FieldStart("type")
		e.Str("selfie")
		{
			s := s.PassportElementErrorSelfie
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorFilePassportElementError:
		e.FieldStart("type")
		e.Str("file")
		{
			s := s.PassportElementErrorFile
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorFilesPassportElementError:
		e.FieldStart("type")
		e.Str("files")
		{
			s := s.PassportElementErrorFiles
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hashes")
				e.ArrStart()
				for _, elem := range s.FileHashes {
					e.Str(elem)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorTranslationFilePassportElementError:
		e.FieldStart("type")
		e.Str("translation_file")
		{
			s := s.PassportElementErrorTranslationFile
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorTranslationFilesPassportElementError:
		e.FieldStart("type")
		e.Str("translation_files")
		{
			s := s.PassportElementErrorTranslationFiles
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hashes")
				e.ArrStart()
				for _, elem := range s.FileHashes {
					e.Str(elem)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorUnspecifiedPassportElementError:
		e.FieldStart("type")
		e.Str("unspecified")
		{
			s := s.PassportElementErrorUnspecified
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("element_hash")
				e.Str(s.ElementHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	}
}

// Decode decodes PassportElementError from json.
func (s *PassportElementError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementError to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "data":
					s.Type = PassportElementErrorDataFieldPassportElementError
					found = true
				case "front_side":
					s.Type = PassportElementErrorFrontSidePassportElementError
					found = true
				case "reverse_side":
					s.Type = PassportElementErrorReverseSidePassportElementError
					found = true
				case "selfie":
					s.Type = PassportElementErrorSelfiePassportElementError
					found = true
				case "file":
					s.Type = PassportElementErrorFilePassportElementError
					found = true
				case "files":
					s.Type = PassportElementErrorFilesPassportElementError
					found = true
				case "translation_file":
					s.Type = PassportElementErrorTranslationFilePassportElementError
					found = true
				case "translation_files":
					s.Type = PassportElementErrorTranslationFilesPassportElementError
					found = true
				case "unspecified":
					s.Type = PassportElementErrorUnspecifiedPassportElementError
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		if err := s.PassportElementErrorDataField.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFrontSidePassportElementError:
		if err := s.PassportElementErrorFrontSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorReverseSidePassportElementError:
		if err := s.PassportElementErrorReverseSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorSelfiePassportElementError:
		if err := s.PassportElementErrorSelfie.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilePassportElementError:
		if err := s.PassportElementErrorFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilesPassportElementError:
		if err := s.PassportElementErrorFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilePassportElementError:
		if err := s.PassportElementErrorTranslationFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilesPassportElementError:
		if err := s.PassportElementErrorTranslationFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorUnspecifiedPassportElementError:
		if err := s.PassportElementErrorUnspecified.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorDataField) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorDataField) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("field_name")
		e.Str(s.FieldName)
	}
	{
		e.FieldStart("data_hash")
		e.Str(s.DataHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorDataField = [5]string{
	0: "source",
	1: "type",
	2: "field_name",
	3: "data_hash",
	4: "message",
}

// Decode decodes PassportElementErrorDataField from json.
func (s *PassportElementErrorDataField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorDataField to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "field_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FieldName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field_name\"")
			}
		case "data_hash":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DataHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorDataField")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorDataField) {
					name = jsonFieldsNameOfPassportElementErrorDataField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorDataField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorDataField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorDataFieldType as json.
func (s PassportElementErrorDataFieldType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorDataFieldType from json.
func (s *PassportElementErrorDataFieldType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorDataFieldType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorDataFieldType(v) {
	case PassportElementErrorDataFieldTypePersonalDetails:
		*s = PassportElementErrorDataFieldTypePersonalDetails
	case PassportElementErrorDataFieldTypePassport:
		*s = PassportElementErrorDataFieldTypePassport
	case PassportElementErrorDataFieldTypeDriverLicense:
		*s = PassportElementErrorDataFieldTypeDriverLicense
	case PassportElementErrorDataFieldTypeIdentityCard:
		*s = PassportElementErrorDataFieldTypeIdentityCard
	case PassportElementErrorDataFieldTypeInternalPassport:
		*s = PassportElementErrorDataFieldTypeInternalPassport
	case PassportElementErrorDataFieldTypeAddress:
		*s = PassportElementErrorDataFieldTypeAddress
	default:
		*s = PassportElementErrorDataFieldType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorDataFieldType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorDataFieldType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorFile = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorFile from json.
func (s *PassportElementErrorFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFile) {
					name = jsonFieldsNameOfPassportElementErrorFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorFileType as json.
func (s PassportElementErrorFileType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFileType from json.
func (s *PassportElementErrorFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFileType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFileType(v) {
	case PassportElementErrorFileTypeUtilityBill:
		*s = PassportElementErrorFileTypeUtilityBill
	case PassportElementErrorFileTypeBankStatement:
		*s = PassportElementErrorFileTypeBankStatement
	case PassportElementErrorFileTypeRentalAgreement:
		*s = PassportElementErrorFileTypeRentalAgreement
	case PassportElementErrorFileTypePassportRegistration:
		*s = PassportElementErrorFileTypePassportRegistration
	case PassportElementErrorFileTypeTemporaryRegistration:
		*s = PassportElementErrorFileTypeTemporaryRegistration
	default:
		*s = PassportElementErrorFileType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorFiles) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hashes")
		e.ArrStart()
		for _, elem := range s.FileHashes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorFiles = [4]string{
	0: "source",
	1: "type",
	2: "file_hashes",
	3: "message",
}

// Decode decodes PassportElementErrorFiles from json.
func (s *PassportElementErrorFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFiles to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hashes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FileHashes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileHashes = append(s.FileHashes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hashes\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorFiles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFiles) {
					name = jsonFieldsNameOfPassportElementErrorFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorFilesType as json.
func (s PassportElementErrorFilesType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFilesType from json.
func (s *PassportElementErrorFilesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFilesType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFilesType(v) {
	case PassportElementErrorFilesTypeUtilityBill:
		*s = PassportElementErrorFilesTypeUtilityBill
	case PassportElementErrorFilesTypeBankStatement:
		*s = PassportElementErrorFilesTypeBankStatement
	case PassportElementErrorFilesTypeRentalAgreement:
		*s = PassportElementErrorFilesTypeRentalAgreement
	case PassportElementErrorFilesTypePassportRegistration:
		*s = PassportElementErrorFilesTypePassportRegistration
	case PassportElementErrorFilesTypeTemporaryRegistration:
		*s = PassportElementErrorFilesTypeTemporaryRegistration
	default:
		*s = PassportElementErrorFilesType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorFilesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFilesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorFrontSide) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorFrontSide) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorFrontSide = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorFrontSide from json.
func (s *PassportElementErrorFrontSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFrontSide to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorFrontSide")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFrontSide) {
					name = jsonFieldsNameOfPassportElementErrorFrontSide[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorFrontSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFrontSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorFrontSideType as json.
func (s PassportElementErrorFrontSideType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFrontSideType from json.
func (s *PassportElementErrorFrontSideType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFrontSideType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFrontSideType(v) {
	case PassportElementErrorFrontSideTypePassport:
		*s = PassportElementErrorFrontSideTypePassport
	case PassportElementErrorFrontSideTypeDriverLicense:
		*s = PassportElementErrorFrontSideTypeDriverLicense
	case PassportElementErrorFrontSideTypeIdentityCard:
		*s = PassportElementErrorFrontSideTypeIdentityCard
	case PassportElementErrorFrontSideTypeInternalPassport:
		*s = PassportElementErrorFrontSideTypeInternalPassport
	default:
		*s = PassportElementErrorFrontSideType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorFrontSideType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFrontSideType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorReverseSide) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorReverseSide) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorReverseSide = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorReverseSide from json.
func (s *PassportElementErrorReverseSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorReverseSide to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorReverseSide")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorReverseSide) {
					name = jsonFieldsNameOfPassportElementErrorReverseSide[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorReverseSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorReverseSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorReverseSideType as json.
func (s PassportElementErrorReverseSideType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorReverseSideType from json.
func (s *PassportElementErrorReverseSideType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorReverseSideType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorReverseSideType(v) {
	case PassportElementErrorReverseSideTypeDriverLicense:
		*s = PassportElementErrorReverseSideTypeDriverLicense
	case PassportElementErrorReverseSideTypeIdentityCard:
		*s = PassportElementErrorReverseSideTypeIdentityCard
	default:
		*s = PassportElementErrorReverseSideType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorReverseSideType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorReverseSideType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorSelfie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorSelfie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorSelfie = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorSelfie from json.
func (s *PassportElementErrorSelfie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorSelfie to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorSelfie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorSelfie) {
					name = jsonFieldsNameOfPassportElementErrorSelfie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorSelfie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorSelfie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorSelfieType as json.
func (s PassportElementErrorSelfieType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorSelfieType from json.
func (s *PassportElementErrorSelfieType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorSelfieType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorSelfieType(v) {
	case PassportElementErrorSelfieTypePassport:
		*s = PassportElementErrorSelfieTypePassport
	case PassportElementErrorSelfieTypeDriverLicense:
		*s = PassportElementErrorSelfieTypeDriverLicense
	case PassportElementErrorSelfieTypeIdentityCard:
		*s = PassportElementErrorSelfieTypeIdentityCard
	case PassportElementErrorSelfieTypeInternalPassport:
		*s = PassportElementErrorSelfieTypeInternalPassport
	default:
		*s = PassportElementErrorSelfieType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorSelfieType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorSelfieType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorTranslationFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorTranslationFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorTranslationFile = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorTranslationFile from json.
func (s *PassportElementErrorTranslationFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorTranslationFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorTranslationFile) {
					name = jsonFieldsNameOfPassportElementErrorTranslationFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorTranslationFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorTranslationFileType as json.
func (s PassportElementErrorTranslationFileType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorTranslationFileType from json.
func (s *PassportElementErrorTranslationFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFileType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorTranslationFileType(v) {
	case PassportElementErrorTranslationFileTypePassport:
		*s = PassportElementErrorTranslationFileTypePassport
	case PassportElementErrorTranslationFileTypeDriverLicense:
		*s = PassportElementErrorTranslationFileTypeDriverLicense
	case PassportElementErrorTranslationFileTypeIdentityCard:
		*s = PassportElementErrorTranslationFileTypeIdentityCard
	case PassportElementErrorTranslationFileTypeInternalPassport:
		*s = PassportElementErrorTranslationFileTypeInternalPassport
	case PassportElementErrorTranslationFileTypeUtilityBill:
		*s = PassportElementErrorTranslationFileTypeUtilityBill
	case PassportElementErrorTranslationFileTypeBankStatement:
		*s = PassportElementErrorTranslationFileTypeBankStatement
	case PassportElementErrorTranslationFileTypeRentalAgreement:
		*s = PassportElementErrorTranslationFileTypeRentalAgreement
	case PassportElementErrorTranslationFileTypePassportRegistration:
		*s = PassportElementErrorTranslationFileTypePassportRegistration
	case PassportElementErrorTranslationFileTypeTemporaryRegistration:
		*s = PassportElementErrorTranslationFileTypeTemporaryRegistration
	default:
		*s = PassportElementErrorTranslationFileType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorTranslationFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorTranslationFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorTranslationFiles) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hashes")
		e.ArrStart()
		for _, elem := range s.FileHashes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorTranslationFiles = [4]string{
	0: "source",
	1: "type",
	2: "file_hashes",
	3: "message",
}

// Decode decodes PassportElementErrorTranslationFiles from json.
func (s *PassportElementErrorTranslationFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFiles to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hashes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FileHashes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileHashes = append(s.FileHashes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hashes\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorTranslationFiles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorTranslationFiles) {
					name = jsonFieldsNameOfPassportElementErrorTranslationFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorTranslationFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorTranslationFilesType as json.
func (s PassportElementErrorTranslationFilesType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorTranslationFilesType from json.
func (s *PassportElementErrorTranslationFilesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFilesType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorTranslationFilesType(v) {
	case PassportElementErrorTranslationFilesTypePassport:
		*s = PassportElementErrorTranslationFilesTypePassport
	case PassportElementErrorTranslationFilesTypeDriverLicense:
		*s = PassportElementErrorTranslationFilesTypeDriverLicense
	case PassportElementErrorTranslationFilesTypeIdentityCard:
		*s = PassportElementErrorTranslationFilesTypeIdentityCard
	case PassportElementErrorTranslationFilesTypeInternalPassport:
		*s = PassportElementErrorTranslationFilesTypeInternalPassport
	case PassportElementErrorTranslationFilesTypeUtilityBill:
		*s = PassportElementErrorTranslationFilesTypeUtilityBill
	case PassportElementErrorTranslationFilesTypeBankStatement:
		*s = PassportElementErrorTranslationFilesTypeBankStatement
	case PassportElementErrorTranslationFilesTypeRentalAgreement:
		*s = PassportElementErrorTranslationFilesTypeRentalAgreement
	case PassportElementErrorTranslationFilesTypePassportRegistration:
		*s = PassportElementErrorTranslationFilesTypePassportRegistration
	case PassportElementErrorTranslationFilesTypeTemporaryRegistration:
		*s = PassportElementErrorTranslationFilesTypeTemporaryRegistration
	default:
		*s = PassportElementErrorTranslationFilesType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorTranslationFilesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFilesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorUnspecified) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorUnspecified) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("element_hash")
		e.Str(s.ElementHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorUnspecified = [4]string{
	0: "source",
	1: "type",
	2: "element_hash",
	3: "message",
}

// Decode decodes PassportElementErrorUnspecified from json.
func (s *PassportElementErrorUnspecified) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorUnspecified to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "element_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ElementHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"element_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorUnspecified")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorUnspecified) {
					name = jsonFieldsNameOfPassportElementErrorUnspecified[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorUnspecified) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorUnspecified) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("file_size")
		e.Int(s.FileSize)
	}
	{
		e.FieldStart("file_date")
		e.Int(s.FileDate)
	}
}

var jsonFieldsNameOfPassportFile = [4]string{
	0: "file_id",
	1: "file_unique_id",
	2: "file_size",
	3: "file_date",
}

// Decode decodes PassportFile from json.
func (s *PassportFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "file_size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.FileSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "file_date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.FileDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportFile) {
					name = jsonFieldsNameOfPassportFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhotoSize) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhotoSize) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfPhotoSize = [5]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "file_size",
}

// Decode decodes PhotoSize from json.
func (s *PhotoSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhotoSize to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhotoSize")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPhotoSize) {
					name = jsonFieldsNameOfPhotoSize[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhotoSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhotoSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PinChatMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PinChatMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
}

var jsonFieldsNameOfPinChatMessage = [3]string{
	0: "chat_id",
	1: "message_id",
	2: "disable_notification",
}

// Decode decodes PinChatMessage from json.
func (s *PinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PinChatMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PinChatMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPinChatMessage) {
					name = jsonFieldsNameOfPinChatMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PinChatMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PinChatMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Poll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Poll) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("question")
		e.Str(s.Question)
	}
	{
		e.FieldStart("options")
		e.ArrStart()
		for _, elem := range s.Options {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_voter_count")
		e.Int(s.TotalVoterCount)
	}
	{
		e.FieldStart("is_closed")
		e.Bool(s.IsClosed)
	}
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("allows_multiple_answers")
		e.Bool(s.AllowsMultipleAnswers)
	}
	{
		if s.CorrectOptionID.Set {
			e.FieldStart("correct_option_id")
			s.CorrectOptionID.Encode(e)
		}
	}
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.ExplanationEntities != nil {
			e.FieldStart("explanation_entities")
			e.ArrStart()
			for _, elem := range s.ExplanationEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OpenPeriod.Set {
			e.FieldStart("open_period")
			s.OpenPeriod.Encode(e)
		}
	}
	{
		if s.CloseDate.Set {
			e.FieldStart("close_date")
			s.CloseDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoll = [13]string{
	0:  "id",
	1:  "question",
	2:  "options",
	3:  "total_voter_count",
	4:  "is_closed",
	5:  "is_anonymous",
	6:  "type",
	7:  "allows_multiple_answers",
	8:  "correct_option_id",
	9:  "explanation",
	10: "explanation_entities",
	11: "open_period",
	12: "close_date",
}

// Decode decodes Poll from json.
func (s *Poll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Poll to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "question":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Question = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question\"")
			}
		case "options":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Options = make([]PollOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PollOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "total_voter_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalVoterCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_voter_count\"")
			}
		case "is_closed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsClosed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_closed\"")
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "allows_multiple_answers":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.AllowsMultipleAnswers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_multiple_answers\"")
			}
		case "correct_option_id":
			if err := func() error {
				s.CorrectOptionID.Reset()
				if err := s.CorrectOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_option_id\"")
			}
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "explanation_entities":
			if err := func() error {
				s.ExplanationEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExplanationEntities = append(s.ExplanationEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation_entities\"")
			}
		case "open_period":
			if err := func() error {
				s.OpenPeriod.Reset()
				if err := s.OpenPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_period\"")
			}
		case "close_date":
			if err := func() error {
				s.CloseDate.Reset()
				if err := s.CloseDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"close_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Poll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPoll) {
					name = jsonFieldsNameOfPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Poll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Poll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PollAnswer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PollAnswer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("poll_id")
		e.Str(s.PollID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("option_ids")
		e.ArrStart()
		for _, elem := range s.OptionIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPollAnswer = [3]string{
	0: "poll_id",
	1: "user",
	2: "option_ids",
}

// Decode decodes PollAnswer from json.
func (s *PollAnswer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PollAnswer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "poll_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PollID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "option_ids":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.OptionIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.OptionIds = append(s.OptionIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"option_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PollAnswer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPollAnswer) {
					name = jsonFieldsNameOfPollAnswer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PollAnswer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PollAnswer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PollOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PollOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("voter_count")
		e.Int(s.VoterCount)
	}
}

var jsonFieldsNameOfPollOption = [2]string{
	0: "text",
	1: "voter_count",
}

// Decode decodes PollOption from json.
func (s *PollOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PollOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voter_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.VoterCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voter_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PollOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPollOption) {
					name = jsonFieldsNameOfPollOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PollOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PollOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PollType as json.
func (s PollType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PollType from json.
func (s *PollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PollType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PollType(v) {
	case PollTypeRegular:
		*s = PollTypeRegular
	case PollTypeQuiz:
		*s = PollTypeQuiz
	default:
		*s = PollType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PollType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PollType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreCheckoutQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreCheckoutQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		if s.ShippingOptionID.Set {
			e.FieldStart("shipping_option_id")
			s.ShippingOptionID.Encode(e)
		}
	}
	{
		if s.OrderInfo.Set {
			e.FieldStart("order_info")
			s.OrderInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfPreCheckoutQuery = [7]string{
	0: "id",
	1: "from",
	2: "currency",
	3: "total_amount",
	4: "invoice_payload",
	5: "shipping_option_id",
	6: "order_info",
}

// Decode decodes PreCheckoutQuery from json.
func (s *PreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreCheckoutQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "shipping_option_id":
			if err := func() error {
				s.ShippingOptionID.Reset()
				if err := s.ShippingOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_option_id\"")
			}
		case "order_info":
			if err := func() error {
				s.OrderInfo.Reset()
				if err := s.OrderInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order_info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreCheckoutQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreCheckoutQuery) {
					name = jsonFieldsNameOfPreCheckoutQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreCheckoutQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreCheckoutQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromoteChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromoteChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.IsAnonymous.Set {
			e.FieldStart("is_anonymous")
			s.IsAnonymous.Encode(e)
		}
	}
	{
		if s.CanManageChat.Set {
			e.FieldStart("can_manage_chat")
			s.CanManageChat.Encode(e)
		}
	}
	{
		if s.CanPostMessages.Set {
			e.FieldStart("can_post_messages")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.FieldStart("can_edit_messages")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanDeleteMessages.Set {
			e.FieldStart("can_delete_messages")
			s.CanDeleteMessages.Encode(e)
		}
	}
	{
		if s.CanManageVoiceChats.Set {
			e.FieldStart("can_manage_voice_chats")
			s.CanManageVoiceChats.Encode(e)
		}
	}
	{
		if s.CanRestrictMembers.Set {
			e.FieldStart("can_restrict_members")
			s.CanRestrictMembers.Encode(e)
		}
	}
	{
		if s.CanPromoteMembers.Set {
			e.FieldStart("can_promote_members")
			s.CanPromoteMembers.Encode(e)
		}
	}
	{
		if s.CanChangeInfo.Set {
			e.FieldStart("can_change_info")
			s.CanChangeInfo.Encode(e)
		}
	}
	{
		if s.CanInviteUsers.Set {
			e.FieldStart("can_invite_users")
			s.CanInviteUsers.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromoteChatMember = [13]string{
	0:  "chat_id",
	1:  "user_id",
	2:  "is_anonymous",
	3:  "can_manage_chat",
	4:  "can_post_messages",
	5:  "can_edit_messages",
	6:  "can_delete_messages",
	7:  "can_manage_voice_chats",
	8:  "can_restrict_members",
	9:  "can_promote_members",
	10: "can_change_info",
	11: "can_invite_users",
	12: "can_pin_messages",
}

// Decode decodes PromoteChatMember from json.
func (s *PromoteChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromoteChatMember to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "is_anonymous":
			if err := func() error {
				s.IsAnonymous.Reset()
				if err := s.IsAnonymous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "can_manage_chat":
			if err := func() error {
				s.CanManageChat.Reset()
				if err := s.CanManageChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_chat\"")
			}
		case "can_post_messages":
			if err := func() error {
				s.CanPostMessages.Reset()
				if err := s.CanPostMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_messages\"")
			}
		case "can_edit_messages":
			if err := func() error {
				s.CanEditMessages.Reset()
				if err := s.CanEditMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_messages\"")
			}
		case "can_delete_messages":
			if err := func() error {
				s.CanDeleteMessages.Reset()
				if err := s.CanDeleteMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_messages\"")
			}
		case "can_manage_voice_chats":
			if err := func() error {
				s.CanManageVoiceChats.Reset()
				if err := s.CanManageVoiceChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_voice_chats\"")
			}
		case "can_restrict_members":
			if err := func() error {
				s.CanRestrictMembers.Reset()
				if err := s.CanRestrictMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_restrict_members\"")
			}
		case "can_promote_members":
			if err := func() error {
				s.CanPromoteMembers.Reset()
				if err := s.CanPromoteMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_promote_members\"")
			}
		case "can_change_info":
			if err := func() error {
				s.CanChangeInfo.Reset()
				if err := s.CanChangeInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			if err := func() error {
				s.CanInviteUsers.Reset()
				if err := s.CanInviteUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromoteChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromoteChatMember) {
					name = jsonFieldsNameOfPromoteChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromoteChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromoteChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProximityAlertTriggered) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProximityAlertTriggered) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("traveler")
		s.Traveler.Encode(e)
	}
	{
		e.FieldStart("watcher")
		s.Watcher.Encode(e)
	}
	{
		e.FieldStart("distance")
		e.Int(s.Distance)
	}
}

var jsonFieldsNameOfProximityAlertTriggered = [3]string{
	0: "traveler",
	1: "watcher",
	2: "distance",
}

// Decode decodes ProximityAlertTriggered from json.
func (s *ProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProximityAlertTriggered to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "traveler":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Traveler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traveler\"")
			}
		case "watcher":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Watcher.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watcher\"")
			}
		case "distance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Distance = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProximityAlertTriggered")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProximityAlertTriggered) {
					name = jsonFieldsNameOfProximityAlertTriggered[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProximityAlertTriggered) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplyKeyboardMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplyKeyboardMarkup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keyboard")
		e.ArrStart()
		for _, elem := range s.Keyboard {
			e.ArrStart()
			for _, elem := range elem {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
	{
		if s.ResizeKeyboard.Set {
			e.FieldStart("resize_keyboard")
			s.ResizeKeyboard.Encode(e)
		}
	}
	{
		if s.OneTimeKeyboard.Set {
			e.FieldStart("one_time_keyboard")
			s.OneTimeKeyboard.Encode(e)
		}
	}
	{
		if s.InputFieldPlaceholder.Set {
			e.FieldStart("input_field_placeholder")
			s.InputFieldPlaceholder.Encode(e)
		}
	}
	{
		if s.Selective.Set {
			e.FieldStart("selective")
			s.Selective.Encode(e)
		}
	}
}

var jsonFieldsNameOfReplyKeyboardMarkup = [5]string{
	0: "keyboard",
	1: "resize_keyboard",
	2: "one_time_keyboard",
	3: "input_field_placeholder",
	4: "selective",
}

// Decode decodes ReplyKeyboardMarkup from json.
func (s *ReplyKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplyKeyboardMarkup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Keyboard = make([][]KeyboardButton, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []KeyboardButton
					elem = make([]KeyboardButton, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem KeyboardButton
						if err := elemElem.Decode(d); err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.Keyboard = append(s.Keyboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyboard\"")
			}
		case "resize_keyboard":
			if err := func() error {
				s.ResizeKeyboard.Reset()
				if err := s.ResizeKeyboard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resize_keyboard\"")
			}
		case "one_time_keyboard":
			if err := func() error {
				s.OneTimeKeyboard.Reset()
				if err := s.OneTimeKeyboard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"one_time_keyboard\"")
			}
		case "input_field_placeholder":
			if err := func() error {
				s.InputFieldPlaceholder.Reset()
				if err := s.InputFieldPlaceholder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_field_placeholder\"")
			}
		case "selective":
			if err := func() error {
				s.Selective.Reset()
				if err := s.Selective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selective\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplyKeyboardMarkup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyKeyboardMarkup) {
					name = jsonFieldsNameOfReplyKeyboardMarkup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplyKeyboardMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplyKeyboardMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplyKeyboardRemove) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplyKeyboardRemove) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remove_keyboard")
		e.Bool(s.RemoveKeyboard)
	}
	{
		if s.Selective.Set {
			e.FieldStart("selective")
			s.Selective.Encode(e)
		}
	}
}

var jsonFieldsNameOfReplyKeyboardRemove = [2]string{
	0: "remove_keyboard",
	1: "selective",
}

// Decode decodes ReplyKeyboardRemove from json.
func (s *ReplyKeyboardRemove) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplyKeyboardRemove to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remove_keyboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.RemoveKeyboard = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_keyboard\"")
			}
		case "selective":
			if err := func() error {
				s.Selective.Reset()
				if err := s.Selective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selective\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplyKeyboardRemove")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyKeyboardRemove) {
					name = jsonFieldsNameOfReplyKeyboardRemove[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplyKeyboardRemove) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplyKeyboardRemove) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Response) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Response) encodeFields(e *jx.Encoder) {
	{
		if s.MigrateToChatID.Set {
			e.FieldStart("migrate_to_chat_id")
			s.MigrateToChatID.Encode(e)
		}
	}
	{
		if s.RetryAfter.Set {
			e.FieldStart("retry_after")
			s.RetryAfter.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponse = [2]string{
	0: "migrate_to_chat_id",
	1: "retry_after",
}

// Decode decodes Response from json.
func (s *Response) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Response to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "migrate_to_chat_id":
			if err := func() error {
				s.MigrateToChatID.Reset()
				if err := s.MigrateToChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migrate_to_chat_id\"")
			}
		case "retry_after":
			if err := func() error {
				s.RetryAfter.Reset()
				if err := s.RetryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_after\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Response")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Response) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Response) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestrictChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestrictChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		if s.UntilDate.Set {
			e.FieldStart("until_date")
			s.UntilDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfRestrictChatMember = [4]string{
	0: "chat_id",
	1: "user_id",
	2: "permissions",
	3: "until_date",
}

// Decode decodes RestrictChatMember from json.
func (s *RestrictChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestrictChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "until_date":
			if err := func() error {
				s.UntilDate.Reset()
				if err := s.UntilDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestrictChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestrictChatMember) {
					name = jsonFieldsNameOfRestrictChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestrictChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestrictChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Result) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Result) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResult = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes Result from json.
func (s *Result) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Result to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Result")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResult) {
					name = jsonFieldsNameOfResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Result) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Result) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfBotCommand) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfBotCommand) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfBotCommand = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfBotCommand from json.
func (s *ResultArrayOfBotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfBotCommand to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]BotCommand, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BotCommand
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfBotCommand")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfBotCommand) {
					name = jsonFieldsNameOfResultArrayOfBotCommand[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfBotCommand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfBotCommand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfChatMember) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfChatMember = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfChatMember from json.
func (s *ResultArrayOfChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfChatMember to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]ChatMember, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatMember
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfChatMember) {
					name = jsonFieldsNameOfResultArrayOfChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfGameHighScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfGameHighScore) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfGameHighScore = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfGameHighScore from json.
func (s *ResultArrayOfGameHighScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfGameHighScore to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]GameHighScore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GameHighScore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfGameHighScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfGameHighScore) {
					name = jsonFieldsNameOfResultArrayOfGameHighScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfGameHighScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfGameHighScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfMessage = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfMessage from json.
func (s *ResultArrayOfMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfMessage to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]Message, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Message
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfMessage) {
					name = jsonFieldsNameOfResultArrayOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfUpdate = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfUpdate from json.
func (s *ResultArrayOfUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfUpdate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]Update, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Update
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfUpdate) {
					name = jsonFieldsNameOfResultArrayOfUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultChat) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultChat = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChat from json.
func (s *ResultChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultChat to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChat) {
					name = jsonFieldsNameOfResultChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultChatInviteLink = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChatInviteLink from json.
func (s *ResultChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChatInviteLink) {
					name = jsonFieldsNameOfResultChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultChatMember) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultChatMember = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChatMember from json.
func (s *ResultChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultChatMember to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChatMember) {
					name = jsonFieldsNameOfResultChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultFile) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultFile = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultFile from json.
func (s *ResultFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultFile) {
					name = jsonFieldsNameOfResultFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultInt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultInt) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultInt = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultInt from json.
func (s *ResultInt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultInt to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultInt")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultInt) {
					name = jsonFieldsNameOfResultInt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultMessage = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessage from json.
func (s *ResultMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultMessage to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessage) {
					name = jsonFieldsNameOfResultMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultMessageId) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultMessageId) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultMessageId = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessageId from json.
func (s *ResultMessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultMessageId to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultMessageId")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessageId) {
					name = jsonFieldsNameOfResultMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultMessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultMessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultPoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultPoll) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultPoll = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultPoll from json.
func (s *ResultPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultPoll to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultPoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultPoll) {
					name = jsonFieldsNameOfResultPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultString) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultString) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultString = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultString from json.
func (s *ResultString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultString to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultString")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultString) {
					name = jsonFieldsNameOfResultString[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultUser) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultUser = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultUser from json.
func (s *ResultUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultUser to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultUser) {
					name = jsonFieldsNameOfResultUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultUserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultUserProfilePhotos) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultUserProfilePhotos = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultUserProfilePhotos from json.
func (s *ResultUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultUserProfilePhotos to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultUserProfilePhotos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultUserProfilePhotos) {
					name = jsonFieldsNameOfResultUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultUserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultUserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultWebhookInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultWebhookInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultWebhookInfo = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultWebhookInfo from json.
func (s *ResultWebhookInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultWebhookInfo to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultWebhookInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultWebhookInfo) {
					name = jsonFieldsNameOfResultWebhookInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultWebhookInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultWebhookInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
}

var jsonFieldsNameOfRevokeChatInviteLink = [2]string{
	0: "chat_id",
	1: "invite_link",
}

// Decode decodes RevokeChatInviteLink from json.
func (s *RevokeChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeChatInviteLink) {
					name = jsonFieldsNameOfRevokeChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendAnimation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendAnimation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("animation")
		e.Str(s.Animation)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendAnimation = [13]string{
	0:  "chat_id",
	1:  "animation",
	2:  "duration",
	3:  "width",
	4:  "height",
	5:  "thumb",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "disable_notification",
	10: "reply_to_message_id",
	11: "allow_sending_without_reply",
	12: "reply_markup",
}

// Decode decodes SendAnimation from json.
func (s *SendAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendAnimation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "animation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Animation = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendAnimation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendAnimation) {
					name = jsonFieldsNameOfSendAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendAnimation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendAnimation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendAnimationReplyMarkup as json.
func (s SendAnimationReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendAnimationReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendAnimationReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendAnimationReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendAnimationReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendAnimationReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendAnimationReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendAnimationReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendAnimationReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendAnimationReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendAnimationReplyMarkup from json.
func (s *SendAnimationReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendAnimationReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendAnimationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendAnimationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendAnimationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendAnimationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendAnimationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendAnimationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendAnimationReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendAnimationReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendAnimationReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendAnimationReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendAnimationReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendAnimationReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("audio")
		e.Str(s.Audio)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendAudio = [13]string{
	0:  "chat_id",
	1:  "audio",
	2:  "caption",
	3:  "parse_mode",
	4:  "caption_entities",
	5:  "duration",
	6:  "performer",
	7:  "title",
	8:  "thumb",
	9:  "disable_notification",
	10: "reply_to_message_id",
	11: "allow_sending_without_reply",
	12: "reply_markup",
}

// Decode decodes SendAudio from json.
func (s *SendAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendAudio to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "audio":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Audio = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendAudio) {
					name = jsonFieldsNameOfSendAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendAudioReplyMarkup as json.
func (s SendAudioReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendAudioReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendAudioReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendAudioReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendAudioReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendAudioReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendAudioReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendAudioReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendAudioReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendAudioReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendAudioReplyMarkup from json.
func (s *SendAudioReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendAudioReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendAudioReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendAudioReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendAudioReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendAudioReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendAudioReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendAudioReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendAudioReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendAudioReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendAudioReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendAudioReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendAudioReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendAudioReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendChatAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendChatAction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("action")
		e.Str(s.Action)
	}
}

var jsonFieldsNameOfSendChatAction = [2]string{
	0: "chat_id",
	1: "action",
}

// Decode decodes SendChatAction from json.
func (s *SendChatAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendChatAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Action = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendChatAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendChatAction) {
					name = jsonFieldsNameOfSendChatAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendChatAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendChatAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendContact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendContact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendContact = [9]string{
	0: "chat_id",
	1: "phone_number",
	2: "first_name",
	3: "last_name",
	4: "vcard",
	5: "disable_notification",
	6: "reply_to_message_id",
	7: "allow_sending_without_reply",
	8: "reply_markup",
}

// Decode decodes SendContact from json.
func (s *SendContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendContact to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendContact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendContact) {
					name = jsonFieldsNameOfSendContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendContactReplyMarkup as json.
func (s SendContactReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendContactReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendContactReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendContactReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendContactReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendContactReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendContactReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendContactReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendContactReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendContactReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendContactReplyMarkup from json.
func (s *SendContactReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendContactReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendContactReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendContactReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendContactReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendContactReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendContactReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendContactReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendContactReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendContactReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendContactReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendContactReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendContactReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendContactReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendDice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendDice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendDice = [6]string{
	0: "chat_id",
	1: "emoji",
	2: "disable_notification",
	3: "reply_to_message_id",
	4: "allow_sending_without_reply",
	5: "reply_markup",
}

// Decode decodes SendDice from json.
func (s *SendDice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendDice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDice) {
					name = jsonFieldsNameOfSendDice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendDice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendDiceReplyMarkup as json.
func (s SendDiceReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendDiceReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendDiceReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendDiceReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendDiceReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendDiceReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendDiceReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendDiceReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendDiceReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendDiceReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendDiceReplyMarkup from json.
func (s *SendDiceReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDiceReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendDiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendDiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendDiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendDiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendDiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendDiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendDiceReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendDiceReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendDiceReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendDiceReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendDiceReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDiceReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("document")
		e.Str(s.Document)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableContentTypeDetection.Set {
			e.FieldStart("disable_content_type_detection")
			s.DisableContentTypeDetection.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendDocument = [11]string{
	0:  "chat_id",
	1:  "document",
	2:  "thumb",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "disable_content_type_detection",
	7:  "disable_notification",
	8:  "reply_to_message_id",
	9:  "allow_sending_without_reply",
	10: "reply_markup",
}

// Decode decodes SendDocument from json.
func (s *SendDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDocument to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "document":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Document = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_content_type_detection":
			if err := func() error {
				s.DisableContentTypeDetection.Reset()
				if err := s.DisableContentTypeDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_content_type_detection\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDocument) {
					name = jsonFieldsNameOfSendDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendDocumentReplyMarkup as json.
func (s SendDocumentReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendDocumentReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendDocumentReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendDocumentReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendDocumentReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendDocumentReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendDocumentReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendDocumentReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendDocumentReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendDocumentReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendDocumentReplyMarkup from json.
func (s *SendDocumentReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDocumentReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendDocumentReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendDocumentReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendDocumentReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendDocumentReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendDocumentReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendDocumentReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendDocumentReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendDocumentReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendDocumentReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendDocumentReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendDocumentReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDocumentReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendGame) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		e.Int64(s.ChatID)
	}
	{
		e.FieldStart("game_short_name")
		e.Str(s.GameShortName)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendGame = [6]string{
	0: "chat_id",
	1: "game_short_name",
	2: "disable_notification",
	3: "reply_to_message_id",
	4: "allow_sending_without_reply",
	5: "reply_markup",
}

// Decode decodes SendGame from json.
func (s *SendGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendGame to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "game_short_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_short_name\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendGame")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendGame) {
					name = jsonFieldsNameOfSendGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendInvoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendInvoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		e.FieldStart("provider_token")
		e.Str(s.ProviderToken)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.MaxTipAmount.Set {
			e.FieldStart("max_tip_amount")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.FieldStart("suggested_tip_amounts")
			e.ArrStart()
			for _, elem := range s.SuggestedTipAmounts {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StartParameter.Set {
			e.FieldStart("start_parameter")
			s.StartParameter.Encode(e)
		}
	}
	{
		if s.ProviderData.Set {
			e.FieldStart("provider_data")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.FieldStart("photo_size")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.FieldStart("need_name")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.FieldStart("need_phone_number")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.FieldStart("need_email")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.FieldStart("need_shipping_address")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.FieldStart("send_phone_number_to_provider")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.FieldStart("send_email_to_provider")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.FieldStart("is_flexible")
			s.IsFlexible.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendInvoice = [26]string{
	0:  "chat_id",
	1:  "title",
	2:  "description",
	3:  "payload",
	4:  "provider_token",
	5:  "currency",
	6:  "prices",
	7:  "max_tip_amount",
	8:  "suggested_tip_amounts",
	9:  "start_parameter",
	10: "provider_data",
	11: "photo_url",
	12: "photo_size",
	13: "photo_width",
	14: "photo_height",
	15: "need_name",
	16: "need_phone_number",
	17: "need_email",
	18: "need_shipping_address",
	19: "send_phone_number_to_provider",
	20: "send_email_to_provider",
	21: "is_flexible",
	22: "disable_notification",
	23: "reply_to_message_id",
	24: "allow_sending_without_reply",
	25: "reply_markup",
}

// Decode decodes SendInvoice from json.
func (s *SendInvoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendInvoice to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "provider_token":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProviderToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_token\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		case "max_tip_amount":
			if err := func() error {
				s.MaxTipAmount.Reset()
				if err := s.MaxTipAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tip_amount\"")
			}
		case "suggested_tip_amounts":
			if err := func() error {
				s.SuggestedTipAmounts = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suggested_tip_amounts\"")
			}
		case "start_parameter":
			if err := func() error {
				s.StartParameter.Reset()
				if err := s.StartParameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_parameter\"")
			}
		case "provider_data":
			if err := func() error {
				s.ProviderData.Reset()
				if err := s.ProviderData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_data\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "photo_size":
			if err := func() error {
				s.PhotoSize.Reset()
				if err := s.PhotoSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_size\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "need_name":
			if err := func() error {
				s.NeedName.Reset()
				if err := s.NeedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_name\"")
			}
		case "need_phone_number":
			if err := func() error {
				s.NeedPhoneNumber.Reset()
				if err := s.NeedPhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_phone_number\"")
			}
		case "need_email":
			if err := func() error {
				s.NeedEmail.Reset()
				if err := s.NeedEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_email\"")
			}
		case "need_shipping_address":
			if err := func() error {
				s.NeedShippingAddress.Reset()
				if err := s.NeedShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_shipping_address\"")
			}
		case "send_phone_number_to_provider":
			if err := func() error {
				s.SendPhoneNumberToProvider.Reset()
				if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_phone_number_to_provider\"")
			}
		case "send_email_to_provider":
			if err := func() error {
				s.SendEmailToProvider.Reset()
				if err := s.SendEmailToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_email_to_provider\"")
			}
		case "is_flexible":
			if err := func() error {
				s.IsFlexible.Reset()
				if err := s.IsFlexible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_flexible\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendInvoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01111111,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendInvoice) {
					name = jsonFieldsNameOfSendInvoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendInvoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendInvoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendLocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendLocation = [11]string{
	0:  "chat_id",
	1:  "latitude",
	2:  "longitude",
	3:  "horizontal_accuracy",
	4:  "live_period",
	5:  "heading",
	6:  "proximity_alert_radius",
	7:  "disable_notification",
	8:  "reply_to_message_id",
	9:  "allow_sending_without_reply",
	10: "reply_markup",
}

// Decode decodes SendLocation from json.
func (s *SendLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendLocation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendLocation) {
					name = jsonFieldsNameOfSendLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendLocationReplyMarkup as json.
func (s SendLocationReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendLocationReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendLocationReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendLocationReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendLocationReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendLocationReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendLocationReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendLocationReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendLocationReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendLocationReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendLocationReplyMarkup from json.
func (s *SendLocationReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendLocationReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendLocationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendLocationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendLocationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendLocationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendLocationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendLocationReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendLocationReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendLocationReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendLocationReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendLocationReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendLocationReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendLocationReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendMediaGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendMediaGroup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("media")
		e.ArrStart()
		for _, elem := range s.Media {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendMediaGroup = [5]string{
	0: "chat_id",
	1: "media",
	2: "disable_notification",
	3: "reply_to_message_id",
	4: "allow_sending_without_reply",
}

// Decode decodes SendMediaGroup from json.
func (s *SendMediaGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMediaGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Media = make([]SendMediaGroupMediaItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SendMediaGroupMediaItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Media = append(s.Media, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendMediaGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendMediaGroup) {
					name = jsonFieldsNameOfSendMediaGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendMediaGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMediaGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendMediaGroupMediaItem as json.
func (s SendMediaGroupMediaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s SendMediaGroupMediaItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("audio")
		{
			s := s.InputMediaAudio
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.Performer.Set {
					e.FieldStart("performer")
					s.Performer.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
		}
	case InputMediaDocumentSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("document")
		{
			s := s.InputMediaDocument
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.DisableContentTypeDetection.Set {
					e.FieldStart("disable_content_type_detection")
					s.DisableContentTypeDetection.Encode(e)
				}
			}
		}
	case InputMediaPhotoSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InputMediaPhoto
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
		}
	case InputMediaVideoSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InputMediaVideo
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumb.Set {
					e.FieldStart("thumb")
					s.Thumb.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.SupportsStreaming.Set {
					e.FieldStart("supports_streaming")
					s.SupportsStreaming.Encode(e)
				}
			}
		}
	}
}

// Decode decodes SendMediaGroupMediaItem from json.
func (s *SendMediaGroupMediaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMediaGroupMediaItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "audio":
					s.Type = InputMediaAudioSendMediaGroupMediaItem
					found = true
				case "document":
					s.Type = InputMediaDocumentSendMediaGroupMediaItem
					found = true
				case "photo":
					s.Type = InputMediaPhotoSendMediaGroupMediaItem
					found = true
				case "video":
					s.Type = InputMediaVideoSendMediaGroupMediaItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentSendMediaGroupMediaItem:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoSendMediaGroupMediaItem:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoSendMediaGroupMediaItem:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendMediaGroupMediaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMediaGroupMediaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableWebPagePreview.Set {
			e.FieldStart("disable_web_page_preview")
			s.DisableWebPagePreview.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendMessage = [9]string{
	0: "chat_id",
	1: "text",
	2: "parse_mode",
	3: "entities",
	4: "disable_web_page_preview",
	5: "disable_notification",
	6: "reply_to_message_id",
	7: "allow_sending_without_reply",
	8: "reply_markup",
}

// Decode decodes SendMessage from json.
func (s *SendMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMessage to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "disable_web_page_preview":
			if err := func() error {
				s.DisableWebPagePreview.Reset()
				if err := s.DisableWebPagePreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_web_page_preview\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendMessage) {
					name = jsonFieldsNameOfSendMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendMessageReplyMarkup as json.
func (s SendMessageReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendMessageReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendMessageReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendMessageReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendMessageReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendMessageReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendMessageReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendMessageReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendMessageReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendMessageReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendMessageReplyMarkup from json.
func (s *SendMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMessageReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendMessageReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendMessageReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendMessageReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendMessageReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendMessageReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendMessageReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMessageReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("photo")
		e.Str(s.Photo)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendPhoto = [9]string{
	0: "chat_id",
	1: "photo",
	2: "caption",
	3: "parse_mode",
	4: "caption_entities",
	5: "disable_notification",
	6: "reply_to_message_id",
	7: "allow_sending_without_reply",
	8: "reply_markup",
}

// Decode decodes SendPhoto from json.
func (s *SendPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPhoto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Photo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPhoto) {
					name = jsonFieldsNameOfSendPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendPhotoReplyMarkup as json.
func (s SendPhotoReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendPhotoReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendPhotoReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendPhotoReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendPhotoReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendPhotoReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendPhotoReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendPhotoReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendPhotoReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendPhotoReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendPhotoReplyMarkup from json.
func (s *SendPhotoReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPhotoReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendPhotoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendPhotoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendPhotoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendPhotoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendPhotoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendPhotoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendPhotoReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendPhotoReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendPhotoReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendPhotoReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendPhotoReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPhotoReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendPoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendPoll) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("question")
		e.Str(s.Question)
	}
	{
		e.FieldStart("options")
		e.ArrStart()
		for _, elem := range s.Options {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.IsAnonymous.Set {
			e.FieldStart("is_anonymous")
			s.IsAnonymous.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.AllowsMultipleAnswers.Set {
			e.FieldStart("allows_multiple_answers")
			s.AllowsMultipleAnswers.Encode(e)
		}
	}
	{
		if s.CorrectOptionID.Set {
			e.FieldStart("correct_option_id")
			s.CorrectOptionID.Encode(e)
		}
	}
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.ExplanationParseMode.Set {
			e.FieldStart("explanation_parse_mode")
			s.ExplanationParseMode.Encode(e)
		}
	}
	{
		if s.ExplanationEntities != nil {
			e.FieldStart("explanation_entities")
			e.ArrStart()
			for _, elem := range s.ExplanationEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OpenPeriod.Set {
			e.FieldStart("open_period")
			s.OpenPeriod.Encode(e)
		}
	}
	{
		if s.CloseDate.Set {
			e.FieldStart("close_date")
			s.CloseDate.Encode(e)
		}
	}
	{
		if s.IsClosed.Set {
			e.FieldStart("is_closed")
			s.IsClosed.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendPoll = [17]string{
	0:  "chat_id",
	1:  "question",
	2:  "options",
	3:  "is_anonymous",
	4:  "type",
	5:  "allows_multiple_answers",
	6:  "correct_option_id",
	7:  "explanation",
	8:  "explanation_parse_mode",
	9:  "explanation_entities",
	10: "open_period",
	11: "close_date",
	12: "is_closed",
	13: "disable_notification",
	14: "reply_to_message_id",
	15: "allow_sending_without_reply",
	16: "reply_markup",
}

// Decode decodes SendPoll from json.
func (s *SendPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPoll to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "question":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Question = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question\"")
			}
		case "options":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Options = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "is_anonymous":
			if err := func() error {
				s.IsAnonymous.Reset()
				if err := s.IsAnonymous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "allows_multiple_answers":
			if err := func() error {
				s.AllowsMultipleAnswers.Reset()
				if err := s.AllowsMultipleAnswers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_multiple_answers\"")
			}
		case "correct_option_id":
			if err := func() error {
				s.CorrectOptionID.Reset()
				if err := s.CorrectOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_option_id\"")
			}
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "explanation_parse_mode":
			if err := func() error {
				s.ExplanationParseMode.Reset()
				if err := s.ExplanationParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation_parse_mode\"")
			}
		case "explanation_entities":
			if err := func() error {
				s.ExplanationEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExplanationEntities = append(s.ExplanationEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation_entities\"")
			}
		case "open_period":
			if err := func() error {
				s.OpenPeriod.Reset()
				if err := s.OpenPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_period\"")
			}
		case "close_date":
			if err := func() error {
				s.CloseDate.Reset()
				if err := s.CloseDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"close_date\"")
			}
		case "is_closed":
			if err := func() error {
				s.IsClosed.Reset()
				if err := s.IsClosed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_closed\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendPoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPoll) {
					name = jsonFieldsNameOfSendPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendPollReplyMarkup as json.
func (s SendPollReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendPollReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendPollReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendPollReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendPollReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendPollReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendPollReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendPollReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendPollReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendPollReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendPollReplyMarkup from json.
func (s *SendPollReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPollReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendPollReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendPollReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendPollReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendPollReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendPollReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendPollReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendPollReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendPollReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendPollReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendPollReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendPollReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPollReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendSticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendSticker) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendSticker = [6]string{
	0: "chat_id",
	1: "sticker",
	2: "disable_notification",
	3: "reply_to_message_id",
	4: "allow_sending_without_reply",
	5: "reply_markup",
}

// Decode decodes SendSticker from json.
func (s *SendSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendSticker to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sticker":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendSticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendSticker) {
					name = jsonFieldsNameOfSendSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendStickerReplyMarkup as json.
func (s SendStickerReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendStickerReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendStickerReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendStickerReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendStickerReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendStickerReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendStickerReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendStickerReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendStickerReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendStickerReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendStickerReplyMarkup from json.
func (s *SendStickerReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendStickerReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendStickerReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendStickerReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendStickerReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendStickerReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendStickerReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendStickerReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendStickerReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendStickerReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendStickerReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendStickerReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendStickerReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendStickerReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVenue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVenue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVenue = [13]string{
	0:  "chat_id",
	1:  "latitude",
	2:  "longitude",
	3:  "title",
	4:  "address",
	5:  "foursquare_id",
	6:  "foursquare_type",
	7:  "google_place_id",
	8:  "google_place_type",
	9:  "disable_notification",
	10: "reply_to_message_id",
	11: "allow_sending_without_reply",
	12: "reply_markup",
}

// Decode decodes SendVenue from json.
func (s *SendVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVenue to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVenue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVenue) {
					name = jsonFieldsNameOfSendVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVenue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVenue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVenueReplyMarkup as json.
func (s SendVenueReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVenueReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVenueReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVenueReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVenueReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendVenueReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVenueReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendVenueReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendVenueReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendVenueReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendVenueReplyMarkup from json.
func (s *SendVenueReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVenueReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendVenueReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendVenueReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendVenueReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendVenueReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendVenueReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendVenueReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVenueReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVenueReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVenueReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVenueReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendVenueReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVenueReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("video")
		e.Str(s.Video)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.FieldStart("supports_streaming")
			s.SupportsStreaming.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVideo = [14]string{
	0:  "chat_id",
	1:  "video",
	2:  "duration",
	3:  "width",
	4:  "height",
	5:  "thumb",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "supports_streaming",
	10: "disable_notification",
	11: "reply_to_message_id",
	12: "allow_sending_without_reply",
	13: "reply_markup",
}

// Decode decodes SendVideo from json.
func (s *SendVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVideo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "video":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Video = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "supports_streaming":
			if err := func() error {
				s.SupportsStreaming.Reset()
				if err := s.SupportsStreaming.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_streaming\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVideo) {
					name = jsonFieldsNameOfSendVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVideoNote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVideoNote) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("video_note")
		e.Str(s.VideoNote)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Length.Set {
			e.FieldStart("length")
			s.Length.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVideoNote = [9]string{
	0: "chat_id",
	1: "video_note",
	2: "duration",
	3: "length",
	4: "thumb",
	5: "disable_notification",
	6: "reply_to_message_id",
	7: "allow_sending_without_reply",
	8: "reply_markup",
}

// Decode decodes SendVideoNote from json.
func (s *SendVideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVideoNote to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "video_note":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VideoNote = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_note\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "length":
			if err := func() error {
				s.Length.Reset()
				if err := s.Length.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVideoNote")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVideoNote) {
					name = jsonFieldsNameOfSendVideoNote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVideoNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVideoNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVideoNoteReplyMarkup as json.
func (s SendVideoNoteReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVideoNoteReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVideoNoteReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVideoNoteReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVideoNoteReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendVideoNoteReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVideoNoteReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendVideoNoteReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendVideoNoteReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendVideoNoteReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendVideoNoteReplyMarkup from json.
func (s *SendVideoNoteReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVideoNoteReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendVideoNoteReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendVideoNoteReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendVideoNoteReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendVideoNoteReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendVideoNoteReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendVideoNoteReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVideoNoteReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVideoNoteReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVideoNoteReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVideoNoteReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendVideoNoteReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVideoNoteReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVideoReplyMarkup as json.
func (s SendVideoReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVideoReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVideoReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVideoReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVideoReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendVideoReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVideoReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendVideoReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendVideoReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendVideoReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendVideoReplyMarkup from json.
func (s *SendVideoReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVideoReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendVideoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendVideoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendVideoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendVideoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendVideoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendVideoReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVideoReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVideoReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVideoReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVideoReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendVideoReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVideoReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("voice")
		e.Str(s.Voice)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.FieldStart("reply_to_message_id")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVoice = [10]string{
	0: "chat_id",
	1: "voice",
	2: "caption",
	3: "parse_mode",
	4: "caption_entities",
	5: "duration",
	6: "disable_notification",
	7: "reply_to_message_id",
	8: "allow_sending_without_reply",
	9: "reply_markup",
}

// Decode decodes SendVoice from json.
func (s *SendVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVoice to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Voice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "reply_to_message_id":
			if err := func() error {
				s.ReplyToMessageID.Reset()
				if err := s.ReplyToMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVoice) {
					name = jsonFieldsNameOfSendVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendVoiceReplyMarkup as json.
func (s SendVoiceReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVoiceReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendVoiceReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendVoiceReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendVoiceReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendVoiceReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendVoiceReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendVoiceReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendVoiceReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendVoiceReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendVoiceReplyMarkup from json.
func (s *SendVoiceReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVoiceReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendVoiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendVoiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendVoiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendVoiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendVoiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendVoiceReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendVoiceReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendVoiceReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendVoiceReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendVoiceReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendVoiceReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVoiceReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatAdministratorCustomTitle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatAdministratorCustomTitle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("custom_title")
		e.Str(s.CustomTitle)
	}
}

var jsonFieldsNameOfSetChatAdministratorCustomTitle = [3]string{
	0: "chat_id",
	1: "user_id",
	2: "custom_title",
}

// Decode decodes SetChatAdministratorCustomTitle from json.
func (s *SetChatAdministratorCustomTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatAdministratorCustomTitle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "custom_title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CustomTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatAdministratorCustomTitle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatAdministratorCustomTitle) {
					name = jsonFieldsNameOfSetChatAdministratorCustomTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatAdministratorCustomTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatAdministratorCustomTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatDescription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetChatDescription = [2]string{
	0: "chat_id",
	1: "description",
}

// Decode decodes SetChatDescription from json.
func (s *SetChatDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatDescription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatDescription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatDescription) {
					name = jsonFieldsNameOfSetChatDescription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
}

var jsonFieldsNameOfSetChatPermissions = [2]string{
	0: "chat_id",
	1: "permissions",
}

// Decode decodes SetChatPermissions from json.
func (s *SetChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatPermissions) {
					name = jsonFieldsNameOfSetChatPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("photo")
		e.Str(s.Photo)
	}
}

var jsonFieldsNameOfSetChatPhoto = [2]string{
	0: "chat_id",
	1: "photo",
}

// Decode decodes SetChatPhoto from json.
func (s *SetChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatPhoto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Photo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatPhoto) {
					name = jsonFieldsNameOfSetChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sticker_set_name")
		e.Str(s.StickerSetName)
	}
}

var jsonFieldsNameOfSetChatStickerSet = [2]string{
	0: "chat_id",
	1: "sticker_set_name",
}

// Decode decodes SetChatStickerSet from json.
func (s *SetChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sticker_set_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StickerSetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_set_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatStickerSet) {
					name = jsonFieldsNameOfSetChatStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatTitle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatTitle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfSetChatTitle = [2]string{
	0: "chat_id",
	1: "title",
}

// Decode decodes SetChatTitle from json.
func (s *SetChatTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatTitle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatTitle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatTitle) {
					name = jsonFieldsNameOfSetChatTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetGameScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetGameScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
	{
		if s.DisableEditMessage.Set {
			e.FieldStart("disable_edit_message")
			s.DisableEditMessage.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetGameScore = [7]string{
	0: "user_id",
	1: "score",
	2: "force",
	3: "disable_edit_message",
	4: "chat_id",
	5: "message_id",
	6: "inline_message_id",
}

// Decode decodes SetGameScore from json.
func (s *SetGameScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetGameScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		case "disable_edit_message":
			if err := func() error {
				s.DisableEditMessage.Reset()
				if err := s.DisableEditMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_edit_message\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetGameScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetGameScore) {
					name = jsonFieldsNameOfSetGameScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetGameScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetGameScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMyCommands) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("commands")
		e.ArrStart()
		for _, elem := range s.Commands {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMyCommands = [3]string{
	0: "commands",
	1: "scope",
	2: "language_code",
}

// Decode decodes SetMyCommands from json.
func (s *SetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMyCommands to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commands":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Commands = make([]BotCommand, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BotCommand
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Commands = append(s.Commands, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commands\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMyCommands")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetMyCommands) {
					name = jsonFieldsNameOfSetMyCommands[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPassportDataErrors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPassportDataErrors) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetPassportDataErrors = [2]string{
	0: "user_id",
	1: "errors",
}

// Decode decodes SetPassportDataErrors from json.
func (s *SetPassportDataErrors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPassportDataErrors to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "errors":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Errors = make([]PassportElementError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PassportElementError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPassportDataErrors")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPassportDataErrors) {
					name = jsonFieldsNameOfSetPassportDataErrors[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPassportDataErrors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPassportDataErrors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerPositionInSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerPositionInSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
}

var jsonFieldsNameOfSetStickerPositionInSet = [2]string{
	0: "sticker",
	1: "position",
}

// Decode decodes SetStickerPositionInSet from json.
func (s *SetStickerPositionInSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerPositionInSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerPositionInSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerPositionInSet) {
					name = jsonFieldsNameOfSetStickerPositionInSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerPositionInSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerPositionInSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerSetThumb) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerSetThumb) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetStickerSetThumb = [3]string{
	0: "name",
	1: "user_id",
	2: "thumb",
}

// Decode decodes SetStickerSetThumb from json.
func (s *SetStickerSetThumb) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerSetThumb to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerSetThumb")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerSetThumb) {
					name = jsonFieldsNameOfSetStickerSetThumb[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerSetThumb) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerSetThumb) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.FieldStart("max_connections")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.FieldStart("allowed_updates")
			e.ArrStart()
			for _, elem := range s.AllowedUpdates {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DropPendingUpdates.Set {
			e.FieldStart("drop_pending_updates")
			s.DropPendingUpdates.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetWebhook = [6]string{
	0: "url",
	1: "certificate",
	2: "ip_address",
	3: "max_connections",
	4: "allowed_updates",
	5: "drop_pending_updates",
}

// Decode decodes SetWebhook from json.
func (s *SetWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "max_connections":
			if err := func() error {
				s.MaxConnections.Reset()
				if err := s.MaxConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_connections\"")
			}
		case "allowed_updates":
			if err := func() error {
				s.AllowedUpdates = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUpdates = append(s.AllowedUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_updates\"")
			}
		case "drop_pending_updates":
			if err := func() error {
				s.DropPendingUpdates.Reset()
				if err := s.DropPendingUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_pending_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetWebhook) {
					name = jsonFieldsNameOfSetWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShippingAddress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShippingAddress) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("country_code")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("city")
		e.Str(s.City)
	}
	{
		e.FieldStart("street_line1")
		e.Str(s.StreetLine1)
	}
	{
		e.FieldStart("street_line2")
		e.Str(s.StreetLine2)
	}
	{
		e.FieldStart("post_code")
		e.Str(s.PostCode)
	}
}

var jsonFieldsNameOfShippingAddress = [6]string{
	0: "country_code",
	1: "state",
	2: "city",
	3: "street_line1",
	4: "street_line2",
	5: "post_code",
}

// Decode decodes ShippingAddress from json.
func (s *ShippingAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShippingAddress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_code\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "city":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.City = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "street_line1":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.StreetLine1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"street_line1\"")
			}
		case "street_line2":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StreetLine2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"street_line2\"")
			}
		case "post_code":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PostCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShippingAddress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingAddress) {
					name = jsonFieldsNameOfShippingAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShippingAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShippingAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShippingOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShippingOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfShippingOption = [3]string{
	0: "id",
	1: "title",
	2: "prices",
}

// Decode decodes ShippingOption from json.
func (s *ShippingOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShippingOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShippingOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingOption) {
					name = jsonFieldsNameOfShippingOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShippingOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShippingOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShippingQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShippingQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		e.FieldStart("shipping_address")
		s.ShippingAddress.Encode(e)
	}
}

var jsonFieldsNameOfShippingQuery = [4]string{
	0: "id",
	1: "from",
	2: "invoice_payload",
	3: "shipping_address",
}

// Decode decodes ShippingQuery from json.
func (s *ShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShippingQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "shipping_address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShippingQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingQuery) {
					name = jsonFieldsNameOfShippingQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShippingQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShippingQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Sticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Sticker) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("is_animated")
		e.Bool(s.IsAnimated)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.SetName.Set {
			e.FieldStart("set_name")
			s.SetName.Encode(e)
		}
	}
	{
		if s.MaskPosition.Set {
			e.FieldStart("mask_position")
			s.MaskPosition.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfSticker = [10]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "is_animated",
	5: "thumb",
	6: "emoji",
	7: "set_name",
	8: "mask_position",
	9: "file_size",
}

// Decode decodes Sticker from json.
func (s *Sticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Sticker to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "is_animated":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsAnimated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_animated\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "set_name":
			if err := func() error {
				s.SetName.Reset()
				if err := s.SetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"set_name\"")
			}
		case "mask_position":
			if err := func() error {
				s.MaskPosition.Reset()
				if err := s.MaskPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_position\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Sticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSticker) {
					name = jsonFieldsNameOfSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Sticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Sticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopMessageLiveLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopMessageLiveLocation) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopMessageLiveLocation = [4]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "reply_markup",
}

// Decode decodes StopMessageLiveLocation from json.
func (s *StopMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopMessageLiveLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopMessageLiveLocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopMessageLiveLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopMessageLiveLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopPoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopPoll) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopPoll = [3]string{
	0: "chat_id",
	1: "message_id",
	2: "reply_markup",
}

// Decode decodes StopPoll from json.
func (s *StopPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopPoll to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopPoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopPoll) {
					name = jsonFieldsNameOfStopPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessfulPayment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessfulPayment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		if s.ShippingOptionID.Set {
			e.FieldStart("shipping_option_id")
			s.ShippingOptionID.Encode(e)
		}
	}
	{
		if s.OrderInfo.Set {
			e.FieldStart("order_info")
			s.OrderInfo.Encode(e)
		}
	}
	{
		e.FieldStart("telegram_payment_charge_id")
		e.Str(s.TelegramPaymentChargeID)
	}
	{
		e.FieldStart("provider_payment_charge_id")
		e.Str(s.ProviderPaymentChargeID)
	}
}

var jsonFieldsNameOfSuccessfulPayment = [7]string{
	0: "currency",
	1: "total_amount",
	2: "invoice_payload",
	3: "shipping_option_id",
	4: "order_info",
	5: "telegram_payment_charge_id",
	6: "provider_payment_charge_id",
}

// Decode decodes SuccessfulPayment from json.
func (s *SuccessfulPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessfulPayment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "shipping_option_id":
			if err := func() error {
				s.ShippingOptionID.Reset()
				if err := s.ShippingOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_option_id\"")
			}
		case "order_info":
			if err := func() error {
				s.OrderInfo.Reset()
				if err := s.OrderInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order_info\"")
			}
		case "telegram_payment_charge_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TelegramPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_payment_charge_id\"")
			}
		case "provider_payment_charge_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ProviderPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_payment_charge_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessfulPayment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessfulPayment) {
					name = jsonFieldsNameOfSuccessfulPayment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessfulPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessfulPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnbanChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnbanChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.OnlyIfBanned.Set {
			e.FieldStart("only_if_banned")
			s.OnlyIfBanned.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnbanChatMember = [3]string{
	0: "chat_id",
	1: "user_id",
	2: "only_if_banned",
}

// Decode decodes UnbanChatMember from json.
func (s *UnbanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnbanChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "only_if_banned":
			if err := func() error {
				s.OnlyIfBanned.Reset()
				if err := s.OnlyIfBanned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"only_if_banned\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnbanChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnbanChatMember) {
					name = jsonFieldsNameOfUnbanChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnbanChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnbanChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnbanChatSenderChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnbanChatSenderChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sender_chat_id")
		e.Int64(s.SenderChatID)
	}
}

var jsonFieldsNameOfUnbanChatSenderChat = [2]string{
	0: "chat_id",
	1: "sender_chat_id",
}

// Decode decodes UnbanChatSenderChat from json.
func (s *UnbanChatSenderChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnbanChatSenderChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sender_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.SenderChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnbanChatSenderChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnbanChatSenderChat) {
					name = jsonFieldsNameOfUnbanChatSenderChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnbanChatSenderChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnbanChatSenderChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnpinAllChatMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnpinAllChatMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfUnpinAllChatMessages = [1]string{
	0: "chat_id",
}

// Decode decodes UnpinAllChatMessages from json.
func (s *UnpinAllChatMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnpinAllChatMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnpinAllChatMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinAllChatMessages) {
					name = jsonFieldsNameOfUnpinAllChatMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnpinAllChatMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnpinAllChatMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnpinChatMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnpinChatMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnpinChatMessage = [2]string{
	0: "chat_id",
	1: "message_id",
}

// Decode decodes UnpinChatMessage from json.
func (s *UnpinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnpinChatMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnpinChatMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinChatMessage) {
					name = jsonFieldsNameOfUnpinChatMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnpinChatMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnpinChatMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Update) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Update) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("update_id")
		e.Int(s.UpdateID)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.EditedMessage.Set {
			e.FieldStart("edited_message")
			s.EditedMessage.Encode(e)
		}
	}
	{
		if s.ChannelPost.Set {
			e.FieldStart("channel_post")
			s.ChannelPost.Encode(e)
		}
	}
	{
		if s.EditedChannelPost.Set {
			e.FieldStart("edited_channel_post")
			s.EditedChannelPost.Encode(e)
		}
	}
	{
		if s.InlineQuery.Set {
			e.FieldStart("inline_query")
			s.InlineQuery.Encode(e)
		}
	}
	{
		if s.ChosenInlineResult.Set {
			e.FieldStart("chosen_inline_result")
			s.ChosenInlineResult.Encode(e)
		}
	}
	{
		if s.CallbackQuery.Set {
			e.FieldStart("callback_query")
			s.CallbackQuery.Encode(e)
		}
	}
	{
		if s.ShippingQuery.Set {
			e.FieldStart("shipping_query")
			s.ShippingQuery.Encode(e)
		}
	}
	{
		if s.PreCheckoutQuery.Set {
			e.FieldStart("pre_checkout_query")
			s.PreCheckoutQuery.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.FieldStart("poll")
			s.Poll.Encode(e)
		}
	}
	{
		if s.PollAnswer.Set {
			e.FieldStart("poll_answer")
			s.PollAnswer.Encode(e)
		}
	}
	{
		if s.MyChatMember.Set {
			e.FieldStart("my_chat_member")
			s.MyChatMember.Encode(e)
		}
	}
	{
		if s.ChatMember.Set {
			e.FieldStart("chat_member")
			s.ChatMember.Encode(e)
		}
	}
	{
		if s.ChatJoinRequest.Set {
			e.FieldStart("chat_join_request")
			s.ChatJoinRequest.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdate = [15]string{
	0:  "update_id",
	1:  "message",
	2:  "edited_message",
	3:  "channel_post",
	4:  "edited_channel_post",
	5:  "inline_query",
	6:  "chosen_inline_result",
	7:  "callback_query",
	8:  "shipping_query",
	9:  "pre_checkout_query",
	10: "poll",
	11: "poll_answer",
	12: "my_chat_member",
	13: "chat_member",
	14: "chat_join_request",
}

// Decode decodes Update from json.
func (s *Update) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Update to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.UpdateID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_id\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "edited_message":
			if err := func() error {
				s.EditedMessage.Reset()
				if err := s.EditedMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edited_message\"")
			}
		case "channel_post":
			if err := func() error {
				s.ChannelPost.Reset()
				if err := s.ChannelPost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_post\"")
			}
		case "edited_channel_post":
			if err := func() error {
				s.EditedChannelPost.Reset()
				if err := s.EditedChannelPost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edited_channel_post\"")
			}
		case "inline_query":
			if err := func() error {
				s.InlineQuery.Reset()
				if err := s.InlineQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_query\"")
			}
		case "chosen_inline_result":
			if err := func() error {
				s.ChosenInlineResult.Reset()
				if err := s.ChosenInlineResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chosen_inline_result\"")
			}
		case "callback_query":
			if err := func() error {
				s.CallbackQuery.Reset()
				if err := s.CallbackQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_query\"")
			}
		case "shipping_query":
			if err := func() error {
				s.ShippingQuery.Reset()
				if err := s.ShippingQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_query\"")
			}
		case "pre_checkout_query":
			if err := func() error {
				s.PreCheckoutQuery.Reset()
				if err := s.PreCheckoutQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_checkout_query\"")
			}
		case "poll":
			if err := func() error {
				s.Poll.Reset()
				if err := s.Poll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll\"")
			}
		case "poll_answer":
			if err := func() error {
				s.PollAnswer.Reset()
				if err := s.PollAnswer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll_answer\"")
			}
		case "my_chat_member":
			if err := func() error {
				s.MyChatMember.Reset()
				if err := s.MyChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"my_chat_member\"")
			}
		case "chat_member":
			if err := func() error {
				s.ChatMember.Reset()
				if err := s.ChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_member\"")
			}
		case "chat_join_request":
			if err := func() error {
				s.ChatJoinRequest.Reset()
				if err := s.ChatJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_join_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Update")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdate) {
					name = jsonFieldsNameOfUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Update) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Update) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadStickerFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadStickerFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("png_sticker")
		e.Str(s.PNGSticker)
	}
}

var jsonFieldsNameOfUploadStickerFile = [2]string{
	0: "user_id",
	1: "png_sticker",
}

// Decode decodes UploadStickerFile from json.
func (s *UploadStickerFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadStickerFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "png_sticker":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PNGSticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"png_sticker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UploadStickerFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadStickerFile) {
					name = jsonFieldsNameOfUploadStickerFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadStickerFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadStickerFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("is_bot")
		e.Bool(s.IsBot)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.CanJoinGroups.Set {
			e.FieldStart("can_join_groups")
			s.CanJoinGroups.Encode(e)
		}
	}
	{
		if s.CanReadAllGroupMessages.Set {
			e.FieldStart("can_read_all_group_messages")
			s.CanReadAllGroupMessages.Encode(e)
		}
	}
	{
		if s.SupportsInlineQueries.Set {
			e.FieldStart("supports_inline_queries")
			s.SupportsInlineQueries.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [9]string{
	0: "id",
	1: "is_bot",
	2: "first_name",
	3: "last_name",
	4: "username",
	5: "language_code",
	6: "can_join_groups",
	7: "can_read_all_group_messages",
	8: "supports_inline_queries",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_bot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsBot = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_bot\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "can_join_groups":
			if err := func() error {
				s.CanJoinGroups.Reset()
				if err := s.CanJoinGroups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_join_groups\"")
			}
		case "can_read_all_group_messages":
			if err := func() error {
				s.CanReadAllGroupMessages.Reset()
				if err := s.CanReadAllGroupMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_read_all_group_messages\"")
			}
		case "supports_inline_queries":
			if err := func() error {
				s.SupportsInlineQueries.Reset()
				if err := s.SupportsInlineQueries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_inline_queries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserProfilePhotos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("photos")
		e.ArrStart()
		for _, elem := range s.Photos {
			e.ArrStart()
			for _, elem := range elem {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUserProfilePhotos = [2]string{
	0: "total_count",
	1: "photos",
}

// Decode decodes UserProfilePhotos from json.
func (s *UserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserProfilePhotos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "photos":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Photos = make([][]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []PhotoSize
					elem = make([]PhotoSize, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem PhotoSize
						if err := elemElem.Decode(d); err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.Photos = append(s.Photos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserProfilePhotos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserProfilePhotos) {
					name = jsonFieldsNameOfUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Venue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Venue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfVenue = [7]string{
	0: "location",
	1: "title",
	2: "address",
	3: "foursquare_id",
	4: "foursquare_type",
	5: "google_place_id",
	6: "google_place_type",
}

// Decode decodes Venue from json.
func (s *Venue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Venue to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Venue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVenue) {
					name = jsonFieldsNameOfVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Venue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Venue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Video) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Video) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVideo = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "duration",
	5: "thumb",
	6: "file_name",
	7: "mime_type",
	8: "file_size",
}

// Decode decodes Video from json.
func (s *Video) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Video to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Video")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideo) {
					name = jsonFieldsNameOfVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Video) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Video) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VideoNote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VideoNote) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("length")
		e.Int(s.Length)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Thumb.Set {
			e.FieldStart("thumb")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVideoNote = [6]string{
	0: "file_id",
	1: "file_unique_id",
	2: "length",
	3: "duration",
	4: "thumb",
	5: "file_size",
}

// Decode decodes VideoNote from json.
func (s *VideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoNote to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "length":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Length = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thumb":
			if err := func() error {
				s.Thumb.Reset()
				if err := s.Thumb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumb\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoNote")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoNote) {
					name = jsonFieldsNameOfVideoNote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VideoNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Voice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Voice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoice = [5]string{
	0: "file_id",
	1: "file_unique_id",
	2: "duration",
	3: "mime_type",
	4: "file_size",
}

// Decode decodes Voice from json.
func (s *Voice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Voice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Voice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoice) {
					name = jsonFieldsNameOfVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Voice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Voice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceChatEnded) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceChatEnded) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
}

var jsonFieldsNameOfVoiceChatEnded = [1]string{
	0: "duration",
}

// Decode decodes VoiceChatEnded from json.
func (s *VoiceChatEnded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceChatEnded to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceChatEnded")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceChatEnded) {
					name = jsonFieldsNameOfVoiceChatEnded[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceChatEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceChatEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceChatParticipantsInvited) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceChatParticipantsInvited) encodeFields(e *jx.Encoder) {
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVoiceChatParticipantsInvited = [1]string{
	0: "users",
}

// Decode decodes VoiceChatParticipantsInvited from json.
func (s *VoiceChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceChatParticipantsInvited to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceChatParticipantsInvited")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceChatParticipantsInvited) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceChatParticipantsInvited) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceChatScheduled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceChatScheduled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("start_date")
		e.Int(s.StartDate)
	}
}

var jsonFieldsNameOfVoiceChatScheduled = [1]string{
	0: "start_date",
}

// Decode decodes VoiceChatScheduled from json.
func (s *VoiceChatScheduled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceChatScheduled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.StartDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceChatScheduled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceChatScheduled) {
					name = jsonFieldsNameOfVoiceChatScheduled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceChatScheduled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceChatScheduled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceChatStarted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceChatStarted) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfVoiceChatStarted = [0]string{}

// Decode decodes VoiceChatStarted from json.
func (s *VoiceChatStarted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceChatStarted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode VoiceChatStarted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceChatStarted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceChatStarted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("has_custom_certificate")
		e.Bool(s.HasCustomCertificate)
	}
	{
		e.FieldStart("pending_update_count")
		e.Int(s.PendingUpdateCount)
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.LastErrorDate.Set {
			e.FieldStart("last_error_date")
			s.LastErrorDate.Encode(e)
		}
	}
	{
		if s.LastErrorMessage.Set {
			e.FieldStart("last_error_message")
			s.LastErrorMessage.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.FieldStart("max_connections")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.FieldStart("allowed_updates")
			e.ArrStart()
			for _, elem := range s.AllowedUpdates {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWebhookInfo = [8]string{
	0: "url",
	1: "has_custom_certificate",
	2: "pending_update_count",
	3: "ip_address",
	4: "last_error_date",
	5: "last_error_message",
	6: "max_connections",
	7: "allowed_updates",
}

// Decode decodes WebhookInfo from json.
func (s *WebhookInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "has_custom_certificate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasCustomCertificate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_custom_certificate\"")
			}
		case "pending_update_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PendingUpdateCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_update_count\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "last_error_date":
			if err := func() error {
				s.LastErrorDate.Reset()
				if err := s.LastErrorDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_error_date\"")
			}
		case "last_error_message":
			if err := func() error {
				s.LastErrorMessage.Reset()
				if err := s.LastErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_error_message\"")
			}
		case "max_connections":
			if err := func() error {
				s.MaxConnections.Reset()
				if err := s.MaxConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_connections\"")
			}
		case "allowed_updates":
			if err := func() error {
				s.AllowedUpdates = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUpdates = append(s.AllowedUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookInfo) {
					name = jsonFieldsNameOfWebhookInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
