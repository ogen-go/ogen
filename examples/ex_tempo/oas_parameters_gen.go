// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// SearchParams is parameters of search operation.
type SearchParams struct {
	// URL-encoded TraceQL query.
	Q OptString `json:",omitempty,omitzero"`
	// Logfmt encoding of any span-level or process-level attributes to filter on.
	// The value is matched as a case-insensitive substring.
	// Key-value pairs are separated by spaces.
	// If a value contains a space, it should be enclosed within double quotes.
	Tags OptString `json:",omitempty,omitzero"`
	// Find traces with at least this duration. Duration values are of the form 10s for 10 seconds, 100ms,
	//  30m, etc.
	MinDuration OptDuration `json:",omitempty,omitzero"`
	// Find traces with no greater than this duration. Uses the same form as `minDuration`.
	MaxDuration OptDuration `json:",omitempty,omitzero"`
	// Limit the number of search results. Default is 20, but this is configurable in the querier. Refer
	// to Configuration.
	Limit OptInt `json:",omitempty,omitzero"`
	// Along with `end` define a time range from which traces should be returned.
	Start OptUnixSeconds `json:",omitempty,omitzero"`
	// Along with `start`, define a time range from which traces should be returned.
	// Providing both `start` and `end` will change the way that Tempo searches.
	// If the parameters are not provided, then Tempo will search the recent trace data stored in the
	// ingesters.
	// If the parameters are provided, it will search the backend as well.
	End OptUnixSeconds `json:",omitempty,omitzero"`
	// Limit the number of spans per span-set. Default value is 3.
	Spss OptInt `json:",omitempty,omitzero"`
}

func unpackSearchParams(packed middleware.Parameters) (params SearchParams) {
	{
		key := middleware.ParameterKey{
			Name: "q",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Q = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "tags",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tags = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "minDuration",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MinDuration = v.(OptDuration)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "maxDuration",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxDuration = v.(OptDuration)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "spss",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Spss = v.(OptInt)
		}
	}
	return params
}

func decodeSearchParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Q.SetTo(paramsDotQVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "q",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: tags.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTagsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTagsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tags.SetTo(paramsDotTagsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tags",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: minDuration.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "minDuration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMinDurationVal time.Duration
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDuration(val)
					if err != nil {
						return err
					}

					paramsDotMinDurationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MinDuration.SetTo(paramsDotMinDurationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "minDuration",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: maxDuration.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "maxDuration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxDurationVal time.Duration
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDuration(val)
					if err != nil {
						return err
					}

					paramsDotMaxDurationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxDuration.SetTo(paramsDotMaxDurationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "maxDuration",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: spss.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "spss",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSpssVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSpssVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Spss.SetTo(paramsDotSpssVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spss",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTagValuesParams is parameters of searchTagValues operation.
type SearchTagValuesParams struct {
	// Tag name.
	TagName string
	// If provided, the tag values returned by the API are filtered to only return values seen on spans
	// matching your filter parameters.
	// Queries can be incomplete: for example, `{ .cluster = }`. Tempo extracts only the valid matchers
	// and build a valid query.
	// Only queries with a single selector `{}`` and AND `&&` operators are supported.
	// - Example supported: `{ .cluster = "us-east-1" && .service = "frontend" }`
	// - Example unsupported: `{ .cluster = "us-east-1" || .service = "frontend" } && { .cluster =
	// "us-east-2" }`.
	Q OptString `json:",omitempty,omitzero"`
	// Along with `end` define a time range from which tags should be returned.
	Start OptUnixSeconds `json:",omitempty,omitzero"`
	// Along with `start` define a time range from which tags should be returned.
	// Providing both `start` and `end` includes blocks for the specified time range only.
	End OptUnixSeconds `json:",omitempty,omitzero"`
}

func unpackSearchTagValuesParams(packed middleware.Parameters) (params SearchTagValuesParams) {
	{
		key := middleware.ParameterKey{
			Name: "tag_name",
			In:   "path",
		}
		params.TagName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "q",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Q = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	return params
}

func decodeSearchTagValuesParams(args [1]string, argsEscaped bool, r *http.Request) (params SearchTagValuesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: tag_name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TagName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tag_name",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: q.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Q.SetTo(paramsDotQVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "q",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTagValuesV2Params is parameters of searchTagValuesV2 operation.
type SearchTagValuesV2Params struct {
	// TraceQL attribute selector (`.service.name`, `resource.service.name`, etc.).
	AttributeSelector string
	// If provided, the tag values returned by the API are filtered to only return values seen on spans
	// matching your filter parameters.
	// Queries can be incomplete: for example, `{ .cluster = }`. Tempo extracts only the valid matchers
	// and build a valid query.
	// Only queries with a single selector `{}`` and AND `&&` operators are supported.
	// - Example supported: `{ .cluster = "us-east-1" && .service = "frontend" }`
	// - Example unsupported: `{ .cluster = "us-east-1" || .service = "frontend" } && { .cluster =
	// "us-east-2" }`.
	Q OptString `json:",omitempty,omitzero"`
	// Along with `end` define a time range from which tags should be returned.
	Start OptUnixSeconds `json:",omitempty,omitzero"`
	// Along with `start` define a time range from which tags should be returned.
	// Providing both `start` and `end` includes blocks for the specified time range only.
	End OptUnixSeconds `json:",omitempty,omitzero"`
}

func unpackSearchTagValuesV2Params(packed middleware.Parameters) (params SearchTagValuesV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "attribute_selector",
			In:   "path",
		}
		params.AttributeSelector = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "q",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Q = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	return params
}

func decodeSearchTagValuesV2Params(args [1]string, argsEscaped bool, r *http.Request) (params SearchTagValuesV2Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: attribute_selector.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "attribute_selector",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AttributeSelector = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "attribute_selector",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: q.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Q.SetTo(paramsDotQVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "q",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTagsParams is parameters of searchTags operation.
type SearchTagsParams struct {
	// Specifies the scope of the tags, this is an optional parameter, if not specified it means all
	// scopes.
	Scope OptTagScope `json:",omitempty,omitzero"`
	// Along with `end` define a time range from which tags should be returned.
	Start OptUnixSeconds `json:",omitempty,omitzero"`
	// Along with `start` define a time range from which tags should be returned.
	// Providing both `start` and `end` includes blocks for the specified time range only.
	End OptUnixSeconds `json:",omitempty,omitzero"`
}

func unpackSearchTagsParams(packed middleware.Parameters) (params SearchTagsParams) {
	{
		key := middleware.ParameterKey{
			Name: "scope",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scope = v.(OptTagScope)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	return params
}

func decodeSearchTagsParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchTagsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: scope.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scope",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScopeVal TagScope
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotScopeVal = TagScope(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Scope.SetTo(paramsDotScopeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Scope.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scope",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTagsV2Params is parameters of searchTagsV2 operation.
type SearchTagsV2Params struct {
	// Specifies the scope of the tags, this is an optional parameter, if not specified it means all
	// scopes.
	Scope OptTagScope `json:",omitempty,omitzero"`
	// Along with `end` define a time range from which tags should be returned.
	Start OptUnixSeconds `json:",omitempty,omitzero"`
	// Along with `start` define a time range from which tags should be returned.
	// Providing both `start` and `end` includes blocks for the specified time range only.
	End OptUnixSeconds `json:",omitempty,omitzero"`
}

func unpackSearchTagsV2Params(packed middleware.Parameters) (params SearchTagsV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "scope",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scope = v.(OptTagScope)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	return params
}

func decodeSearchTagsV2Params(args [0]string, argsEscaped bool, r *http.Request) (params SearchTagsV2Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: scope.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scope",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScopeVal TagScope
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotScopeVal = TagScope(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Scope.SetTo(paramsDotScopeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Scope.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scope",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// TraceByIDParams is parameters of traceByID operation.
type TraceByIDParams struct {
	// TraceID to query.
	TraceID string
	// Along with `end` define a time range from which traces should be returned.
	Start OptUnixSeconds `json:",omitempty,omitzero"`
	// Along with `start` define a time range from which traces should be returned.
	// Providing both `start` and `end` will include traces for the specified time range only.
	// If the parameters are not provided then Tempo will check for the trace across all blocks in
	// backend.
	// If the parameters are provided, it will only check in the blocks within the specified time range,
	// this can result in trace not being found or partial results if it does not fall in the specified
	// time range.
	End    OptUnixSeconds `json:",omitempty,omitzero"`
	Accept string
}

func unpackTraceByIDParams(packed middleware.Parameters) (params TraceByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "traceID",
			In:   "path",
		}
		params.TraceID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept",
			In:   "header",
		}
		params.Accept = packed[key].(string)
	}
	return params
}

func decodeTraceByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params TraceByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: traceID.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "traceID",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TraceID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "traceID",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	// Decode header: Accept.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Accept = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}
